

# TCP와 UDP의 차이점에 대해서 설명해보세요.
1. TCP는 연결 지향형 프로토콜이고 UDP는 데이터를 데이터그램단위로 전송하는 프로토콜입니다.
2. TCP는 가상 회선을 만들어 신뢰성을 보장하도록(흐름 제어, 혼잡 제어, 오류 제어) 하는 프로토콜로 따로 신뢰성을 보장하기 위한 절차가 없는 UDP에 비해 속도가 느린편입니다.
3. TCP는 그래서 파일전송과 같은 신뢰성이 중요한 서비스에 사용되고, UDP는 스트리밍, RTP와 같이 연속성이 더 중요한 서비스에 사용됩니다.

> ) 하지만 UDP도 신뢰성을 UDP자체에서 보장하지 않는 것 뿐이지, 개발자가 직접 신뢰성을 보장하도록 할 수 있습니다. 그래서 HTTP/3은 QUIC이라는 프로토콜을 기반으로 하는데, QUIC은 UDP를 기반으로 합니다. 즉, UDP 자체는 신뢰성을 보장하지 않지만, 추가적인 정의를 통해 신뢰성을 보장받을 수 있습니다.


# TCP 3, 4 way handshake에 대해서 설명해보세요.

TCP 3way handshake는 가상회선을 수립하는 단계
- 클라이언트는 서버에 요청을 전송할 수 있는지, 서버는 클라이언트에게 응답을 전송할 수 있는지 확인하는 과정입니다.
- SYN, ACK 패킷을 주고받으며, 임의의 난수로 SYN 플래그를 전송하고, ACK 플래그에는 1을 더한값을 전송합니다.
> 정확한 순서는 SYN(n) -> ACK(n + 1), SYN(m) -> ACK(m + 1) 순으로 일어납니다.


TCP 4way handshake는 TCP연결을 해제하는 단계
- 클라이언트는 서버에게 연결해제를 통지하고 서버가 이를 확인하고 클라이언트에게 이를 받았음을 전송해주고 최종적으로 연결이 해제됩니다. 
- 단, 서버에서 소켓이 닫혔다고 통지해도 클라이언트 측에서는 일정시간 대기하는데, 혹시나 패킷이 나중에 도착할 수 있기 때문입니다.

# HTTP와 HTTPS의 차이점
HTTP
- 따로 암호화 과정을 거치지 않기 때문에 중간에 패킷을 가로챌 수 있고, 수정할 수 있습니다.
- 따라서 보안이 취약해짐을 알 수 있습니다.

HTTPS
- HTTP의 취약한 보안 문제점을 보완하기 위해 나온 것이다.
- 중간에 암호화 계층을 거쳐서 패킷을 암호화합니다.


# HTTPS, SSL Handshake
- HTTPS는 HTTP에 보안 계층을 추가한 것입니다. HTTPS는 제3자 인증, 공개키 암호화, 비밀키 암호화를 사용합니다.
- 제3자 인증은 믿을 수 있는 인증기관에 등록된 인증서만 신뢰하는 것이고, 공개키 암호화는 비밀키를 공유하기 위해 사용합니다. 
- 비밀키 암호화는 통신하는 데이터를 암호화하는데 사용합니다.

SSL Handshake

1.
클라이언트 : TCP 3way handshake를 수행한 이후, Hello를 전송
서버 : 인증서를 보낸다.

2.
클라이언트 
- 받은 인증서를 신뢰하기 위해서 등록된 인증기관인지 확인합니다.
- 이 인증서는 인증기관의 개인키로 암호화되어있고, 공개키로 검증할 수 있습니다.
- 공개키로 통신에 사용할 비밀키를 암호화해서 서버에 보냅니다.

서버
- 서버는 이를 개인키로 확인하고 이후 통신은 공유된 비밀키로 암호화되어 통신합니다.

제3자 인증
- 인증서, 인증기관/공개키 암호화: 인증서
- 비밀키 공유/비밀키 암호화: 통신과정


# GET과 POST의 차이점
GET 요청
- 서버로부터 데이터를 요청하는 메서드입니다. 
- 주로 데이터의 조회나 검색을 위해 사용됩니다. 

특징
1. 데이터 전송
- GET 요청은 서버로 데이터를 전송하지 않고, 요청 URL에 쿼리 매개변수를 포함시켜 전송합니다. 
- 쿼리 매개변수는 key=value 형태로 전달되며, 여러 개의 매개변수는 &로 구분됩니다. 
- 예를 들면 https://api.example.com/users?id=123와 같은 형식입니다.

2. 캐싱 가능
- GET 요청은 동일한 요청에 대한 응답을 캐싱할 수 있습니다.
- 캐시를 사용하면 동일한 요청을 반복할 때 서버에 다시 요청하지 않고 캐시된 응답을 사용할 수 있으므로 성능 향상에 도움이 됩니다.

3. 무상태성(Stateless)
- GET 요청은 서버에 상태를 변경시키지 않으며, 요청 간에 서버가 클라이언트의 상태를 유지하지 않습니다.
- 각각의 GET 요청은 독립적이며 서버는 요청을 이해하고 적절한 응답을 반환합니다.

4. 보안 
- GET 요청은 URL에 데이터를 포함시키기 때문에 보안에 취약할 수 있습니다.
- 예를 들어, 로그인 정보나 민감한 데이터를 GET 요청으로 전송하면 URL에 노출되어 보안 위협이 될 수 있습니다. 
- 따라서 보안이 필요한 데이터는 POST 요청을 사용해야 합니다.


POST 요청 
- 서버로 데이터를 전송하는 메서드입니다. 
- 주로 데이터의 생성이나 수정을 위해 사용됩니다. 

특징
1. 데이터 전송
- POST 요청은 요청 본문(body)에 데이터를 담아 전송합니다.
- 데이터는 일반적으로 JSON, XML, 폼 데이터 등의 형식으로 전송됩니다.
- POST 요청의 본문에는 요청하는 리소스를 생성 또는 수정하기 위한 데이터가 포함됩니다.

2. 캐싱 불가능
- POST 요청은 데이터의 생성 또는 수정과 같이 서버의 상태를 변경하는 목적으로 사용되므로, 동일한 POST 요청에 대한 응답은 캐싱할 수 없습니다.
- 매번 요청할 때마다 서버는 해당 요청을 처리하고 새로운 응답을 반환합니다.

3. 무상태성(Stateless)
- GET 요청과 마찬가지로 POST 요청도 서버에 상태를 변경시키지 않으며, 요청 간에 서버가 클라이언트의 상태를 유지하지 않습니다.

4.보안
- POST 요청은 요청 본문에 데이터를 포함시키기 때문에 GET 요청에 비해 보안이 더 강력합니다. 
- 데이터는 URL에 노출되지 않고, 암호화된 연결(HTTPS)을 통해 전송될 수 있습니다.

> 정리 > GET 요청은 데이터 조회를 위해 URL에 쿼리 매개변수를 포함하여 전송하고, POST 요청은 데이터의 생성 또는 수정을 위해 요청 본문에 데이터를 담아 전송합니다. GET 요청은 캐싱 가능하고 보안에 취약하며, POST 요청은 캐싱 불가능하고 보안이 강력합니다.

# CORS
- CORS(Cross-Origin Resource Sharing)는 웹 애플리케이션에서 다른 도메인의 리소스에 접근하기 위한 보안 메커니즘입니다. 
- 웹 브라우저의 동일 출처 정책(Same-Origin Policy)로 인해 동일한 도메인 내에서만 리소스에 접근할 수 있습니다. 
- 하지만 CORS는 이 정책을 우회하여 다른 도메인 간의 리소스 공유를 허용합니다.
- 일반적으로 웹 애플리케이션은 HTML, CSS, JavaScript와 같은 정적인 리소스뿐만 아니라 API 서비스로부터 데이터를 가져와야 합니다. 
- 이때 다른 도메인에 위치한 API 서비스로 직접 요청을 보내는 경우, 동일 출처 정책에 의해 브라우저는 요청을 차단합니다. 


# CORS 동작 방식
- 클라이언트는 리소스를 요청할 때 HTTP 헤더에 Origin을 포함시켜 요청을 보냅니다. Origin은 요청을 보내는 도메인을 나타냅니다.
- 서버는 요청을 받아들이고, 허용된 도메인인지 확인하기 위해 Access-Control-Allow-Origin 헤더를 포함한 응답을 반환합니다. 
- 이 헤더는 허용된 도메인의 목록을 나타냅니다. 예를 들어, Access-Control-Allow-Origin: https://www.example.com와 같이 헤더를 설정합니다.
- 브라우저는 서버의 응답을 확인하여 Access-Control-Allow-Origin 헤더가 자신의 도메인과 일치하는지 확인합니다. 
- 일치하는 경우, 리소스에 접근이 허용되고 브라우저는 리소스를 사용할 수 있도록 합니다. 일치하지 않는 경우, 브라우저는 접근을 차단하고 에러를 발생시킵니다.


# 웹 서버 소프트웨어(Apache, Nginx)는 OSI 7계층 중 어디서 작동할까?
- 웹 서버 소프트웨어인 Apache와 Nginx는 OSI(Open Systems Interconnection) 모델의 응용 계층(Application Layer)에서 작동합니다.

Apache와 Nginx
- 응용 계층에서 동작하는 웹 서버 소프트웨어로, HTTP(HyperText Transfer Protocol)를 기반으로 웹 페이지나 파일을 클라이언트에게 전송하는 역할을 수행합니다. 이러한 웹 서버는 클라이언트의 HTTP 요청을 받아들이고, 해당 요청에 대한 처리와 응답을 생성하여 클라이언트에게 반환합니다.
- HTTP 요청에 대한 처리를 위해 TCP/IP 프로토콜 스택과 함께 작동합니다. 
- TCP/IP 프로토콜은 OSI 모델에서 네트워크 계층과 전송 계층에 해당합니다.
- 웹 서버는 이러한 프로토콜을 사용하여 클라이언트와의 연결을 설정하고, HTTP 프로토콜을 사용하여 요청과 응답을 주고받습니다.

> 정리 : Apache와 Nginx는 OSI 7계층 중 응용 계층에서 동작하여 HTTP 프로토콜을 통해 웹 요청을 처리하고, 클라이언트에게 웹 페이지나 파일을 전송합니다.


# 웹 서버 소프트웨어(Apache, Nginx)의 서버 간 라우팅 기능은 OSI 7계층 중 어디서 작동할까?
- 웹 서버 소프트웨어인 Apache와 Nginx의 서버 간 라우팅 기능은 OSI(Open Systems Interconnection) 모델의 네트워크 계층(Network Layer)에서 작동합니다.

서버 간 라우팅 기능
- 웹 서버 소프트웨어는 HTTP 요청을 받아들이고, 해당 요청을 처리하기 위해 적절한 서버로 전달해야 합니다.
- 이때 서버 간 라우팅 기능이 사용되며, 네트워크 계층에서 작동합니다.


서버 간 라우팅 동작방식
- 클라이언트로부터 도착한 HTTP 요청은 웹 서버 소프트웨어에 의해 받아들여집니다. 
- 이는 응용 계층(Application Layer)에서 이루어지며, HTTP 프로토콜을 통해 이루어집니다.
- 웹 서버 소프트웨어는 받은 요청의 목적지 서버를 결정하기 위해 서버 간 라우팅 기능을 사용합니다. 이 과정은 네트워크 계층에서 이루어집니다.


라우팅 기능
- 네트워크 계층의 주소 정보(IP 주소)를 사용하여 요청을 적절한 서버로 전달합니다. 
- 이때 라우팅 테이블, 로드 밸런서, 프록시 서버 등의 기술이 사용될 수 있습니다.
- 목적지 서버는 요청을 받아들이고, 해당 요청에 대한 처리와 응답을 생성하여 클라이언트에게 반환합니다.

> 정리 : Apache와 Nginx의 서버 간 라우팅 기능은 OSI 7계층 중 네트워크 계층에서 동작하여 클라이언트의 요청을 목적지 서버로 전달합니다. 이를 통해 로드 밸런싱, 트래픽 분산 등의 기능을 구현할 수 있습니다.

# -------------------- DataBase --------------------

# MongoDB
- NoSQL(비관계형) 데이터베이스로서, 유연성과 확장성을 갖춘 고성능 데이터 저장 및 검색 시스템입니다


MongoDB의 특징
1. 스키마 유연성
- MongoDB는 동적 스키마를 사용하여 데이터를 저장합니다.
- 다른 문서 간에 각기 다른 필드를 가질 수 있고, 필요에 따라 스키마를 변경할 수 있습니다. 
- 이는 개발 생산성과 데이터 모델의 유연성을 높여줍니다.

2. 분산 아키텍처
- MongoDB는 수평적 확장을 지원하기 위해 분산 아키텍처를 채택하고 있습니다. 
- 여러 대의 서버에 데이터를 분산하여 저장하고 처리할 수 있으며, 클러스터링과 샤딩을 통해 확장성을 보장합니다.

3. 높은 성능
- MongoDB는 메모리 기반의 캐싱 시스템을 사용하여 데이터에 빠르게 액세스할 수 있습니다. 
- 또한 인덱싱 기능과 쿼리 최적화를 통해 빠른 데이터 검색을 지원합니다.

4. 다양한 데이터 모델
- MongoDB는 다양한 데이터 모델을 지원합니다.
- 주요한 모델로는 문서(Document) 모델과 그리드 파일 시스템(GridFS)이 있습니다.
- 문서 모델은 JSON 형태로 데이터를 저장하고 쿼리할 수 있으며, GridFS는 대용량 파일을 저장하는 데 사용됩니다.

5. Replication과 고가용성
- MongoDB는 데이터의 복제를 지원하여 고가용성을 보장합니다. 
- 여러 복제본을 유지하여 장애 발생 시에도 데이터의 가용성을 유지할 수 있습니다.

6. MongoDB의 쿼리 언어
- MongoDB는 자체 쿼리 언어인 MongoDB Query Language (MQL)을 사용합니다. 
- MQL은 문서 지향적인 쿼리를 지원하며, 일반적으로 JSON 형식으로 작성됩니다. 
- 다양한 연산자를 사용하여 쿼리를 작성할 수 있으며, 복잡한 조건을 표현하기에 용이합니다.

# Mongo 사용예시
1. 대규모 데이터 처리
- MongoDB는 대용량 데이터 처리를 위해 수평적 확장이 가능하며, 분산 아키텍처를 통해 높은 성능을 제공합니다.

2. 실시간 분석
- MongoDB는 실시간 분석을 위한 데이터베이스로 사용될 수 있습니다. 
- 데이터의 삽입과 조회가 빠르며, 다양한 분석 도구와 통합이 용이합니다.

3. 컨텐츠 관리 시스템
- MongoDB는 문서 모델을 사용하므로, 컨텐츠 관리 시스템(CMS)과 같은 애플리케이션에서 유연하게 데이터를 관리할 수 있습니다.

4. 로그 및 이벤트 저장
- MongoDB는 대량의 로그 데이터나 이벤트 데이터를 저장하기에 적합합니다. 
- 스키마의 유연성과 분산 아키텍처를 통해 데이터를 효율적으로 저장하고 분석할 수 있습니다.


# -------------------- OS --------------------

# 세마포어와 뮤텍스
뮤텍스(Mutex)
- 뮤텍스는 상호 배제를 위한 동기화 기법 중 하나입니다.
- 뮤텍스는 하나의 스레드 또는 프로세스만 공유 자원에 접근할 수 있도록 보호합니다.
- 뮤텍스는 락(lock)과 언락(unlock) 두 가지 상태를 가지며, 락 상태에서는 자원에 대한 접근이 차단됩니다.
- 한 스레드가 뮤텍스를 락(lock)하고 있으면, 다른 스레드는 해당 뮤텍스를 락(lock)할 때까지 대기해야 합니다.
- 뮤텍스는 보통 단일 스레드나 프로세스 사이에서 상호 배제를 위해 사용됩니다.

세마포어(Semaphore)
- 세마포어는 동시에 접근 가능한 리소스의 개수를 지정하여 상호 배제를 관리하는 동기화 기법입니다.
- 세마포어는 카운터 값을 가지며, 해당 카운터 값은 동시에 접근 가능한 리소스의 수를 나타냅니다. 
- 카운터 값이 양수인 경우, 스레드는 리소스에 접근할 수 있습니다. 카운터 값이 0인 경우, 스레드는 대기해야 합니다.
- 세마포어는 락(lock)과 언락(unlock) 또는 P(wait)와 V(signal) 두 가지 연산을 사용합니다.
- P 연산은 세마포어의 카운터 값을 감소시키고, V 연산은 카운터 값을 증가시킵니다.
- 세마포어는 일반적으로 스레드 풀, 프로세스 간 통신 등 다양한 상황에서 사용됩니다.


# 세마포어와 뮤텍스의 주요 차이점

사용 목적
- 뮤텍스는 하나의 스레드 또는 프로세스만이 공유 자원에 접근할 수 있도록 보호하는 데 사용됩니다.
- 세마포어는 동시에 접근 가능한 리소스의 개수를 제어하기 위해 사용됩니다.

카운터
- 뮤텍스는 단일 카운터를 사용하지만, 세마포어는 여러 개의 카운터를 사용할 수 있습니다.

대기 방식
- 뮤텍스는 락을 획득한 스레드가 언락을 실행하기 전까지 다른 스레드가 대기해야 합니다.
- 세마포어는 카운터 값에 따라 스레드가 대기하거나 진행할 수 있습니다.

리소스 개수
- 뮤텍스는 보통 1개의 리소스에 대한 상호 배제를 처리합니다.
- 세마포어는 카운터 값을 조정하여 여러 개의 리소스에 대한 접근을 관리할 수 있습니다.

> 정리 : 뮤텍스는 상호 배제를 위해 단일 스레드 또는 프로세스에 대한 접근을 보호하는 데 사용되고, 세마포어는 동시에 접근 가능한 리소스의 수를 제어하는 데 사용됩니다.

# ------------------ Infra / Cloud ------------------


# ------------------ Design Pattern -----------------


# 생성 패턴
- 새로운 객체를 생성하는 방법을 제공


싱글톤 패턴
- 단 하나의 인스턴스를 생성하고, 이에 대한 전역적인 접근을 제공하는 패턴
- 주로 공유 리소스에 대한 접근을 조절하거나 설정 정보와 같은 단일 객체에 대한 접근을 제한하는 데 사용

팩토리메서드
- 객체 생성을 서브 클래스로 위임하는 패턴입니다. 
- 슈퍼 클래스에서는 객체의 인스턴스화를 처리하는 추상 메서드를 정의하고, 서브 클래스에서는 이를 구체적으로 구현합니다. 
- 이를 통해 객체 생성의 유연성을 확보하고, 클라이언트 코드와 객체 생성을 분리할 수 있습니다.

추상 팩토리
- 추상 팩토리 패턴은 서로 관련이 있는 여러 객체의 생성을 담당하는 패턴입니다. 
- 추상 팩토리는 관련 객체군을 생성하기 위한 인터페이스를 제공하고, 구체적인 팩토리 클래스들은 이를 구현합니다.
- 클라이언트는 추상 팩토리를 통해 객체를 생성하며, 구체적인 팩토리 클래스를 교체함으로써 서로 다른 객체군을 생성할 수 있습니다.

빌더 
- 빌더 패턴은 복잡한 객체의 생성 과정을 단계별로 나누는 패턴입니다.
- 빌더 패턴을 사용하면 객체 생성 과정의 유연성을 제공하면서, 복잡한 객체를 일관된 방식으로 구축할 수 있습니다.
- 일반적으로 객체의 속성을 설정하는 메서드 체인 형태로 구현됩니다.

프로토타입 
- 프로토타입 패턴은 객체의 복사를 통해 새로운 객체를 생성하는 패턴입니다. 
- 기존 객체의 상태를 복사하여 새로운 객체를 생성하므로, 복잡한 초기화 과정을 거치지 않고 객체를 생성할 수 있습니다. 
- 주로 객체 생성 비용이 높은 경우나 객체의 상태가 동적으로 변하는 경우에 사용됩니다.


