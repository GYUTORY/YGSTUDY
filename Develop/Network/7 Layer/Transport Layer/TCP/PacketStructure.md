# TCP 패킷 구조 상세 설명

## 1. TCP 패킷의 기본 구조
TCP(Transmission Control Protocol)는 신뢰성 있는 데이터 전송을 보장하는 전송 계층 프로토콜입니다. TCP 패킷은 헤더와 데이터로 구성되며, 각각의 필드는 특정한 목적을 가지고 있습니다.

### 1.1 TCP 헤더 구조 (20바이트 기본)
```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          Source Port          |       Destination Port        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Sequence Number                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Acknowledgment Number                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Data |           |U|A|P|R|S|F|                               |
| Offset| Reserved  |R|C|S|S|Y|I|            Window             |
|       |           |G|K|H|T|N|N|                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Checksum            |         Urgent Pointer        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Options (if any)                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Data (if any)                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

## 2. 제어 문자와 프레임 구조

### 2.1 STX (Start of Text)
#### 2.1.1 기본 개념
- STX는 데이터 전송의 시작을 나타내는 제어 문자입니다.
- ASCII 코드: 0x02 (2진수: 00000010)
- 데이터 프레임의 시작점을 수신자에게 알리는 역할을 합니다.

#### 2.1.2 상세 설명
1. **역할과 목적**
   - 데이터 프레임의 시작을 명확히 표시
   - 수신측의 데이터 동기화 보장
   - 프레임 경계 식별
   - 데이터 스트림의 시작점 식별

2. **사용 시나리오**
   - 시리얼 통신에서 데이터 프레임 시작 표시
   - 프로토콜에서 메시지 시작 표시
   - 데이터 스트림 동기화
   - 프레임 기반 통신에서 프레임 시작 표시

3. **구현 방식**
   - 하드웨어 레벨: 특정 비트 패턴으로 인코딩
   - 소프트웨어 레벨: 특정 바이트 값으로 표현
   - 프로토콜 레벨: 프레임 시작 마커로 사용

### 2.2 ETX (End of Text)
#### 2.2.1 기본 개념
- ETX는 데이터 전송의 종료를 나타내는 제어 문자입니다.
- ASCII 코드: 0x03 (2진수: 00000011)
- 데이터 프레임의 끝을 수신자에게 알리는 역할을 합니다.

#### 2.2.2 상세 설명
1. **역할과 목적**
   - 데이터 프레임의 종료를 명확히 표시
   - 수신측의 데이터 처리 완료 신호
   - 프레임 경계 식별
   - 데이터 스트림의 종료점 식별

2. **사용 시나리오**
   - 시리얼 통신에서 데이터 프레임 종료 표시
   - 프로토콜에서 메시지 종료 표시
   - 데이터 스트림 종료 신호
   - 프레임 기반 통신에서 프레임 종료 표시

3. **구현 방식**
   - 하드웨어 레벨: 특정 비트 패턴으로 인코딩
   - 소프트웨어 레벨: 특정 바이트 값으로 표현
   - 프로토콜 레벨: 프레임 종료 마커로 사용

### 2.3 프레임 구조 예시
```
[STX][데이터][ETX][CRC]
```
- STX: 프레임 시작
- 데이터: 실제 전송할 데이터
- ETX: 프레임 종료
- CRC: 오류 검출 코드

## 3. CRC (Cyclic Redundancy Check)

### 3.1 기본 개념
CRC는 데이터 전송 과정에서 발생할 수 있는 오류를 검출하기 위한 방법입니다. 순환 중복 검사라고도 불리며, 데이터의 무결성을 검증하는 체크섬 방식입니다.

### 3.2 상세 설명

#### 3.2.1 CRC의 원리
1. **수학적 기반**
   - 다항식 기반의 나눗셈 연산
   - 모듈로 2 연산 사용
   - 비트 단위 연산

2. **작동 방식**
   - 송신측:
     1. 데이터를 다항식으로 변환
     2. 생성 다항식으로 나눗셈 수행
     3. 나머지를 CRC 값으로 사용
     4. 데이터와 CRC를 함께 전송
   
   - 수신측:
     1. 수신된 데이터를 동일한 생성 다항식으로 나눗셈
     2. 나머지가 0이면 오류 없음
     3. 나머지가 0이 아니면 오류 발생

#### 3.2.2 CRC의 종류
1. **CRC-16**
   - 다항식: x^16 + x^15 + x^2 + 1
   - 16비트 CRC 값 생성
   - 일반적인 통신 프로토콜에서 사용
   - 2^16 - 1 비트까지의 데이터 처리 가능

2. **CRC-32**
   - 다항식: x^32 + x^26 + x^23 + x^22 + x^16 + x^12 + x^11 + x^10 + x^8 + x^7 + x^5 + x^4 + x^2 + x + 1
   - 32비트 CRC 값 생성
   - 이더넷, ZIP 파일 등에서 사용
   - 2^32 - 1 비트까지의 데이터 처리 가능

#### 3.2.3 CRC의 장점
1. **오류 검출 능력**
   - 단일 비트 오류 100% 검출
   - 2비트 오류 100% 검출
   - 버스트 오류 검출 가능
   - 홀수 개의 비트 오류 검출 가능

2. **구현 효율성**
   - 하드웨어 구현이 용이
   - 계산이 빠르고 효율적
   - 메모리 사용량이 적음
   - 실시간 처리 가능

3. **유연성**
   - 다양한 데이터 길이 지원
   - 다양한 생성 다항식 사용 가능
   - 프로토콜에 맞춰 커스터마이징 가능

#### 3.2.4 CRC 구현 예시
```c
// CRC-16 구현 예시
uint16_t calculateCRC16(const uint8_t* data, size_t length) {
    uint16_t crc = 0xFFFF;
    for (size_t i = 0; i < length; i++) {
        crc ^= (uint16_t)data[i] << 8;
        for (int j = 0; j < 8; j++) {
            if (crc & 0x8000) {
                crc = (crc << 1) ^ 0x1021;
            } else {
                crc <<= 1;
            }
        }
    }
    return crc;
}
```

### 3.3 CRC 사용 시나리오
1. **데이터 통신**
   - 시리얼 통신
   - 이더넷 통신
   - 무선 통신
   - 센서 데이터 전송

2. **저장 시스템**
   - 파일 시스템
   - RAID 시스템
   - 백업 시스템
   - 데이터베이스

3. **임베디드 시스템**
   - 마이크로컨트롤러 통신
   - 센서 네트워크
   - 산업용 제어 시스템
   - IoT 디바이스

## 4. 실제 적용 예시

### 4.1 시리얼 통신에서의 사용
```
[STX][데이터][ETX][CRC-16]
```
1. 송신측:
   - STX 전송
   - 데이터 전송
   - ETX 전송
   - CRC-16 계산 및 전송

2. 수신측:
   - STX 수신 대기
   - 데이터 수신
   - ETX 확인
   - CRC 검증

### 4.2 이더넷 프레임에서의 사용
```
[프리앰블][SFD][목적지 MAC][출발지 MAC][타입][데이터][CRC-32]
```
1. 프리앰블: 프레임 동기화
2. SFD: 프레임 시작 구분자
3. MAC 주소: 통신 대상 식별
4. 타입: 상위 계층 프로토콜 식별
5. 데이터: 실제 전송 데이터
6. CRC-32: 오류 검출

## 5. 보안 고려사항

### 5.1 CRC의 한계
1. **보안적 한계**
   - 의도적인 데이터 변조 검출 불가
   - 암호화 기능 없음
   - 인증 기능 없음

2. **해결 방안**
   - 암호화와 함께 사용
   - 해시 함수와 함께 사용
   - 디지털 서명 사용

### 5.2 보안 강화 방안
1. **데이터 암호화**
   - 대칭키 암호화
   - 공개키 암호화
   - 하이브리드 암호화

2. **인증 메커니즘**
   - MAC(Message Authentication Code)
   - HMAC(Hash-based MAC)
   - 디지털 서명

3. **무결성 검증**
   - SHA-256 등 해시 함수 사용
   - 디지털 서명 검증
   - 타임스탬프 사용
