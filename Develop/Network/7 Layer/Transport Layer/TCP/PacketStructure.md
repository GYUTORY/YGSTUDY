---
title: TCP 패킷 구조 상세 설명
tags: [network, 7-layer, transport-layer, tcp, packetstructure, packet-analysis]
updated: 2025-12-22
---

# TCP 패킷 구조 상세 설명

## 개요

TCP 패킷은 인터넷에서 데이터를 안전하게 전송하기 위한 기본 단위다. TCP(Transmission Control Protocol)는 신뢰성 있는 데이터 전송을 보장하는 전송 계층 프로토콜로, 웹 브라우징, 이메일, 파일 전송 등에서 널리 사용된다.

### TCP 패킷의 중요성

- 데이터 무결성: 전송 중 데이터 손실 방지
- 순서 보장: 패킷이 올바른 순서로 도착하도록 보장
- 오류 검출: 전송 중 발생한 오류를 감지하고 수정
- 흐름 제어: 송신자와 수신자 간의 데이터 전송 속도 조절

### 실제 활용 분야

- 웹 통신: HTTP/HTTPS에서 TCP 사용
- 파일 전송: FTP에서 TCP 사용
- 이메일: SMTP에서 TCP 사용
- 데이터베이스: MySQL, PostgreSQL에서 TCP 사용

**실무 팁:**
TCP는 신뢰성이 중요한 통신에 사용한다. 웹, 이메일, 파일 전송 등에서 사용한다.

## TCP 패킷의 전체 구조

### 기본 구성 요소

TCP 패킷은 헤더(Header)와 데이터(Data) 두 부분으로 구성된다.

```
┌─────────────────────────────────────────────────────────────┐
│                    TCP 패킷 구조                              │
├─────────────────────────────────────────────────────────────┤
│  TCP 헤더 (20-60 바이트)                                    │
│  ┌─────────┬─────────┬─────────┬─────────┬─────────┐        │
│  │ 소스포트│ 목적포트│ 시퀀스번호│ 확인번호│ 헤더길이│        │
│  ├─────────┼─────────┼─────────┼─────────┼─────────┤        │
│  │ 예약필드│ 제어플래그│ 윈도우크기│ 체크섬│ 긴급포인터│        │
│  ├─────────┴─────────┴─────────┴─────────┴─────────┤        │
│  │              옵션 필드 (가변 길이)                │        │
│  └─────────────────────────────────────────────────┘        │
├─────────────────────────────────────────────────────────────┤
│  데이터 페이로드 (가변 길이)                                │
└─────────────────────────────────────────────────────────────┘
```

#### 헤더와 데이터의 역할

- 헤더: 패킷의 제어 정보와 메타데이터를 포함
- 데이터: 실제 전송할 애플리케이션 데이터

## TCP 헤더 상세 분석

### 포트 번호 (16비트 × 2)

**소스 포트 (Source Port):**
- 송신 애플리케이션을 식별하는 포트 번호
- 클라이언트가 동적으로 할당받는 임시 포트 (보통 1024-65535)
- 예: 웹 브라우저가 웹 서버에 연결할 때 사용하는 포트

**목적지 포트 (Destination Port):**
- 수신 애플리케이션을 식별하는 포트 번호
- 서버가 미리 예약해둔 잘 알려진 포트 (Well-known Port)
- 예: HTTP(80), HTTPS(443), FTP(21), SSH(22)

**실무 팁:**
포트 번호는 애플리케이션을 식별하는 데 사용한다. 클라이언트는 동적 포트를, 서버는 고정 포트를 사용한다.

### 시퀀스 번호 (Sequence Number, 32비트)

**개념:**
- 전송되는 데이터의 바이트 순서를 나타내는 번호
- 각 바이트마다 고유한 시퀀스 번호가 할당됨
- 32비트 범위 (0 ~ 4,294,967,295)를 순환적으로 사용

**역할:**
- 순서 보장: 패킷이 올바른 순서로 도착했는지 확인
- 중복 제거: 같은 데이터가 여러 번 전송되었는지 감지
- 재조립: 분할된 데이터를 원래 순서대로 재조립

**예시:**
```
데이터: "Hello World" (11바이트)
시퀀스 번호 1000: "Hello" (5바이트)
시퀀스 번호 1005: " Worl" (5바이트)  
시퀀스 번호 1010: "d" (1바이트)
```

### 확인 번호 (Acknowledgment Number, 32비트)

**개념:**
- 다음에 받기를 기대하는 바이트의 시퀀스 번호
- ACK 플래그가 설정된 경우에만 유효
- 상대방이 성공적으로 받은 데이터의 다음 바이트를 가리킴

**역할:**
- 신뢰성 보장: 데이터가 정상적으로 수신되었음을 확인
- 흐름 제어: 수신자가 처리할 수 있는 속도로 데이터 전송 조절
- 오류 복구: 손실된 데이터의 재전송 요청

**예시:**
```
송신자 → 수신자: 시퀀스 1000, 데이터 "Hello" (5바이트)
수신자 → 송신자: ACK 1005 (다음에 1005번부터 받겠다는 의미)
```

### 헤더 길이 (Data Offset, 4비트)

**개념:**
- TCP 헤더의 길이를 32비트 워드 단위로 나타냄
- 최소값: 5 (20바이트), 최대값: 15 (60바이트)
- 옵션 필드의 존재 여부에 따라 헤더 길이가 달라짐

**계산 방법:**
```
헤더 길이 (바이트) = Data Offset × 4
예: Data Offset = 5 → 헤더 길이 = 20바이트
예: Data Offset = 8 → 헤더 길이 = 32바이트 (옵션 포함)
```

### 예약 필드 (Reserved, 6비트)

**개념:**
- 현재 사용하지 않는 예약된 비트들
- 모두 0으로 설정되어야 함
- 향후 TCP 프로토콜 확장을 위해 보존

### 제어 플래그 (Control Flags, 6비트)

**URG (Urgent, 1비트):**
- 긴급 데이터가 포함되어 있음을 나타냄
- Urgent Pointer 필드와 함께 사용
- 예: Telnet에서 Ctrl+C 같은 긴급 명령

**ACK (Acknowledgment, 1비트):**
- 확인 번호가 유효함을 나타냄
- 연결 설정 후 대부분의 패킷에서 설정됨
- 데이터 수신 확인의 핵심 플래그

**PSH (Push, 1비트):**
- 수신자에게 즉시 데이터를 애플리케이션으로 전달하도록 요청
- 버퍼링 없이 실시간 데이터 전송
- 예: 채팅 메시지, 실시간 게임 데이터

**RST (Reset, 1비트):**
- 연결을 강제로 재설정
- 오류 상황이나 비정상적인 연결 시 사용
- 예: 존재하지 않는 포트에 연결 시도

**SYN (Synchronize, 1비트):**
- 연결 설정을 위한 동기화 신호
- 3-way handshake의 첫 번째와 두 번째 단계에서 사용
- 시퀀스 번호 초기화

**FIN (Finish, 1비트):**
- 연결 종료를 위한 신호
- 정상적인 연결 해제 과정에서 사용
- 더 이상 전송할 데이터가 없음을 나타냄

**실무 팁:**
SYN, ACK, FIN 플래그는 연결 설정과 종료에 사용한다. RST는 오류 상황에서 사용한다.

### 윈도우 크기 (Window Size, 16비트)

**개념:**
- 수신자가 받을 수 있는 데이터의 최대 크기
- 흐름 제어의 핵심 메커니즘
- 0 ~ 65,535 바이트 범위

**역할:**
- 흐름 제어: 수신자의 처리 능력에 맞춰 전송 속도 조절
- 혼잡 제어: 네트워크 상태에 따른 전송량 조절
- 버퍼 관리: 수신자 버퍼 오버플로우 방지

**동작 원리:**
```
송신자: 윈도우 크기가 1000바이트라면, 확인 번호 + 1000바이트까지만 전송
수신자: 데이터 처리 후 윈도우 크기를 업데이트하여 전송
```

### 체크섬 (Checksum, 16비트)

**개념:**
- 헤더와 데이터의 무결성을 검증하는 값
- 송신자가 계산하여 설정, 수신자가 검증
- 오류가 감지되면 패킷을 폐기

**계산 범위:**
- TCP 헤더
- TCP 데이터
- 의사 헤더 (IP 주소, 프로토콜 번호 등)

**오류 검출 능력:**
- 단일 비트 오류: 100% 검출
- 다중 비트 오류: 대부분 검출
- 순서 바뀜: 일부 검출

### 긴급 포인터 (Urgent Pointer, 16비트)

**개념:**
- URG 플래그가 설정된 경우에만 사용
- 긴급 데이터의 끝 위치를 나타냄
- 시퀀스 번호를 기준으로 한 오프셋

**사용 예시:**
```
시퀀스 번호: 1000
긴급 포인터: 1005
→ 1000~1004번 바이트가 긴급 데이터
```

**실무 팁:**
윈도우 크기는 흐름 제어의 핵심이다. 수신자의 처리 능력에 맞춰 전송 속도를 조절한다.

## TCP 옵션 필드

### 옵션의 특징

- 가변 길이: 0~40바이트까지 가능
- 선택적 사용: 필요한 경우에만 포함
- 32비트 정렬: 옵션은 32비트 경계에 맞춰 정렬

### 주요 옵션들

**MSS (Maximum Segment Size):**
- 한 번에 전송할 수 있는 최대 데이터 크기
- 연결 설정 시 협상
- 일반적으로 1460바이트 (이더넷 MTU 1500 - IP헤더 20 - TCP헤더 20)

**Window Scale:**
- 윈도우 크기 확장 옵션
- 16비트 윈도우를 최대 1GB까지 확장
- 고속 네트워크에서 필수

**SACK (Selective Acknowledgment):**
- 선택적 확인 응답
- 연속되지 않은 데이터 블록도 개별적으로 확인
- 네트워크 효율성 향상

**Timestamp:**
- RTT(Round Trip Time) 측정
- 패킷 재전송 시 오래된 패킷과 구분
- 네트워크 성능 분석에 활용

**실무 팁:**
MSS는 네트워크 MTU에 맞춰 설정한다. Window Scale은 고속 네트워크에서 필수다.

## TCP 데이터 페이로드

### 데이터의 특징

- 가변 길이: 0바이트부터 최대 세그먼트 크기까지
- 애플리케이션 데이터: 상위 계층에서 전달받은 실제 데이터
- 프로토콜 독립적: TCP는 데이터 내용에 관여하지 않음

### 데이터 전송 방식

**세그멘테이션 (Segmentation):**
- 큰 데이터를 여러 TCP 세그먼트로 분할
- 각 세그먼트는 독립적인 시퀀스 번호를 가짐
- 수신 측에서 원래 데이터로 재조립

**버퍼링 (Buffering):**
- 송신 버퍼: 전송 대기 중인 데이터 저장
- 수신 버퍼: 수신된 데이터를 애플리케이션에 전달하기 전 저장
- 흐름 제어의 핵심 요소

**실무 팁:**
TCP는 큰 데이터를 여러 세그먼트로 분할하여 전송한다. 수신 측에서 원래 데이터로 재조립한다.

### 5. TCP 패킷의 생명주기

#### 5.1 패킷 생성 과정
1. **애플리케이션 데이터 수신**: 상위 계층에서 데이터 전달
2. **헤더 정보 설정**: 포트, 시퀀스 번호, 플래그 등 설정
3. **체크섬 계산**: 헤더와 데이터의 무결성 검증값 계산
4. **패킷 캡슐화**: IP 헤더 추가하여 IP 패킷으로 변환

#### 5.2 패킷 전송 과정
1. **네트워크 인터페이스**: 물리적 네트워크로 전송
2. **라우팅**: 목적지까지의 경로 결정
3. **전송**: 여러 네트워크 홉을 거쳐 목적지 도달

#### 5.3 패킷 수신 과정
1. **물리적 수신**: 네트워크 인터페이스에서 패킷 수신
2. **IP 처리**: IP 헤더 검증 및 TCP 세그먼트 추출
3. **TCP 처리**: 헤더 검증, 체크섬 확인, 데이터 추출
4. **애플리케이션 전달**: 상위 계층으로 데이터 전달

### 6. TCP 패킷의 신뢰성 메커니즘

#### 6.1 순서 보장
- **시퀀스 번호**: 각 바이트의 고유 식별자
- **재정렬**: 도착 순서와 관계없이 올바른 순서로 재배열
- **중복 제거**: 같은 시퀀스 번호의 중복 패킷 제거

#### 6.2 오류 검출 및 복구
- **체크섬**: 데이터 무결성 검증
- **타임아웃**: 응답이 없을 때 재전송
- **재전송**: 손실된 패킷의 자동 재전송

#### 6.3 흐름 제어
- **윈도우 크기**: 수신자의 처리 능력에 맞춘 전송량 조절
- **슬라이딩 윈도우**: 동적으로 윈도우 크기 조정
- **백프레셔**: 수신자 버퍼 상태에 따른 전송 제어

### 7. TCP 패킷 분석의 실제 활용

#### 7.1 네트워크 문제 진단
- **연결 문제**: SYN/ACK 플래그 분석으로 연결 상태 확인
- **성능 문제**: 윈도우 크기와 RTT 분석으로 병목 지점 파악
- **오류 분석**: RST 플래그와 체크섬 오류로 문제 원인 추적

#### 7.2 보안 분석
- **포트 스캔**: 비정상적인 포트 접근 시도 감지
- **DDoS 공격**: 대량의 SYN 패킷으로 인한 서비스 거부 공격 탐지
- **데이터 유출**: 의심스러운 대용량 데이터 전송 모니터링

#### 7.3 성능 최적화
- **MSS 튜닝**: 네트워크 환경에 맞는 최적 세그먼트 크기 설정
- **윈도우 스케일링**: 고속 네트워크에서 윈도우 크기 확장
- **SACK 활용**: 네트워크 효율성 향상을 위한 선택적 확인 응답

## 예시

### 실제 TCP 패킷 분석 시나리오

#### 웹 브라우징 과정의 TCP 패킷
1. **연결 설정 (3-way handshake)**
   - 클라이언트 → 서버: SYN (시퀀스: 1000)
   - 서버 → 클라이언트: SYN+ACK (시퀀스: 2000, ACK: 1001)
   - 클라이언트 → 서버: ACK (시퀀스: 1001, ACK: 2001)

2. **HTTP 요청 전송**
   - 클라이언트 → 서버: PSH+ACK (데이터: "GET / HTTP/1.1...")
   - 서버 → 클라이언트: ACK (확인 응답)

3. **HTTP 응답 전송**
   - 서버 → 클라이언트: PSH+ACK (데이터: "HTTP/1.1 200 OK...")
   - 클라이언트 → 서버: ACK (확인 응답)

4. **연결 종료 (4-way handshake)**
   - 클라이언트 → 서버: FIN+ACK
   - 서버 → 클라이언트: ACK
   - 서버 → 클라이언트: FIN+ACK
   - 클라이언트 → 서버: ACK

#### 파일 전송 과정의 TCP 패킷
1. **대용량 데이터 세그멘테이션**
   - 1MB 파일을 1460바이트씩 분할
   - 각 세그먼트마다 순차적인 시퀀스 번호 할당
   - 윈도우 크기에 따른 전송량 조절

2. **오류 복구 과정**
   - 일부 세그먼트 손실 감지
   - 타임아웃 후 손실된 세그먼트 재전송
   - SACK를 통한 선택적 재전송

## 운영 팁

### 성능 최적화

#### 패킷 크기 최적화
- **MSS 설정**: 네트워크 MTU에 맞는 최적 세그먼트 크기
- **윈도우 스케일링**: 고속 네트워크에서 윈도우 크기 확장
- **Nagle 알고리즘**: 작은 패킷들의 결합으로 효율성 향상

#### 네트워크 혼잡 제어
- **슬로우 스타트**: 연결 초기 전송 속도 점진적 증가
- **혼잡 회피**: 네트워크 혼잡 감지 시 전송 속도 조절
- **빠른 재전송**: 중복 ACK를 통한 빠른 손실 감지

### 보안 고려사항

#### 패킷 보안 검증
- **체크섬 검증**: 모든 패킷의 무결성 확인
- **포트 스캔 방지**: 비정상적인 연결 시도 모니터링
- **DDoS 방어**: 대량 연결 시도에 대한 제한

#### 데이터 보호
- **암호화**: 민감한 데이터의 TLS/SSL 암호화
- **인증**: 연결의 신뢰성 확인
- **무결성**: 전송 중 데이터 변경 방지

### 모니터링 및 진단

#### 실시간 모니터링
- **연결 상태**: 활성 TCP 연결 수 추적
- **전송 속도**: 초당 패킷 수 및 바이트 수 모니터링
- **오류율**: 재전송률과 오류 패킷 비율 측정

#### 문제 진단
- **네트워크 지연**: RTT 측정을 통한 지연 분석
- **패킷 손실**: 재전송률을 통한 손실률 계산
- **대역폭 활용**: 윈도우 크기와 전송 속도 분석

## 참고

### 관련 프로토콜과의 관계

#### IP와의 관계
- **캡슐화**: TCP 세그먼트가 IP 패킷의 페이로드로 전송
- **주소 지정**: IP 주소로 호스트 식별, 포트 번호로 애플리케이션 식별
- **라우팅**: IP가 패킷 라우팅, TCP가 데이터 전송 보장

#### 애플리케이션과의 관계
- **소켓 인터페이스**: 애플리케이션이 TCP를 사용하는 표준 방법
- **포트 바인딩**: 애플리케이션이 특정 포트에 바인딩하여 서비스 제공
- **데이터 스트림**: TCP가 제공하는 신뢰성 있는 바이트 스트림

### 표준 및 규격

#### RFC 문서
- **RFC 793**: TCP 프로토콜의 기본 명세
- **RFC 1122**: TCP 구현을 위한 요구사항
- **RFC 1323**: TCP 확장 (윈도우 스케일링, 타임스탬프)
- **RFC 2018**: SACK (선택적 확인 응답)

#### 구현 고려사항
- **플랫폼 독립성**: 다양한 운영체제에서 동일한 동작
- **성능 최적화**: 하드웨어 특성을 고려한 최적화
- **보안 강화**: 최신 보안 위협에 대한 대응

## 요약

TCP 패킷 구조는 인터넷 통신의 기본 요소로, 신뢰성 있는 데이터 전송을 보장한다. 헤더의 각 필드는 특정한 역할을 담당하며, 전체적으로 데이터의 무결성, 순서, 흐름 제어를 구현한다.

실제 네트워크 환경에서는 성능 최적화, 보안 강화, 모니터링이 중요하다. TCP 패킷 분석을 통해 네트워크 문제를 진단하고 성능을 개선할 수 있다.

**실무 팁:**
TCP 패킷 분석은 네트워크 문제 진단에 유용하다. Wireshark 같은 도구를 사용하여 패킷을 분석할 수 있다.
