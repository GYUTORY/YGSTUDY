---
title: 웹 통신의 흐름
tags: [network, domain, 웹-통신의-흐름]
updated: 2025-09-21
---

## 목차

- [개요](#개요)
- [1단계: 브라우저 요청 생성](#1단계-브라우저-요청-생성)
- [2단계: DNS 조회](#2단계-dns-조회)
- [3단계: TCP/IP 연결](#3단계-tcpip-연결)
- [4단계: 서버 요청 처리](#4단계-서버-요청-처리)
- [5단계: 응답 생성](#5단계-응답-생성)
- [6단계: 응답 전송 및 클라이언트 처리](#6단계-응답-전송-및-클라이언트-처리)
- [실제 통신 시나리오](#실제-통신-시나리오)
- [성능 최적화 요소](#성능-최적화-요소)
- [참조](#참조)

---

## 개요

웹 통신은 사용자가 브라우저에서 웹사이트에 접속할 때부터 페이지가 완전히 로드될 때까지의 모든 과정을 의미합니다. 이 과정은 여러 단계로 나뉘며, 각 단계마다 다양한 기술과 프로토콜이 사용됩니다.

### 핵심 용어 정리

| 용어 | 설명 |
|------|------|
| **프로토콜** | 컴퓨터 간 통신 규칙 (HTTP, HTTPS, TCP 등) |
| **도메인** | 웹사이트 주소 (예: www.google.com) |
| **IP 주소** | 인터넷상 컴퓨터의 고유 주소 (예: 192.168.1.1) |
| **포트** | 서비스 구분 번호 (HTTP: 80, HTTPS: 443) |
| **DNS** | 도메인 이름을 IP 주소로 변환하는 시스템 |
| **TCP** | 데이터 전송을 보장하는 통신 프로토콜 |
| **TLS/SSL** | 데이터 암호화를 위한 보안 프로토콜 |

---

## 1단계: 브라우저 요청 생성

### URL 파싱 과정

브라우저는 사용자가 입력한 URL을 분석하여 통신에 필요한 정보를 추출합니다. URL의 각 구성 요소는 특정한 의미를 가지며, 이를 통해 서버와의 통신 방식을 결정합니다.

```
https://www.example.com:443/login?redirect=home#section1
```

| 구성 요소 | 값 | 설명 |
|-----------|-----|------|
| **프로토콜** | `https://` | 보안 통신 방식 (HTTP vs HTTPS) |
| **도메인** | `www.example.com` | 웹사이트 주소 (DNS 조회 대상) |
| **포트** | `:443` | HTTPS 기본 포트 (생략 가능) |
| **경로** | `/login` | 서버 내 특정 페이지 |
| **쿼리** | `?redirect=home` | 추가 정보 전달 |
| **프래그먼트** | `#section1` | 페이지 내 특정 위치 |

### HTTP 요청 메시지 생성

브라우저는 URL 분석 결과를 바탕으로 HTTP 요청 메시지를 생성합니다. 이 메시지는 요청 라인, 헤더, 본문으로 구성되며, 각 부분은 서버가 요청을 처리하는 데 필요한 정보를 담고 있습니다.

**요청 라인**
- HTTP 메서드: GET, POST, PUT, DELETE 등
- 요청 경로: 서버에서 처리할 리소스 위치
- HTTP 버전: 1.1 또는 2.0

**요청 헤더**
- Host: 서버 도메인 정보
- User-Agent: 클라이언트(브라우저) 정보
- Accept: 클라이언트가 받을 수 있는 콘텐츠 타입
- Cookie: 이전 방문 정보 및 세션 데이터

**요청 본문**
- GET 요청: 보통 비어있음
- POST 요청: 전송할 데이터 포함

---

## 2단계: DNS 조회

### DNS의 역할과 중요성

DNS(Domain Name System)는 사람이 기억하기 쉬운 도메인 이름을 컴퓨터가 이해할 수 있는 IP 주소로 변환하는 시스템입니다. 이 과정은 웹 통신의 첫 번째 단계로, 올바른 서버를 찾기 위한 필수 과정입니다.

### DNS 조회 과정

#### 1단계: 로컬 캐시 확인
브라우저는 먼저 자신의 DNS 캐시에서 해당 도메인의 IP 주소를 찾습니다. 이전에 방문한 사이트의 경우 캐시에서 즉시 IP 주소를 얻을 수 있어 통신 속도가 크게 향상됩니다.

#### 2단계: 운영체제 캐시 확인
브라우저 캐시에 없는 경우, 운영체제의 DNS 캐시를 확인합니다. Windows의 경우 hosts 파일과 DNS 캐시를, Linux/macOS의 경우 /etc/hosts 파일과 시스템 DNS 캐시를 확인합니다.

#### 3단계: 라우터 캐시 확인
로컬 캐시에 없는 경우, 네트워크 라우터의 DNS 캐시를 확인합니다. 라우터는 네트워크 내의 모든 기기에서 사용하는 DNS 정보를 캐시하고 있습니다.

#### 4단계: ISP DNS 서버 조회
로컬 캐시에 없는 경우, 인터넷 서비스 제공업체(ISP)의 DNS 서버에 조회 요청을 보냅니다. ISP DNS 서버는 일반적으로 가장 가까운 DNS 서버로, 빠른 응답을 제공합니다.

#### 5단계: 계층적 DNS 조회
ISP DNS 서버에도 정보가 없는 경우, 계층적 DNS 구조를 따라 조회를 진행합니다.

**루트 DNS 서버 조회**
- 루트 DNS 서버는 최상위 도메인(.com, .org, .kr 등)의 정보를 관리
- 도메인의 TLD(Top Level Domain) 정보를 제공

**TLD DNS 서버 조회**
- TLD DNS 서버는 특정 최상위 도메인의 권한 있는 DNS 서버 정보를 관리
- 예: .com 도메인의 경우 .com TLD 서버에서 해당 도메인의 권한 있는 DNS 서버 정보 제공

**권한 있는 DNS 서버 조회**
- 권한 있는 DNS 서버는 실제 도메인의 IP 주소 정보를 관리
- 최종적으로 도메인에 대한 IP 주소를 반환

### DNS 조회 시간과 성능

| 조회 단계 | 소요 시간 | 설명 |
|-----------|-----------|------|
| 로컬 캐시 | 0-1ms | 가장 빠른 응답 |
| ISP DNS | 10-50ms | 일반적인 DNS 조회 |
| 전체 DNS 조회 | 100-300ms | 캐시 미스 시 전체 과정 |

---

## 3단계: TCP/IP 연결

### TCP 연결의 중요성

TCP(Transmission Control Protocol)는 데이터 전송의 신뢰성을 보장하는 프로토콜입니다. 웹 통신에서 TCP는 데이터가 손실 없이 순서대로 전달되도록 하는 핵심 역할을 담당합니다.

### TCP 3-Way Handshake

TCP 연결은 3단계 핸드셰이크 과정을 통해 확립됩니다. 이 과정은 클라이언트와 서버 간의 통신 준비를 위한 필수 단계입니다.

#### 1단계: SYN (Synchronize)
클라이언트가 서버에게 연결 요청을 보냅니다. 이때 SYN 플래그가 설정된 패킷을 전송하여 연결을 시작하고자 함을 알립니다.

#### 2단계: SYN-ACK (Synchronize-Acknowledgment)
서버가 클라이언트의 연결 요청을 받고, 연결을 수락한다는 의미로 SYN과 ACK 플래그가 모두 설정된 패킷을 응답으로 보냅니다.

#### 3단계: ACK (Acknowledgment)
클라이언트가 서버의 응답을 받고, 연결이 확립되었음을 확인하는 ACK 패킷을 보냅니다. 이 시점에서 TCP 연결이 완전히 확립됩니다.

### HTTPS의 경우: TLS Handshake

HTTPS 통신의 경우, TCP 연결 후 추가로 TLS(Transport Layer Security) 핸드셰이크가 필요합니다. 이 과정을 통해 암호화된 통신 채널을 설정합니다.

#### 1단계: Client Hello
클라이언트가 서버에게 지원하는 암호화 알고리즘 목록과 클라이언트 랜덤 값을 전송합니다. 이 정보는 암호화 통신에 사용될 키를 생성하는 데 사용됩니다.

#### 2단계: Server Hello
서버가 클라이언트의 정보를 받고, 사용할 암호화 알고리즘을 선택하여 서버 인증서와 서버 랜덤 값을 전송합니다.

#### 3단계: 인증서 검증
클라이언트가 서버의 인증서를 검증합니다. 인증서의 유효성, 인증서 체인, 도메인 일치 여부를 확인하여 서버의 신원을 검증합니다.

#### 4단계: 키 교환
클라이언트가 Pre-Master Secret을 생성하고, 서버의 공개키로 암호화하여 전송합니다. 이를 통해 양쪽에서 동일한 Master Secret을 생성할 수 있습니다.

#### 5단계: 암호화 통신 시작
양쪽에서 Master Secret을 바탕으로 암호화 키를 생성하고, 이후 모든 통신을 암호화하여 전송합니다.

### 연결 시간 분석

| 연결 단계 | 소요 시간 | 설명 |
|-----------|-----------|------|
| TCP 연결 | 10-50ms | 3-way handshake |
| TLS Handshake | 100-300ms | 암호화 채널 설정 |
| 총 연결 시간 | 110-350ms | TCP + TLS |

---

## 4단계: 서버 요청 처리

### 웹 서버 처리 과정

웹 서버는 클라이언트의 요청을 받아 적절한 처리를 수행합니다. 이 과정은 요청의 유형에 따라 다른 방식으로 처리됩니다.

#### 1단계: 요청 수신 및 분석
웹 서버는 클라이언트로부터 HTTP 요청을 받아 헤더 정보를 분석합니다. Host 헤더를 통해 가상 호스트 설정을 확인하고, 요청의 유형을 파악합니다.

#### 2단계: 라우팅 결정
웹 서버는 요청된 URL을 분석하여 처리 방식을 결정합니다. 정적 파일 요청인지 동적 요청인지에 따라 다른 처리 과정을 거칩니다.

**정적 파일 요청**
- 이미지, CSS, JavaScript 파일 등
- 파일 시스템에서 직접 파일을 읽어 전송
- 빠른 처리 속도와 낮은 서버 부하

**동적 요청**
- 데이터베이스 조회, 사용자 인증 등
- 애플리케이션 서버로 요청 전달
- 복잡한 비즈니스 로직 처리

### 애플리케이션 서버 처리

동적 요청의 경우, 웹 서버는 애플리케이션 서버로 요청을 전달합니다. 애플리케이션 서버는 다음과 같은 과정을 거쳐 요청을 처리합니다.

#### 1단계: 미들웨어 체인 실행
미들웨어는 요청과 응답 사이에서 특정 기능을 수행하는 소프트웨어입니다. 여러 미들웨어가 체인 형태로 연결되어 순차적으로 실행됩니다.

**인증 미들웨어**
- 사용자의 로그인 상태 확인
- 세션 토큰 또는 JWT 토큰 검증
- 사용자 권한 확인

**로깅 미들웨어**
- 요청 정보 기록 (시간, IP, 경로, 응답 시간)
- 시스템 모니터링 및 디버깅 지원

**CORS 미들웨어**
- Cross-Origin Resource Sharing 정책 적용
- 다른 도메인에서의 요청 허용 여부 결정

#### 2단계: 라우터 처리
라우터는 URL 패턴을 분석하여 적절한 컨트롤러를 선택합니다. RESTful API의 경우, HTTP 메서드와 URL 경로를 조합하여 처리할 로직을 결정합니다.

#### 3단계: 컨트롤러 실행
컨트롤러는 요청을 처리하는 핵심 로직을 담당합니다. 요청 파라미터를 분석하고, 필요한 서비스를 호출하여 결과를 생성합니다.

#### 4단계: 비즈니스 로직 처리
서비스 레이어에서 실제 비즈니스 로직을 처리합니다. 데이터베이스 조회, 외부 API 호출, 데이터 가공 등의 작업을 수행합니다.

#### 5단계: 데이터베이스 연동
필요한 경우 데이터베이스에 쿼리를 실행하여 데이터를 조회하거나 수정합니다. 인덱스 활용, 트랜잭션 처리 등을 통해 효율적인 데이터 처리를 수행합니다.

### 서버 처리 시간 분석

| 처리 단계 | 소요 시간 | 설명 |
|-----------|-----------|------|
| 웹 서버 처리 | 1-10ms | 요청 분석 및 라우팅 |
| 애플리케이션 서버 | 10-100ms | 비즈니스 로직 처리 |
| 데이터베이스 쿼리 | 5-50ms | 데이터 조회/수정 |
| 총 서버 처리 | 16-160ms | 전체 서버 처리 시간 |

---

## 5단계: 응답 생성

### HTTP 응답 구조

서버는 요청을 처리한 후 HTTP 응답을 생성합니다. 응답은 상태 라인, 헤더, 본문으로 구성되며, 각 부분은 클라이언트가 응답을 올바르게 처리할 수 있도록 필요한 정보를 제공합니다.

**상태 라인**
- HTTP 버전과 상태 코드
- 요청 처리 결과를 나타내는 상태 메시지

**응답 헤더**
- Content-Type: 응답 데이터의 형식
- Cache-Control: 캐시 정책
- Set-Cookie: 세션 정보 설정
- Access-Control-Allow-Origin: CORS 정책

**응답 본문**
- 실제 데이터 (HTML, JSON, 이미지 등)

### HTTP 상태 코드

HTTP 상태 코드는 요청 처리 결과를 나타내는 3자리 숫자입니다. 각 코드는 특정한 의미를 가지며, 클라이언트가 응답을 어떻게 처리할지 결정하는 데 사용됩니다.

| 코드 범위 | 의미 | 대표적 코드 |
|-----------|------|-------------|
| **1xx** | 정보 | 100 Continue |
| **2xx** | 성공 | 200 OK, 201 Created |
| **3xx** | 리다이렉션 | 301 Moved Permanently, 304 Not Modified |
| **4xx** | 클라이언트 오류 | 400 Bad Request, 404 Not Found |
| **5xx** | 서버 오류 | 500 Internal Server Error |

### 응답 생성 과정

#### 1단계: 데이터 준비
서비스 레이어에서 처리된 결과를 응답 형식에 맞게 준비합니다. 데이터베이스 결과, 외부 API 결과 등을 통합하고 필요한 형태로 변환합니다.

#### 2단계: 직렬화
데이터를 전송 가능한 형태로 변환합니다. JSON, XML 등의 형식으로 직렬화하여 클라이언트가 파싱할 수 있도록 합니다.

#### 3단계: 헤더 설정
응답 헤더를 구성합니다. 상태 코드, 캐시 정책, 보안 헤더 등을 설정하여 클라이언트가 응답을 올바르게 처리할 수 있도록 합니다.

#### 4단계: 압축 (선택적)
전송 효율성을 위해 응답 데이터를 압축합니다. gzip, deflate 등의 압축 방식을 사용하여 네트워크 대역폭을 절약합니다.

---

## 6단계: 응답 전송 및 클라이언트 처리

### 응답 전송 과정

서버는 생성된 응답을 TCP 연결을 통해 클라이언트로 전송합니다. 큰 데이터의 경우 패킷 단위로 분할하여 전송하고, 전송 완료를 확인합니다.

### 클라이언트 처리 과정

#### 1단계: 응답 수신
브라우저는 서버로부터 TCP 패킷을 수신합니다. 패킷을 재조립하여 완전한 HTTP 응답을 복원하고, 응답을 파싱합니다.

#### 2단계: 응답 헤더 분석
브라우저는 응답 헤더를 분석하여 처리 방식을 결정합니다. 상태 코드를 확인하고, Content-Type을 통해 데이터 형식을 파악합니다. 캐시 정책을 적용하고 쿠키를 저장합니다.

#### 3단계: 콘텐츠 처리

**HTML 응답의 경우**
브라우저는 HTML을 파싱하여 DOM(Document Object Model) 트리를 생성합니다. CSS를 파싱하고 스타일을 계산한 후, JavaScript를 실행합니다. 렌더링 트리를 생성하고 레이아웃을 계산한 후 화면에 픽셀을 렌더링합니다.

**JSON 응답의 경우**
브라우저는 JSON을 파싱하여 JavaScript 객체로 변환합니다. 콜백 함수를 실행하고 DOM을 업데이트합니다.

#### 4단계: 추가 리소스 요청
HTML에 포함된 이미지, CSS, JavaScript 파일 등을 추가로 요청합니다. 비동기 API 호출이나 웹소켓 연결이 필요한 경우 이 단계에서 수행됩니다.

### 클라이언트 처리 시간 분석

| 처리 단계 | 소요 시간 | 설명 |
|-----------|-----------|------|
| 응답 수신 | 10-100ms | 네트워크 전송 시간 |
| HTML 파싱 | 5-50ms | DOM 트리 생성 |
| CSS/JS 처리 | 10-200ms | 스타일 계산 및 스크립트 실행 |
| 렌더링 | 5-100ms | 화면에 픽셀 렌더링 |
| 총 클라이언트 처리 | 30-450ms | 전체 클라이언트 처리 시간 |

---

## 실제 통신 시나리오

### 시나리오: 사용자가 로그인 페이지에 접속

#### 1. 사용자 행동
사용자가 브라우저 주소창에 "https://myapp.com/login"을 입력합니다.

#### 2. 브라우저 요청 생성
브라우저는 URL을 파싱하여 프로토콜(https), 도메인(myapp.com), 경로(/login)를 분석합니다. HTTP 요청을 생성하여 서버로 전송합니다.

#### 3. DNS 조회
브라우저는 myapp.com의 IP 주소를 찾기 위해 DNS 조회를 수행합니다. 로컬 캐시에서 찾지 못한 경우, ISP DNS 서버를 통해 계층적 DNS 조회를 진행합니다.

#### 4. TCP 연결
브라우저는 DNS 조회 결과로 얻은 IP 주소(예: 203.0.113.10)로 TCP 연결을 시도합니다. 3-way handshake를 통해 연결을 확립하고, HTTPS의 경우 TLS handshake를 추가로 수행합니다.

#### 5. 서버 요청 처리
로드 밸런서가 요청을 받아 적절한 웹 서버를 선택합니다. 웹 서버는 정적 파일 확인 후 애플리케이션 서버로 요청을 전달합니다. 애플리케이션 서버는 라우터를 통해 LoginController를 선택하고 로그인 페이지 HTML을 생성합니다.

#### 6. 응답 생성
서버는 HTML 응답을 생성합니다. 상태 코드 200 OK와 함께 Content-Type: text/html 헤더를 설정하고, 로그인 페이지의 HTML 내용을 응답 본문에 포함합니다.

#### 7. 클라이언트 처리
브라우저는 HTML을 파싱하여 DOM 트리를 생성합니다. CSS와 JavaScript 파일을 추가로 요청하고, 페이지 렌더링을 완료합니다.

### 전체 소요 시간 분석

| 단계 | 시간 | 누적 시간 |
|------|------|-----------|
| DNS 조회 | 150ms | 150ms |
| TCP 연결 | 200ms | 350ms |
| 서버 처리 | 100ms | 450ms |
| 응답 전송 | 50ms | 500ms |
| 클라이언트 처리 | 200ms | 700ms |
| **총 시간** | **700ms** | **700ms** |

---

## 성능 최적화 요소

### DNS 최적화
- DNS 캐시 활용: 로컬 캐시를 통해 DNS 조회 시간 단축
- DNS 프리페칭: 페이지 로드 전 미리 DNS 조회 수행
- CDN 활용: 지리적으로 가까운 서버 사용

### 연결 최적화
- HTTP/2 사용: 다중화를 통한 연결 효율성 향상
- Keep-Alive: 연결 재사용으로 핸드셰이크 시간 절약
- TLS 세션 재사용: 암호화 설정 시간 단축

### 서버 최적화
- 로드 밸런싱: 여러 서버로 부하 분산
- 캐싱: 정적 파일 및 동적 콘텐츠 캐싱
- 압축: gzip 등을 통한 데이터 크기 감소

### 클라이언트 최적화
- 리소스 최적화: 이미지 압축, CSS/JS 최소화
- 비동기 로딩: 중요하지 않은 리소스 지연 로딩
- 브라우저 캐싱: 정적 리소스 캐싱 활용

---

## 참조

1. **HTTP/1.1 명세 (RFC 7230-7237)**
   - https://tools.ietf.org/html/rfc7230
   - HTTP 프로토콜의 공식 명세서

2. **DNS 명세 (RFC 1035)**
   - https://tools.ietf.org/html/rfc1035
   - DNS 시스템의 기본 구조와 동작 방식

3. **TCP 명세 (RFC 793)**
   - https://tools.ietf.org/html/rfc793
   - TCP 프로토콜의 신뢰성 보장 메커니즘

4. **TLS 1.3 명세 (RFC 8446)**
   - https://tools.ietf.org/html/rfc8446
   - 최신 TLS 프로토콜의 보안 기능

5. **웹 성능 최적화 가이드**
   - https://web.dev/performance/
   - Google의 웹 성능 최적화 모범 사례

6. **MDN 웹 문서 - HTTP**
   - https://developer.mozilla.org/ko/docs/Web/HTTP
   - HTTP 프로토콜의 상세한 설명과 예시

7. **브라우저 렌더링 과정**
   - https://web.dev/howbrowserswork/
   - 브라우저의 내부 동작 원리

8. **DNS 작동 원리**
   - https://howdns.works/
   - DNS 시스템의 시각적 설명

9. **TCP/IP 프로토콜 스택**
   - https://www.ietf.org/rfc/rfc1122.txt
   - 인터넷 프로토콜 스택의 전체 구조

10. **웹 보안 모범 사례**
    - https://owasp.org/www-project-top-ten/
    - OWASP의 웹 보안 취약점 및 대응 방안
