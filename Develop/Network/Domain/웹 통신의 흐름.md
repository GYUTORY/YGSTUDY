# 웹 통신의 큰 흐름

### 1. 브라우저의 요청 생성(API 호출)
- 사용자가 웹 브라우저에 URL을 입력하거나 링크를 클릭하면, 브라우저는 해당 요청을 처리하기 시작합니다.
- 브라우저는 URL을 파싱하여 다음과 같은 정보를 추출합니다:
  - 프로토콜 (http://, https://)
  - 도메인 이름 (예: www.example.com)
  - 포트 번호 (기본값: http는 80, https는 443)
  - 경로 (/path/to/resource)
  - 쿼리 파라미터 (?key=value)
  - 프래그먼트 (#section)
- HTTP 요청 메시지가 생성되며, 다음과 같은 요소들이 포함됩니다:
  - HTTP 메서드 (GET, POST, PUT, DELETE 등)
  - 요청 헤더 (User-Agent, Accept, Content-Type, Cookie 등)
  - 요청 본문 (POST나 PUT 요청의 경우 데이터 포함)
  - 쿠키 정보 (세션 관리, 인증 등에 사용)

### 2. DNS Lookup (도메인 이름 시스템 조회)
- 브라우저는 도메인 이름을 IP 주소로 변환하기 위해 DNS 조회를 수행합니다.
- DNS 조회 과정:
  1. 브라우저 캐시 확인: 이전에 방문한 도메인의 IP 주소가 캐시되어 있는지 확인
  2. 운영체제 캐시 확인: hosts 파일과 시스템 DNS 캐시 확인
  3. 라우터 캐시 확인: 라우터의 DNS 캐시 확인
  4. ISP(인터넷 서비스 제공자)의 DNS 서버에 요청
  5. 루트 DNS 서버 → TLD(Top Level Domain) 서버 → 권한 있는 DNS 서버 순으로 조회
- DNS 조회 결과로 IP 주소를 얻으면, 브라우저는 해당 IP 주소를 사용하여 서버에 연결합니다.

### 3. TCP/IP 연결 (3-way handshake)
- 브라우저는 서버와의 안정적인 연결을 위해 TCP/IP 프로토콜을 사용합니다.
- TCP 3-way handshake 과정:
  1. SYN: 클라이언트가 서버에 연결 요청 (SYN 패킷 전송)
  2. SYN-ACK: 서버가 요청을 수락하고 응답 (SYN-ACK 패킷 전송)
  3. ACK: 클라이언트가 서버의 응답을 확인 (ACK 패킷 전송)
- HTTPS의 경우, TLS(Transport Layer Security) handshake가 추가로 수행됩니다:
  1. 클라이언트가 지원하는 암호화 방식 전송
  2. 서버가 선택한 암호화 방식과 인증서 전송
  3. 클라이언트가 인증서 검증
  4. 대칭키 교환 및 암호화 통신 시작

### 4. 서버 요청 처리
- 웹 서버(예: Nginx, Apache)가 요청을 받으면:
  1. 요청 헤더 분석
  2. 가상 호스트 설정 확인
  3. URL 라우팅 규칙 적용
  4. 정적 파일 서빙 또는 애플리케이션 서버로 요청 전달
- 애플리케이션 서버(예: Node.js, Django, Spring)에서:
  1. 미들웨어 처리 (인증, 로깅, CORS 등)
  2. 라우터에서 적절한 컨트롤러 선택
  3. 비즈니스 로직 실행
  4. 데이터베이스 쿼리 실행 (필요한 경우)
  5. 외부 API 호출 (필요한 경우)

### 5. 응답 생성
- 서버는 요청 처리 결과를 기반으로 HTTP 응답을 생성합니다:
  - 상태 코드 (예: 200 OK, 404 Not Found, 500 Internal Server Error)
  - 응답 헤더 (Content-Type, Cache-Control, Set-Cookie 등)
  - 응답 본문 (HTML, JSON, XML 등)
- 응답 생성 과정:
  1. 데이터베이스 결과 처리
  2. 템플릿 렌더링 (서버 사이드 렌더링의 경우)
  3. JSON 직렬화 (API 응답의 경우)
  4. 캐시 헤더 설정
  5. 보안 헤더 설정 (CORS, CSP 등)

### 6. 응답 전송 및 클라이언트 처리
- 서버는 TCP/IP 연결을 통해 응답을 전송합니다.
- 브라우저는 응답을 받아 처리합니다:
  1. 응답 헤더 분석
  2. 캐시 정책 확인 및 적용
  3. 콘텐츠 디코딩 (압축 해제 등)
  4. HTML 파싱 및 DOM 트리 생성
  5. CSS 파싱 및 스타일 계산
  6. JavaScript 실행
  7. 렌더링 트리 생성 및 레이아웃 계산
  8. 화면에 픽셀 렌더링
- 추가 리소스 요청:
  - 이미지, 스타일시트, 스크립트 등 추가 리소스 요청
  - 비동기 API 요청 (AJAX, Fetch API)
  - 웹소켓 연결 (실시간 통신이 필요한 경우)

---

# 서버 라우팅 상세 설명

### 1. 웹 서버 레벨 라우팅
- 정적 파일 서빙:
  - 파일 시스템 기반 라우팅
  - MIME 타입 자동 감지
  - 디렉토리 인덱싱 설정
- 리버스 프록시:
  - URL 패턴에 따른 백엔드 서버 분배
  - 로드 밸런싱
  - SSL/TLS 종료

### 2. 애플리케이션 서버 라우팅
- 라우트 정의:
  - HTTP 메서드와 URL 패턴 매칭
  - 파라미터 추출 (/users/:id)
  - 쿼리 스트링 처리
- 미들웨어 체인:
  - 인증/인가
  - 요청/응답 변환
  - 에러 처리
  - 로깅
- 컨트롤러:
  - 비즈니스 로직 실행
  - 데이터베이스 연동
  - 응답 생성

### 3. API 게이트웨이
- 엔드포인트 통합
- 요청/응답 변환
- 레이트 리미팅
- 서킷 브레이커
- API 버전 관리

### 4. 마이크로서비스 라우팅
- 서비스 디스커버리
- 동적 라우팅
- 서비스 메시
- 로드 밸런싱
- 헬스 체크

---

# 쉬운정리

### 1. 클라이언트 요청
- 사용자가 웹 브라우저나 모바일 앱을 통해 웹 서비스에 접속하고 원하는 작업을 요청합니다.
- 이 요청은 일반적으로 HTTP(S) 프로토콜을 사용하여 전송됩니다.

### 2. 서버 라우팅
- 서버는 클라이언트 요청을 받아들이고 해당 요청을 처리할 적절한 핸들러(Handler)로 라우팅

### 3. 비즈니스 로직 처리
- 핸들러는 비즈니스 로직을 수행하여 요청에 필요한 데이터를 가져오거나 변경.
- 이 단계에서 데이터베이스나 외부 API와 상호작용이 필요한 경우가 많습니다.

### 4. 데이터 처리와 저장
- 필요한 데이터를 가져왔다면, 핸들러는 해당 데이터를 처리하고 필요한 변경 사항을 데이터베이스에 저장합니다.

### 5. 응답생성
- 핸들러는 처리된 결과를 클라이언트에게 반환하기 위해 응답을 생성합니다.
- 응답은 일반적으로 JSON, XML 또는 HTML과 같은 형식으로 구성됩니다.
- 응답에는 클라이언트에게 전달할 데이터와 상태 코드가 포함될 수 있습니다.

### 6. 클라이언트 응답 처리
- 클라리언트는 받은 응답을 해석ㅎ고 필요한 처리를 수행




---

### 서버 라우팅에 대해 알아보자.


#### 서버 라우팅
- 클라이언트의 요청이 도달한 서버로 효율적으로 전달되는 과정을 의미합니다. 
- 서버 라우팅은 네트워크 환경에서 데이터 패킷을 적절한 목적지로 전송하는 데 사용되며, 웹 서버, 애플리케이션 서버, 로드 밸런서 등 다양한 서버 환경에서 적용될 수 있습니다.

