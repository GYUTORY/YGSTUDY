---
title: 가상 메모리 (Virtual Memory) 완벽 가이드
tags: [os, memory, virtual-memory, paging, page-fault, tlb]
updated: 2024-12-19
---

# 가상 메모리 (Virtual Memory) 완벽 가이드

## 배경

### 가상 메모리란?
가상 메모리는 컴퓨터 시스템의 물리적 메모리를 효율적으로 사용하기 위해 도입된 메모리 관리 기법입니다. 프로그램이 실제로 필요한 메모리보다 더 큰 메모리를 사용할 수 있도록 하며, 운영체제(OS)가 이를 지원합니다.

### 가상 메모리의 필요성
- **메모리 효율성**: 물리적 메모리보다 큰 프로그램 실행 가능
- **멀티태스킹**: 여러 프로그램의 동시 실행 지원
- **메모리 보호**: 프로세스 간 메모리 격리
- **메모리 단편화 해결**: 논리적 연속성을 물리적 연속성과 분리

### 기본 개념
- **가상 주소**: 프로그램이 참조하는 논리적 메모리 주소
- **물리 주소**: 실제 RAM의 물리적 메모리 주소
- **페이지**: 가상 메모리를 일정 크기로 나눈 블록 (보통 4KB)
- **페이지 테이블**: 가상 주소와 물리 주소 간의 매핑 정보

## 핵심

### 1. 가상 메모리 동작 원리

#### 가상 주소 변환 과정
```
1. 가상 주소 요청: 프로그램이 데이터를 요청할 때 가상 주소 사용
2. 페이지 테이블 참조: OS가 페이지 테이블을 확인하여 매핑 정보 검색
3. TLB 캐시 확인: 빠른 주소 변환을 위한 캐시 검색
4. 물리 주소 접근: 변환된 물리 주소로 실제 데이터 접근
```

#### TLB (Translation Lookaside Buffer)
- 페이지 테이블의 정보를 빠르게 검색하기 위한 캐시
- 최근 사용된 가상 주소와 물리 주소 매핑 정보 저장
- CPU 내부에 위치하여 매우 빠른 접근 가능

#### 페이지 폴트 (Page Fault)
- 요청한 데이터가 물리적 메모리에 없을 때 발생하는 인터럽트
- OS가 디스크에서 필요한 페이지를 메모리로 로드
- 페이지 교체 알고리즘을 통해 메모리 관리

### 2. 가상 메모리 관리 기법

#### 페이징 (Paging)
```c
// 페이지 테이블 엔트리 구조 예시
struct page_table_entry {
    uint32_t frame_number;    // 물리 프레임 번호
    uint8_t present;          // 메모리 상주 여부
    uint8_t dirty;            // 수정 여부
    uint8_t accessed;         // 접근 여부
    uint8_t protection;       // 보호 비트
};
```

#### 페이지 교체 알고리즘
- **FIFO (First In First Out)**: 가장 오래된 페이지 교체
- **LRU (Least Recently Used)**: 가장 오랫동안 사용되지 않은 페이지 교체
- **Clock Algorithm**: 참조 비트를 이용한 근사 LRU 알고리즘

### 3. 가상 메모리의 장단점

#### 장점
1. **효율적인 메모리 사용**
   - 모든 프로그램이 동시에 메모리를 점유하지 않고, 필요한 부분만 메모리에 로드
2. **프로그램 크기 제한 해제**
   - 물리적 메모리보다 큰 프로그램도 실행 가능
3. **보안 강화**
   - 프로세스마다 고유한 가상 메모리 공간을 제공하여 서로의 메모리에 접근 방지

#### 단점
1. **속도 저하**
   - 디스크에서 데이터를 읽고 쓰는 과정이 느림
2. **페이지 폴트 비용**
   - 페이지 폴트가 빈번하게 발생하면 시스템 성능 저하
3. **복잡성 증가**
   - 가상 메모리 관리를 위한 추가적인 하드웨어와 소프트웨어 자원 필요

## 예시

### 1. 실제 사용 사례

#### Python을 이용한 메모리 사용 확인
```python
import os
import psutil

def check_memory_usage():
    process = psutil.Process(os.getpid())
    memory_info = process.memory_info()
    
    print(f"가상 메모리 사용량: {memory_info.vms / 1024 ** 2:.2f} MB")
    print(f"물리적 메모리 사용량: {memory_info.rss / 1024 ** 2:.2f} MB")
    
    # 시스템 전체 메모리 정보
    system_memory = psutil.virtual_memory()
    print(f"시스템 전체 메모리: {system_memory.total / 1024 ** 3:.2f} GB")
    print(f"사용 가능한 메모리: {system_memory.available / 1024 ** 3:.2f} GB")
    print(f"메모리 사용률: {system_memory.percent:.1f}%")

if __name__ == "__main__":
    check_memory_usage()
```

#### C 언어에서 메모리 매핑
```c
#include <sys/mman.h>
#include <stdio.h>
#include <unistd.h>

int main() {
    // 메모리 매핑 생성
    size_t size = 1024 * 1024; // 1MB
    void *mapped_memory = mmap(NULL, size, PROT_READ | PROT_WRITE, 
                               MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    
    if (mapped_memory == MAP_FAILED) {
        perror("mmap failed");
        return 1;
    }
    
    printf("매핑된 메모리 주소: %p\n", mapped_memory);
    
    // 메모리 사용
    int *data = (int*)mapped_memory;
    data[0] = 42;
    printf("저장된 값: %d\n", data[0]);
    
    // 메모리 매핑 해제
    munmap(mapped_memory, size);
    
    return 0;
}
```

### 2. 운영체제별 가상 메모리 관리

#### Linux 가상 메모리 확인
```bash
# 메모리 정보 확인
cat /proc/meminfo

# 프로세스별 메모리 사용량
ps aux --sort=-%mem | head -10

# 스왑 사용량 확인
free -h

# 가상 메모리 통계
vmstat 1 5
```

#### Windows 가상 메모리 설정
```powershell
# 가상 메모리 설정 확인
Get-WmiObject -Class Win32_ComputerSystem | Select-Object TotalPhysicalMemory

# 페이지 파일 정보 확인
Get-WmiObject -Class Win32_PageFileUsage | Select-Object Name, AllocatedBaseSize, CurrentUsage
```

## 운영 팁

### 1. 가상 메모리 성능 최적화

#### 페이지 크기 최적화
```bash
# Linux에서 페이지 크기 확인
getconf PAGESIZE

# 대용량 페이지 사용 (Linux)
echo 1024 > /proc/sys/vm/nr_hugepages
```

#### TLB 최적화
```c
// 페이지 정렬을 통한 TLB 효율성 향상
#include <sys/mman.h>

void *aligned_malloc(size_t size) {
    // 페이지 크기에 맞춰 정렬
    size_t page_size = sysconf(_SC_PAGESIZE);
    size_t aligned_size = (size + page_size - 1) & ~(page_size - 1);
    
    return mmap(NULL, aligned_size, PROT_READ | PROT_WRITE,
                MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
}
```

### 2. 메모리 모니터링

#### 실시간 메모리 모니터링 스크립트
```bash
#!/bin/bash
# memory_monitor.sh

while true; do
    echo "=== $(date) ==="
    echo "메모리 사용량:"
    free -h
    echo ""
    echo "스왑 사용량:"
    swapon --show
    echo ""
    echo "페이지 폴트 통계:"
    cat /proc/vmstat | grep -E "(pgfault|pgmajfault)"
    echo "================================"
    sleep 5
done
```

### 3. 문제 해결

#### 메모리 부족 문제 해결
```bash
# 메모리 사용량이 많은 프로세스 확인
ps aux --sort=-%mem | head -10

# 스왑 사용량 확인
swapon --show

# 메모리 캐시 정리
echo 3 > /proc/sys/vm/drop_caches
```

## 참고

### 가상 메모리 관련 용어

| 용어 | 설명 |
|------|------|
| **페이지(Page)** | 메모리를 일정 크기로 나눈 블록 |
| **프레임(Frame)** | 물리적 메모리의 페이지 크기 블록 |
| **스왑(Swap)** | 물리적 메모리가 부족할 때 데이터를 디스크로 옮기는 과정 |
| **TLB** | 페이지 테이블을 빠르게 검색하기 위한 캐시 |
| **페이지 폴트** | 가상 주소에 해당하는 데이터가 물리적 메모리에 없을 때 발생하는 인터럽트 |
| **워킹 셋** | 프로세스가 실제로 사용하는 페이지들의 집합 |

### 가상 메모리 사용 분야

#### 멀티태스킹 운영체제
여러 프로그램이 동시에 실행될 때, 각 프로그램이 물리적 메모리 부족 없이 실행될 수 있습니다.

#### 클라우드 컴퓨팅
가상 머신에서 메모리를 효율적으로 분배하고 관리할 수 있습니다.

#### 게임 엔진
대규모 게임 환경에서도 메모리 사용을 최적화하여 성능을 유지합니다.

### 가상 메모리 vs 물리 메모리

| 특징 | 가상 메모리 | 물리 메모리 |
|------|-------------|-------------|
| **크기** | 프로세스마다 독립적 | 시스템 전체 공유 |
| **속도** | 상대적으로 느림 | 빠름 |
| **관리** | OS가 관리 | 하드웨어 직접 관리 |
| **보호** | 프로세스 간 격리 | 없음 |

### 결론
가상 메모리는 컴퓨터 시스템에서 효율적인 메모리 관리와 멀티태스킹 지원을 위해 필수적인 기술입니다. 하지만 가상 메모리의 성능을 최적화하기 위해서는 하드웨어와 운영체제의 적절한 협업이 중요합니다. 적절한 페이지 크기 설정, TLB 최적화, 그리고 효율적인 페이지 교체 알고리즘을 통해 가상 메모리의 성능을 향상시킬 수 있습니다.





