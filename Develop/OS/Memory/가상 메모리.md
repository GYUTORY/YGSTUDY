---
title: Virtual Memory
tags: [os, memory, 가상-메모리]
updated: 2025-09-21
---

# 가상 메모리(Virtual Memory)

## 가상 메모리의 본질

가상 메모리는 현대 컴퓨터 시스템에서 메모리 관리를 혁신적으로 바꾼 핵심 기술입니다. 이 기술의 핵심은 **프로그램이 실제 물리적 메모리보다 훨씬 큰 메모리 공간을 사용할 수 있게 해주는 것**입니다. 마치 마법처럼 보이지만, 이는 운영체제와 하드웨어가 협력하여 만들어내는 정교한 메커니즘입니다.

### 왜 가상 메모리가 필요한가?

초기 컴퓨터 시스템에서는 프로그램이 물리적 메모리 크기에 제한을 받았습니다. 4GB RAM이 있다면, 실행 중인 모든 프로그램의 메모리 사용량이 4GB를 초과할 수 없었습니다. 하지만 현실에서는:

- 웹 브라우저만으로도 수십 개의 탭을 열어 수 GB의 메모리를 사용
- 개발 도구, 게임, 미디어 플레이어 등이 동시에 실행
- 각 프로그램이 자신만의 독립적인 메모리 공간을 요구

이러한 요구사항을 해결하기 위해 가상 메모리 시스템이 등장했습니다.

## 가상 메모리의 핵심 구성 요소

### 1. 가상 주소 공간 (Virtual Address Space)

모든 프로세스는 자신만의 독립적인 가상 주소 공간을 가집니다. 이 공간은 보통 32비트 시스템에서는 4GB, 64비트 시스템에서는 16EB(엑사바이트)까지 확장 가능합니다. 

**핵심 포인트**: 이 주소 공간은 논리적이며, 실제 물리적 메모리와는 별개입니다. 프로그램이 0x1000 주소에 데이터를 저장한다고 해서, 물리적 메모리의 0x1000 위치에 저장되는 것이 아닙니다.

### 2. 페이지 (Page)와 페이지 프레임 (Page Frame)

가상 메모리는 **페이지**라는 고정 크기 블록으로 나뉩니다. 일반적인 페이지 크기는 4KB이지만, 시스템에 따라 8KB, 2MB, 1GB 등 다양한 크기를 사용할 수 있습니다.

- **페이지**: 가상 메모리의 고정 크기 블록
- **페이지 프레임**: 물리적 메모리의 고정 크기 블록
- **페이지 크기**: 시스템에 따라 다르지만, 보통 4KB

### 3. 페이지 테이블 (Page Table)

페이지 테이블은 가상 메모리 시스템의 핵심 데이터 구조입니다. 각 프로세스마다 독립적인 페이지 테이블을 가지며, 이 테이블은 가상 주소를 물리 주소로 변환하는 매핑 정보를 저장합니다.

**페이지 테이블 엔트리의 구성**:
- **유효 비트 (Valid Bit)**: 해당 페이지가 물리적 메모리에 있는지 여부
- **물리 주소**: 가상 페이지가 매핑된 물리적 페이지 프레임의 주소
- **접근 권한**: 읽기, 쓰기, 실행 권한 정보
- **기타 제어 비트**: 캐시 가능 여부, 수정 여부 등

## 가상 메모리의 동작 원리

### 1. 주소 변환 과정

프로그램이 메모리에 접근할 때의 과정을 단계별로 살펴보겠습니다:

1. **가상 주소 생성**: 프로그램이 가상 주소를 생성
2. **페이지 번호 추출**: 가상 주소에서 페이지 번호와 오프셋을 분리
3. **페이지 테이블 조회**: 페이지 번호를 인덱스로 사용하여 페이지 테이블에서 물리 주소 조회
4. **물리 주소 계산**: 물리적 페이지 프레임 주소 + 오프셋
5. **메모리 접근**: 계산된 물리 주소로 실제 메모리 접근

### 2. TLB (Translation Lookaside Buffer)

페이지 테이블 조회는 메모리 접근이므로 시간이 오래 걸립니다. 이를 해결하기 위해 **TLB**라는 하드웨어 캐시를 사용합니다.

TLB는 최근에 사용된 가상 주소-물리 주소 매핑을 저장하는 고속 캐시입니다. TLB 히트 시에는 페이지 테이블 조회 없이 바로 물리 주소를 얻을 수 있어 성능이 크게 향상됩니다.

### 3. 페이지 폴트 (Page Fault)

페이지 폴트는 요청된 페이지가 물리적 메모리에 없을 때 발생하는 인터럽트입니다. 이는 가상 메모리 시스템의 핵심 메커니즘 중 하나입니다.

**페이지 폴트 처리 과정**:
1. **페이지 폴트 발생**: CPU가 유효하지 않은 페이지에 접근 시도
2. **인터럽트 처리**: 운영체제의 페이지 폴트 핸들러 호출
3. **페이지 위치 확인**: 디스크의 스왑 영역에서 해당 페이지 위치 확인
4. **페이지 로드**: 디스크에서 물리적 메모리로 페이지 로드
5. **페이지 테이블 업데이트**: 새로운 매핑 정보로 페이지 테이블 갱신
6. **프로세스 재시작**: 원래 명령어부터 다시 실행

## 스왑 (Swap) 메커니즘

### 스왑의 필요성

물리적 메모리가 부족할 때, 운영체제는 사용하지 않는 페이지를 디스크의 스왑 영역으로 이동시킵니다. 이를 통해 더 많은 프로세스가 동시에 실행될 수 있습니다.

### 스왑 아웃 (Swap Out) 과정

1. **메모리 부족 감지**: 시스템이 물리적 메모리 부족 상황 감지
2. **대상 페이지 선택**: LRU(Least Recently Used) 등의 알고리즘으로 교체 대상 선택
3. **페이지 쓰기**: 선택된 페이지를 디스크의 스왑 영역에 저장
4. **페이지 테이블 업데이트**: 해당 페이지를 "스왑됨" 상태로 표시
5. **메모리 해제**: 물리적 메모리에서 페이지 제거

### 스왑 인 (Swap In) 과정

1. **페이지 폴트 발생**: 스왑된 페이지에 접근 시도
2. **스왑 위치 확인**: 페이지 테이블에서 스왑 영역의 위치 확인
3. **페이지 로드**: 디스크에서 물리적 메모리로 페이지 복원
4. **페이지 테이블 업데이트**: 새로운 물리 주소로 매핑 정보 갱신

## 가상 메모리의 장점과 단점

### 주요 장점

**1. 메모리 효율성**
- 프로그램이 실제로 사용하는 메모리만 물리적 메모리에 로드
- 여러 프로세스가 동일한 코드나 데이터를 공유 가능 (Copy-on-Write)
- 메모리 단편화 문제 해결

**2. 프로그램 크기 제한 해제**
- 물리적 메모리보다 큰 프로그램도 실행 가능
- 대용량 데이터베이스나 게임 엔진 등에서 필수적

**3. 보안과 격리**
- 각 프로세스가 독립적인 가상 주소 공간을 가짐
- 프로세스 간 메모리 접근 차단으로 보안 강화
- 메모리 보호 기능 제공

**4. 멀티태스킹 지원**
- 여러 프로그램이 동시에 실행되어도 메모리 부족 없이 동작
- 프로세스 간 전환이 빠르고 효율적

### 주요 단점

**1. 성능 오버헤드**
- 주소 변환 과정에서 추가적인 메모리 접근 필요
- 페이지 폴트 발생 시 디스크 I/O로 인한 지연
- TLB 미스 시 성능 저하

**2. 복잡성 증가**
- 하드웨어와 소프트웨어의 복잡한 협력 필요
- 메모리 관리 알고리즘의 복잡성
- 디버깅과 성능 튜닝의 어려움

**3. 스왑 공간 관리**
- 디스크 공간을 스왑 영역으로 사용해야 함
- 스왑 I/O로 인한 시스템 성능 저하 가능성

## 실제 시스템에서의 가상 메모리

### Linux 시스템의 가상 메모리

Linux에서는 `/proc/meminfo` 파일을 통해 가상 메모리 사용 현황을 확인할 수 있습니다:

- **MemTotal**: 전체 물리적 메모리
- **MemFree**: 사용 가능한 물리적 메모리
- **SwapTotal**: 전체 스왑 공간
- **SwapFree**: 사용 가능한 스왑 공간
- **Cached**: 페이지 캐시로 사용되는 메모리
- **Buffers**: 버퍼로 사용되는 메모리

### Windows 시스템의 가상 메모리

Windows에서는 작업 관리자나 성능 모니터를 통해 가상 메모리 사용량을 모니터링할 수 있습니다. Windows는 페이지 파일(pagefile.sys)을 스왑 공간으로 사용합니다.

## 가상 메모리 최적화 전략

### 1. 페이지 크기 최적화

시스템의 워크로드에 따라 적절한 페이지 크기를 선택하는 것이 중요합니다:
- **작은 페이지 (4KB)**: 메모리 효율성이 높지만 TLB 미스 증가
- **큰 페이지 (2MB, 1GB)**: TLB 효율성이 높지만 메모리 낭비 가능

### 2. TLB 최적화

- **TLB 크기 증가**: 더 많은 매핑 정보를 캐시
- **TLB 구조 개선**: 멀티레벨 TLB, 하이브리드 TLB 등
- **프로그램 최적화**: 지역성 원칙을 활용한 메모리 접근 패턴

### 3. 스왑 최적화

- **스왑 공간 크기 조정**: 시스템 워크로드에 맞는 적절한 크기 설정
- **스왑 위치 최적화**: SSD 사용, 별도 파티션 할당
- **스왑 알고리즘 튜닝**: LRU, LFU 등 교체 알고리즘 최적화

## 현대 컴퓨터에서의 가상 메모리

### 클라우드 환경에서의 가상 메모리

클라우드 컴퓨팅 환경에서는 가상 머신(VM)마다 독립적인 가상 메모리 공간을 가지며, 하이퍼바이저가 이를 관리합니다. 이는 물리적 서버의 메모리를 여러 VM이 효율적으로 공유할 수 있게 해줍니다.

### 컨테이너 환경에서의 가상 메모리

Docker와 같은 컨테이너 기술에서는 호스트 OS의 가상 메모리 시스템을 공유하면서도 프로세스 격리를 제공합니다. 이는 VM보다 가벼우면서도 충분한 격리를 제공합니다.

### 모바일 환경에서의 가상 메모리

스마트폰과 태블릿에서는 배터리 수명과 성능의 균형을 위해 가상 메모리 시스템이 최적화되어 있습니다. 메모리 압축, 적응형 스왑 등의 기술이 사용됩니다.

## 결론

가상 메모리는 현대 컴퓨터 시스템의 핵심 기술로, 메모리 관리의 혁신을 가져왔습니다. 이 기술을 통해 우리는 제한된 물리적 메모리로도 복잡하고 대용량의 프로그램들을 효율적으로 실행할 수 있게 되었습니다.

하지만 가상 메모리 시스템의 성능을 최대화하려면 하드웨어와 소프트웨어의 세심한 조율이 필요합니다. 페이지 크기, TLB 구조, 스왑 정책 등 다양한 요소들이 시스템 성능에 영향을 미치기 때문입니다.

앞으로도 메모리 용량의 증가와 새로운 워크로드의 등장에 따라 가상 메모리 기술은 계속 발전할 것입니다. 특히 인공지능, 빅데이터, 실시간 시스템 등의 요구사항을 충족하기 위한 새로운 메모리 관리 기법들이 연구되고 있습니다.

---

## 참조

- Tanenbaum, A. S., & Bos, H. (2014). *Modern Operating Systems* (4th ed.). Pearson.
- Silberschatz, A., Galvin, P. B., & Gagne, G. (2018). *Operating System Concepts* (10th ed.). Wiley.
- Intel Corporation. (2020). *Intel 64 and IA-32 Architectures Software Developer's Manual*.
- Linux Kernel Documentation. (2023). *Memory Management*.
- Microsoft Corporation. (2022). *Windows Internals* (7th ed.). Microsoft Press.