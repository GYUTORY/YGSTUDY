---
title: 레이스 컨디션 (Race Condition) 완벽 가이드
tags: [os, process-and-thread, race-condition, concurrency, synchronization]
updated: 2025-08-10
---

# 레이스 컨디션 (Race Condition) 완벽 가이드

## 배경

레이스 컨디션은 두 개 이상의 프로세스나 스레드가 공유 자원에 동시에 접근할 때, 실행 순서에 따라 결과가 달라질 수 있는 상황을 말합니다. 이는 병렬 프로그래밍에서 가장 흔한 문제 중 하나이며, 멀티스레드 환경에서 특히 주의해야 할 이슈입니다.

### 레이스 컨디션의 필요성
- **병렬 처리**: 여러 스레드의 동시 실행으로 인한 성능 향상
- **자원 공유**: 메모리, 파일, 네트워크 연결 등의 공유 자원 활용
- **동시성 제어**: 공유 자원에 대한 안전한 접근 보장
- **데이터 일관성**: 여러 스레드 간의 데이터 무결성 유지
- **시스템 안정성**: 예측 가능한 프로그램 동작 보장

### 기본 개념
- **공유 자원**: 여러 스레드가 동시에 접근할 수 있는 자원
- **임계 구역**: 공유 자원에 접근하는 코드 영역
- **동기화**: 스레드 간의 실행 순서 조정
- **원자성**: 더 이상 나눌 수 없는 연산 단위
- **상호 배제**: 한 번에 하나의 스레드만 접근 허용

## 핵심

### 1. 레이스 컨디션 발생 원인

#### 공유 자원의 동시 접근
```c
// 공유 변수에 대한 동시 접근
#include <pthread.h>
#include <stdio.h>

int shared_counter = 0;  // 공유 자원

void* increment_counter(void* arg) {
    for (int i = 0; i < 100000; i++) {
        shared_counter++;  // 레이스 컨디션 발생 지점
    }
    return NULL;
}

int main() {
    pthread_t thread1, thread2;
    
    // 두 스레드 생성
    pthread_create(&thread1, NULL, increment_counter, NULL);
    pthread_create(&thread2, NULL, increment_counter, NULL);
    
    // 스레드 완료 대기
    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);
    
    printf("Final counter value: %d\n", shared_counter);
    // 예상값: 200000, 실제값: 200000보다 작을 수 있음
    return 0;
}
```

#### 비원자적 연산의 특성
```c
// 단순해 보이는 연산도 실제로는 여러 단계로 나뉨
int i = 0;

// i++ 연산의 실제 실행 과정:
// 1. 메모리에서 i 값을 레지스터로 로드 (LOAD)
// 2. 레지스터의 값을 1 증가 (INCREMENT)
// 3. 증가된 값을 메모리에 저장 (STORE)

// 두 스레드가 동시에 i++를 실행할 때:
// 스레드 A: LOAD i=0 → INCREMENT → STORE i=1
// 스레드 B: LOAD i=0 → INCREMENT → STORE i=1
// 결과: i=1 (두 번 증가했지만 한 번만 반영됨)
```

### 2. 레이스 컨디션 예시

#### 은행 계좌 이체 시나리오
```java
public class BankAccount {
    private int balance;
    
    public BankAccount(int initialBalance) {
        this.balance = initialBalance;
    }
    
    public void transfer(BankAccount target, int amount) {
        if (this.balance >= amount) {
            this.balance -= amount;  // 첫 번째 연산
            target.balance += amount; // 두 번째 연산
        }
    }
    
    public int getBalance() {
        return balance;
    }
}

// 문제 상황 시뮬레이션
public class RaceConditionDemo {
    public static void main(String[] args) throws InterruptedException {
        BankAccount accountA = new BankAccount(1000);
        BankAccount accountB = new BankAccount(0);
        BankAccount accountC = new BankAccount(0);
        
        // 스레드 1: A → B로 500원 이체
        Thread thread1 = new Thread(() -> {
            accountA.transfer(accountB, 500);
        });
        
        // 스레드 2: A → C로 800원 이체
        Thread thread2 = new Thread(() -> {
            accountA.transfer(accountC, 800);
        });
        
        thread1.start();
        thread2.start();
        
        thread1.join();
        thread2.join();
        
        System.out.println("Account A balance: " + accountA.getBalance());
        System.out.println("Account B balance: " + accountB.getBalance());
        System.out.println("Account C balance: " + accountC.getBalance());
        // 예상: A=0, B=500, C=800 또는 A=200, B=500, C=300
        // 실제: A=-300, B=500, C=800 (레이스 컨디션)
    }
}
```

#### 싱글톤 패턴의 레이스 컨디션
```java
public class Singleton {
    private static Singleton instance;
    
    private Singleton() {}
    
    public static Singleton getInstance() {
        if (instance == null) {  // 첫 번째 검사
            instance = new Singleton();  // 인스턴스 생성
        }
        return instance;
    }
}

// 문제점:
// 스레드 A: instance == null 확인 → 인스턴스 생성 시작
// 스레드 B: instance == null 확인 → 인스턴스 생성 시작
// 결과: 두 개의 인스턴스가 생성될 수 있음
```

### 3. 레이스 컨디션 해결 방법

#### 뮤텍스(Mutex) 사용
```c
// POSIX 스레드 뮤텍스 예시
#include <pthread.h>
#include <stdio.h>

int shared_counter = 0;
pthread_mutex_t counter_mutex = PTHREAD_MUTEX_INITIALIZER;

void* increment_counter_safe(void* arg) {
    for (int i = 0; i < 100000; i++) {
        pthread_mutex_lock(&counter_mutex);  // 뮤텍스 잠금
        shared_counter++;  // 임계 구역
        pthread_mutex_unlock(&counter_mutex);  // 뮤텍스 해제
    }
    return NULL;
}

int main() {
    pthread_t thread1, thread2;
    
    pthread_create(&thread1, NULL, increment_counter_safe, NULL);
    pthread_create(&thread2, NULL, increment_counter_safe, NULL);
    
    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);
    
    printf("Final counter value: %d\n", shared_counter);
    // 결과: 항상 200000
    
    pthread_mutex_destroy(&counter_mutex);
    return 0;
}
```

#### 세마포어(Semaphore) 사용
```c
#include <pthread.h>
#include <semaphore.h>
#include <stdio.h>

#define BUFFER_SIZE 10
int buffer[BUFFER_SIZE];
int in = 0, out = 0;

sem_t empty, full, mutex;

void* producer(void* arg) {
    for (int i = 0; i < 20; i++) {
        sem_wait(&empty);   // 빈 슬롯 대기
        sem_wait(&mutex);   // 뮤텍스 잠금
        
        buffer[in] = i;     // 데이터 생산
        in = (in + 1) % BUFFER_SIZE;
        
        sem_post(&mutex);   // 뮤텍스 해제
        sem_post(&full);    // 가득찬 슬롯 신호
    }
    return NULL;
}

void* consumer(void* arg) {
    for (int i = 0; i < 20; i++) {
        sem_wait(&full);    // 가득찬 슬롯 대기
        sem_wait(&mutex);   // 뮤텍스 잠금
        
        int item = buffer[out];  // 데이터 소비
        out = (out + 1) % BUFFER_SIZE;
        printf("Consumed: %d\n", item);
        
        sem_post(&mutex);   // 뮤텍스 해제
        sem_post(&empty);   // 빈 슬롯 신호
    }
    return NULL;
}

int main() {
    sem_init(&empty, 0, BUFFER_SIZE);
    sem_init(&full, 0, 0);
    sem_init(&mutex, 0, 1);
    
    pthread_t prod_thread, cons_thread;
    pthread_create(&prod_thread, NULL, producer, NULL);
    pthread_create(&cons_thread, NULL, consumer, NULL);
    
    pthread_join(prod_thread, NULL);
    pthread_join(cons_thread, NULL);
    
    sem_destroy(&empty);
    sem_destroy(&full);
    sem_destroy(&mutex);
    
    return 0;
}
```

#### 원자적 연산 사용
```c
#include <pthread.h>
#include <stdatomic.h>
#include <stdio.h>

atomic_int shared_counter = 0;  // 원자적 변수

void* increment_counter_atomic(void* arg) {
    for (int i = 0; i < 100000; i++) {
        atomic_fetch_add(&shared_counter, 1);  // 원자적 증가
    }
    return NULL;
}

int main() {
    pthread_t thread1, thread2;
    
    pthread_create(&thread1, NULL, increment_counter_atomic, NULL);
    pthread_create(&thread2, NULL, increment_counter_atomic, NULL);
    
    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);
    
    printf("Final counter value: %d\n", atomic_load(&shared_counter));
    // 결과: 항상 200000
    
    return 0;
}
```

## 예시

### 1. 실제 사용 사례

#### 멀티스레드 웹 서버
```java
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.ReentrantLock;

public class WebServer {
    private AtomicInteger requestCount = new AtomicInteger(0);
    private ReentrantLock logLock = new ReentrantLock();
    
    public void handleRequest(String request) {
        // 원자적 카운터 증가
        int currentCount = requestCount.incrementAndGet();
        
        // 스레드 안전한 로깅
        logLock.lock();
        try {
            System.out.println("Request #" + currentCount + ": " + request);
            System.out.println("Thread: " + Thread.currentThread().getName());
        } finally {
            logLock.unlock();
        }
        
        // 요청 처리
        processRequest(request);
    }
    
    private void processRequest(String request) {
        // 요청 처리 로직
        try {
            Thread.sleep(100); // 처리 시간 시뮬레이션
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
    
    public int getRequestCount() {
        return requestCount.get();
    }
}

// 사용 예시
public class WebServerDemo {
    public static void main(String[] args) throws InterruptedException {
        WebServer server = new WebServer();
        
        // 여러 스레드에서 동시에 요청 처리
        Thread[] threads = new Thread[10];
        for (int i = 0; i < 10; i++) {
            final int requestId = i;
            threads[i] = new Thread(() -> {
                server.handleRequest("Request-" + requestId);
            });
            threads[i].start();
        }
        
        // 모든 스레드 완료 대기
        for (Thread thread : threads) {
            thread.join();
        }
        
        System.out.println("Total requests handled: " + server.getRequestCount());
    }
}
```

#### 공유 캐시 구현
```java
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

public class ThreadSafeCache<K, V> {
    private final ConcurrentHashMap<K, V> cache = new ConcurrentHashMap<>();
    private final ReadWriteLock lock = new ReentrantReadWriteLock();
    
    public V get(K key) {
        // 읽기 락 (여러 스레드가 동시에 읽기 가능)
        lock.readLock().lock();
        try {
            return cache.get(key);
        } finally {
            lock.readLock().unlock();
        }
    }
    
    public void put(K key, V value) {
        // 쓰기 락 (한 번에 하나의 스레드만 쓰기 가능)
        lock.writeLock().lock();
        try {
            cache.put(key, value);
        } finally {
            lock.writeLock().unlock();
        }
    }
    
    public V computeIfAbsent(K key, java.util.function.Function<K, V> mappingFunction) {
        // 원자적 연산으로 레이스 컨디션 방지
        return cache.computeIfAbsent(key, mappingFunction);
    }
    
    public int size() {
        return cache.size();
    }
}

// 사용 예시
public class CacheDemo {
    public static void main(String[] args) throws InterruptedException {
        ThreadSafeCache<String, String> cache = new ThreadSafeCache<>();
        
        // 여러 스레드에서 동시에 캐시 접근
        Thread[] threads = new Thread[5];
        for (int i = 0; i < 5; i++) {
            final int threadId = i;
            threads[i] = new Thread(() -> {
                for (int j = 0; j < 10; j++) {
                    String key = "key-" + threadId + "-" + j;
                    String value = cache.computeIfAbsent(key, k -> "value-" + k);
                    System.out.println("Thread " + threadId + " got: " + value);
                }
            });
            threads[i].start();
        }
        
        for (Thread thread : threads) {
            thread.join();
        }
        
        System.out.println("Cache size: " + cache.size());
    }
}
```

### 2. 고급 패턴

#### 데드락 방지
```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class DeadlockPrevention {
    private final Lock lock1 = new ReentrantLock();
    private final Lock lock2 = new ReentrantLock();
    
    // 데드락 발생 가능한 코드
    public void method1() {
        lock1.lock();
        try {
            Thread.sleep(100);
            lock2.lock();
            try {
                System.out.println("Method 1 executed");
            } finally {
                lock2.unlock();
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            lock1.unlock();
        }
    }
    
    public void method2() {
        lock2.lock();
        try {
            Thread.sleep(100);
            lock1.lock();
            try {
                System.out.println("Method 2 executed");
            } finally {
                lock1.unlock();
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            lock2.unlock();
        }
    }
    
    // 데드락 방지: 계층적 락킹
    public void safeMethod1() {
        lock1.lock();
        try {
            Thread.sleep(100);
            lock2.lock();
            try {
                System.out.println("Safe Method 1 executed");
            } finally {
                lock2.unlock();
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            lock1.unlock();
        }
    }
    
    public void safeMethod2() {
        lock1.lock();  // 항상 lock1을 먼저 획득
        try {
            Thread.sleep(100);
            lock2.lock();
            try {
                System.out.println("Safe Method 2 executed");
            } finally {
                lock2.unlock();
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            lock1.unlock();
        }
    }
}
```

#### 조건 변수 사용
```java
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.LinkedList;
import java.util.Queue;

public class ProducerConsumer {
    private final Queue<Integer> buffer = new LinkedList<>();
    private final int capacity = 10;
    private final Lock lock = new ReentrantLock();
    private final Condition notFull = lock.newCondition();
    private final Condition notEmpty = lock.newCondition();
    
    public void produce(int item) throws InterruptedException {
        lock.lock();
        try {
            while (buffer.size() == capacity) {
                notFull.await();  // 버퍼가 가득 찰 때까지 대기
            }
            buffer.offer(item);
            System.out.println("Produced: " + item);
            notEmpty.signal();  // 소비자에게 신호
        } finally {
            lock.unlock();
        }
    }
    
    public int consume() throws InterruptedException {
        lock.lock();
        try {
            while (buffer.isEmpty()) {
                notEmpty.await();  // 버퍼가 비어있을 때까지 대기
            }
            int item = buffer.poll();
            System.out.println("Consumed: " + item);
            notFull.signal();  // 생산자에게 신호
            return item;
        } finally {
            lock.unlock();
        }
    }
}

// 사용 예시
public class ProducerConsumerDemo {
    public static void main(String[] args) throws InterruptedException {
        ProducerConsumer pc = new ProducerConsumer();
        
        // 생산자 스레드
        Thread producer = new Thread(() -> {
            try {
                for (int i = 0; i < 20; i++) {
                    pc.produce(i);
                    Thread.sleep(100);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });
        
        // 소비자 스레드
        Thread consumer = new Thread(() -> {
            try {
                for (int i = 0; i < 20; i++) {
                    pc.consume();
                    Thread.sleep(150);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });
        
        producer.start();
        consumer.start();
        
        producer.join();
        consumer.join();
    }
}
```

## 운영 팁

### 성능 최적화

#### 락 경합 최소화
```java
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.locks.StampedLock;

public class OptimizedCounter {
    private final AtomicLong counter = new AtomicLong(0);
    private final StampedLock lock = new StampedLock();
    
    // 원자적 연산으로 빠른 증가
    public void incrementFast() {
        counter.incrementAndGet();
    }
    
    // 읽기 최적화된 락
    public long getValueOptimistic() {
        long stamp = lock.tryOptimisticRead();
        long value = counter.get();
        
        if (lock.validate(stamp)) {
            return value;  // 낙관적 읽기 성공
        }
        
        // 낙관적 읽기 실패 시 일반 읽기 락 사용
        stamp = lock.readLock();
        try {
            return counter.get();
        } finally {
            lock.unlockRead(stamp);
        }
    }
    
    // 배치 업데이트
    public void batchIncrement(int count) {
        long stamp = lock.writeLock();
        try {
            for (int i = 0; i < count; i++) {
                counter.incrementAndGet();
            }
        } finally {
            lock.unlockWrite(stamp);
        }
    }
}
```

### 디버깅 및 모니터링

#### 레이스 컨디션 감지
```java
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.ReentrantLock;

public class RaceConditionDetector {
    private final AtomicInteger accessCount = new AtomicInteger(0);
    private final ReentrantLock lock = new ReentrantLock();
    private volatile boolean raceDetected = false;
    
    public void safeOperation() {
        int count = accessCount.incrementAndGet();
        if (count > 1) {
            raceDetected = true;
            System.err.println("Race condition detected! Access count: " + count);
        }
        
        lock.lock();
        try {
            // 임계 구역 작업
            Thread.sleep(10);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            lock.unlock();
            accessCount.decrementAndGet();
        }
    }
    
    public boolean isRaceDetected() {
        return raceDetected;
    }
    
    public void reset() {
        raceDetected = false;
        accessCount.set(0);
    }
}
```

## 참고

### 동기화 메커니즘 비교

| 메커니즘 | 특징 | 장점 | 단점 |
|----------|------|------|------|
| **뮤텍스** | 상호 배제 | 간단, 효율적 | 데드락 가능성 |
| **세마포어** | 카운팅 | 유연한 동기화 | 복잡성 |
| **조건 변수** | 조건 대기 | 효율적인 대기 | 복잡한 구현 |
| **원자적 연산** | 하드웨어 지원 | 빠름, 간단 | 제한된 연산 |

### 레이스 컨디션 방지 전략

| 전략 | 설명 | 사용 시기 |
|------|------|-----------|
| **상호 배제** | 한 번에 하나의 스레드만 접근 | 공유 자원 보호 |
| **원자적 연산** | 하드웨어 수준의 원자성 | 단순한 연산 |
| **불변 객체** | 객체 상태 변경 불가 | 읽기 전용 데이터 |
| **스레드 로컬** | 스레드별 독립 데이터 | 스레드별 상태 |

### 결론
레이스 컨디션은 병렬 프로그래밍에서 가장 중요한 문제 중 하나로, 적절한 동기화 메커니즘을 사용하여 해결해야 합니다.
상황에 맞는 동기화 방법을 선택하고, 성능과 안전성의 균형을 고려하세요.
데드락 방지와 성능 최적화를 통해 안정적이고 효율적인 멀티스레드 프로그램을 구축하세요.

