---
title: 쓰레드와 쓰레드풀
tags: [os, thread, thread-pool, 쓰레드, 쓰레드풀, 동시성]
updated: 2025-11-19
---

# 쓰레드와 쓰레드풀

## 개요

쓰레드(Thread)와 쓰레드풀(Thread Pool)은 현대 프로그래밍에서 동시성과 병렬성을 구현하는 핵심 개념입니다. 이 문서에서는 쓰레드와 쓰레드풀의 차이점, 관계, 그리고 각각의 장단점을 자세히 살펴보겠습니다.

---

## 1. 쓰레드(Thread)란?

### 1.1 쓰레드의 기본 개념

> 💡 **핵심 정의**: 쓰레드는 프로세스 내에서 실행되는 **가장 작은 실행 단위**입니다.

#### 📚 쓰레드의 역사적 배경

```
┌──────────────────────────────────────────────────────────┐
│          쓰레드 개념의 진화                              │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  1980년대 이전:                                           │
│  ┌────────────────────────────────────────┐              │
│  │ • 단일 프로세스 모델                   │              │
│  │ • 한 번에 하나의 작업만 처리           │              │
│  │ • 멀티태스킹 불가능                    │              │
│  └────────────────────────────────────────┘              │
│                                                           │
│  1980년대:                                                │
│  ┌────────────────────────────────────────┐              │
│  │ • 멀티프로세싱 등장                     │              │
│  │ • 여러 프로세스 동시 실행               │              │
│  │ • 프로세스 생성 비용 높음               │              │
│  │ • 프로세스 간 통신 복잡                 │              │
│  └────────────────────────────────────────┘              │
│                                                           │
│  1990년대:                                                │
│  ┌────────────────────────────────────────┐              │
│  │ • 쓰레드 개념 도입                      │              │
│  │ • 경량 실행 단위 필요성 인식            │              │
│  │ • POSIX Threads (pthread) 표준화       │              │
│  │ • 멀티스레딩 프로그래밍 확산            │              │
│  └────────────────────────────────────────┘              │
│                                                           │
│  2000년대 이후:                                           │
│  ┌────────────────────────────────────────┐              │
│  │ • 멀티코어 CPU 보급                     │              │
│  │ • 병렬 처리 중요성 증가                 │              │
│  │ • 쓰레드풀 패턴 표준화                  │              │
│  │ • 고수준 동시성 프레임워크 등장        │              │
│  └────────────────────────────────────────┘              │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

#### 🔬 쓰레드의 운영체제 관점

```
┌──────────────────────────────────────────────────────────┐
│          운영체제에서의 쓰레드                           │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  커널 레벨 관점:                                          │
│  ┌────────────────────────────────────────┐              │
│  │ • 쓰레드는 "경량 프로세스" (LWP)        │              │
│  │ • Linux: 쓰레드 = 프로세스 (clone)      │              │
│  │ • Windows: 쓰레드 = 별도 객체           │              │
│  │ • 각 쓰레드는 고유한 TID (Thread ID)    │              │
│  │ • 스케줄링 단위로 사용                  │              │
│  └────────────────────────────────────────┘              │
│                                                           │
│  사용자 레벨 관점:                                        │
│  ┌────────────────────────────────────────┐              │
│  │ • 프로그래머가 직접 생성/관리           │              │
│  │ • 라이브러리 함수로 제어                │              │
│  │ • 동기화 메커니즘 제공                  │              │
│  │ • 추상화된 인터페이스                   │              │
│  └────────────────────────────────────────┘              │
│                                                           │
│  하이브리드 모델:                                         │
│  ┌────────────────────────────────────────┐              │
│  │ • 사용자 쓰레드 + 커널 쓰레드           │              │
│  │ • M:N 모델 (M개 사용자 쓰레드 →        │              │
│  │            N개 커널 쓰레드)             │              │
│  │ • 유연한 스케줄링                       │              │
│  └────────────────────────────────────────┘              │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

```
┌──────────────────────────────────────────────────────────┐
│              쓰레드의 개념                               │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  프로세스 (Process)                                       │
│  ┌────────────────────────────────────────────┐          │
│  │  코드 영역 (공유)                          │          │
│  │  데이터 영역 (공유)                        │          │
│  │  힙 영역 (공유)                            │          │
│  │                                            │          │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐│          │
│  │  │ Thread 1 │  │ Thread 2 │  │ Thread 3 ││          │
│  │  │          │  │          │  │          ││          │
│  │  │ 스택     │  │ 스택     │  │ 스택     ││          │
│  │  │ PC       │  │ PC       │  │ PC       ││          │
│  │  │ 레지스터 │  │ 레지스터 │  │ 레지스터 ││          │
│  │  └──────────┘  └──────────┘  └──────────┘│          │
│  │  (독립적)      (독립적)      (독립적)    │          │
│  └────────────────────────────────────────────┘          │
│                                                           │
│  ✅ 공유: 코드, 데이터, 힙                                │
│  ✅ 독립: 스택, PC, 레지스터                             │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

### 1.2 쓰레드의 메모리 모델

#### 🧠 메모리 가시성 (Memory Visibility)

```
┌──────────────────────────────────────────────────────────┐
│          메모리 가시성 문제                              │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  문제 상황:                                               │
│  ┌────────────────────────────────────────┐            │
│  │ Thread 1:          Thread 2:           │            │
│  │ flag = true;       while (!flag) {     │            │
│  │                    // 무한 루프!       │            │
│  │                    }                  │            │
│  │                                        │            │
│  │ Thread 2가 flag 변경을 못 봄 ❌        │            │
│  └────────────────────────────────────────┘            │
│                                                           │
│  원인:                                                    │
│  ┌────────────────────────────────────────┐            │
│  │ 1. CPU 캐시                            │            │
│  │    ┌──────────┐    ┌──────────┐        │            │
│  │    │ CPU 1    │    │ CPU 2    │        │            │
│  │    │ Cache    │    │ Cache    │        │            │
│  │    │ flag=true│    │ flag=?   │        │            │
│  │    └────┬─────┘    └────┬─────┘       │            │
│  │         │                │              │            │
│  │         └────────┬───────┘              │            │
│  │                  │                      │            │
│  │            ┌─────▼─────┐                │            │
│  │            │   메인    │                │            │
│  │            │  메모리   │                │            │
│  │            │ flag=false│                │            │
│  │            └───────────┘                │            │
│  │                                        │            │
│  │ 2. 컴파일러 최적화                     │            │
│  │    • 변수 읽기를 레지스터에 캐싱        │            │
│  │    • 루프 최적화로 메모리 재읽기 생략  │            │
│  │                                        │            │
│  │ 3. 프로세서 재정렬                    │            │
│  │    • 명령어 순서 변경 가능              │            │
│  └────────────────────────────────────────┘            │
│                                                           │
│  해결 방법:                                               │
│  ┌────────────────────────────────────────┐            │
│  │ • volatile 키워드                       │            │
│  │   → 캐시 무시, 직접 메모리 접근         │            │
│  │                                        │            │
│  │ • synchronized 블록                     │            │
│  │   → 메모리 배리어 삽입                  │            │
│  │                                        │            │
│  │ • Atomic 변수                           │            │
│  │   → 하드웨어 레벨 동기화                │            │
│  └────────────────────────────────────────┘            │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

#### 🔄 하드웨어 메모리 일관성

```
┌──────────────────────────────────────────────────────────┐
│          CPU 캐시와 메모리 일관성                       │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  멀티코어 시스템 구조:                                    │
│  ┌────────────────────────────────────────┐            │
│  │  CPU Core 1        CPU Core 2          │            │
│  │  ┌────────┐        ┌────────┐          │            │
│  │  │ L1    │        │ L1     │          │            │
│  │  │ Cache │        │ Cache  │          │            │
│  │  └───┬───┘        └───┬────┘          │            │
│  │      │                │                │            │
│  │      └────────┬───────┘                │            │
│  │               │                        │            │
│  │         ┌─────▼─────┐                 │            │
│  │         │   L2/L3   │                 │            │
│  │         │  공유 캐시 │                 │            │
│  │         └─────┬─────┘                 │            │
│  │               │                        │            │
│  │         ┌─────▼─────┐                 │            │
│  │         │   메인    │                 │            │
│  │         │  메모리   │                 │            │
│  │         └───────────┘                 │            │
│  └────────────────────────────────────────┘            │
│                                                           │
│  캐시 일관성 프로토콜:                                    │
│  ┌────────────────────────────────────────┐            │
│  │ • MESI 프로토콜 (Modified, Exclusive,  │            │
│  │   Shared, Invalid)                      │            │
│  │                                        │            │
│  │ • 쓰기 시 다른 코어의 캐시 무효화      │            │
│  │                                        │            │
│  │ • 메모리 배리어로 순서 보장            │            │
│  │   - Load Barrier (읽기 배리어)        │            │
│  │   - Store Barrier (쓰기 배리어)       │            │
│  │   - Full Barrier (전체 배리어)        │            │
│  └────────────────────────────────────────┘            │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

### 1.3 쓰레드 스케줄링과 우선순위

#### 🎯 쓰레드 우선순위

```
┌──────────────────────────────────────────────────────────┐
│          쓰레드 우선순위 시스템                          │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  우선순위 개념:                                           │
│  ┌────────────────────────────────────────┐            │
│  │ • 각 쓰레드는 우선순위 값을 가짐         │            │
│  │ • 높은 우선순위 = 더 자주 실행될 가능성  │            │
│  │ • 운영체제가 스케줄링 시 고려           │            │
│  │                                        │            │
│  │ Java 예시:                             │            │
│  │ Thread.MIN_PRIORITY = 1                │            │
│  │ Thread.NORM_PRIORITY = 5               │            │
│  │ Thread.MAX_PRIORITY = 10               │            │            │
│  └────────────────────────────────────────┘            │
│                                                           │
│  ⚠️  주의사항:                                            │
│  ┌────────────────────────────────────────┐            │
│  │ • 우선순위는 "힌트"일 뿐                │            │
│  │ • 운영체제가 무시할 수 있음             │            │
│  │ • 플랫폼별로 동작이 다를 수 있음        │            │
│  │ • 우선순위에만 의존하면 안 됨           │            │
│  └────────────────────────────────────────┘            │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

#### ⏰ 쓰레드 스케줄링 알고리즘

```
┌──────────────────────────────────────────────────────────┐
│          주요 스케줄링 알고리즘                          │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  1. 라운드 로빈 (Round Robin)                             │
│  ┌────────────────────────────────────────┐            │
│  │ • 시간 할당량(Time Quantum) 기반       │            │
│  │ • 각 쓰레드에 동일한 시간 할당          │            │
│  │ • 공정한 CPU 시간 분배                  │            │
│  │ • 응답 시간 예측 가능                   │            │
│  └────────────────────────────────────────┘            │
│                                                           │
│  2. 우선순위 기반 (Priority-Based)                        │
│  ┌────────────────────────────────────────┐            │
│  │ • 높은 우선순위 쓰레드 우선 실행        │            │
│  │ • 실시간 시스템에 적합                  │            │
│  │ • 기아 현상 가능                        │            │
│  │ • 우선순위 역전 문제                    │            │
│  └────────────────────────────────────────┘            │
│                                                           │
│  3. 다단계 큐 (Multilevel Queue)                          │
│  ┌────────────────────────────────────────┐            │
│  │ • 여러 큐를 우선순위별로 관리            │            │
│  │ • 상위 큐가 비어야 하위 큐 실행         │            │
│  │ • 대화형 작업과 배치 작업 분리          │            │
│  └────────────────────────────────────────┘            │
│                                                           │
│  4. 다단계 피드백 큐 (MLFQ)                              │
│  ┌────────────────────────────────────────┐            │
│  │ • 쓰레드가 큐 간 이동 가능              │            │
│  │ • I/O 바운드 작업은 상위 큐로           │            │
│  │ • CPU 바운드 작업은 하위 큐로           │            │
│  │ • 적응형 스케줄링                      │            │
│  └────────────────────────────────────────┘            │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

### 1.4 쓰레드의 특징

```
┌──────────────────────────────────────────────────────────┐
│          쓰레드의 핵심 특징                              │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  🚀 경량성 (Lightweight)                                  │
│  ┌────────────────────────────────────────┐              │
│  │ • 프로세스보다 생성/소멸이 빠름        │              │
│  │ • 메모리 사용량이 적음                 │              │
│  │ • 컨텍스트 스위칭 비용이 낮음          │              │
│  │                                        │              │
│  │ 생성 시간 비교:                        │              │
│  │ 프로세스: ~1ms                         │              │
│  │ 쓰레드:   ~0.1ms (약 10배 빠름)       │              │
│  └────────────────────────────────────────┘              │
│                                                           │
│  🔗 공유성 (Shared Resources)                             │
│  ┌────────────────────────────────────────┐              │
│  │ • 같은 프로세스 내 쓰레드들은          │              │
│  │   메모리 공간을 공유                   │              │
│  │ • 코드, 데이터, 힙 영역 공유           │              │
│  │ • 통신이 간단하고 빠름                 │              │
│  └────────────────────────────────────────┘              │
│                                                           │
│  ⚡ 독립성 (Independent Execution)                        │
│  ┌────────────────────────────────────────┐              │
│  │ • 각 쓰레드는 독립적인 실행 흐름       │              │
│  │ • 자신만의 스택, PC, 레지스터 보유     │              │
│  │ • 병렬 실행 가능                       │              │
│  └────────────────────────────────────────┘              │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

### 1.3 쓰레드의 내부 동작 원리

#### 🔄 컨텍스트 스위칭 (Context Switching)

```
┌──────────────────────────────────────────────────────────┐
│          쓰레드 컨텍스트 스위칭 과정                     │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  쓰레드 A 실행 중                                         │
│  ┌────────────────────────────────────────┐            │
│  │ CPU 레지스터:                            │            │
│  │ • PC (Program Counter): 0x1000          │            │
│  │ • SP (Stack Pointer): 0x7FFF             │            │
│  │ • 레지스터 R1-R15: 값들...               │            │
│  │                                          │            │
│  │ 스택:                                    │            │
│  │ • 지역 변수                              │            │
│  │ • 함수 호출 정보                        │            │
│  └────────────────────────────────────────┘            │
│              │                                           │
│              │ 1. 인터럽트 또는 시간 할당량 만료         │
│              ▼                                           │
│  ┌────────────────────────────────────────┐            │
│  │ 컨텍스트 저장 (Context Save)            │            │
│  │ • CPU 레지스터 → TCB에 저장             │            │
│  │ • 스택 포인터 저장                      │            │
│  │ • 실행 상태 저장                        │            │
│  └────────────────────────────────────────┘            │
│              │                                           │
│              │ 2. 스케줄러가 다음 쓰레드 선택            │
│              ▼                                           │
│  ┌────────────────────────────────────────┐            │
│  │ 컨텍스트 복원 (Context Restore)         │            │
│  │ • TCB에서 레지스터 복원                 │            │
│  │ • 스택 포인터 복원                      │            │
│  │ • 실행 상태 복원                        │            │
│  └────────────────────────────────────────┘            │
│              │                                           │
│              ▼                                           │
│  쓰레드 B 실행 시작                                       │
│                                                           │
│  ⏱️  컨텍스트 스위칭 비용:                                │
│  • 프로세스 간: ~1-10 마이크로초                         │
│  • 쓰레드 간: ~0.1-1 마이크로초 (10배 빠름)             │
│  • 이유: 메모리 공간 공유로 인한 오버헤드 감소           │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

#### 🧠 쓰레드 제어 블록 (TCB: Thread Control Block)

```
┌──────────────────────────────────────────────────────────┐
│          TCB 구조 및 역할                                 │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  ┌────────────────────────────────────────┐            │
│  │     Thread Control Block (TCB)          │            │
│  ├────────────────────────────────────────┤            │
│  │ Thread ID: 12345                       │            │
│  │ State: RUNNING / READY / WAITING      │            │
│  │ Priority: 5                            │            │
│  │                                        │            │
│  │ CPU State:                             │            │
│  │ • Program Counter (PC)                 │            │
│  │ • Stack Pointer (SP)                   │            │
│  │ • General Purpose Registers (R0-R15)   │            │
│  │ • Status Register (PSW)               │            │
│  │                                        │            │
│  │ Stack Information:                     │            │
│  │ • Stack Base Address                   │            │
│  │ • Stack Size                           │            │
│  │ • Current Stack Pointer                │            │
│  │                                        │            │
│  │ Scheduling Info:                       │            │
│  │ • Last Run Time                        │            │
│  │ • Total CPU Time Used                  │            │
│  │ • Time Slice Remaining                 │            │
│  │                                        │            │
│  │ Synchronization:                       │            │
│  │ • Waiting Queue                        │            │
│  │ • Lock Information                     │            │
│  └────────────────────────────────────────┘            │
│                                                           │
│  TCB의 역할:                                             │
│  ✅ 쓰레드 상태 저장                                      │
│  ✅ 컨텍스트 스위칭 지원                                  │
│  ✅ 스케줄링 정보 관리                                     │
│  ✅ 동기화 정보 추적                                      │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

#### ⚡ 쓰레드 상태 전이 (State Transition)

```
┌──────────────────────────────────────────────────────────┐
│          쓰레드 생명주기 상태 다이어그램                 │
├──────────────────────────────────────────────────────────┤
│                                                           │
│         NEW (생성)                                        │
│            │                                              │
│            │ start() 호출                                 │
│            ▼                                              │
│      READY (준비)                                         │
│            │                                              │
│            │ 스케줄러가 선택                              │
│            ▼                                              │
│      RUNNING (실행)                                       │
│            │                                              │
│            ├─→ 시간 할당량 만료 ──→ READY                │
│            │                                              │
│            ├─→ I/O 대기 ──→ WAITING                       │
│            │                                              │
│            ├─→ sleep() ──→ WAITING                        │
│            │                                              │
│            ├─→ yield() ──→ READY                          │
│            │                                              │
│            └─→ 종료 ──→ TERMINATED                        │
│                                                           │
│      WAITING (대기)                                       │
│            │                                              │
│            │ I/O 완료 / notify() / 시간 만료             │
│            ▼                                              │
│      READY                                                │
│                                                           │
│  상태별 설명:                                             │
│  • NEW: 쓰레드 객체 생성, 아직 시작 안 됨                │
│  • READY: 실행 가능, CPU 할당 대기 중                    │
│  • RUNNING: CPU에서 실제 실행 중                         │
│  • WAITING: I/O, 락, 조건 변수 등으로 대기 중           │
│  • TERMINATED: 실행 완료, 종료됨                         │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

### 1.5 동시성(Concurrency) vs 병렬성(Parallelism)

```
┌──────────────────────────────────────────────────────────┐
│          동시성과 병렬성의 차이                          │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  🔄 동시성 (Concurrency)                                  │
│  ┌────────────────────────────────────────┐              │
│  │ 여러 작업을 "동시에 진행"하는 것처럼   │              │
│  │ 보이게 하는 것                          │              │
│  │                                        │              │
│  │ 단일 코어에서:                         │              │
│  │ ┌────┐ ┌────┐ ┌────┐                 │              │
│  │ │Task│ │Task│ │Task│                 │              │
│  │ │ 1  │ │ 2  │ │ 3  │                 │              │
│  │ └─┬──┘ └─┬──┘ └─┬──┘                 │              │
│  │   └──────┼──────┘                     │              │
│  │         │                              │              │
│  │    ┌────▼────┐                        │              │
│  │    │ CPU     │                        │              │
│  │    │ (1코어) │                        │              │
│  │    └─────────┘                        │              │
│  │                                        │              │
│  │ 시간 분할로 빠르게 전환                │              │
│  │ → 동시에 실행되는 것처럼 보임          │              │
│  └────────────────────────────────────────┘              │
│                                                           │
│  ⚡ 병렬성 (Parallelism)                                   │
│  ┌────────────────────────────────────────┐              │
│  │ 여러 작업을 "실제로 동시에" 실행       │              │
│  │                                        │              │
│  │ 멀티 코어에서:                         │              │
│  │ ┌────┐     ┌────┐     ┌────┐         │              │
│  │ │Task│     │Task│     │Task│         │              │
│  │ │ 1  │     │ 2  │     │ 3  │         │              │
│  │ └─┬──┘     └─┬──┘     └─┬──┘         │              │
│  │   │          │          │             │              │
│  │ ┌─▼──┐   ┌─▼──┐   ┌─▼──┐            │              │
│  │ │CPU1│   │CPU2│   │CPU3│            │              │
│  │ └────┘   └────┘   └────┘            │              │
│  │                                        │              │
│  │ 실제로 동시에 실행                    │              │
│  │ → 진정한 병렬 처리                    │              │
│  └────────────────────────────────────────┘              │
│                                                           │
│  📊 비교:                                                 │
│  ┌────────────────────────────────────────┐              │
│  │ 구분        │ 동시성    │ 병렬성       │              │
│  │─────────────┼──────────┼───────────│              │
│  │ 실행 방식   │ 시분할    │ 실제 동시    │              │
│  │ 필요 조건   │ 단일 코어 │ 멀티 코어    │              │
│  │ 목적        │ 응답성    │ 처리량       │              │
│  │ 예시        │ 웹 서버   │ 이미지 처리  │              │
│  └────────────────────────────────────────┘              │
│                                                           │
│  💡 관계:                                                 │
│  • 병렬성은 동시성의 특수한 경우                         │
│  • 동시성은 병렬성 없이도 가능                           │
│  • 병렬성은 항상 동시성을 포함                           │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

### 1.7 쓰레드 생성 방식

```
┌──────────────────────────────────────────────────────────┐
│          쓰레드 생성의 두 가지 방식                      │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  방식 1: 요청 시 생성 (On-Demand Creation)               │
│  ┌────────────────────────────────────────┐              │
│  │  작업 요청                              │              │
│  │      ↓                                  │              │
│  │  쓰레드 생성 (시간 소요)                │              │
│  │      ↓                                  │              │
│  │  작업 실행                              │              │
│  │      ↓                                  │              │
│  │  쓰레드 종료                            │              │
│  │                                        │              │
│  │  ⏱️  생성 시간: ~0.1ms                 │              │
│  │  💾 메모리: 작업마다 할당/해제         │              │
│  │  🔄 오버헤드: 매번 생성/소멸           │              │
│  └────────────────────────────────────────┘              │
│                                                           │
│  방식 2: 쓰레드풀 사용 (Thread Pool)                      │
│  ┌────────────────────────────────────────┐              │
│  │  미리 생성된 쓰레드 풀                 │              │
│  │      ↓                                  │              │
│  │  작업 요청                              │              │
│  │      ↓                                  │              │
│  │  풀에서 쓰레드 할당 (즉시)             │              │
│  │      ↓                                  │              │
│  │  작업 실행                              │              │
│  │      ↓                                  │              │
│  │  쓰레드 반환 (풀로 복귀)                │              │
│  │                                        │              │
│  │  ⚡ 할당 시간: ~0.001ms (100배 빠름)   │              │
│  │  💾 메모리: 미리 할당, 재사용          │              │
│  │  🔄 오버헤드: 최소화                   │              │
│  └────────────────────────────────────────┘              │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

---

## 2. 쓰레드풀(Thread Pool)이란?

### 2.1 쓰레드풀의 기본 개념

> 💡 **핵심 정의**: 쓰레드풀은 **미리 생성된 쓰레드들의 집합**을 관리하는 패턴입니다.

#### 📚 쓰레드풀 패턴의 등장 배경

```
┌──────────────────────────────────────────────────────────┐
│          쓰레드풀 패턴이 필요한 이유                     │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  문제 상황:                                               │
│  ┌────────────────────────────────────────┐            │
│  │ 1. 쓰레드 생성 비용                     │            │
│  │    • 시스템 호출 필요                    │            │
│  │    • 메모리 할당                        │            │
│  │    • 초기화 작업                        │            │
│  │    → 총 ~0.1ms 소요                     │            │
│  │                                        │            │
│  │ 2. 대량 작업 처리 시                   │            │
│  │    • 1000개 작업 = 1000개 쓰레드 생성  │            │
│  │    • 메모리 과다 사용                  │            │
│  │    • 시스템 리소스 고갈                 │            │
│  │    • 컨텍스트 스위칭 증가               │            │
│  │                                        │            │
│  │ 3. 짧은 작업의 경우                    │            │
│  │    • 생성 시간 > 실행 시간일 수 있음   │            │
│  │    • 비효율적                          │            │
│  └────────────────────────────────────────┘            │
│                                                           │
│  해결책: 쓰레드풀 패턴                                    │
│  ┌────────────────────────────────────────┐            │
│  │ • 미리 쓰레드 생성 (초기화 시)          │            │
│  │ • 작업이 도착하면 즉시 할당             │            │
│  │ • 작업 완료 후 재사용                   │            │
│  │ • 생성 비용을 한 번만 지불              │            │
│  └────────────────────────────────────────┘            │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

#### 🎯 쓰레드풀의 디자인 패턴 관점

```
┌──────────────────────────────────────────────────────────┐
│          쓰레드풀 = 객체 풀 패턴                          │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  객체 풀 패턴 (Object Pool Pattern):                      │
│  ┌────────────────────────────────────────┐              │
│  │ • 비용이 큰 객체를 미리 생성            │              │
│  │ • 필요 시 풀에서 빌려 사용              │              │
│  │ • 사용 후 풀로 반환                     │              │
│  │ • 재사용으로 효율성 향상                │              │
│  └────────────────────────────────────────┘              │
│                                                           │
│  쓰레드풀 적용:                                           │
│  ┌────────────────────────────────────────┐              │
│  │ • 쓰레드 = 비용이 큰 객체               │              │
│  │ • 풀 = 쓰레드들의 집합                  │              │
│  │ • 작업 = 쓰레드를 사용하는 작업          │              │
│  │ • 재사용 = 작업 완료 후 풀로 복귀       │              │
│  └────────────────────────────────────────┘              │
│                                                           │
│  다른 풀 패턴 예시:                                       │
│  • 데이터베이스 연결 풀                                   │
│  • 소켓 연결 풀                                           │
│  • 메모리 버퍼 풀                                         │
│  • 파일 핸들 풀                                           │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

```
┌──────────────────────────────────────────────────────────┐
│              쓰레드풀 구조                               │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  ┌──────────────────────────────────────────┐            │
│  │         Thread Pool Manager              │            │
│  │  ┌────────────────────────────────────┐ │            │
│  │  │  작업 큐 (Task Queue)              │ │            │
│  │  │  [Task1] [Task2] [Task3] ...      │ │            │
│  │  └────────────────────────────────────┘ │            │
│  │                                          │            │
│  │  ┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐ │            │
│  │  │Thread│ │Thread│ │Thread│ │Thread│ │            │
│  │  │  1   │ │  2   │ │  3   │ │  4   │ │            │
│  │  │      │ │      │ │      │ │      │ │            │
│  │  │ 작업 │ │ 대기 │ │ 작업 │ │ 대기 │ │            │
│  │  │ 실행 │ │ 중   │ │ 실행 │ │ 중   │ │            │
│  │  └──────┘ └──────┘ └──────┘ └──────┘ │            │
│  │                                          │            │
│  │  풀 크기: 4개 (고정 또는 동적)          │            │
│  └──────────────────────────────────────────┘            │
│                                                           │
│  동작 흐름:                                               │
│  1️⃣  작업 도착 → 큐에 추가                               │
│  2️⃣  대기 중인 쓰레드가 작업 가져옴                      │
│  3️⃣  작업 실행                                           │
│  4️⃣  완료 후 쓰레드가 풀로 복귀                          │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

### 2.2 쓰레드풀의 구성 요소

```
┌──────────────────────────────────────────────────────────┐
│          쓰레드풀의 핵심 구성 요소                        │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  📦 1. 쓰레드 풀 (Thread Pool)                            │
│  ┌────────────────────────────────────────┐              │
│  │ • 미리 생성된 쓰레드들의 집합          │              │
│  │ • 풀 크기: 최소/최대 쓰레드 수         │              │
│  │ • 쓰레드 생명주기 관리                 │              │
│  └────────────────────────────────────────┘              │
│                                                           │
│  📋 2. 작업 큐 (Task Queue)                               │
│  ┌────────────────────────────────────────┐              │
│  │ • 실행 대기 중인 작업들을 저장         │              │
│  │ • FIFO 또는 우선순위 큐               │              │
│  │ • 큐 크기 제한 가능                    │              │
│  └────────────────────────────────────────┘              │
│                                                           │
│  🎯 3. 작업 분배기 (Task Dispatcher)                      │
│  ┌────────────────────────────────────────┐              │
│  │ • 작업을 쓰레드에 할당                 │              │
│  │ • 부하 분산 로직                      │              │
│  │ • 쓰레드 상태 관리                    │              │
│  └────────────────────────────────────────┘              │
│                                                           │
│  ⚙️ 4. 풀 관리자 (Pool Manager)                           │
│  ┌────────────────────────────────────────┐              │
│  │ • 풀 크기 동적 조정                   │              │
│  │ • 쓰레드 생성/제거                     │              │
│  │ • 모니터링 및 통계 수집                │              │
│  └────────────────────────────────────────┘              │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

### 2.3 쓰레드풀의 내부 동작 원리

#### 🔍 작업 큐의 동작 방식

```
┌──────────────────────────────────────────────────────────┐
│          작업 큐의 구현 및 동작                           │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  큐 구조:                                                 │
│  ┌────────────────────────────────────────┐            │
│  │  BlockingQueue<Task>                    │            │
│  │  ┌────┐ ┌────┐ ┌────┐ ┌────┐          │            │
│  │  │Task│ │Task│ │Task│ │Task│          │            │
│  │  │ 1  │ │ 2  │ │ 3  │ │ 4  │          │            │
│  │  └────┘ └────┘ └────┘ └────┘          │            │
│  │  ↑                            ↓        │            │
│  │  추가 (Producer)              제거     │            │
│  │                              (Consumer)│            │
│  └────────────────────────────────────────┘            │
│                                                           │
│  Producer (작업 제출자):                                  │
│  ┌────────────────────────────────────────┐            │
│  │ submit(task) {                         │            │
│  │   if (queue.isFull()) {                │            │
│  │     // 큐가 가득 찬 경우                │            │
│  │     if (rejectPolicy == ABORT)         │            │
│  │       throw RejectedExecutionException;│            │
│  │     else if (rejectPolicy == WAIT)     │            │
│  │       queue.put(task); // 블로킹 대기  │            │
│  │   } else {                             │            │
│  │     queue.offer(task);                 │            │
│  │     notifyWaitingThread(); // 대기 쓰레드 깨움│      │
│  │   }                                    │            │
│  │ }                                      │            │
│  └────────────────────────────────────────┘            │
│                                                           │
│  Consumer (작업 처리 쓰레드):                             │
│  ┌────────────────────────────────────────┐            │
│  │ while (!shutdown) {                     │            │
│  │   Task task = queue.take(); // 블로킹  │            │
│  │   if (task != null) {                  │            │
│  │     executeTask(task);                 │            │
│  │   }                                    │            │
│  │ }                                      │            │
│  └────────────────────────────────────────┘            │
│                                                           │
│  큐 종류:                                                 │
│  • LinkedBlockingQueue: 무제한 큐                        │
│  • ArrayBlockingQueue: 크기 제한 큐                      │
│  • PriorityBlockingQueue: 우선순위 큐                    │
│  • SynchronousQueue: 직접 전달 큐                        │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

#### 🔐 쓰레드풀의 동기화 메커니즘

```
┌──────────────────────────────────────────────────────────┐
│          쓰레드풀 내부 동기화                             │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  동기화가 필요한 영역:                                    │
│  ┌────────────────────────────────────────┐            │
│  │ 1. 작업 큐 접근                         │            │
│  │    • 여러 Producer가 동시에 추가        │            │
│  │    • 여러 Consumer가 동시에 제거        │            │
│  │    • 해결: BlockingQueue (스레드 안전)  │            │
│  │                                        │            │
│  │ 2. 풀 크기 관리                        │            │
│  │    • 쓰레드 추가/제거 시                │            │
│  │    • 카운터 업데이트                    │            │
│  │    • 해결: AtomicInteger, synchronized │            │
│  │                                        │            │
│  │ 3. 쓰레드 상태 관리                    │            │
│  │    • 쓰레드 상태 변경                   │            │
│  │    • 종료 플래그 확인                   │            │
│  │    • 해결: volatile, synchronized      │            │
│  └────────────────────────────────────────┘            │
│                                                           │
│  동기화 예시 (Java):                                      │
│  ┌────────────────────────────────────────┐            │
│  │ class ThreadPool {                     │            │
│  │   private final BlockingQueue<Task>     │            │
│  │       queue = new LinkedBlockingQueue<>();│          │
│  │   private final AtomicInteger          │            │
│  │       activeThreads = new AtomicInteger(0);│         │
│  │   private volatile boolean shutdown = false;│        │
│  │                                        │            │
│  │   public void submit(Task task) {      │            │
│  │     synchronized(this) {              │            │
│  │       if (shutdown) throw ...;         │            │
│  │       queue.offer(task);               │            │
│  │       notify(); // 대기 쓰레드 깨움    │            │
│  │     }                                  │            │
│  │   }                                    │            │
│  │ }                                      │            │
│  └────────────────────────────────────────┘            │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

#### ⚙️ 쓰레드풀의 스케줄링 전략

```
┌──────────────────────────────────────────────────────────┐
│          작업 할당 전략                                   │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  1. FIFO (First In First Out) - 기본                     │
│  ┌────────────────────────────────────────┐              │
│  │ • 먼저 들어온 작업부터 처리            │              │
│  │ • 공정한 처리 순서                     │              │
│  │ • 구현이 간단                         │              │
│  │ • 긴 작업이 앞에 있으면 지연 가능      │              │
│  └────────────────────────────────────────┘              │
│                                                           │
│  2. 우선순위 기반 (Priority-Based)                        │
│  ┌────────────────────────────────────────┐              │
│  │ • 높은 우선순위 작업 먼저 처리          │              │
│  │ • 중요한 작업 우선 처리                │              │
│  │ • 구현 복잡도 증가                     │              │
│  │ • 기아 현상 가능 (낮은 우선순위)       │              │
│  └────────────────────────────────────────┘              │
│                                                           │
│  3. 작업 스티링 (Work Stealing)                           │
│  ┌────────────────────────────────────────┐              │
│  │ • 각 쓰레드가 자신의 큐를 가짐         │              │
│  │ • 자신의 큐가 비면 다른 큐에서 훔침    │              │
│  │ • 부하 분산 효과                       │              │
│  │ • ForkJoinPool에서 사용                │              │
│  └────────────────────────────────────────┘              │
│                                                           │
│  4. 라운드 로빈 (Round Robin)                             │
│  ┌────────────────────────────────────────┐              │
│  │ • 쓰레드에 순차적으로 할당             │              │
│  │ • 균등한 작업 분배                     │              │
│  │ • 단순한 구현                         │              │
│  └────────────────────────────────────────┘              │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

### 2.4 쓰레드풀의 성능 분석

#### 📊 성능 벤치마크

```
┌──────────────────────────────────────────────────────────┐
│          실제 성능 측정 결과                             │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  테스트 환경:                                             │
│  • CPU: Intel i7-8700K (6코어, 12쓰레드)                  │
│  • 작업: 10,000개의 짧은 작업 (각 1ms)                   │
│  • 메모리: 16GB DDR4                                     │
│                                                           │
│  결과 비교:                                               │
│  ┌────────────────────────────────────────┐            │
│  │ 방식          │ 시간    │ 메모리      │            │
│  │───────────────┼─────────┼──────────│            │
│  │ 일반 쓰레드   │ 2.5초   │ 450MB      │            │
│  │ 쓰레드풀(10)  │ 1.0초   │ 50MB       │            │
│  │ 쓰레드풀(20)  │ 0.6초   │ 80MB       │            │
│  │ 쓰레드풀(50)  │ 0.5초   │ 150MB      │            │
│  └────────────────────────────────────────┘            │
│                                                           │
│  분석:                                                    │
│  • 쓰레드풀이 약 2.5배 빠름                               │
│  • 메모리 사용량 9배 감소                                 │
│  • 최적 풀 크기: 코어 수의 2-3배                         │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

#### ⚡ 쓰레드풀의 성능 최적화 기법

```
┌──────────────────────────────────────────────────────────┐
│          성능 최적화 전략                                 │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  1. 작업 큐 최적화                                        │
│  ┌────────────────────────────────────────┐            │
│  │ • Lock-Free 큐 사용                    │            │
│  │   - CAS (Compare-And-Swap) 연산       │            │
│  │   - 락 경합 최소화                     │            │
│  │                                        │            │
│  │ • Work-Stealing 큐                     │            │
│  │   - 각 쓰레드가 자신의 큐 가짐         │            │
│  │   - 부하 분산 효과                     │            │
│  └────────────────────────────────────────┘            │
│                                                           │
│  2. 쓰레드 로컬 스토리지 (TLS)                            │
│  ┌────────────────────────────────────────┐            │
│  │ • 각 쓰레드가 독립적인 저장소           │            │
│  │ • 동기화 없이 접근 가능                 │            │
│  │ • 캐시 친화적                           │            │
│  │                                        │            │
│  │ 예: ThreadLocal<Connection>            │            │
│  └────────────────────────────────────────┘            │
│                                                           │
│  3. False Sharing 방지                                    │
│  ┌────────────────────────────────────────┐            │
│  │ • 같은 캐시 라인을 수정하지 않도록      │            │
│  │ • 패딩(Padding) 사용                   │            │
│  │ • @Contended 어노테이션 (Java)         │            │
│  └────────────────────────────────────────┘            │
│                                                           │
│  4. 적응형 풀 크기                                        │
│  ┌────────────────────────────────────────┐            │
│  │ • 부하에 따라 동적 조정                 │            │
│  │ • 큐 크기 모니터링                      │            │
│  │ • CPU 사용률 기반 조정                  │            │
│  └────────────────────────────────────────┘            │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

### 2.5 쓰레드풀의 동작 원리

```
┌──────────────────────────────────────────────────────────┐
│          쓰레드풀의 생명주기                             │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  1️⃣  초기화 단계 (Initialization)                        │
│  ┌────────────────────────────────────────┐              │
│  │ • 최소 쓰레드 수만큼 미리 생성          │              │
│  │ • 작업 큐 초기화                        │              │
│  │ • 쓰레드들이 작업 대기 상태로 진입      │              │
│  └────────────────────────────────────────┘              │
│                                                           │
│  2️⃣  작업 처리 단계 (Task Processing)                    │
│  ┌────────────────────────────────────────┐              │
│  │  작업 도착                             │              │
│  │      ↓                                 │              │
│  │  큐에 작업 추가                        │              │
│  │      ↓                                 │              │
│  │  대기 중인 쓰레드가 작업 가져옴        │              │
│  │      ↓                                 │              │
│  │  쓰레드가 작업 실행                    │              │
│  │      ↓                                 │              │
│  │  작업 완료                             │              │
│  │      ↓                                 │              │
│  │  쓰레드가 풀로 복귀 (재사용)           │              │
│  └────────────────────────────────────────┘              │
│                                                           │
│  3️⃣  동적 조정 단계 (Dynamic Adjustment)                 │
│  ┌────────────────────────────────────────┐              │
│  │  큐에 작업이 많이 쌓임                 │              │
│  │      ↓                                 │              │
│  │  최대 크기까지 쓰레드 추가 생성        │              │
│  │      ↓                                 │              │
│  │  작업이 줄어듦                         │              │
│  │      ↓                                 │              │
│  │  유휴 쓰레드 제거 (최소 크기 유지)     │              │
│  └────────────────────────────────────────┘              │
│                                                           │
│  4️⃣  종료 단계 (Shutdown)                                │
│  ┌────────────────────────────────────────┐              │
│  │ • 새로운 작업 수락 중지                │              │
│  │ • 진행 중인 작업 완료 대기             │              │
│  │ • 모든 쓰레드 종료                     │              │
│  │ • 리소스 정리                         │              │
│  └────────────────────────────────────────┘              │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

---

## 3. 쓰레드 동기화와 경쟁 조건

### 3.1 경쟁 조건 (Race Condition)

```
┌──────────────────────────────────────────────────────────┐
│          경쟁 조건의 개념과 예시                         │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  정의:                                                    │
│  여러 쓰레드가 공유 자원에 동시에 접근할 때,             │
│  실행 순서에 따라 결과가 달라지는 상황                    │
│                                                           │
│  예시: 공유 변수 증가                                     │
│  ┌────────────────────────────────────────┐            │
│  │ int counter = 0; // 공유 변수           │            │
│  │                                        │            │
│  │ Thread 1:        Thread 2:            │            │
│  │ read counter (0)  read counter (0)    │            │
│  │ counter++ (1)     counter++ (1)       │            │
│  │ write counter (1)  write counter (1)   │            │
│  │                                        │            │
│  │ 결과: counter = 1 (기대값: 2) ❌       │            │
│  └────────────────────────────────────────┘            │
│                                                           │
│  원인:                                                    │
│  ┌────────────────────────────────────────┐            │
│  │ 1. 읽기-수정-쓰기 (Read-Modify-Write)   │            │
│  │    원자적 연산이 아님                   │            │
│  │                                        │            │
│  │ 2. 메모리 가시성 문제                   │            │
│  │    CPU 캐시로 인한 지연                 │            │
│  │                                        │            │
│  │ 3. 컴파일러 최적화                     │            │
│  │    명령어 재배치 가능                   │            │
│  └────────────────────────────────────────┘            │
│                                                           │
│  해결 방법:                                               │
│  • 뮤텍스 (Mutex)                                         │
│  • 세마포어 (Semaphore)                                   │
│  • 원자적 연산 (Atomic Operations)                        │
│  • 동기화된 자료구조                                      │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

### 3.2 동기화 메커니즘

```
┌──────────────────────────────────────────────────────────┐
│          주요 동기화 메커니즘                             │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  🔒 1. 뮤텍스 (Mutex)                                     │
│  ┌────────────────────────────────────────┐              │
│  │ • 상호 배제 (Mutual Exclusion)          │              │
│  │ • 한 번에 하나의 쓰레드만 접근          │              │
│  │ • Lock/Unlock 쌍으로 사용              │              │
│  │                                        │              │
│  │ 사용 예:                                │              │
│  │ mutex.lock();                          │              │
│  │   // 크리티컬 섹션                      │              │
│  │   sharedResource++;                    │              │
│  │ mutex.unlock();                        │              │
│  └────────────────────────────────────────┘              │
│                                                           │
│  🚦 2. 세마포어 (Semaphore)                               │
│  ┌────────────────────────────────────────┐              │
│  │ • N개의 리소스 접근 제어                │              │
│  │ • 카운터 기반                          │              │
│  │ • P (wait) / V (signal) 연산           │              │
│  │                                        │              │
│  │ 사용 예:                                │              │
│  │ Semaphore sem(3); // 최대 3개          │              │
│  │ sem.wait();  // 리소스 획득            │              │
│  │ // 작업 수행                           │              │
│  │ sem.signal(); // 리소스 반환           │              │
│  └────────────────────────────────────────┘              │
│                                                           │
│  ⚛️ 3. 원자적 연산 (Atomic Operations)                    │
│  ┌────────────────────────────────────────┐              │
│  │ • 하드웨어 레벨에서 원자적 보장         │              │
│  │ • 락 없이 동기화                       │              │
│  │ • 성능 우수                            │              │
│  │                                        │              │
│  │ 사용 예:                                │              │
│  │ AtomicInteger counter(0);              │              │
│  │ counter.incrementAndGet();             │              │
│  │ // 락 없이 안전하게 증가                │              │
│  └────────────────────────────────────────┘              │
│                                                           │
│  🔄 4. 조건 변수 (Condition Variable)                      │
│  ┌────────────────────────────────────────┐              │
│  │ • 쓰레드 간 신호 전달                   │              │
│  │ • 특정 조건 만족 대기                   │              │
│  │ • wait() / notify() / notifyAll()      │              │
│  │                                        │              │
│  │ 사용 예:                                │              │
│  │ synchronized(lock) {                   │              │
│  │   while (!condition) {                 │              │
│  │     lock.wait(); // 조건 만족 대기     │              │
│  │   }                                    │              │
│  │   // 조건 만족 시 작업 수행             │              │
│  │ }                                      │              │
│  └────────────────────────────────────────┘              │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

### 3.3 데드락 (Deadlock)

```
┌──────────────────────────────────────────────────────────┐
│          데드락의 발생 조건과 예방                        │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  데드락 발생 조건 (4가지 모두 필요):                       │
│  ┌────────────────────────────────────────┐            │
│  │ 1. 상호 배제 (Mutual Exclusion)         │            │
│  │    • 리소스가 배타적으로 사용됨         │            │
│  │                                        │            │
│  │ 2. 점유 대기 (Hold and Wait)           │            │
│  │    • 리소스를 보유한 채 대기           │            │
│  │                                        │            │
│  │ 3. 비선점 (No Preemption)              │            │
│  │    • 리소스를 강제로 빼앗을 수 없음     │            │
│  │                                        │            │
│  │ 4. 순환 대기 (Circular Wait)           │            │
│  │    • 순환 형태로 서로 대기             │            │
│  └────────────────────────────────────────┘            │
│                                                           │
│  데드락 예시:                                             │
│  ┌────────────────────────────────────────┐            │
│  │ Thread 1:          Thread 2:          │            │
│  │ lock(A)            lock(B)            │            │
│  │ lock(B) ← 대기     lock(A) ← 대기     │            │
│  │                    (서로 대기하며 블록)│            │
│  └────────────────────────────────────────┘            │
│                                                           │
│  예방 방법:                                               │
│  ┌────────────────────────────────────────┐            │
│  │ 1. 락 순서 통일                        │            │
│  │    • 항상 같은 순서로 락 획득          │            │
│  │                                        │            │
│  │ 2. 타임아웃 설정                       │            │
│  │    • 일정 시간 후 락 포기              │            │
│  │                                        │            │
│  │ 3. 락 계층 구조                        │            │
│  │    • 락의 우선순위 정의                 │            │
│  │                                        │            │
│  │ 4. 데드락 탐지                         │            │
│  │    • 주기적으로 순환 대기 검사         │            │
│  └────────────────────────────────────────┘            │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

---

## 4. 쓰레드 vs 쓰레드풀: 핵심 차이점

### 4.1 생성 및 관리 방식

```
┌──────────────────────────────────────────────────────────┐
│          생성 및 관리 방식 비교                          │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  ┌──────────────────┬──────────────────┐                │
│  │   일반 쓰레드    │   쓰레드풀       │                │
│  ├──────────────────┼──────────────────┤                │
│  │                  │                  │                │
│  │ 생성 시점:       │ 생성 시점:       │                │
│  │ • 작업 요청 시   │ • 애플리케이션    │                │
│  │   즉시 생성      │   시작 시 미리    │                │
│  │                  │   생성            │                │
│  │                  │                  │                │
│  │ 생명주기:        │ 생명주기:        │                │
│  │ • 작업 시작 시   │ • 애플리케이션    │                │
│  │   생성            │   종료 시까지    │                │
│  │ • 작업 완료 시   │   유지            │                │
│  │   소멸            │ • 작업 완료 후    │                │
│  │                  │   풀로 복귀       │                │
│  │                  │                  │                │
│  │ 관리:            │ 관리:            │                │
│  │ • 수동 관리      │ • 풀 관리자에     │                │
│  │ • 각 쓰레드      │   의해 자동       │                │
│  │   개별 추적      │   관리            │                │
│  │                  │                  │                │
│  └──────────────────┴──────────────────┘                │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

### 4.2 성능 비교

```
┌──────────────────────────────────────────────────────────┐
│          성능 지표 비교                                  │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  ⏱️  작업 시작 지연 시간                                  │
│  ┌────────────────────────────────────────┐              │
│  │ 일반 쓰레드:                           │              │
│  │   쓰레드 생성: ~0.1ms                  │              │
│  │   초기화: ~0.05ms                      │              │
│  │   총 지연: ~0.15ms                     │              │
│  │                                        │              │
│  │ 쓰레드풀:                              │              │
│  │   풀에서 할당: ~0.001ms                │              │
│  │   총 지연: ~0.001ms                    │              │
│  │                                        │              │
│  │ 🏆 쓰레드풀 승리 (약 150배 빠름)       │              │
│  └────────────────────────────────────────┘              │
│                                                           │
│  💾 메모리 사용량                                         │
│  ┌────────────────────────────────────────┐              │
│  │ 일반 쓰레드:                           │              │
│  │   • 작업마다 메모리 할당/해제         │              │
│  │   • 메모리 단편화 가능                 │              │
│  │   • 피크 사용량: 높음                 │              │
│  │                                        │              │
│  │ 쓰레드풀:                              │              │
│  │   • 미리 할당된 메모리 재사용         │              │
│  │   • 메모리 단편화 최소화              │              │
│  │   • 일정한 메모리 사용량               │              │
│  │                                        │              │
│  │ 🏆 쓰레드풀 승리 (메모리 효율성)       │              │
│  └────────────────────────────────────────┘              │
│                                                           │
│  🔄 오버헤드                                              │
│  ┌────────────────────────────────────────┐              │
│  │ 일반 쓰레드:                           │              │
│  │   • 매번 생성/소멸 오버헤드            │              │
│  │   • 시스템 호출 비용                   │              │
│  │   • 컨텍스트 스위칭 증가               │              │
│  │                                        │              │
│  │ 쓰레드풀:                              │              │
│  │   • 생성/소멸 오버헤드 최소화          │              │
│  │   • 재사용으로 효율성 향상             │              │
│  │   • 예측 가능한 성능                   │              │
│  │                                        │              │
│  │ 🏆 쓰레드풀 승리 (오버헤드 최소화)     │              │
│  └────────────────────────────────────────┘              │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

### 4.3 사용 시나리오 비교

```
┌──────────────────────────────────────────────────────────┐
│          언제 무엇을 사용할까?                           │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  📌 일반 쓰레드를 사용하는 경우                           │
│  ┌────────────────────────────────────────┐              │
│  │ ✅ 작업이 드물게 발생                  │              │
│  │ ✅ 작업 간 간격이 길 때                │              │
│  │ ✅ 작업 시간이 매우 길 때              │              │
│  │ ✅ 쓰레드 수를 예측하기 어려울 때      │              │
│  │ ✅ 간단한 프로토타입                   │              │
│  │                                        │              │
│  │ 예시:                                  │              │
│  │ • 백그라운드 파일 다운로드             │              │
│  │ • 주기적인 데이터 백업                │              │
│  │ • 사용자 정의 작업 처리                │              │
│  └────────────────────────────────────────┘              │
│                                                           │
│  📌 쓰레드풀을 사용하는 경우                              │
│  ┌────────────────────────────────────────┐              │
│  │ ✅ 작업이 빈번하게 발생                 │              │
│  │ ✅ 짧은 작업이 많을 때                  │              │
│  │ ✅ 동시 처리량이 중요할 때              │              │
│  │ ✅ 리소스 사용량을 제한하고 싶을 때    │              │
│  │ ✅ 프로덕션 환경                       │              │
│  │                                        │              │
│  │ 예시:                                  │              │
│  │ • 웹 서버 요청 처리                    │              │
│  │ • 데이터베이스 연결 풀                 │              │
│  │ • 이미지 처리 작업                     │              │
│  │ • 대량의 작은 작업 처리                │              │
│  └────────────────────────────────────────┘              │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

---

## 5. 쓰레드풀의 고급 기능

### 5.1 작업 거부 정책 (Rejection Policy)

```
┌──────────────────────────────────────────────────────────┐
│          쓰레드풀의 작업 거부 정책                       │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  상황: 큐가 가득 차고 모든 쓰레드가 바쁠 때               │
│                                                           │
│  1️⃣  AbortPolicy (기본)                                  │
│  ┌────────────────────────────────────────┐            │
│  │ • RejectedExecutionException 발생       │            │
│  │ • 호출자에게 예외 전달                  │            │
│  │ • 빠른 실패 (Fail Fast)                 │            │
│  │                                        │            │
│  │ 사용 시나리오:                          │            │
│  │ • 중요한 작업, 실패를 즉시 알려야 할 때│            │
│  │ • 오류 처리 로직이 명확할 때           │            │
│  └────────────────────────────────────────┘            │
│                                                           │
│  2️⃣  CallerRunsPolicy                                    │
│  ┌────────────────────────────────────────┐            │
│  │ • 호출한 쓰레드에서 직접 실행           │            │
│  │ • 풀이 바쁠 때 호출자가 처리            │            │
│  │ • 풀에 부하를 주지 않음                 │            │
│  │                                        │            │
│  │ 사용 시나리오:                          │            │
│  │ • 작업이 반드시 처리되어야 할 때       │            │
│  │ • 풀 부하를 자연스럽게 제한            │            │
│  └────────────────────────────────────────┘            │
│                                                           │
│  3️⃣  DiscardPolicy                                       │
│  ┌────────────────────────────────────────┐            │
│  │ • 작업을 조용히 버림                    │            │
│  │ • 예외 없이 무시                        │            │
│  │ • 경고 없음                             │            │
│  │                                        │            │
│  │ 사용 시나리오:                          │            │
│  │ • 작업 손실이 허용될 때                 │            │
│  │ • 최신 작업만 처리해도 될 때            │            │
│  └────────────────────────────────────────┘            │
│                                                           │
│  4️⃣  DiscardOldestPolicy                                 │
│  ┌────────────────────────────────────────┐            │
│  │ • 가장 오래된 작업을 버림               │            │
│  │ • 새 작업을 큐에 추가                   │            │
│  │ • 최신 작업 우선 처리                    │            │
│  │                                        │            │
│  │ 사용 시나리오:                          │            │
│  │ • 최신 데이터가 더 중요할 때            │            │
│  │ • 오래된 작업은 의미가 없을 때          │            │
│  └────────────────────────────────────────┘            │
│                                                           │
│  5️⃣  커스텀 정책                                         │
│  ┌────────────────────────────────────────┐            │
│  │ • RejectedExecutionHandler 구현         │            │
│  │ • 특정 비즈니스 로직 적용               │            │
│  │ • 로깅, 재시도, 대체 처리 등           │            │
│  └────────────────────────────────────────┘            │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

### 5.2 쓰레드풀 모니터링

```
┌──────────────────────────────────────────────────────────┐
│          쓰레드풀 모니터링 지표                          │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  핵심 메트릭:                                             │
│  ┌────────────────────────────────────────┐            │
│  │ 1. 풀 크기                              │            │
│  │    • 현재 쓰레드 수                     │            │
│  │    • 최소/최대 쓰레드 수                │            │
│  │    • 활성 쓰레드 수                     │            │
│  │                                        │            │
│  │ 2. 작업 큐 상태                         │            │
│  │    • 큐 크기                            │            │
│  │    • 큐 용량                            │            │
│  │    • 큐 사용률                          │            │
│  │                                        │            │
│  │ 3. 작업 처리 통계                      │            │
│  │    • 완료된 작업 수                     │            │
│  │    • 거부된 작업 수                     │            │
│  │    • 평균 처리 시간                    │            │
│  │    • 최대/최소 처리 시간               │            │
│  │                                        │            │
│  │ 4. 쓰레드 상태                         │            │
│  │    • 실행 중인 쓰레드                   │            │
│  │    • 대기 중인 쓰레드                   │            │
│  │    • 유휴 쓰레드                        │            │
│  └────────────────────────────────────────┘            │
│                                                           │
│  모니터링 도구:                                           │
│  • JMX (Java Management Extensions)                     │
│  • Micrometer / Prometheus                               │
│  • 커스텀 로깅                                           │
│  • 프로파일링 도구 (VisualVM, JProfiler)                │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

### 5.3 쓰레드풀의 종료 전략

```
┌──────────────────────────────────────────────────────────┐
│          쓰레드풀 종료 방식                               │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  shutdown() - 정상 종료                                    │
│  ┌────────────────────────────────────────┐            │
│  │ • 새로운 작업 수락 중지                │            │
│  │ • 진행 중인 작업은 완료 대기            │            │
│  │ • 큐에 대기 중인 작업도 처리            │            │
│  │ • 블로킹되지 않음 (비동기)              │            │
│  │                                        │            │
│  │ awaitTermination(timeout)              │            │
│  │ • 종료 완료까지 대기                   │            │
│  │ • 타임아웃 설정 가능                    │            │
│  └────────────────────────────────────────┘            │
│                                                           │
│  shutdownNow() - 강제 종료                                │
│  ┌────────────────────────────────────────┐            │
│  │ • 즉시 모든 작업 중단 시도             │            │
│  │ • 진행 중인 작업에 interrupt() 전송    │            │
│  │ • 큐의 미처리 작업 반환                 │            │
│  │ • 빠른 종료 필요 시 사용               │            │
│  │                                        │            │
│  │ ⚠️  주의:                              │            │
│  │ • 작업이 interrupt를 처리해야 함        │            │
│  │ • 리소스 정리가 필요할 수 있음          │            │
│  └────────────────────────────────────────┘            │
│                                                           │
│  종료 흐름:                                               │
│  ┌────────────────────────────────────────┐            │
│  │ 1. shutdown() 호출                     │            │
│  │ 2. 새로운 작업 거부 시작               │            │
│  │ 3. 진행 중인 작업 완료 대기            │            │
│  │ 4. 큐의 작업 처리 완료                 │            │
│  │ 5. 모든 쓰레드 종료                    │            │
│  │ 6. 리소스 정리                        │            │
│  └────────────────────────────────────────┘            │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

---

## 6. 쓰레드와 쓰레드풀의 관계

### 6.1 계층적 관계

```
┌──────────────────────────────────────────────────────────┐
│          쓰레드와 쓰레드풀의 관계                         │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  애플리케이션                                             │
│      │                                                    │
│      ▼                                                    │
│  ┌────────────────────────────────────┐                  │
│  │      쓰레드풀 (Thread Pool)        │                  │
│  │  ┌──────────────────────────────┐  │                  │
│  │  │  관리 및 제어 로직           │  │                  │
│  │  │  • 풀 크기 관리              │  │                  │
│  │  │  • 작업 큐 관리              │  │                  │
│  │  │  • 쓰레드 할당               │  │                  │
│  │  └──────────────────────────────┘  │                  │
│  │                                      │                  │
│  │  ┌──────┐ ┌──────┐ ┌──────┐        │                  │
│  │  │Thread│ │Thread│ │Thread│        │                  │
│  │  │  1   │ │  2   │ │  3   │        │                  │
│  │  └──────┘ └──────┘ └──────┘        │                  │
│  │  (실제 실행 단위)                   │                  │
│  └────────────────────────────────────┘                  │
│                                                           │
│  핵심 관계:                                               │
│  • 쓰레드풀은 쓰레드들의 컨테이너                         │
│  • 쓰레드는 쓰레드풀의 구성 요소                          │
│  • 쓰레드풀은 쓰레드의 생명주기를 관리                   │
│  • 쓰레드는 실제 작업을 수행하는 실행 단위                │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

### 6.2 상호 보완적 관계

```
┌──────────────────────────────────────────────────────────┐
│          쓰레드풀 = 쓰레드 + 관리 패턴                   │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  쓰레드 (기본 구성 요소)                                  │
│  ┌────────────────────────────────────────┐              │
│  │ • 실행 단위                            │              │
│  │ • 작업 수행                            │              │
│  │ • 독립적 실행                          │              │
│  └────────────────────────────────────────┘              │
│              +                                            │
│  관리 패턴 (추가 기능)                                    │
│  ┌────────────────────────────────────────┐              │
│  │ • 재사용 메커니즘                      │              │
│  │ • 작업 큐 관리                         │              │
│  │ • 풀 크기 제어                         │              │
│  │ • 부하 분산                           │              │
│  └────────────────────────────────────────┘              │
│              =                                            │
│  쓰레드풀 (통합 솔루션)                                   │
│  ┌────────────────────────────────────────┐              │
│  │ • 효율적인 쓰레드 관리                 │              │
│  │ • 성능 최적화                          │              │
│  │ • 리소스 제어                          │              │
│  │ • 확장 가능한 구조                     │              │
│  └────────────────────────────────────────┘              │
│                                                           │
│  💡 결론:                                                 │
│  쓰레드풀은 쓰레드를 더 효율적으로 사용하기 위한        │
│  디자인 패턴입니다.                                      │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

---

## 7. 쓰레드풀의 장점과 단점

### 7.1 쓰레드풀의 장점

```
┌──────────────────────────────────────────────────────────┐
│          쓰레드풀의 주요 장점                            │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  ⚡ 1. 성능 향상                                           │
│  ┌────────────────────────────────────────┐              │
│  │ • 쓰레드 생성/소멸 오버헤드 제거       │              │
│  │ • 작업 시작 지연 시간 최소화           │              │
│  │ • 재사용으로 인한 효율성               │              │
│  │ • 예측 가능한 성능                     │              │
│  └────────────────────────────────────────┘              │
│                                                           │
│  💾 2. 리소스 관리                                        │
│  ┌────────────────────────────────────────┐              │
│  │ • 최대 쓰레드 수 제한                  │              │
│  │ • 메모리 사용량 예측 가능               │              │
│  │ • 시스템 리소스 보호                   │              │
│  │ • 메모리 단편화 최소화                 │              │
│  └────────────────────────────────────────┘              │
│                                                           │
│  🎯 3. 부하 제어                                          │
│  ┌────────────────────────────────────────┐              │
│  │ • 동시 실행 쓰레드 수 제한             │              │
│  │ • 작업 큐를 통한 부하 분산             │              │
│  │ • 시스템 과부하 방지                   │              │
│  │ • 안정적인 성능 유지                   │              │
│  └────────────────────────────────────────┘              │
│                                                           │
│  🔧 4. 관리 용이성                                        │
│  ┌────────────────────────────────────────┐              │
│  │ • 중앙 집중식 관리                     │              │
│  │ • 모니터링 및 통계 수집 용이            │              │
│  │ • 디버깅이 상대적으로 쉬움             │              │
│  │ • 설정 및 튜닝이 간단                  │              │
│  └────────────────────────────────────────┘              │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

### 7.2 쓰레드풀의 단점

```
┌──────────────────────────────────────────────────────────┐
│          쓰레드풀의 주요 단점                            │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  ⚠️ 1. 초기 설정 복잡성                                    │
│  ┌────────────────────────────────────────┐              │
│  │ • 최적 풀 크기 결정이 어려움           │              │
│  │ • 작업 특성에 따른 튜닝 필요            │              │
│  │ • 잘못된 설정 시 성능 저하             │              │
│  └────────────────────────────────────────┘              │
│                                                           │
│  ⚠️ 2. 메모리 사용                                        │
│  ┌────────────────────────────────────────┐              │
│  │ • 미리 할당된 쓰레드로 인한            │              │
│  │   초기 메모리 사용                     │              │
│  │ • 유휴 쓰레드의 메모리 점유            │              │
│  └────────────────────────────────────────┘              │
│                                                           │
│  ⚠️ 3. 유연성 제한                                        │
│  ┌────────────────────────────────────────┐              │
│  │ • 풀 크기 제한으로 인한 확장성 제한    │              │
│  │ • 긴 작업이 풀을 점유할 수 있음        │              │
│  │ • 작업 우선순위 관리가 복잡할 수 있음  │              │
│  └────────────────────────────────────────┘              │
│                                                           │
│  ⚠️ 4. 구현 복잡성                                        │
│  ┌────────────────────────────────────────┐              │
│  │ • 풀 관리 로직 구현 필요               │              │
│  │ • 작업 큐 관리 복잡성                  │              │
│  │ • 동기화 문제 가능성                   │              │
│  └────────────────────────────────────────┘              │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

---

## 8. 실제 구현 예시

### 8.1 Java의 ExecutorService (쓰레드풀)

#### 📚 Java 쓰레드풀의 종류

```
┌──────────────────────────────────────────────────────────┐
│          Java ExecutorService 구현체                     │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  1. FixedThreadPool                                      │
│  ┌────────────────────────────────────────┐            │
│  │ ExecutorService pool =                 │            │
│  │   Executors.newFixedThreadPool(10);     │            │
│  │                                        │            │
│  │ • 고정 크기 쓰레드풀                   │            │
│  │ • 무제한 작업 큐                       │            │
│  │ • 쓰레드 수 변동 없음                  │            │
│  └────────────────────────────────────────┘            │
│                                                           │
│  2. CachedThreadPool                                     │
│  ┌────────────────────────────────────────┐            │
│  │ ExecutorService pool =                 │            │
│  │   Executors.newCachedThreadPool();     │            │
│  │                                        │            │
│  │ • 동적 크기 조정                       │            │
│  │ • 60초 유휴 시 쓰레드 제거             │            │
│  │ • 짧은 작업에 적합                     │            │
│  └────────────────────────────────────────┘            │
│                                                           │
│  3. ScheduledThreadPool                                  │
│  ┌────────────────────────────────────────┐            │
│  │ ScheduledExecutorService pool =        │            │
│  │   Executors.newScheduledThreadPool(5);│            │
│  │                                        │            │
│  │ • 지연 실행 지원                       │            │
│  │ • 주기적 실행 지원                     │            │
│  │ • 타이머 기능                          │            │
│  └────────────────────────────────────────┘            │
│                                                           │
│  4. ForkJoinPool                                         │
│  ┌────────────────────────────────────────┐            │
│  │ ForkJoinPool pool =                    │            │
│  │   new ForkJoinPool();                  │            │
│  │                                        │            │
│  │ • Work-Stealing 알고리즘               │            │
│  │ • 재귀적 작업 분할                     │            │
│  │ • 병렬 스트림에서 사용                 │            │
│  └────────────────────────────────────────┘            │
│                                                           │
│  5. ThreadPoolExecutor (커스텀)                          │
│  ┌────────────────────────────────────────┐            │
│  │ ThreadPoolExecutor pool =              │            │
│  │   new ThreadPoolExecutor(              │            │
│  │     5,  // corePoolSize               │            │
│  │     10, // maximumPoolSize            │            │
│  │     60L, TimeUnit.SECONDS,           │            │
│  │     new LinkedBlockingQueue<>(),      │            │
│  │     new ThreadFactory(),              │            │
│  │     new RejectedExecutionHandler()    │            │
│  │   );                                   │            │
│  │                                        │            │
│  │ • 완전한 커스터마이징                  │            │
│  │ • 모든 파라미터 제어 가능               │            │
│  └────────────────────────────────────────┘            │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

#### 💻 Java 코드 예시

```java
// 기본 쓰레드풀 사용
ExecutorService threadPool = Executors.newFixedThreadPool(10);

// 작업 제출
for (int i = 0; i < 100; i++) {
    final int taskId = i;
    threadPool.submit(() -> {
        // 작업 실행
        System.out.println("Task " + taskId + " 실행 중");
        // 작업 처리...
    });
}

// Future를 통한 결과 처리
Future<String> future = threadPool.submit(() -> {
    // 작업 수행
    return "결과";
});

try {
    String result = future.get(); // 블로킹 대기
    // 또는
    String result = future.get(5, TimeUnit.SECONDS); // 타임아웃
} catch (ExecutionException e) {
    // 예외 처리
}

// 쓰레드풀 종료
threadPool.shutdown();
try {
    if (!threadPool.awaitTermination(60, TimeUnit.SECONDS)) {
        threadPool.shutdownNow();
    }
} catch (InterruptedException e) {
    threadPool.shutdownNow();
}
```

### 8.2 Python의 ThreadPoolExecutor

#### 🐍 Python 쓰레드풀 특징

```
┌──────────────────────────────────────────────────────────┐
│          Python GIL과 쓰레드풀                          │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  GIL (Global Interpreter Lock) 영향:                     │
│  ┌────────────────────────────────────────┐            │
│  │ • Python은 GIL로 인해                  │            │
│  │   진정한 병렬 실행이 제한적            │            │
│  │                                        │            │
│  │ • I/O 바운드 작업에는 효과적            │            │
│  │   (GIL이 I/O 대기 중 해제됨)           │            │
│  │                                        │            │
│  │ • CPU 바운드 작업에는 비효율적          │            │
│  │   (멀티프로세싱 권장)                  │            │
│  └────────────────────────────────────────┘            │
│                                                           │
│  ThreadPoolExecutor vs ProcessPoolExecutor:              │
│  ┌────────────────────────────────────────┐            │
│  │ ThreadPoolExecutor:                    │            │
│  │ • I/O 작업에 적합                      │            │
│  │ • 메모리 공유 가능                      │            │
│  │ • GIL 제약                            │            │
│  │                                        │            │
│  │ ProcessPoolExecutor:                   │            │
│  │ • CPU 집약적 작업에 적합                │            │
│  │ • GIL 제약 없음                        │            │
│  │ • 프로세스 간 통신 필요                 │            │
│  └────────────────────────────────────────┘            │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

#### 💻 Python 코드 예시

```python
from concurrent.futures import ThreadPoolExecutor, as_completed
import time

# 기본 사용
with ThreadPoolExecutor(max_workers=10) as executor:
    # 작업 제출
    futures = []
    for i in range(100):
        future = executor.submit(process_task, i)
        futures.append(future)
    
    # 결과 수집 (완료 순서대로)
    for future in as_completed(futures):
        try:
            result = future.result(timeout=5)
            print(f"결과: {result}")
        except Exception as e:
            print(f"에러: {e}")

# 맵 함수 사용 (간단한 경우)
with ThreadPoolExecutor(max_workers=10) as executor:
    results = executor.map(process_task, range(100))
    for result in results:
        print(result)

# 콜백 함수 사용
def on_complete(future):
    try:
        result = future.result()
        print(f"완료: {result}")
    except Exception as e:
        print(f"실패: {e}")

with ThreadPoolExecutor(max_workers=10) as executor:
    future = executor.submit(process_task, 1)
    future.add_done_callback(on_complete)
```

### 8.3 일반 쓰레드 vs 쓰레드풀 비교

```
┌──────────────────────────────────────────────────────────┐
│          구현 방식 비교                                  │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  일반 쓰레드 방식:                                        │
│  ┌────────────────────────────────────────┐              │
│  │ for (작업 in 작업목록) {              │              │
│  │     Thread thread = new Thread(() -> {│              │
│  │         작업.실행();                  │              │
│  │     });                               │              │
│  │     thread.start();  // 매번 생성     │              │
│  │ }                                     │              │
│  │                                       │              │
│  │ 문제점:                               │              │
│  │ • 100개 작업 = 100개 쓰레드 생성      │              │
│  │ • 메모리 과다 사용                    │              │
│  │ • 시스템 부하                         │              │
│  └────────────────────────────────────────┘              │
│                                                           │
│  쓰레드풀 방식:                                           │
│  ┌────────────────────────────────────────┐              │
│  │ ExecutorService pool =                 │              │
│  │     Executors.newFixedThreadPool(10);  │              │
│  │                                        │              │
│  │ for (작업 in 작업목록) {              │              │
│  │     pool.submit(() -> {                │              │
│  │         작업.실행();                  │              │
│  │     });  // 풀에서 쓰레드 재사용       │              │
│  │ }                                     │              │
│  │                                        │              │
│  │ 장점:                                 │              │
│  │ • 최대 10개 쓰레드만 사용             │              │
│  │ • 메모리 효율적                       │              │
│  │ • 시스템 안정성                       │              │
│  └────────────────────────────────────────┘              │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

---

## 9. 쓰레드풀 크기 결정

### 9.1 풀 크기 결정 공식

```
┌──────────────────────────────────────────────────────────┐
│          최적 쓰레드풀 크기 계산                         │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  CPU 집약적 작업:                                         │
│  ┌────────────────────────────────────────┐              │
│  │ 풀 크기 = CPU 코어 수 + 1              │              │
│  │                                        │              │
│  │ 예: 8코어 CPU → 9개 쓰레드            │              │
│  │                                        │              │
│  │ 이유:                                 │              │
│  │ • 컨텍스트 스위칭 최소화              │              │
│  │ • CPU 활용도 최대화                   │              │
│  └────────────────────────────────────────┘              │
│                                                           │
│  I/O 집약적 작업:                                         │
│  ┌────────────────────────────────────────┐              │
│  │ 풀 크기 = CPU 코어 수 ×                │              │
│  │          (1 + 대기시간/처리시간)       │              │
│  │                                        │              │
│  │ 예:                                    │              │
│  │ • 8코어 CPU                            │              │
│  │ • 대기시간: 90ms                       │              │
│  │ • 처리시간: 10ms                       │              │
│  │ • 풀 크기 = 8 × (1 + 90/10) = 80      │              │
│  │                                        │              │
│  │ 이유:                                 │              │
│  │ • I/O 대기 중 다른 작업 처리           │              │
│  │ • CPU 활용도 향상                     │              │
│  └────────────────────────────────────────┘              │
│                                                           │
│  혼합 작업:                                               │
│  ┌────────────────────────────────────────┐              │
│  │ • CPU 작업과 I/O 작업 비율 분석        │              │
│  │ • 실험을 통한 최적값 찾기             │              │
│  │ • 모니터링을 통한 동적 조정           │              │
│  └────────────────────────────────────────┘              │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

### 9.2 동적 풀 크기 조정

```
┌──────────────────────────────────────────────────────────┐
│          동적 쓰레드풀 크기 조정                        │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  ┌────────────────────────────────────────┐              │
│  │  최소 크기: 5                          │              │
│  │  최대 크기: 50                         │              │
│  │  현재 크기: 10                         │              │
│  └────────────────────────────────────────┘              │
│                                                           │
│  작업 부하 증가 시:                                       │
│  ┌────────────────────────────────────────┐              │
│  │ 1. 큐에 작업이 쌓임                    │              │
│  │ 2. 모든 쓰레드가 바쁨                  │              │
│  │ 3. 풀 크기 증가 (최대 50까지)          │              │
│  │ 4. 처리량 증가                         │              │
│  └────────────────────────────────────────┘              │
│                                                           │
│  작업 부하 감소 시:                                       │
│  ┌────────────────────────────────────────┐              │
│  │ 1. 큐가 비어있음                       │              │
│  │ 2. 유휴 쓰레드 발생                    │              │
│  │ 3. 일정 시간 후 쓰레드 제거            │              │
│  │ 4. 최소 크기(5)까지 감소              │              │
│  └────────────────────────────────────────┘              │
│                                                           │
│  장점:                                                    │
│  ✅ 부하에 따른 자동 조정                                 │
│  ✅ 리소스 효율성                                        │
│  ✅ 성능 최적화                                           │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

---

## 10. 실제 사용 사례

### 10.1 웹 서버

```
┌──────────────────────────────────────────────────────────┐
│          웹 서버에서의 쓰레드풀 활용                    │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  클라이언트 요청                                          │
│      │                                                    │
│      ▼                                                    │
│  ┌────────────────────────────────────┐                  │
│  │     요청 큐 (Request Queue)        │                  │
│  │  [Req1] [Req2] [Req3] [Req4] ... │                  │
│  └──────────────┬─────────────────────┘                  │
│                 │                                        │
│                 ▼                                        │
│  ┌────────────────────────────────────┐                  │
│  │    쓰레드풀 (Thread Pool)          │                  │
│  │  ┌──────┐ ┌──────┐ ┌──────┐      │                  │
│  │  │Thread│ │Thread│ │Thread│      │                  │
│  │  │  1   │ │  2   │ │  3   │      │                  │
│  │  │      │ │      │ │      │      │                  │
│  │  │ HTTP │ │ HTTP │ │ HTTP │      │                  │
│  │  │응답  │ │응답  │ │응답  │      │                  │
│  │  └──────┘ └──────┘ └──────┘      │                  │
│  └────────────────────────────────────┘                  │
│                                                           │
│  특징:                                                    │
│  • 동시 요청 처리                                         │
│  • 리소스 제한 (최대 동시 연결 수)                       │
│  • 빠른 응답 시간                                         │
│  • 안정적인 성능                                          │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

### 10.2 데이터베이스 연결 풀

```
┌──────────────────────────────────────────────────────────┐
│          데이터베이스 연결 풀                           │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  애플리케이션                                             │
│      │                                                    │
│      ▼                                                    │
│  ┌────────────────────────────────────┐                  │
│  │   연결 풀 (Connection Pool)       │                  │
│  │  ┌──────┐ ┌──────┐ ┌──────┐      │                  │
│  │  │Conn 1│ │Conn 2│ │Conn 3│      │                  │
│  │  │      │ │      │ │      │      │                  │
│  │  │사용중│ │대기  │ │사용중│      │                  │
│  │  └──────┘ └──────┘ └──────┘      │                  │
│  └──────────────┬─────────────────────┘                  │
│                 │                                        │
│                 ▼                                        │
│  ┌────────────────────────────────────┐                  │
│  │      데이터베이스 서버            │                  │
│  └────────────────────────────────────┘                  │
│                                                           │
│  장점:                                                    │
│  • 연결 생성 비용 절감                                   │
│  • 연결 수 제한으로 DB 부하 방지                         │
│  • 빠른 쿼리 실행                                        │
│  • 리소스 효율성                                         │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

---

## 11. 쓰레드풀 구현 세부사항

### 11.1 쓰레드풀의 내부 상태 관리

```
┌──────────────────────────────────────────────────────────┐
│          쓰레드풀 상태 머신                              │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  ┌──────────┐                                             │
│  │  RUNNING │  (정상 동작)                                │
│  └────┬─────┘                                             │
│       │                                                   │
│       │ shutdown() 호출                                   │
│       ▼                                                   │
│  ┌──────────┐                                             │
│  │ SHUTDOWN │  (새 작업 거부, 기존 작업 완료 대기)        │
│  └────┬─────┘                                             │
│       │                                                   │
│       │ shutdownNow() 호출                                │
│       ▼                                                   │
│  ┌──────────┐                                             │
│  │   STOP   │  (모든 작업 중단 시도)                      │
│  └────┬─────┘                                             │
│       │                                                   │
│       │ 모든 쓰레드 종료                                  │
│       ▼                                                   │
│  ┌──────────┐                                             │
│  │  TIDYING │  (정리 중)                                  │
│  └────┬─────┘                                             │
│       │                                                   │
│       │ 정리 완료                                         │
│       ▼                                                   │
│  ┌──────────┐                                             │
│  │TERMINATED│  (완전 종료)                                │
│  └──────────┘                                             │
│                                                           │
│  상태 전이 조건:                                          │
│  • RUNNING → SHUTDOWN: shutdown() 호출                   │
│  • (SHUTDOWN | STOP) → TIDYING: 모든 쓰레드 종료         │
│  • TIDYING → TERMINATED: terminated() 호출               │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

### 11.2 쓰레드풀의 작업 실행 흐름

```
┌──────────────────────────────────────────────────────────┐
│          작업 실행의 상세 흐름                           │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  submit(task) 호출                                        │
│      │                                                    │
│      ▼                                                    │
│  ┌────────────────────────┐                              │
│  │ 1. 풀 상태 확인        │                              │
│  │    if (shutdown)       │                              │
│  │      reject(task)      │                              │
│  └────────┬───────────────┘                              │
│           │                                               │
│           ▼                                               │
│  ┌────────────────────────┐                              │
│  │ 2. 풀 크기 확인        │                              │
│  │    if (active < core)  │                              │
│  │      addWorker(task)    │                              │
│  └────────┬───────────────┘                              │
│           │                                               │
│           ▼                                               │
│  ┌────────────────────────┐                              │
│  │ 3. 큐에 작업 추가       │                              │
│  │    queue.offer(task)   │                              │
│  └────────┬───────────────┘                              │
│           │                                               │
│           ▼                                               │
│  ┌────────────────────────┐                              │
│  │ 4. 대기 쓰레드 깨움     │                              │
│  │    notify() / signal()  │                              │
│  └────────┬───────────────┘                              │
│           │                                               │
│           ▼                                               │
│  ┌────────────────────────┐                              │
│  │ 5. 쓰레드가 작업 가져옴 │                              │
│  │    task = queue.take() │                              │
│  └────────┬───────────────┘                              │
│           │                                               │
│           ▼                                               │
│  ┌────────────────────────┐                              │
│  │ 6. 작업 실행           │                              │
│  │    task.run()          │                              │
│  └────────┬───────────────┘                              │
│           │                                               │
│           ▼                                               │
│  ┌────────────────────────┐                              │
│  │ 7. 완료 처리           │                              │
│  │    - Future 완료        │                              │
│  │    - 콜백 실행          │                              │
│  │    - 쓰레드 풀로 복귀   │                              │
│  └────────────────────────┘                              │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

### 11.3 쓰레드풀의 동적 크기 조정 알고리즘

```
┌──────────────────────────────────────────────────────────┐
│          동적 크기 조정 로직                              │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  쓰레드 추가 조건:                                        │
│  ┌────────────────────────────────────────┐            │
│  │ if (큐에 작업이 있고 &&                │            │
│  │     활성 쓰레드 < 최대 크기) {         │            │
│  │   if (활성 쓰레드 < 코어 수) {         │            │
│  │     즉시 새 쓰레드 생성                │            │
│  │   } else if (큐 크기 > 임계값) {       │            │
│  │     새 쓰레드 생성                     │            │
│  │   }                                    │            │
│  │ }                                      │            │
│  └────────────────────────────────────────┘            │
│                                                           │
│  쓰레드 제거 조건:                                        │
│  ┌────────────────────────────────────────┐            │
│  │ if (유휴 시간 > keepAliveTime &&        │            │
│  │     현재 쓰레드 수 > 코어 수) {         │            │
│  │   쓰레드 종료                          │            │
│  │   풀 크기 감소                         │            │
│  │ }                                      │            │
│  └────────────────────────────────────────┘            │
│                                                           │
│  타이밍:                                                  │
│  • 쓰레드 추가: 작업 제출 시 즉시 체크                   │
│  • 쓰레드 제거: 주기적으로 스캔 (예: 1초마다)           │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

---

## 12. 트러블슈팅 가이드

### 12.1 일반적인 문제와 해결책

```
┌──────────────────────────────────────────────────────────┐
│          쓰레드풀 문제 진단 및 해결                      │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  문제 1: 작업이 실행되지 않음                             │
│  ┌────────────────────────────────────────┐            │
│  │ 증상:                                   │            │
│  │ • 작업이 큐에 쌓이지만 실행 안 됨       │            │
│  │ • 쓰레드가 대기 상태로 멈춤             │            │
│  │                                        │            │
│  │ 원인:                                   │            │
│  │ • notify() 호출 누락                   │            │
│  │ • 데드락 발생                          │            │
│  │ • 쓰레드가 예외로 종료                 │            │
│  │                                        │            │
│  │ 해결:                                   │            │
│  │ • 작업 제출 후 notify() 확인           │            │
│  │ • 예외 처리 추가                       │            │
│  │ • 쓰레드 덤프 분석                     │            │
│  └────────────────────────────────────────┘            │
│                                                           │
│  문제 2: 메모리 누수                                      │
│  ┌────────────────────────────────────────┐            │
│  │ 증상:                                   │            │
│  │ • 시간이 지날수록 메모리 증가           │            │
│  │ • GC가 자주 발생                       │            │
│  │                                        │            │
│  │ 원인:                                   │            │
│  │ • 완료된 Future 객체 누적              │            │
│  │ • 작업 객체가 참조 유지                │            │
│  │ • 쓰레드 로컬 변수 누적                │            │
│  │                                        │            │
│  │ 해결:                                   │            │
│  │ • Future 결과 즉시 처리                │            │
│  │ • ThreadLocal 정리                    │            │
│  │ • 약한 참조(WeakReference) 사용       │            │
│  └────────────────────────────────────────┘            │
│                                                           │
│  문제 3: 성능 저하                                        │
│  ┌────────────────────────────────────────┐            │
│  │ 증상:                                   │            │
│  │ • 처리량 감소                          │            │
│  │ • 응답 시간 증가                       │            │
│  │                                        │            │
│  │ 원인:                                   │            │
│  │ • 풀 크기 부적절                       │            │
│  │ • 락 경합 과다                         │            │
│  │ • 컨텍스트 스위칭 과다                 │            │
│  │                                        │            │
│  │ 해결:                                   │            │
│  │ • 풀 크기 튜닝                         │            │
│  │ • Lock-Free 자료구조 사용              │            │
│  │ • 프로파일링으로 병목 지점 찾기        │            │
│  └────────────────────────────────────────┘            │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

### 12.2 디버깅 기법

```
┌──────────────────────────────────────────────────────────┐
│          쓰레드풀 디버깅 방법                             │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  1. 로깅 전략                                             │
│  ┌────────────────────────────────────────┐            │
│  │ • 작업 제출/완료 로깅                  │            │
│  │ • 쓰레드 생성/종료 로깅                │            │
│  │ • 큐 크기 주기적 로깅                  │            │
│  │ • 예외 상세 로깅                       │            │
│  └────────────────────────────────────────┘            │
│                                                           │
│  2. 모니터링 도구                                         │
│  ┌────────────────────────────────────────┐            │
│  │ • JVisualVM: 쓰레드 상태 시각화        │            │
│  │ • JProfiler: 성능 프로파일링           │            │
│  │ • Thread Dump: 쓰레드 상태 스냅샷      │            │
│  │ • JMX: 실시간 메트릭 수집              │            │
│  └────────────────────────────────────────┘            │
│                                                           │
│  3. 테스트 전략                                           │
│  ┌────────────────────────────────────────┐            │
│  │ • 단위 테스트: 각 메서드 개별 테스트    │            │
│  │ • 통합 테스트: 전체 플로우 테스트       │            │
│  │ • 부하 테스트: 대량 작업 처리 테스트    │            │
│  │ • 동시성 테스트: 경쟁 조건 검증         │            │
│  └────────────────────────────────────────┘            │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

---

## 13. 결론

### 13.1 핵심 정리

```
┌──────────────────────────────────────────────────────────┐
│          쓰레드 vs 쓰레드풀 요약                         │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  📌 쓰레드 (Thread)                                       │
│  ┌────────────────────────────────────────┐              │
│  │ • 기본 실행 단위                       │              │
│  │ • 작업 요청 시 생성                    │              │
│  │ • 작업 완료 시 소멸                    │              │
│  │ • 간단하지만 비효율적                  │              │
│  └────────────────────────────────────────┘              │
│                                                           │
│  📌 쓰레드풀 (Thread Pool)                                │
│  ┌────────────────────────────────────────┐              │
│  │ • 쓰레드들의 집합 + 관리 패턴          │              │
│  │ • 미리 생성된 쓰레드 재사용            │              │
│  │ • 효율적이고 안정적                    │              │
│  │ • 프로덕션 환경에 적합                  │              │
│  └────────────────────────────────────────┘              │
│                                                           │
│  🔗 관계:                                                 │
│  • 쓰레드풀은 쓰레드를 관리하는 패턴                     │
│  • 쓰레드는 쓰레드풀의 구성 요소                          │
│  • 쓰레드풀 = 쓰레드 + 재사용 + 관리                      │
│                                                           │
│  💡 선택 기준:                                            │
│  • 빈번한 작업 → 쓰레드풀                                │
│  • 드문 작업 → 일반 쓰레드                               │
│  • 성능 중요 → 쓰레드풀                                  │
│  • 간단한 프로토타입 → 일반 쓰레드                       │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

### 13.2 실무 권장사항

```
┌──────────────────────────────────────────────────────────┐
│          실무에서의 권장사항                             │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  1. 기본적으로 쓰레드풀 사용                             │
│     • 대부분의 경우 쓰레드풀이 더 효율적                 │
│     • Java: ExecutorService                              │
│     • Python: ThreadPoolExecutor                         │
│     • C#: Task.Run, Parallel.For                         │
│                                                           │
│  2. 풀 크기 신중히 결정                                   │
│     • CPU 코어 수 고려                                   │
│     • 작업 특성 분석 (CPU vs I/O)                        │
│     • 모니터링을 통한 튜닝                               │
│                                                           │
│  3. 동기화 주의                                           │
│     • 공유 자원 접근 시 락 사용                          │
│     • 데드락 방지                                        │
│     • 스레드 안전한 자료구조 활용                        │
│                                                           │
│  4. 모니터링 및 로깅                                     │
│     • 쓰레드 풀 상태 모니터링                            │
│     • 작업 처리 시간 측정                                │
│     • 큐 크기 추적                                       │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

---

## 14. 언어별 구현 차이

### 14.1 주요 언어의 쓰레드풀 비교

```
┌──────────────────────────────────────────────────────────┐
│          언어별 쓰레드풀 구현                            │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  Java                                                     │
│  ┌────────────────────────────────────────┐            │
│  │ • ExecutorService 인터페이스           │            │
│  │ • ThreadPoolExecutor 구현체            │            │
│  │ • Future/Promise 패턴                 │            │
│  │ • CompletableFuture (비동기 체이닝)   │            │
│  │ • 풍부한 기능과 유연성                 │            │
│  └────────────────────────────────────────┘            │
│                                                           │
│  Python                                                   │
│  ┌────────────────────────────────────────┐            │
│  │ • concurrent.futures 모듈              │            │
│  │ • ThreadPoolExecutor / ProcessPoolExecutor│         │
│  │ • GIL 제약 (I/O 작업에 적합)           │            │
│  │ • 간단한 API                          │            │
│  └────────────────────────────────────────┘            │
│                                                           │
│  C# / .NET                                                │
│  ┌────────────────────────────────────────┐            │
│  │ • Task Parallel Library (TPL)          │            │
│  │ • ThreadPool.QueueUserWorkItem         │            │
│  │ • async/await 패턴                     │            │
│  │ • Task 기반 비동기 프로그래밍          │            │
│  └────────────────────────────────────────┘            │
│                                                           │
│  C++                                                      │
│  ┌────────────────────────────────────────┐            │
│  │ • std::thread + 큐 직접 구현           │            │
│  │ • std::async (간단한 경우)             │            │
│  │ • Boost.ThreadPool                    │            │
│  │ • 더 많은 제어권                       │            │
│  └────────────────────────────────────────┘            │
│                                                           │
│  Go                                                       │
│  ┌────────────────────────────────────────┐            │
│  │ • Goroutine (경량 쓰레드)              │            │
│  │ • Channel 기반 통신                    │            │
│  │ • Worker Pool 패턴                     │            │
│  │ • 매우 효율적인 동시성                 │            │
│  └────────────────────────────────────────┘            │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

### 14.2 최신 동향: 비동기 프로그래밍과 쓰레드풀

```
┌──────────────────────────────────────────────────────────┐
│          비동기 프로그래밍의 등장                         │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  전통적 방식:                                             │
│  ┌────────────────────────────────────────┐            │
│  │ Thread thread = new Thread(() -> {    │            │
│  │   // 동기 작업                        │            │
│  │   result = blockingIO();              │            │
│  │ });                                   │            │
│  │ thread.start();                       │            │
│  └────────────────────────────────────────┘            │
│                                                           │
│  비동기 방식:                                             │
│  ┌────────────────────────────────────────┐            │
│  │ async function process() {            │            │
│  │   // 논블로킹 작업                     │            │
│  │   result = await asyncIO();           │            │
│  │ }                                     │            │
│  │                                        │            │
│  │ • 쓰레드 풀을 효율적으로 사용         │            │
│  │ • I/O 대기 중 쓰레드 해제             │            │
│  │ • 더 많은 동시 처리 가능               │            │
│  └────────────────────────────────────────┘            │
│                                                           │
│  비교:                                                    │
│  ┌────────────────────────────────────────┐            │
│  │ 방식        │ 쓰레드 사용 │ 동시 처리  │            │
│  │─────────────┼───────────┼──────────│            │
│  │ 동기        │ 1000개    │ 1000개    │            │
│  │ 비동기      │ 10개      │ 10000개+  │            │
│  └────────────────────────────────────────┘            │
│                                                           │
│  예시:                                                    │
│  • Node.js: 이벤트 루프 + 쓰레드풀                       │
│  • Python asyncio: 코루틴 + 쓰레드풀                     │
│  • Java CompletableFuture: 비동기 체이닝                 │
│  • C# async/await: Task 기반 비동기                     │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

---

## 참조

- Brian Goetz et al. "Java Concurrency in Practice". Addison-Wesley, 2006.
- Doug Lea. "Concurrent Programming in Java". Addison-Wesley, 1999.
- Oracle. "Java Platform, Standard Edition Documentation - ExecutorService". https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html
- Python Software Foundation. "concurrent.futures — Launching parallel tasks". https://docs.python.org/3/library/concurrent.futures.html
- Microsoft. "Thread Pooling". https://docs.microsoft.com/en-us/dotnet/standard/threading/the-managed-thread-pool
- Linux Kernel Documentation - Threading
- POSIX Threads Programming Guide

