---
title: 스레드의 개념
tags: [os, process-and-thread, thread, 스레드의-개념]
updated: 2025-09-21
---

## 스레드 개요

스레드는 프로세스 내부에서 실행되는 가장 작은 실행 단위로, 현대 컴퓨팅에서 병렬 처리와 동시성을 구현하는 핵심 메커니즘입니다. 하나의 프로세스 안에서 여러 개의 실행 흐름을 동시에 처리할 수 있게 해주며, 시스템의 성능과 응답성을 크게 향상시킵니다.

<div align="center">
    <img src="../../../../etc/image/OS_IMAGE/스레드의 구조.png" alt="스레드의 구조.png" width="30%">
</div>

### 스레드의 기본 특성

스레드는 프로세스와 비교했을 때 다음과 같은 특성을 가집니다:

- **경량성**: 프로세스보다 생성과 관리가 빠르며 자원을 적게 사용합니다
- **공유성**: 같은 프로세스 내의 스레드들은 메모리 공간을 공유합니다
- **독립성**: 각 스레드는 독립적인 실행 컨텍스트를 유지합니다
- **동시성**: 여러 스레드가 동시에 실행되어 병렬 처리를 가능하게 합니다

---

## 1. 스레드의 정의와 특징

### 개념과 역할

스레드는 프로세스 내부에서 실행되는 경량화된 실행 단위입니다. 쉽게 말해, 하나의 프로그램(프로세스) 안에서 동시에 여러 작업을 수행할 수 있게 해주는 실행 흐름이라고 볼 수 있습니다.

### 프로세스와 스레드의 관계

**프로세스의 구성 요소**
- 프로세스는 독립적인 메모리 공간을 가진 프로그램의 실행 단위입니다
- 하나의 프로세스는 최소 하나의 스레드를 가지며, 이를 메인 스레드라고 부릅니다
- 프로세스는 코드, 데이터, 힙, 스택 영역을 포함한 완전한 메모리 공간을 가집니다

**스레드의 특성**
- 스레드는 프로세스 내부에서 실행되는 경량화된 실행 단위입니다
- 프로세스의 메모리 공간을 공유하면서 자신만의 실행 컨텍스트를 유지합니다
- 프로세스보다 생성과 종료가 빠르며, 문맥 전환 비용이 적습니다

### 스레드의 핵심 특징

**1. 자원 공유의 효율성**
프로세스들은 서로의 데이터에 직접 접근할 수 없어서 IPC(Inter-Process Communication)라는 복잡한 통신 방식을 사용해야 합니다. 하지만 스레드는 같은 프로세스 내부에 존재하기 때문에 프로세스의 데이터 영역에 자유롭게 접근할 수 있습니다.

스레드들끼리도 서로의 데이터에 접근이 가능하며, 별도의 통신 메커니즘 없이도 데이터를 공유할 수 있습니다. 이는 마치 같은 사무실에서 일하는 직원들이 서로의 책상에 있는 자료를 쉽게 확인할 수 있는 것과 같습니다.

**2. 경량화된 작업 단위**
리눅스에서는 스레드를 Light Weight Process라고 부르는데, 이는 스레드도 프로세스처럼 작업을 처리한다는 의미입니다. 스레드는 프로세스처럼 병렬로 작업을 처리하여 전체적인 성능을 향상시킬 수 있습니다.

다만 프로세스보다 훨씬 가볍고 빠르게 생성되고 관리됩니다. 일반적으로 스레드 생성 시간은 프로세스 생성 시간의 약 1/10 수준입니다.

**3. 독립적인 실행 환경**
스레드는 함수처럼 구현되며, 각자 고유한 지역 변수와 스택 메모리 영역을 가집니다. 이 스택 공간은 프로세스의 메인 스택과는 별개이며, 스레드 스택이라고 부릅니다.

각 스레드는 자신만의 실행 컨텍스트를 유지하면서 독립적으로 실행됩니다. 이는 각 스레드가 독립적인 프로그램 카운터, 레지스터 상태, 스택 포인터를 가진다는 의미입니다.

**4. 다중 스레드 지원**
하나의 프로세스는 내부에 여러 개의 스레드를 가질 수 있습니다. 이를 통해 복잡한 작업을 여러 개의 작은 작업으로 나누어 동시에 처리할 수 있습니다.

---

## 2. 스레드의 메모리 구조

### 독립적으로 가지는 자원들

스레드는 프로세스의 메모리 공간을 공유하면서도 자신만의 독립적인 실행 환경을 유지합니다.

**프로그램 카운터(PC)**
- 현재 실행 중인 명령어의 위치를 추적합니다
- 각 스레드마다 독립적인 실행 위치를 가집니다
- 스레드가 다른 함수를 호출하거나 다른 코드 경로를 따라갈 때 독립적으로 변경됩니다

**스택 포인터(SP)**
- 스택의 최상단 위치를 가리킵니다
- 각 스레드는 자신만의 스택 공간을 가집니다
- 함수 호출과 지역 변수 관리를 위해 필수적입니다

**레지스터 상태**
- CPU 레지스터의 현재 상태를 저장합니다
- 스레드 전환 시 이전 상태를 복원하기 위해 필요합니다
- 각 스레드마다 독립적인 레지스터 상태를 유지합니다

**지역 데이터**
- 함수 내에서 선언된 지역 변수들입니다
- 각 스레드의 스택에 저장됩니다
- 다른 스레드와 공유되지 않는 독립적인 데이터입니다

**스택 공간**
- 함수 호출 정보와 지역 변수를 저장하는 공간입니다
- 각 스레드마다 독립적으로 할당됩니다
- 스레드 스택이라고 부르며, 프로세스의 메인 스택과는 별개입니다

### 공유하는 자원들

같은 프로세스 내의 모든 스레드들은 다음 자원들을 공유합니다.

**코드 영역**
- 실행할 프로그램 코드가 저장된 영역입니다
- 모든 스레드가 동일한 코드를 실행합니다
- 읽기 전용이므로 안전하게 공유할 수 있습니다

**전역 데이터**
- 프로그램의 전역 변수들이 저장된 영역입니다
- 모든 스레드가 접근할 수 있습니다
- 동기화가 필요한 공유 자원입니다

**힙 영역**
- 동적으로 할당되는 메모리 영역입니다
- 모든 스레드가 공유하여 사용합니다
- 메모리 관리와 동기화가 중요한 영역입니다

<div align="center">
    <img src="../../../../etc/image/OS_IMAGE/스레드의 주소 공간.png" alt="스레드의 주소 공간.png" width="30%">
</div>

같은 프로세스 내의 모든 스레드들은 동일한 주소 공간을 공유합니다. 이는 스레드들이 서로의 데이터에 쉽게 접근할 수 있게 해주지만, 동시에 동기화 문제를 야기할 수도 있습니다.

프로세스 내의 여러 스레드들은 공동의 목적을 달성하기 위해 병렬로 작업을 수행합니다. 마치 한 팀의 여러 멤버가 각자 다른 역할을 맡아 동시에 작업하는 것과 같습니다.

---

## 3. 멀티스레딩의 장점

### 사용자 경험의 향상

**반응성 개선**
단일 스레드 프로그램에서는 하나의 작업이 끝날 때까지 다른 작업을 할 수 없습니다. 하지만 멀티스레드 프로그램에서는 긴 작업을 백그라운드에서 처리하면서 동시에 사용자 인터페이스를 반응적으로 유지할 수 있습니다.

**실생활 예시**
웹 브라우저를 예로 들 수 있습니다. 파일을 다운로드하는 동안에도 다른 웹페이지를 탐색할 수 있는 것이 바로 멀티스레딩 덕분입니다. 만약 단일 스레드로 구현되었다면, 다운로드가 완료될 때까지 브라우저가 완전히 멈춰있을 것입니다.

### 자원 공유의 편리함

**자연스러운 데이터 공유**
프로세스들 사이에서는 데이터를 공유하기 위해 복잡한 통신 메커니즘(IPC)을 사용해야 합니다. 하지만 같은 프로세스 내의 스레드들은 자연스럽게 메모리 공간을 공유하므로, 별도의 통신 과정 없이도 데이터를 주고받을 수 있습니다.

**통신 오버헤드 감소**
IPC를 사용할 때 발생하는 오버헤드가 없어집니다. 공유 메모리나 메시지 전달과 같은 복잡한 기법을 사용하지 않아도 되므로, 성능상 이점이 있습니다.

### 효율적인 자원 사용

**빠른 생성과 관리**
스레드 생성은 프로세스 생성보다 훨씬 빠르고 가볍습니다. 일반적으로 스레드 생성 시간은 프로세스 생성 시간의 약 1/10 수준입니다. 또한 스레드 간의 문맥 전환도 프로세스 간 전환보다 훨씬 빠릅니다.

**메모리 효율성**
코드, 데이터, 힙 영역을 공유하므로 메모리 사용량이 효율적입니다. 동일한 프로그램을 실행하는 여러 프로세스를 만드는 것보다 훨씬 적은 메모리를 사용합니다.

### 멀티코어 시스템의 활용

**병렬 처리 능력**
현대의 컴퓨터는 여러 개의 CPU 코어를 가지고 있습니다. 멀티스레딩을 통해 각 스레드를 다른 코어에서 동시에 실행함으로써 전체적인 성능을 크게 향상시킬 수 있습니다.

**특화된 작업 처리**
특히 대용량 데이터 처리나 복잡한 계산 작업에서 그 효과가 두드러집니다. 각 코어가 독립적인 작업을 처리하면서 전체 작업 시간을 단축할 수 있습니다.

---

## 4. 멀티스레딩의 단점과 주의사항

### 동기화의 복잡성

**경쟁 상태(Race Condition)**
여러 스레드가 같은 데이터에 동시에 접근할 때 발생하는 문제입니다. 마치 여러 사람이 동시에 같은 문서를 수정하려고 할 때 발생하는 혼란과 같습니다.

**교착 상태(Deadlock)**
락(Lock) 메커니즘을 사용하여 동기화 문제를 해결하려고 할 때 발생할 수 있는 문제입니다. 교착 상태는 두 스레드가 서로의 자원을 기다리며 무한정 대기하는 상황입니다.

**동기화 오버헤드**
상호 배제를 위한 락 메커니즘이 성능 저하를 야기할 수 있습니다. 과도한 락 사용은 오히려 성능을 저하시킬 수 있습니다.

### 디버깅의 어려움

**비결정적 실행**
멀티스레드 프로그램의 가장 큰 어려움 중 하나는 디버깅입니다. 스레드들이 언제 실행될지, 어떤 순서로 실행될지 예측하기 어렵기 때문입니다.

**재현 어려운 버그**
같은 프로그램을 여러 번 실행해도 매번 다른 결과가 나올 수 있어서, 버그를 재현하고 원인을 찾는 것이 매우 어렵습니다. 이는 마치 여러 명이 동시에 작업하는 프로젝트에서 누가 어떤 실수를 했는지 찾기 어려운 것과 같습니다.

**동시성 관련 버그**
동시성 관련 버그는 발견하기 어렵고 수정이 복잡합니다. 스레드 간의 상호작용이 복잡하여 버그 발생 시 원인 파악이 어렵습니다.

### 자원 관리의 부담

**메모리 사용량 증가**
스레드가 많아질수록 메모리 사용량도 증가합니다. 각 스레드는 독립적인 스택 공간을 필요로 하기 때문입니다.

**스레드 풀 관리**
스레드의 생성과 소멸을 효율적으로 관리하기 위해 스레드 풀(Thread Pool) 같은 기법을 사용해야 하는데, 이는 프로그램의 복잡성을 더욱 증가시킵니다.

**컨텍스트 스위칭 비용**
스레드 수가 많아질수록 컨텍스트 스위칭 비용도 증가합니다. 적절한 스레드 수를 유지하는 것이 중요합니다.

### 안정성의 취약점

**프로세스 전체 영향**
하나의 스레드에서 심각한 오류가 발생하면 전체 프로세스가 종료될 수 있습니다. 이는 마치 한 팀원의 실수가 전체 프로젝트를 망칠 수 있는 것과 같습니다.

**메모리 누수 위험**
메모리 누수나 자원 해제 실패 같은 문제가 발생하면, 이는 프로세스 전체에 영향을 미칠 수 있어서 시스템의 안정성을 해칠 수 있습니다.

**예외 처리 복잡성**
멀티스레드 환경에서는 예외 처리가 복잡해집니다. 한 스레드의 예외가 다른 스레드에 영향을 미칠 수 있습니다.

---

## 스레드와 프로세스의 비교

### 생성 및 관리 비용

**스레드의 장점**
- 생성 시간: 프로세스 생성 시간의 약 1/10
- 메모리 사용량: 프로세스보다 훨씬 적음
- 문맥 전환: 빠르고 효율적

**프로세스의 장점**
- 독립성: 한 프로세스의 오류가 다른 프로세스에 영향 없음
- 보안: 프로세스 간 메모리 보호
- 안정성: 프로세스 격리로 인한 높은 안정성

### 통신 및 동기화

**스레드 통신**
- 자연스러운 메모리 공유
- 빠른 데이터 접근
- 동기화 메커니즘 필요

**프로세스 통신**
- IPC 메커니즘 필요 (파이프, 소켓, 공유 메모리 등)
- 느린 통신 속도
- 복잡한 동기화

### 성능 및 확장성

**멀티스레딩**
- 멀티코어 활용에 유리
- 빠른 응답성
- 복잡한 동기화 관리 필요

**멀티프로세싱**
- 높은 안정성과 격리
- 확장성 제한
- 높은 자원 사용량

---

## 결론

스레드는 현대 컴퓨팅에서 필수적인 개념입니다. 프로세스보다 가볍고 빠르면서도 병렬 처리를 가능하게 해주는 스레드는 성능 향상과 사용자 경험 개선에 큰 역할을 합니다.

하지만 멀티스레딩은 양날의 검과 같습니다. 올바르게 사용하면 큰 이익을 가져다주지만, 잘못 사용하면 복잡한 문제들을 야기할 수 있습니다. 따라서 스레드를 사용할 때는 동기화, 자원 관리, 안정성 등을 충분히 고려해야 합니다.

스레드의 개념을 이해하는 것은 단순히 기술적 지식을 습득하는 것을 넘어서, 현대 소프트웨어 개발에서 필수적인 사고방식을 익히는 것입니다. 복잡한 문제를 여러 개의 작은 작업으로 나누어 동시에 처리하는 것은 단순히 프로그래밍 기법이 아니라, 문제 해결의 새로운 관점을 제시해줍니다.

---

## 참조

- Abraham Silberschatz, Peter Baer Galvin, Greg Gagne. "Operating System Concepts" 10th Edition
- Andrew S. Tanenbaum, Herbert Bos. "Modern Operating Systems" 4th Edition  
- Linux Kernel Documentation - Threading
- POSIX Threads Programming Guide
- https://inpa.tistory.com/entry/👩‍💻-프로세스-⚔️-쓰레드-차이 [Inpa Dev 👨‍💻:티스토리]