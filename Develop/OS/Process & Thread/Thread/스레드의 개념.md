## 배경
- 스레드(Thread)는 프로세스 내부에서 실행되는 가장 작은 실행 단위이며, CPU 스케줄링의 기본 단위이다.
- 하나의 프로세스는 최소 하나의 스레드를 가지며, 이를 메인 스레드(Main Thread)라고 한다.
- 스레드는 프로세스의 코드, 데이터, 힙 영역을 공유하면서 자신만의 스택, 레지스터, 프로그램 카운터를 가진다.
- 각 스레드는 독립적으로 실행되며, 동일한 프로세스 내의 다른 스레드들과 자원을 공유한다.
- 스레드는 프로세스보다 생성과 종료가 빠르며, 문맥 전환(Context Switching) 비용이 적다.

1. 프로세스들이 서로의 데이터에 접근하는 것이 직접적으로 불가능한데 반면, 스레드는 프로세스 내부에 존재하기에 프로세스의 데이터 영역에 접근이 가능하다. 그리고 스레드들끼리 서로의 데이터에 접근 가능하다. IPC 필요없이 프로세스의 데이터를 가져올 수 있다.
2. 스레드도 일조의 작업 단위라서, 프로세스처럼 작업이 처리된다(리눅스에선 스레드를 Light Weight Process라고 부르는데, 프로세스 취급을 하는 것이다) 이 말은 즉, 스레드도 프로세스처럼 작업을 병렬로 처리해서 속도를 높일 수 있다는 것이다.
3. 스레드는 일종의 함수로 구현된다. 스레드도 함수라서 데이터(지역 변수)를 다루고, 데이터를 관리하기 위해 stack 메모리 영역을 가진다. 이 stack 공간은 프로세스가 가지는 stack 메모리 영역과는 별개이며, 스레드의 메모리 영역으 thread stack이라고 부른다.
4. 하나의 프로세스는 내부에 여러개의 스레드를 가질 수 있다.

![스레드의 구조.png](..%2F..%2F..%2Fetc%2Fimage%2FOS_IMAGE%2F%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98%20%EA%B5%AC%EC%A1%B0.png) 

- 해당 그림과 같이 프로그램 카운터(PC)와 스택 포인터(SP) 등을 비롯한 스레드 실행 환경 정보(문맥 정보), 지역 데이터, 스택을 독립적으로 가지면서 코드,
전역 데이터, 힙을 다른 스레드와 공유한다.
- 스레드는 보통 다른 프로시저를 호출하고 다른 실행을 기록한다.

![스레드의 주소 공간.png](..%2F..%2F..%2Fetc%2Fimage%2FOS_IMAGE%2F%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98%20%EC%A3%BC%EC%86%8C%20%EA%B3%B5%EA%B0%84.png) 

- 같은 프로세스의 스레드들은 해당 그림과 같이 동일한 주소 공간을 공유한다.
- 프로세스 하나에 포함된 스레드들은 공동의 목적을 달성하려고 병렬로 수행한다. 즉, 프로세스가 하나인 서로 다른 프로세스에서 프로그램의 다른 부분을 동시에 실행할 수 있다.

1. **응답성 향상**
   - 단일 스레드 프로그램에서는 긴 작업이 완료될 때까지 다른 작업을 수행할 수 없다.
   - 멀티스레드 프로그램에서는 하나의 스레드가 긴 작업을 수행하는 동안 다른 스레드가 사용자 인터페이스를 처리할 수 있다.
   - 예: 웹 브라우저에서 다운로드 중에도 다른 페이지를 탐색할 수 있는 것

2. **자원 공유 효율성**
   - 프로세스 간 통신(IPC)이 필요 없이 동일한 프로세스 내 스레드들이 자원을 공유할 수 있다.
   - 공유 메모리나 메시지 전달과 같은 IPC 기법을 사용하지 않아도 된다.
   - 코드, 데이터, 힙 영역을 공유하므로 메모리 사용량이 효율적이다.

3. **경제성**
   - 프로세스 생성보다 스레드 생성이 더 빠르고 자원을 적게 사용한다.
   - 문맥 전환 시 프로세스 간 전환보다 스레드 간 전환이 더 빠르다.
   - 스레드 생성 시간은 프로세스 생성 시간의 약 1/10 수준이다.

4. **멀티프로세서 활용**
   - 여러 개의 CPU 코어를 효과적으로 활용할 수 있다.
   - 각 스레드를 다른 CPU 코어에서 병렬로 실행하여 성능을 향상시킬 수 있다.
   - 데이터 처리나 계산 집약적인 작업에서 특히 효과적이다.

1. **동기화 문제**
   - 여러 스레드가 공유 자원에 동시에 접근할 때 발생하는 경쟁 상태(Race Condition)
   - 교착 상태(Deadlock) 발생 가능성
   - 상호 배제(Mutual Exclusion)를 위한 락(Lock) 메커니즘 필요
   - 동기화 오버헤드로 인한 성능 저하

2. **디버깅의 어려움**
   - 스레드 간의 상호작용이 복잡하여 버그 발생 시 원인 파악이 어렵다.
   - 비결정적(Non-deterministic) 실행 순서로 인해 재현이 어려운 버그가 발생할 수 있다.
   - 동시성 관련 버그는 발견하기 어렵고 수정이 복잡하다.

3. **자원 관리의 복잡성**
   - 스레드 수가 증가할수록 메모리 사용량이 선형적으로 증가한다.
   - 각 스레드는 독립적인 스택 공간을 필요로 한다.
   - 스레드 풀(Thread Pool) 관리가 필요할 수 있다.

4. **안정성 문제**
   - 하나의 스레드가 비정상 종료되면 전체 프로세스가 종료될 수 있다.
   - 메모리 누수나 자원 해제 실패가 전체 프로세스에 영향을 미칠 수 있다.
   - 예외 처리가 복잡해질 수 있다.










