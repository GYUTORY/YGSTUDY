---
title: 스레드의 개념
tags: [os, process-and-thread, thread, 스레드의-개념]
updated: 2025-12-08
---

## 스레드 개요

스레드는 프로세스 내부에서 실행되는 가장 작은 실행 단위로, 병렬 처리와 동시성을 구현하는 메커니즘이다. 하나의 프로세스 안에서 여러 개의 실행 흐름을 동시에 처리할 수 있게 해주며, 시스템의 성능과 응답성을 향상시킨다.

**실무 팁:**
스레드는 프로세스보다 가볍다. 같은 프로세스 내의 스레드들은 메모리 공간을 공유한다.

<div align="center">
    <img src="../../../../etc/image/OS_IMAGE/스레드의 구조.png" alt="스레드의 구조.png" width="30%">
</div>

### 스레드의 기본 특성

스레드는 프로세스와 비교했을 때 다음과 같은 특성을 가진다:

- 경량성: 프로세스보다 생성과 관리가 빠르며 자원을 적게 사용한다
- 공유성: 같은 프로세스 내의 스레드들은 메모리 공간을 공유한다
- 독립성: 각 스레드는 독립적인 실행 컨텍스트를 유지한다
- 동시성: 여러 스레드가 동시에 실행되어 병렬 처리를 가능하게 한다

---

## 스레드의 정의와 특징

### 개념과 역할

스레드는 프로세스 내부에서 실행되는 경량화된 실행 단위다. 하나의 프로그램(프로세스) 안에서 동시에 여러 작업을 수행할 수 있게 해주는 실행 흐름이다.

**실무 팁:**
스레드는 프로세스보다 생성과 관리가 빠르다. 같은 프로세스 내의 스레드들은 메모리 공간을 공유한다.

### 프로세스와 스레드의 관계

**프로세스의 구성 요소**
- 프로세스는 독립적인 메모리 공간을 가진 프로그램의 실행 단위다
- 하나의 프로세스는 최소 하나의 스레드를 가지며, 이를 메인 스레드라고 부른다
- 프로세스는 코드, 데이터, 힙, 스택 영역을 포함한 완전한 메모리 공간을 가진다

**스레드의 특성**
- 스레드는 프로세스 내부에서 실행되는 경량화된 실행 단위다
- 프로세스의 메모리 공간을 공유하면서 자신만의 실행 컨텍스트를 유지한다
- 프로세스보다 생성과 종료가 빠르며, 문맥 전환 비용이 적다

### 스레드의 주요 특징

**1. 자원 공유의 효율성**
프로세스들은 서로의 데이터에 직접 접근할 수 없어서 IPC(Inter-Process Communication)라는 복잡한 통신 방식을 사용해야 합니다. 하지만 스레드는 같은 프로세스 내부에 존재하기 때문에 프로세스의 데이터 영역에 자유롭게 접근할 수 있습니다.

스레드들끼리도 서로의 데이터에 접근이 가능하며, 별도의 통신 메커니즘 없이도 데이터를 공유할 수 있다.

**실무 팁:**
스레드 간 데이터 공유는 동기화가 필요하다. 공유 자원에 동시 접근하면 레이스 컨디션이 발생할 수 있다.

**2. 경량화된 작업 단위**
리눅스에서는 스레드를 Light Weight Process라고 부르는데, 이는 스레드도 프로세스처럼 작업을 처리한다는 의미입니다. 스레드는 프로세스처럼 병렬로 작업을 처리하여 전체적인 성능을 향상시킬 수 있습니다.

다만 프로세스보다 훨씬 가볍고 빠르게 생성되고 관리된다. 일반적으로 스레드 생성 시간은 프로세스 생성 시간의 약 1/10 수준이다.

**실무 팁:**
스레드 생성은 프로세스 생성보다 빠르다. 하지만 스레드 수가 많아지면 컨텍스트 스위칭 비용이 증가한다.

**3. 독립적인 실행 환경**
스레드는 함수처럼 구현되며, 각자 고유한 지역 변수와 스택 메모리 영역을 가집니다. 이 스택 공간은 프로세스의 메인 스택과는 별개이며, 스레드 스택이라고 부릅니다.

각 스레드는 자신만의 실행 컨텍스트를 유지하면서 독립적으로 실행됩니다. 이는 각 스레드가 독립적인 프로그램 카운터, 레지스터 상태, 스택 포인터를 가진다는 의미입니다.

**4. 다중 스레드 지원**
하나의 프로세스는 내부에 여러 개의 스레드를 가질 수 있습니다. 이를 통해 복잡한 작업을 여러 개의 작은 작업으로 나누어 동시에 처리할 수 있습니다.

---

## 스레드의 메모리 구조

### 독립적으로 가지는 자원들

스레드는 프로세스의 메모리 공간을 공유하면서도 자신만의 독립적인 실행 환경을 유지합니다.

**프로그램 카운터(PC)**
- 현재 실행 중인 명령어의 위치를 추적한다
- 각 스레드마다 독립적인 실행 위치를 가진다
- 스레드가 다른 함수를 호출하거나 다른 코드 경로를 따라갈 때 독립적으로 변경된다

**스택 포인터(SP)**
- 스택의 최상단 위치를 가리킨다
- 각 스레드는 자신만의 스택 공간을 가진다
- 함수 호출과 지역 변수 관리를 위해 필수적이다

**레지스터 상태**
- CPU 레지스터의 현재 상태를 저장한다
- 스레드 전환 시 이전 상태를 복원하기 위해 필요하다
- 각 스레드마다 독립적인 레지스터 상태를 유지한다

**지역 데이터**
- 함수 내에서 선언된 지역 변수들이다
- 각 스레드의 스택에 저장된다
- 다른 스레드와 공유되지 않는 독립적인 데이터다

**스택 공간**
- 함수 호출 정보와 지역 변수를 저장하는 공간이다
- 각 스레드마다 독립적으로 할당된다
- 스레드 스택이라고 부르며, 프로세스의 메인 스택과는 별개다

**실무 팁:**
각 스레드는 독립적인 스택을 가진다. 스레드 간 통신은 공유 메모리를 통해 이루어진다.

### 공유하는 자원들

같은 프로세스 내의 모든 스레드들은 다음 자원들을 공유합니다.

**코드 영역**
- 실행할 프로그램 코드가 저장된 영역이다
- 모든 스레드가 동일한 코드를 실행한다
- 읽기 전용이므로 안전하게 공유할 수 있다

**전역 데이터**
- 프로그램의 전역 변수들이 저장된 영역이다
- 모든 스레드가 접근할 수 있다
- 동기화가 필요한 공유 자원이다

**힙 영역**
- 동적으로 할당되는 메모리 영역이다
- 모든 스레드가 공유하여 사용한다
- 메모리 관리와 동기화가 중요한 영역이다

**실무 팁:**
같은 프로세스 내의 스레드들은 코드, 데이터, 힙 영역을 공유한다. 공유 자원 접근 시 동기화가 필요하다.

<div align="center">
    <img src="../../../../etc/image/OS_IMAGE/스레드의 주소 공간.png" alt="스레드의 주소 공간.png" width="30%">
</div>

같은 프로세스 내의 모든 스레드들은 동일한 주소 공간을 공유한다. 이는 스레드들이 서로의 데이터에 쉽게 접근할 수 있게 해주지만, 동시에 동기화 문제를 야기할 수도 있다.

**실무 팁:**
스레드 간 데이터 공유는 동기화가 필요하다. 뮤텍스, 세마포어 등을 사용하여 공유 자원 접근을 제어한다.

---

## 멀티스레딩의 장점

### 사용자 경험의 향상

**반응성 개선**
단일 스레드 프로그램에서는 하나의 작업이 끝날 때까지 다른 작업을 할 수 없습니다. 하지만 멀티스레드 프로그램에서는 긴 작업을 백그라운드에서 처리하면서 동시에 사용자 인터페이스를 반응적으로 유지할 수 있습니다.

**실생활 예시**
웹 브라우저를 예로 들 수 있다. 파일을 다운로드하는 동안에도 다른 웹페이지를 탐색할 수 있는 것이 바로 멀티스레딩 덕분이다. 만약 단일 스레드로 구현되었다면, 다운로드가 완료될 때까지 브라우저가 완전히 멈춰있을 것이다.

**실무 팁:**
멀티스레딩은 응답성을 향상시킨다. 긴 작업을 백그라운드 스레드에서 처리하면 UI가 블로킹되지 않는다.

### 자원 공유의 편리함

**자연스러운 데이터 공유**
프로세스들 사이에서는 데이터를 공유하기 위해 복잡한 통신 메커니즘(IPC)을 사용해야 합니다. 하지만 같은 프로세스 내의 스레드들은 자연스럽게 메모리 공간을 공유하므로, 별도의 통신 과정 없이도 데이터를 주고받을 수 있습니다.

**통신 오버헤드 감소**
IPC를 사용할 때 발생하는 오버헤드가 없다. 공유 메모리나 메시지 전달과 같은 복잡한 기법을 사용하지 않아도 되므로, 성능상 이점이 있다.

**실무 팁:**
스레드 간 통신은 공유 메모리를 통해 이루어진다. IPC보다 빠르지만 동기화가 필요하다.

### 효율적인 자원 사용

**빠른 생성과 관리**
스레드 생성은 프로세스 생성보다 훨씬 빠르고 가볍다. 일반적으로 스레드 생성 시간은 프로세스 생성 시간의 약 1/10 수준이다. 또한 스레드 간의 문맥 전환도 프로세스 간 전환보다 훨씬 빠르다.

**메모리 효율성**
코드, 데이터, 힙 영역을 공유하므로 메모리 사용량이 효율적이다. 동일한 프로그램을 실행하는 여러 프로세스를 만드는 것보다 훨씬 적은 메모리를 사용한다.

**실무 팁:**
스레드 풀을 사용하면 스레드 생성 비용을 줄일 수 있다. 미리 생성된 스레드를 재사용하여 성능을 향상시킨다.

### 멀티코어 시스템의 활용

**병렬 처리 능력**
현대의 컴퓨터는 여러 개의 CPU 코어를 가지고 있습니다. 멀티스레딩을 통해 각 스레드를 다른 코어에서 동시에 실행함으로써 전체적인 성능을 크게 향상시킬 수 있습니다.

**특화된 작업 처리**
특히 대용량 데이터 처리나 복잡한 계산 작업에서 그 효과가 두드러집니다. 각 코어가 독립적인 작업을 처리하면서 전체 작업 시간을 단축할 수 있습니다.

---

## 멀티스레딩의 단점과 주의사항

### 동기화의 복잡성

**경쟁 상태(Race Condition)**
여러 스레드가 같은 데이터에 동시에 접근할 때 발생하는 문제다. 마치 여러 사람이 동시에 같은 문서를 수정하려고 할 때 발생하는 혼란과 같다.

**교착 상태(Deadlock)**
락(Lock) 메커니즘을 사용하여 동기화 문제를 해결하려고 할 때 발생할 수 있는 문제다. 교착 상태는 두 스레드가 서로의 자원을 기다리며 무한정 대기하는 상황이다.

**동기화 오버헤드**
상호 배제를 위한 락 메커니즘이 성능 저하를 야기할 수 있다. 과도한 락 사용은 오히려 성능을 저하시킬 수 있다.

**실무 팁:**
레이스 컨디션을 방지하기 위해 뮤텍스나 세마포어를 사용한다. 락 순서를 일관되게 유지하여 데드락을 방지한다.

### 디버깅의 어려움

**비결정적 실행**
멀티스레드 프로그램의 가장 큰 어려움 중 하나는 디버깅이다. 스레드들이 언제 실행될지, 어떤 순서로 실행될지 예측하기 어렵기 때문이다.

**재현 어려운 버그**
같은 프로그램을 여러 번 실행해도 매번 다른 결과가 나올 수 있어서, 버그를 재현하고 원인을 찾는 것이 어렵다. 이는 여러 명이 동시에 작업하는 프로젝트에서 누가 어떤 실수를 했는지 찾기 어려운 것과 같다.

**동시성 관련 버그**
동시성 관련 버그는 발견하기 어렵고 수정이 복잡하다. 스레드 간의 상호작용이 복잡하여 버그 발생 시 원인 파악이 어렵다.

**실무 팁:**
멀티스레드 프로그램은 디버깅이 어렵다. 스레드 안전한 자료구조를 사용하고, 정적 분석 도구를 활용한다.

### 자원 관리의 부담

**메모리 사용량 증가**
스레드가 많아질수록 메모리 사용량도 증가한다. 각 스레드는 독립적인 스택 공간을 필요로 하기 때문이다.

**스레드 풀 관리**
스레드의 생성과 소멸을 효율적으로 관리하기 위해 스레드 풀(Thread Pool) 같은 기법을 사용해야 하는데, 이는 프로그램의 복잡성을 증가시킨다.

**컨텍스트 스위칭 비용**
스레드 수가 많아질수록 컨텍스트 스위칭 비용도 증가한다. 적절한 스레드 수를 유지하는 것이 중요하다.

**실무 팁:**
스레드 수는 CPU 코어 수의 2-3배가 적절하다. 스레드 풀을 사용하여 스레드 생명주기를 관리한다.

### 안정성의 취약점

**프로세스 전체 영향**
하나의 스레드에서 심각한 오류가 발생하면 전체 프로세스가 종료될 수 있다. 이는 한 팀원의 실수가 전체 프로젝트를 망칠 수 있는 것과 같다.

**메모리 누수 위험**
메모리 누수나 자원 해제 실패 같은 문제가 발생하면, 이는 프로세스 전체에 영향을 미칠 수 있어서 시스템의 안정성을 해칠 수 있다.

**예외 처리 복잡성**
멀티스레드 환경에서는 예외 처리가 복잡해진다. 한 스레드의 예외가 다른 스레드에 영향을 미칠 수 있다.

**실무 팁:**
스레드에서 발생한 예외는 프로세스 전체에 영향을 준다. 예외 처리를 철저히 하고, 스레드 안전한 코드를 작성한다.

---

## 스레드와 프로세스의 비교

### 생성 및 관리 비용

**스레드의 장점**
- 생성 시간: 프로세스 생성 시간의 약 1/10
- 메모리 사용량: 프로세스보다 훨씬 적음
- 문맥 전환: 빠르고 효율적

**프로세스의 장점**
- 독립성: 한 프로세스의 오류가 다른 프로세스에 영향 없음
- 보안: 프로세스 간 메모리 보호
- 안정성: 프로세스 격리로 인한 높은 안정성

### 통신 및 동기화

**스레드 통신**
- 자연스러운 메모리 공유
- 빠른 데이터 접근
- 동기화 메커니즘 필요

**프로세스 통신**
- IPC 메커니즘 필요 (파이프, 소켓, 공유 메모리 등)
- 느린 통신 속도
- 복잡한 동기화

### 성능 및 확장성

**멀티스레딩**
- 멀티코어 활용에 유리
- 빠른 응답성
- 복잡한 동기화 관리 필요

**멀티프로세싱**
- 높은 안정성과 격리
- 확장성 제한
- 높은 자원 사용량

---

## 요약
스레드는 현대 컴퓨팅에서 필수적인 개념이다. 프로세스보다 가볍고 빠르면서도 병렬 처리를 가능하게 해주는 스레드는 성능 향상과 사용자 경험 개선에 역할을 한다.

멀티스레딩은 올바르게 사용하면 이익을 가져다주지만, 잘못 사용하면 복잡한 문제들을 야기할 수 있다. 따라서 스레드를 사용할 때는 동기화, 자원 관리, 안정성 등을 충분히 고려해야 한다.

**실무 팁:**
스레드는 프로세스보다 가볍고 빠르다. 하지만 동기화 문제가 발생할 수 있으므로 주의가 필요하다. 스레드 풀을 사용하여 스레드 생명주기를 관리한다.

---

## 참조

- Abraham Silberschatz, Peter Baer Galvin, Greg Gagne. "Operating System Concepts" 10th Edition
- Andrew S. Tanenbaum, Herbert Bos. "Modern Operating Systems" 4th Edition  
- Linux Kernel Documentation - Threading
- POSIX Threads Programming Guide
- https://inpa.tistory.com/entry/👩‍💻-프로세스-⚔️-쓰레드-차이 [Inpa Dev 👨‍💻:티스토리]