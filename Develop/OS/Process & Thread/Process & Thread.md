---
title: Process & Thread
tags: [os, process-and-thread]
updated: 2025-09-22
---

## 개요

운영체제에서 프로세스와 스레드는 프로그램 실행의 핵심 개념입니다. 이 문서에서는 프로그램, 프로세스, 스레드의 정의와 특징, 그리고 이들 간의 관계를 자세히 살펴보겠습니다.

<div align="center">
    <img src="../../../etc/image/OS/Process & Thread.png" alt="Process & Thread Image" width="50%">
</div>

---

## 프로그램 (Program)

### 프로그램의 정의
프로그램은 실행 가능한 명령어들의 집합으로, 디스크에 저장된 정적인(static) 파일입니다. 소스 코드가 컴파일되어 생성된 실행 파일(exe, bin 등)을 의미하며, 실행되기 전까지는 단순히 디스크에 저장된 데이터에 불과합니다.

### 프로그램의 구성 요소
1. **코드 영역**: 실행할 명령어들이 저장된 영역
2. **데이터 영역**: 전역 변수, 정적 변수가 저장된 영역  
3. **리소스 영역**: 프로그램이 사용하는 이미지, 사운드 등의 리소스

### 프로그램의 특징
- **정적성**: 프로그램 자체는 실행되지 않는 상태의 코드와 데이터
- **재사용성**: 하나의 프로그램으로 여러 프로세스를 생성할 수 있음
- **저장성**: 디스크에 영구적으로 저장되어 반복 실행 가능

---

## 프로세스 (Process)

### 프로세스의 정의
프로세스는 실행 중인 프로그램의 인스턴스(instance)를 말합니다. 프로그램이 실행되면 운영체제는 다음과 같은 작업을 수행합니다:

1. 프로그램 코드를 메모리에 로드
2. 필요한 시스템 자원(CPU, 메모리, 파일 등)을 할당
3. 프로세스 제어 블록(PCB) 생성
4. 실행 상태로 전환

### 프로세스의 핵심 특징

#### 1. 독립성 (Isolation)
- **메모리 독립성**: 각 프로세스는 독립된 메모리 공간을 가짐
- **보안성**: 다른 프로세스의 메모리 공간에 직접 접근 불가
- **안정성**: 한 프로세스의 오류가 다른 프로세스에 직접적인 영향을 주지 않음
- **통신 방식**: 프로세스 간 통신은 IPC(Inter-Process Communication)를 통해 이루어짐

#### 2. 자원 할당 (Resource Allocation)
- **시스템 자원**: 운영체제로부터 CPU 시간, 메모리, I/O 장치 등을 할당받음
- **고유 식별자**: 각 프로세스는 고유한 PID(Process ID)를 가짐
- **자원 관리**: 프로세스는 필요한 시스템 자원을 요청하고 해제할 수 있음
- **스케줄링**: 자원 할당은 운영체제의 스케줄러가 관리

#### 3. 상태 관리 (State Management)
프로세스는 다음과 같은 상태를 가집니다:

- **생성(New)**: 프로세스가 생성되는 상태
- **준비(Ready)**: CPU를 할당받기 위해 대기하는 상태
- **실행(Running)**: CPU를 할당받아 명령을 실행하는 상태
- **대기(Waiting)**: I/O 작업 등으로 인해 대기하는 상태
- **종료(Terminated)**: 프로세스가 종료되는 상태

#### 4. 프로세스 제어 블록(PCB)
프로세스의 상태 정보를 저장하는 자료구조로, 다음 정보를 포함합니다:
- 프로세스 식별자(PID)
- 프로그램 카운터(PC)
- 레지스터 상태
- 메모리 관리 정보
- 스케줄링 정보
- I/O 상태 정보

<div align="center">
    <img src="../../../etc/image/OS/Process1.png" alt="Process1" width="50%">
</div>

### 프로그램과 프로세스의 차이점

| 구분 | 프로그램 | 프로세스 |
|------|----------|----------|
| **성격** | 정적인 코드와 데이터의 집합 | 실행 중인 프로그램의 동적인 인스턴스 |
| **저장 위치** | 디스크에 저장 | 메모리에 상주 |
| **생성** | 컴파일 시 생성 | 실행 시 생성 |
| **개수** | 하나의 프로그램으로 여러 프로세스 생성 가능 | 프로그램의 실행 인스턴스 |
| **자원** | 자원 없음 | 실행에 필요한 모든 자원 포함 |

<div align="center">
    <img src="../../../etc/image/OS/프로그램과 프로세스의 차이.png" alt="Process vs Program" width="50%">
</div>

---

## 스레드 (Thread)

### 스레드의 등장 배경

#### 1. 프로세스 모델의 한계
- **단일 실행 흐름**: 전통적인 프로세스 모델은 하나의 프로세스가 하나의 실행 흐름만 가질 수 있었음
- **멀티태스킹 요구**: 현대 애플리케이션의 복잡성 증가로 인한 동시 처리 필요성
- **오버헤드 문제**: 프로세스 생성과 컨텍스트 스위칭의 높은 비용
- **통신 복잡성**: 프로세스 간 통신의 복잡성과 비용

#### 2. 스레드의 필요성
- **경량 실행 단위**: 프로세스보다 가벼운 실행 단위 필요
- **빠른 전환**: 빠른 컨텍스트 스위칭 요구
- **동시 처리**: 프로세스 내에서 여러 작업의 동시 처리
- **효율성**: 시스템 자원의 효율적 활용

### 스레드의 개념
스레드는 프로세스 내의 실행 단위로, 다음과 같은 특징을 가집니다:
- 하나의 프로세스는 여러 개의 스레드를 가질 수 있음
- 스레드는 프로세스의 코드, 데이터, 힙 영역을 공유
- 각 스레드는 독립적인 스택 영역을 가짐

### 스레드의 핵심 특징

#### 1. 공유 자원 (Shared Resources)
- **메모리 공유**: 같은 프로세스의 스레드들은 메모리 공간을 공유
- **통신 효율성**: 코드, 데이터, 힙 영역을 공유하여 통신이 용이
- **독립적 스택**: 스택 영역만 독립적으로 가짐
- **동기화 필요**: 공유 자원 접근 시 동기화가 필요

#### 2. 경량 프로세스 (Lightweight Process)
- **빠른 생성**: 스레드 생성과 스위칭이 프로세스보다 빠름
- **적은 자원**: 시스템 자원을 적게 사용
- **효율적 전환**: 컨텍스트 스위칭이 빠름
- **효율적 통신**: 스레드 간 통신이 효율적

#### 3. 동시성 (Concurrency)
- **병렬 실행**: 여러 스레드가 동시에 실행 가능
- **멀티코어 활용**: 멀티코어 시스템에서 병렬 처리 가능
- **성능 향상**: 응답성과 처리량이 향상
- **작업 분할**: 작업 분할이 용이

<div align="center">
    <img src="../../../etc/image/OS/쓰레드.png" alt="Thread Structure" width="75%">
</div>

### 멀티스레딩의 장단점

#### 장점
1. **응답성 향상**: 사용자 인터페이스가 블로킹되지 않음
2. **자원 공유**: 프로세스 간 통신보다 효율적
3. **경제성**: 프로세스 생성보다 스레드 생성이 효율적
4. **병렬성**: 멀티코어 시스템에서 성능 향상
5. **자원 활용**: 시스템 자원을 효율적으로 사용

#### 단점
1. **동기화 문제**: 공유 자원 접근 시 주의 필요
2. **디버깅 어려움**: 실행 순서가 불확실함
3. **교착 상태**: 잘못된 동기화로 인한 교착 상태 발생 가능
4. **스레드 안전성**: 공유 자원 접근 시 동기화 필요
5. **복잡성**: 멀티스레드 프로그래밍의 복잡성 증가

### 스레드 구현 방식

#### 1. 사용자 수준 스레드 (User-Level Thread)
- **구현 위치**: 커널의 지원 없이 사용자 수준에서 구현
- **장점**: 빠른 스위칭이 가능
- **단점**: 커널이 스레드의 존재를 모름
- **예시**: Java의 Green Thread

#### 2. 커널 수준 스레드 (Kernel-Level Thread)
- **구현 위치**: 운영체제 커널이 직접 지원
- **장점**: 멀티프로세서에서 병렬 실행 가능
- **단점**: 스위칭이 상대적으로 느림
- **예시**: Windows의 스레드

#### 3. 혼합형 스레드 (Hybrid Thread)
- **구현 방식**: 사용자 수준과 커널 수준 스레드의 혼합
- **장점**: 유연한 스레드 관리 가능
- **단점**: 복잡한 구현이 필요
- **예시**: Solaris의 스레드

### 스레드 동기화

#### 1. 동기화의 필요성
- **일관성 유지**: 공유 자원의 일관성 유지
- **경쟁 상태 방지**: Race Condition 방지
- **교착 상태 방지**: Deadlock 방지

#### 2. 동기화 메커니즘
- **뮤텍스(Mutex)**: 상호 배제를 위한 기본 동기화 도구
- **세마포어(Semaphore)**: 리소스 접근 제어
- **모니터(Monitor)**: 고수준 동기화 구조
- **조건 변수(Condition Variable)**: 스레드 간 신호 전달

#### 3. 동기화 문제 해결 원칙
- **상호 배제(Mutual Exclusion)**: 한 번에 하나의 스레드만 공유 자원에 접근
- **진행(Progress)**: 공유 자원을 사용하지 않는 스레드는 다른 스레드의 진행을 방해하지 않음
- **제한된 대기(Bounded Waiting)**: 스레드가 무한정 대기하지 않도록 보장

<div align="center">
    <img src="../../../etc/image/OS/Thread의 흐름.png" alt="Thread Flow" width="50%">
</div>

---

## 프로세스와 스레드의 관계

### 핵심 관계
1. **프로세스는 자원의 집합체**: 프로세스는 메모리, 파일, 네트워크 연결 등의 자원을 관리
2. **스레드는 실행의 단위**: 스레드는 실제 작업을 수행하는 실행 흐름
3. **필수 관계**: 프로세스는 최소 하나의 스레드를 가져야 함
4. **계층 구조**: 스레드는 프로세스의 하위 실행 단위

### 메모리 구조 비교

| 구분 | 프로세스 | 스레드 |
|------|----------|--------|
| **코드 영역** | 독립적 | 공유 |
| **데이터 영역** | 독립적 | 공유 |
| **힙 영역** | 독립적 | 공유 |
| **스택 영역** | 독립적 | 독립적 |
| **PCB/TCB** | PCB | TCB |

---

## 현대 프로그래밍에서의 활용

### 1. 웹 서버
- **동시 요청 처리**: 여러 클라이언트의 요청을 동시에 처리
- **스레드 풀**: 미리 생성된 스레드 풀을 사용하여 성능 최적화
- **비동기 처리**: I/O 작업을 비동기로 처리하여 응답성 향상

### 2. GUI 애플리케이션
- **UI 응답성**: 사용자 인터페이스가 블로킹되지 않도록 백그라운드 작업 처리
- **이벤트 처리**: 사용자 입력과 백그라운드 작업의 분리
- **멀티태스킹**: 여러 작업을 동시에 수행

### 3. 데이터 처리
- **병렬 처리**: 대용량 데이터의 병렬 처리로 성능 향상
- **파이프라인**: 데이터 처리 파이프라인의 각 단계를 병렬로 처리
- **배치 처리**: 여러 작업을 동시에 처리하여 전체 처리 시간 단축

### 4. 게임 개발
- **물리 엔진**: 물리 계산을 별도 스레드에서 처리
- **AI 처리**: 게임 AI의 계산을 병렬로 처리
- **렌더링**: 그래픽 렌더링과 게임 로직의 분리

### 5. 데이터베이스
- **동시 트랜잭션**: 여러 트랜잭션을 동시에 처리
- **쿼리 최적화**: 복잡한 쿼리를 병렬로 처리
- **연결 풀**: 데이터베이스 연결을 효율적으로 관리

---

## 성능 최적화 고려사항

### 1. 스레드 수 최적화
- **CPU 코어 수**: CPU 코어 수에 맞는 스레드 수 설정
- **I/O 집약적 작업**: I/O 대기 시간을 고려한 스레드 수 조정
- **메모리 사용량**: 스레드당 메모리 사용량 고려

### 2. 동기화 오버헤드 최소화
- **락 경합 감소**: 불필요한 락 사용 최소화
- **원자적 연산**: 단순한 연산은 원자적 연산 사용
- **락프리 자료구조**: 가능한 경우 락프리 자료구조 사용

### 3. 캐시 친화적 설계
- **데이터 지역성**: 관련 데이터를 함께 배치
- **캐시 라인 고려**: 캐시 라인 크기를 고려한 데이터 배치
- **False Sharing 방지**: 서로 다른 스레드가 같은 캐시 라인을 수정하지 않도록 주의

### 4. 스레드 풀 관리
- **풀 크기 조정**: 작업 부하에 따른 동적 풀 크기 조정
- **작업 큐 관리**: 효율적인 작업 큐 구현
- **부하 분산**: 작업을 스레드에 균등하게 분산

---

## 결론

프로세스와 스레드는 현대 컴퓨팅의 핵심 개념으로, 프로그램의 실행과 시스템 자원의 효율적 활용을 가능하게 합니다. 프로세스는 자원의 독립성과 안정성을 제공하고, 스레드는 동시성과 성능 향상을 제공합니다. 

멀티스레드 프로그래밍에서는 동기화 문제와 성능 최적화를 고려해야 하며, 적절한 설계와 구현을 통해 시스템의 성능과 안정성을 확보할 수 있습니다. 현대의 복잡한 애플리케이션에서는 프로세스와 스레드를 적절히 조합하여 사용하는 것이 중요합니다.

---

## 참조 문헌

1. Abraham Silberschatz, Peter Baer Galvin, Greg Gagne. "Operating System Concepts" (10th Edition). John Wiley & Sons, 2018.

2. Andrew S. Tanenbaum, Herbert Bos. "Modern Operating Systems" (4th Edition). Pearson, 2014.

3. William Stallings. "Operating Systems: Internals and Design Principles" (9th Edition). Pearson, 2017.

4. Inpa Dev. "프로세스 ⚔️ 쓰레드 차이". https://inpa.tistory.com/entry/👩‍💻-프로세스-⚔️-쓰레드-차이

5. GeeksforGeeks. "Process vs Thread". https://www.geeksforgeeks.org/process-vs-thread/

6. TutorialsPoint. "Operating System - Processes". https://www.tutorialspoint.com/operating_system/os_processes.htm

7. IBM Developer. "Multithreading in Java". https://developer.ibm.com/technologies/java/tutorials/j-threads/

8. Microsoft Docs. "Processes and Threads". https://docs.microsoft.com/en-us/windows/win32/procthread/processes-and-threads
