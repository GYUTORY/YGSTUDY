---
title: 프로세스의 자원 구조
tags: [os, process-and-thread, process, 프로세스의-자원-구조]
updated: 2025-09-21
---

## 프로세스 메모리 구조 개요

프로세스가 실행되면 운영체제는 메모리 공간을 논리적으로 분할하여 각각의 목적에 맞게 사용할 수 있도록 합니다. 이렇게 분할된 메모리 영역들은 서로 다른 특성과 역할을 가지며, 프로그램의 효율적인 실행을 위해 체계적으로 관리됩니다.

<div align="center">
    <img src="../../../../etc/image/OS/프로세스의 자원 구조.png" alt="프로세스의 자원 구조.png" width="30%">
</div>

### 메모리 영역의 기본 특성

프로세스의 메모리 구조는 크게 **고정 영역**과 **가변 영역**으로 나뉩니다:

- **고정 영역**: 코드 영역과 데이터 영역은 프로그램 시작 시 크기가 결정되어 실행 중 변경되지 않습니다
- **가변 영역**: 스택과 힙은 프로그램 실행 중 동적으로 크기가 변하며, 서로 반대 방향으로 성장합니다
- **메모리 보호**: 각 영역은 독립적인 접근 권한을 가지며, 서로의 영역을 침범하면 메모리 오류가 발생합니다

---

## 1. 코드 영역 (Code / Text Segment)

### 개념과 역할

코드 영역은 프로그램의 실행 가능한 명령어들이 저장되는 메모리 영역입니다. 이 영역에는 컴파일러가 생성한 기계어 코드가 저장되며, CPU가 직접 실행할 수 있는 형태로 구성되어 있습니다.

### 주요 특징

**읽기 전용 특성**
- 프로그램 실행 중 내용이 변경되지 않는 읽기 전용(Read-Only) 영역입니다
- 이는 프로그램의 안정성을 보장하고, 여러 프로세스가 동일한 프로그램을 실행할 때 메모리를 효율적으로 사용할 수 있게 합니다

**고정 크기**
- 프로그램 시작 시 크기가 결정되며, 실행 중에는 크기 변경이 불가능합니다
- 컴파일 시점에 모든 함수와 제어문의 크기가 계산되어 할당됩니다

**공유 가능성**
- 동일한 프로그램을 실행하는 여러 프로세스는 코드 영역을 공유할 수 있습니다
- 이는 물리적 메모리 사용량을 크게 줄여주는 중요한 최적화 기법입니다

### 저장되는 내용

- 함수의 실행 코드
- 제어문(if, for, while 등)의 기계어
- 연산자와 표현식의 처리 코드
- 상수 처리 로직

---

## 2. 데이터 영역 (Data Segment)

### 개념과 역할

데이터 영역은 프로그램의 전역 변수와 정적 변수가 저장되는 영역으로, 프로그램의 생명주기 동안 유지되는 데이터를 관리합니다. 이 영역은 다시 세 개의 하위 섹션으로 나뉩니다.

### .data 섹션 (초기화된 데이터)

**특징**
- 초기값이 설정된 전역 변수와 정적 변수가 저장됩니다
- 프로그램 시작 시 이미 값이 할당되어 있어 즉시 사용 가능합니다
- 읽기/쓰기가 모두 가능한 영역입니다

**저장되는 데이터**
- 초기화된 전역 변수
- 초기화된 정적 변수
- 초기화된 정적 지역 변수

### .bss 섹션 (초기화되지 않은 데이터)

**특징**
- Block Started by Symbol의 줄임말로, 초기화되지 않은 전역 변수와 정적 변수를 위한 영역입니다
- 실제 데이터는 저장하지 않고 크기만 예약합니다
- 프로그램 시작 시 자동으로 0으로 초기화됩니다

**메모리 효율성**
- 초기화되지 않은 변수들은 실제로는 모두 0값을 가지므로, 물리적 메모리에 0을 저장할 필요가 없습니다
- 대신 크기 정보만 저장하여 메모리를 절약합니다

### .rodata 섹션 (읽기 전용 데이터)

**특징**
- 상수 데이터가 저장되는 읽기 전용 영역입니다
- 프로그램 실행 중 변경이 불가능합니다
- 코드 영역과 유사한 보호 특성을 가집니다

**저장되는 데이터**
- const로 선언된 변수
- 문자열 리터럴
- 상수 배열
- 열거형(enum) 값들

---

## 3. 스택 영역 (Stack Segment)

### 개념과 역할

스택 영역은 함수 호출과 관련된 임시 데이터를 저장하는 메모리 영역입니다. 함수가 호출될 때마다 스택 프레임이 생성되고, 함수가 종료되면 해당 프레임이 자동으로 해제되는 구조로 동작합니다.

### LIFO 구조의 동작 원리

**스택의 기본 원리**
- Last In First Out(후입선출) 구조로 동작합니다
- 가장 나중에 들어온 데이터가 가장 먼저 나가는 구조입니다
- 스택 포인터(Stack Pointer)가 현재 스택의 최상단 위치를 추적합니다

**함수 호출 시 동작**
1. 함수가 호출되면 새로운 스택 프레임이 생성됩니다
2. 함수의 매개변수들이 스택에 저장됩니다
3. 함수의 반환 주소가 저장됩니다
4. 지역 변수들이 스택에 할당됩니다
5. 함수 종료 시 모든 데이터가 자동으로 해제됩니다

### 스택에 저장되는 데이터

**함수 실행 정보**
- 함수의 매개변수: 호출 시 전달된 인자들
- 지역 변수: 함수 내에서 선언된 변수들
- 반환 주소: 함수 종료 후 돌아갈 메모리 주소
- CPU 레지스터 백업: 함수 호출 전 레지스터 상태

**스택 프레임 구조**
각 함수 호출마다 생성되는 스택 프레임은 다음과 같은 구조를 가집니다:
- 매개변수 영역
- 반환 주소
- 이전 스택 프레임 포인터
- 지역 변수 영역

### 스택 오버플로우

**발생 원인**
- 재귀 호출이 너무 깊어질 때
- 지역 변수가 과도하게 많을 때
- 스택 크기 제한을 초과할 때

**위험성**
- 스택 오버플로우는 프로그램의 비정상 종료를 야기할 수 있습니다
- 보안 취약점으로 악용될 수 있어 주의가 필요합니다

---

## 4. 힙 영역 (Heap Segment)

### 개념과 역할

힙 영역은 프로그램 실행 중 동적으로 할당되는 메모리 영역입니다. 스택과 달리 프로그래머가 직접 메모리의 할당과 해제를 제어할 수 있으며, 런타임에 크기가 변할 수 있습니다.

### 동적 메모리 관리

**할당과 해제**
- 메모리 할당: 프로그래머가 명시적으로 요청할 때 수행됩니다
- 메모리 해제: 프로그래머가 명시적으로 해제하거나 프로그램 종료 시 자동으로 해제됩니다
- 가비지 컬렉션: 일부 언어에서는 자동으로 미사용 메모리를 해제합니다

**메모리 관리 함수**
- C 언어: malloc(), calloc(), realloc(), free()
- C++: new, delete 연산자
- Java: new 연산자 (가비지 컬렉터가 자동 해제)
- Python: 객체 생성 시 자동 할당 (가비지 컬렉터가 자동 해제)

### 힙에 저장되는 데이터

**동적 객체**
- 런타임에 생성되는 객체들
- 크기가 컴파일 시점에 결정되지 않는 데이터
- 사용자 입력에 따라 크기가 결정되는 배열

**동적 구조체**
- 연결 리스트의 노드
- 트리 구조의 노드
- 그래프의 정점과 간선

### 메모리 관리의 문제점

**메모리 단편화**
- 메모리가 여러 조각으로 나뉘어 사용 가능한 연속된 공간이 부족해지는 현상
- 외부 단편화: 사용 가능한 메모리가 있지만 연속되지 않아 할당할 수 없는 경우
- 내부 단편화: 할당된 메모리 블록 내에서 사용하지 않는 공간이 생기는 경우

**메모리 누수**
- 할당된 메모리를 해제하지 않아 발생하는 메모리 낭비
- 프로그램이 장시간 실행될 때 메모리 사용량이 계속 증가
- 시스템 성능 저하 및 메모리 부족 현상 야기

---

## 메모리 영역 간의 상호작용

### 영역 간 경계 관리

**스택과 힙의 성장**
- 스택은 높은 주소에서 낮은 주소로 성장합니다
- 힙은 낮은 주소에서 높은 주소로 성장합니다
- 두 영역이 만나면 메모리 오류가 발생할 수 있습니다

**메모리 보호**
- 각 영역은 독립적인 접근 권한을 가집니다
- 잘못된 영역에 접근하면 세그멘테이션 폴트가 발생합니다
- 운영체제가 메모리 보호를 담당합니다

### 성능 최적화

**캐시 효율성**
- 코드 영역은 자주 접근되므로 CPU 캐시에 적합합니다
- 데이터 지역성(Locality)을 고려한 메모리 배치가 중요합니다

**메모리 사용량 최적화**
- 코드 영역 공유를 통한 메모리 절약
- 동적 할당의 신중한 사용
- 메모리 풀링 기법의 활용

---

## 참조

- Abraham Silberschatz, Peter Baer Galvin, Greg Gagne. "Operating System Concepts" 10th Edition
- Andrew S. Tanenbaum, Herbert Bos. "Modern Operating Systems" 4th Edition  
- https://inpa.tistory.com/entry/👩‍💻-프로세스-⚔️-쓰레드-차이 [Inpa Dev 👨‍💻:티스토리]