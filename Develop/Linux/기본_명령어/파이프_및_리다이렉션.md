---
title: 파이프 및 리다이렉션
tags: [linux, pipe, redirection, stdin, stdout, stderr]
updated: 2025-12-08
---

# 파이프 및 리다이렉션

## 개요

명령어의 입력과 출력을 연결하고 리다이렉션하는 방법. 명령어를 조합하여 복잡한 작업을 수행할 수 있다.

## 표준 입출력

### 파일 디스크립터

- 0: 표준 입력 (stdin)
- 1: 표준 출력 (stdout)
- 2: 표준 에러 (stderr)

에러 메시지는 stderr로 출력된다. 로그를 분리할 때 유용하다.

## 리다이렉션

### 출력 리다이렉션

```bash
command > file.txt                 # stdout을 파일로 (덮어쓰기)
command >> file.txt                # stdout을 파일로 (추가)
command 1> file.txt
command 2> error.log               # stderr를 파일로
command > file.txt 2>&1            # stdout과 stderr를 모두 파일로
command &> file.txt                # 간단한 형식
command > file.txt 2> /dev/null    # stderr 버리기
command >> file.txt 2>&1           # 추가 모드로 모두 저장
```

`2>&1`은 stderr를 stdout으로 리다이렉션한다. 순서가 중요하다. `> file.txt 2>&1`이 올바른 순서.

### 입력 리다이렉션

```bash
command < file.txt
command << EOF                     # 히어독
text
EOF
command < file1.txt > file2.txt
```

히어독은 스크립트에서 여러 줄 입력을 전달할 때 유용하다. 설정 파일 생성에 자주 사용.

### 파일 디스크립터 복사

```bash
command 2>&1
command > file.txt 2>&1
command <&3
command >&3
```

## 파이프

### 기본 파이프

```bash
command1 | command2
command1 | command2 | command3
```

파이프는 명령어를 조합하여 복잡한 작업을 수행한다. 각 명령어는 병렬로 실행된다.

### 예시

```bash
# 로그에서 에러만 추출
cat app.log | grep error

# 프로세스 목록에서 특정 프로세스 찾기
ps aux | grep nginx

# 파일 크기 순 정렬
ls -lh | sort -k5 -h

# 중복 제거
cat file.txt | sort | uniq

# 특정 사용자 프로세스 개수
ps aux | grep user | wc -l
```

## 고급 리다이렉션

### tee

출력을 파일과 화면에 동시에 출력한다.

```bash
command | tee file.txt
command | tee -a file.txt          # 파일에 추가
command | tee file1.txt file2.txt
command | tee /dev/tty file.txt
sudo command | tee file.txt
```

명령어 실행 결과를 저장하면서 화면에서도 확인할 때 사용. 로그를 저장하면서 모니터링할 수 있다.

### 프로세스 치환

```bash
diff <(command1) <(command2)
comm <(sort file1) <(sort file2)
```

두 명령어의 출력을 비교할 때 유용하다. 임시 파일 없이 직접 비교할 수 있다.

### 명령어 치환

```bash
echo "Today is $(date)"
echo "Today is `date`"              # 백틱 (구버전)
files=$(ls *.txt)
count=$(wc -l < file.txt)
```

`$()` 형식이 더 명확하고 중첩이 가능하다. 백틱은 구버전이고 중첩이 어렵다.

## 로그 처리

로그 파일을 처리할 때 자주 사용하는 패턴.

```bash
# 에러 로그만 저장
grep error app.log > error.log

# 출력과 에러 분리
command 1> output.log 2> error.log

# 실시간 모니터링하면서 저장
tail -f app.log | tee -a saved.log

# 여러 로그 병합
cat *.log > combined.log

# 에러만 필터링
grep -i error app.log | grep -v "INFO" > errors_only.log
```

`tee`는 출력을 파일과 화면에 동시에 보여준다. 로그 모니터링에 유용하다.

## 데이터 처리

파이프로 명령어를 연결하여 데이터를 처리한다.

```bash
# 패턴 찾아서 정렬
grep "pattern" file.txt | sort | uniq

# 상위 10개만
sort -rn file.txt | head -10

# 중복 제거 후 개수
sort file.txt | uniq | wc -l

# 특정 필드 추출
awk '{print $3}' file.txt | sort | uniq -c
```

## 에러 처리

에러 메시지를 적절히 처리한다.

```bash
# 에러 무시
command 2>/dev/null

# 에러만 저장
command 1>/dev/null 2>error.log

# 모두 로그에 기록
command >> output.log 2>&1
```

`2>&1`은 stderr를 stdout으로 리다이렉션한다. 순서가 중요하다.

## 파이프라인 예시

자주 사용하는 파이프라인 패턴.

```bash
# IP 주소별 접근 횟수
awk '{print $1}' access.log | sort | uniq -c | sort -rn | head -10

# 메모리 사용량 상위 프로세스
ps aux | sort -k4 -rn | head -5

# 큰 디렉토리 찾기
du -h /var | sort -h | tail -10

# 시간대별 에러 개수
grep "ERROR" app.log | awk '{print $1, $2}' | cut -d: -f1 | uniq -c

# 빈 줄 제거
grep -v '^$' file.txt | sort
```

## 주의사항

### 파이프와 에러

```bash
# 파이프는 stdout만 전달, stderr는 전달 안 됨
command1 | command2

# stderr도 전달하려면
command1 2>&1 | command2
```

에러 메시지도 처리하려면 `2>&1`을 사용한다. 파이프 전에 리다이렉션한다.

### 순서의 중요성

```bash
# 올바른 순서
command > file.txt 2>&1

# 잘못된 순서
command 2>&1 > file.txt            # stderr만 파일로, stdout은 화면에
```

리다이렉션 순서가 중요하다. 왼쪽에서 오른쪽으로 처리된다.

### 파일 덮어쓰기 방지

```bash
set -o noclobber
command > file.txt                 # 에러 발생
command >| file.txt                # 강제 덮어쓰기
```

스크립트에서 실수로 파일을 덮어쓰는 것을 방지할 수 있다.

### 파이프 실패 처리

```bash
# 파이프 중간에 실패해도 계속 실행
set +o pipefail
command1 | command2 | command3

# 파이프 중간에 실패하면 중단
set -o pipefail
command1 | command2 | command3
```

`set -o pipefail`을 사용하면 파이프라인 중간에 에러가 발생하면 즉시 중단한다. 디버깅에 유용하다.

## here document

여러 줄 입력을 전달한다.

```bash
cat << EOF
Line 1
Line 2
Line 3
EOF

# 변수 치환
cat << EOF
Hello $USER
Today is $(date)
EOF

# 변수 치환 안 함
cat << 'EOF'
Hello $USER
EOF

# 들여쓰기 제거
cat <<- EOF
    Line 1
    Line 2
EOF
```

스크립트에서 설정 파일을 생성하거나 SQL 쿼리를 실행할 때 유용하다. `<<-`는 탭을 제거한다.

**예시:**
```bash
# 설정 파일 생성
cat > /etc/myapp.conf << EOF
host=localhost
port=3000
debug=false
EOF

# SQL 쿼리 실행
mysql << EOF
SELECT * FROM users;
EOF
```

## here string

문자열을 stdin으로 전달한다.

```bash
grep "pattern" <<< "text to search"
tr '[:lower:]' '[:upper:]' <<< "hello"
wc -l <<< "line1\nline2\nline3"
```

간단한 문자열 처리에 유용하다. 변수 내용을 명령어에 전달할 때 편리하다.

## 고급 기법

### 명령어 그룹화

```bash
# 명령어 그룹화하여 리다이렉션
{ command1; command2; } > output.log

# 서브쉘로 실행
(command1; command2) > output.log
```

그룹화는 같은 프로세스에서 실행되므로 변수 공유가 가능하다. 서브쉘은 독립적이다.

### 파일 디스크립터 직접 사용

```bash
# 파일 디스크립터 3에 파일 열기
exec 3> file.txt
echo "Line 1" >&3
echo "Line 2" >&3
exec 3>&-                    # 닫기

# 여러 파일에 동시 출력
exec 3> file1.txt
exec 4> file2.txt
echo "To file1" >&3
echo "To file2" >&4
exec 3>&- 4>&-
```

복잡한 리다이렉션이 필요할 때 파일 디스크립터를 직접 사용한다. 스크립트에서 유용하다.

## 원격 백업

파이프를 사용하여 원격으로 백업할 수 있다.

```bash
# 원격 백업
tar -czf - /var/www | ssh user@remote "cat > backup.tar.gz"

# 원격 복원
ssh user@remote "cat backup.tar.gz" | tar -xzf -

# 증분 백업
find /var/www -newer /tmp/last_backup -print0 | tar -czf - --null -T - | ssh user@remote "cat > incremental.tar.gz"
```

원격 백업은 네트워크 대역폭을 고려한다. 압축을 사용하면 전송량을 줄일 수 있다.
