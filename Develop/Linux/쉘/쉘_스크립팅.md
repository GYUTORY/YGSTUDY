---
title: 쉘 스크립팅
tags: [linux, shell, bash, scripting, automation]
updated: 2025-12-08
---

# 쉘 스크립팅

## 개요

Bash 쉘 스크립트 작성 방법. 반복 작업을 자동화하고 실수를 줄인다.

## 스크립트 기본

### 스크립트 작성

```bash
#!/bin/bash
# 첫 줄은 shebang으로 인터프리터 지정

echo "Hello, World!"
```

### 스크립트 실행

```bash
chmod +x script.sh
./script.sh
bash script.sh                    # bash로 직접 실행
```

shebang(`#!/bin/bash`)을 첫 줄에 작성한다.

## 변수

### 변수 선언

```bash
name="value"
name='value'                      # 작은따옴표 (변수 치환 안 됨)
name="Hello $USER"                # 큰따옴표 (변수 치환)
```

변수명과 값 사이에 공백이 없어야 한다.

### 변수 사용

```bash
echo $name
echo ${name}                      # 명시적 변수 (권장)
echo "${name}_suffix"
```

`${variable}` 형식이 더 명확하다.

### 환경 변수

```bash
export VAR="value"
echo $PATH
env
```

### 특수 변수

```bash
$0                                # 스크립트 이름
$1, $2, ...                       # 위치 매개변수
$#                                # 매개변수 개수
$@                                # 모든 매개변수
$*                                # 모든 매개변수 (하나의 문자열)
$?                                # 마지막 명령어 종료 코드
$$                                # 현재 프로세스 PID
```

`$?`는 명령어 성공 여부를 확인할 때 사용한다.

## 조건문

### if 문

```bash
if [ condition ]; then
    commands
fi

# 예시
if [ $1 -gt 10 ]; then
    echo "Greater than 10"
fi
```

### 조건 연산자

```bash
# 숫자 비교
[ $a -eq $b ]                    # 같음
[ $a -ne $b ]                    # 다름
[ $a -gt $b ]                    # 큼
[ $a -lt $b ]                    # 작음
[ $a -ge $b ]                    # 크거나 같음
[ $a -le $b ]                    # 작거나 같음

# 문자열 비교
[ "$str" = "value" ]
[ "$str" != "value" ]
[ -z "$str" ]                     # 빈 문자열
[ -n "$str" ]                     # 비어있지 않음

# 파일 테스트
[ -f file.txt ]                  # 일반 파일
[ -d dir ]                        # 디렉토리
[ -r file.txt ]                   # 읽기 가능
[ -w file.txt ]
[ -x file.txt ]
[ -e file.txt ]                  # 존재
```

문자열 비교 시 변수를 따옴표로 감싼다. 공백이 있으면 에러가 발생한다.

### if-else

```bash
if [ condition ]; then
    commands1
else
    commands2
fi
```

### if-elif-else

```bash
if [ condition1 ]; then
    commands1
elif [ condition2 ]; then
    commands2
else
    commands3
fi
```

### case 문

```bash
case $variable in
    pattern1)
        commands1
        ;;
    pattern2)
        commands2
        ;;
    *)
        default_commands
        ;;
esac
```

**예시:**
```bash
case $1 in
    start)
        echo "Starting..."
        ;;
    stop)
        echo "Stopping..."
        ;;
    *)
        echo "Usage: $0 {start|stop}"
        ;;
esac
```

## 반복문

### for 문

```bash
for item in list; do
    commands
done

# 예시
for file in *.txt; do
    echo $file
done

for i in {1..10}; do
    echo $i
done

for ((i=1; i<=10; i++)); do
    echo $i
done
```

### while 문

```bash
while [ condition ]; do
    commands
done

# 예시
count=1
while [ $count -le 10 ]; do
    echo $count
    count=$((count + 1))
done
```

### until 문

```bash
until [ condition ]; do
    commands
done
```

`while`은 조건이 참일 때, `until`은 조건이 거짓일 때 실행한다.

### break / continue

```bash
for i in {1..10}; do
    if [ $i -eq 5 ]; then
        break                   # 루프 종료
    fi
    if [ $i -eq 3 ]; then
        continue                # 다음 반복
    fi
    echo $i
done
```

## 함수

### 함수 정의

```bash
function_name() {
    commands
    return value
}

# 또는
function function_name() {
    commands
    return value
}
```

### 함수 호출

```bash
function_name arg1 arg2
```

### 함수 예시

```bash
check_file() {
    if [ -f "$1" ]; then
        echo "File exists: $1"
        return 0
    else
        echo "File not found: $1"
        return 1
    fi
}

check_file /etc/passwd
```

함수는 재사용 가능한 코드 블록이다.

## 배열

### 배열 선언

```bash
array=(item1 item2 item3)
array[0]="item1"
array[1]="item2"
```

### 배열 사용

```bash
echo ${array[0]}                 # 첫 번째 요소
echo ${array[@]}                 # 모든 요소
echo ${#array[@]}                # 배열 길이
```

### 배열 순회

```bash
for item in "${array[@]}"; do
    echo $item
done
```

## 산술 연산

### expr

```bash
result=$(expr 10 + 5)
result=$(expr $a \* $b)          # 곱하기는 이스케이프 필요
```

### $(( ))

```bash
result=$((10 + 5))
result=$((a * b))                 # 이스케이프 불필요
result=$((a++))
```

`$(( ))`가 더 간단하고 빠르다.

### let

```bash
let result=10+5
let "result = a * b"
```

## 문자열 처리

### 문자열 길이

```bash
str="Hello"
echo ${#str}                      # 5
```

### 문자열 자르기

```bash
str="Hello World"
echo ${str:0:5}                   # Hello (시작:길이)
echo ${str:6}                     # World (시작부터 끝까지)
```

### 문자열 치환

```bash
str="Hello World"
echo ${str/World/Linux}           # Hello Linux (첫 번째만)
echo ${str//o/O}                  # HellO WOrld (모두)
```

### 문자열 제거

```bash
str="file.txt"
echo ${str%.txt}                  # file (뒤에서 제거)
echo ${str#file}                  # .txt (앞에서 제거)
```

## 입출력

### read

사용자 입력을 읽는다.

```bash
read name
read -p "Enter name: " name
read -s password                  # 비밀번호 (화면에 안 보임)
read -t 10 name                   # 타임아웃 10초
```

### select

메뉴를 만든다.

```bash
select option in "Option 1" "Option 2" "Quit"; do
    case $option in
        "Option 1")
            echo "Selected 1"
            ;;
        "Option 2")
            echo "Selected 2"
            ;;
        "Quit")
            break
            ;;
    esac
done
```

## 에러 처리

### 종료 코드 확인

```bash
command
if [ $? -eq 0 ]; then
    echo "Success"
else
    echo "Failed"
fi
```

### set 옵션

```bash
set -e                            # 에러 발생 시 즉시 종료
set -u                            # 정의되지 않은 변수 사용 시 에러
set -x                            # 명령어 실행 전 출력
set -o pipefail                   # 파이프에서 에러 발생 시 종료
```

스크립트 시작 부분에 `set -euo pipefail`을 추가하면 안전하다.

### trap

시그널을 처리한다.

```bash
trap 'cleanup; exit' INT TERM

cleanup() {
    echo "Cleaning up..."
    rm -f /tmp/tempfile
}
```

## 디버깅

### 디버그 모드

```bash
bash -x script.sh                 # 명령어 실행 전 출력
bash -v script.sh                 # 스크립트 내용 출력
bash -n script.sh                 # 문법 검사만
```

### 스크립트 내부

```bash
set -x                            # 디버그 모드 시작
# commands
set +x                            # 디버그 모드 종료
```

## 백업 스크립트

```bash
#!/bin/bash
set -euo pipefail

BACKUP_DIR="/backup"
SOURCE_DIR="/var/www"
DATE=$(date +%Y%m%d)

mkdir -p $BACKUP_DIR
tar -czf $BACKUP_DIR/backup-$DATE.tar.gz $SOURCE_DIR

echo "Backup completed: backup-$DATE.tar.gz"
```

`set -euo pipefail`로 에러 처리를 안전하게 한다. 변수는 따옴표로 감싼다.

## 로그 분석 스크립트

```bash
#!/bin/bash

LOG_FILE="/var/log/app.log"
ERROR_COUNT=$(grep -c "ERROR" "$LOG_FILE")

if [ $ERROR_COUNT -gt 100 ]; then
    echo "High error count: $ERROR_COUNT"
    # 알림 전송
fi
```

로그 분석은 정기적으로 실행한다. cron으로 스케줄링한다.

## 서비스 관리 스크립트

```bash
#!/bin/bash

SERVICE=$1
ACTION=$2

case $ACTION in
    start)
        systemctl start "$SERVICE"
        ;;
    stop)
        systemctl stop "$SERVICE"
        ;;
    restart)
        systemctl restart "$SERVICE"
        ;;
    *)
        echo "Usage: $0 <service> {start|stop|restart}"
        exit 1
        ;;
esac
```

서비스 이름은 변수로 받아서 사용한다. 따옴표로 감싸면 공백이 있어도 안전하다.
