---
title: 디스크 관리
tags: [linux, disk, partition, lvm, mount, fstab, storage]
updated: 2025-12-08
---

# 디스크 관리

## 개요

디스크 파티션, 파일시스템, 마운트 관리 방법. 데이터 손실 위험이 있으니 백업 후 작업한다.

## 디스크 확인

### lsblk

블록 장치를 트리 형태로 표시한다.

```bash
lsblk                            # 모든 블록 장치
lsblk -f                         # 파일시스템 정보 포함
lsblk -o NAME,SIZE,TYPE,MOUNTPOINT
lsblk -d                         # 디스크만
lsblk -p                         # 전체 경로
```

### fdisk

디스크 파티션을 관리한다.

```bash
fdisk -l                         # 모든 디스크 파티션 정보
fdisk /dev/sda                   # 특정 디스크 파티션 편집
```

**fdisk 명령어:**
- `p`: 파티션 목록
- `n`: 새 파티션 생성
- `d`: 파티션 삭제
- `t`: 파티션 타입 변경
- `w`: 저장 후 종료
- `q`: 저장 안 하고 종료

**파티션 생성:**
```bash
fdisk /dev/sdb
# n (새 파티션)
# p (주 파티션)
# 1 (파티션 번호)
# Enter (시작 섹터)
# +50G (크기)
# w (저장)
```

파티션 작업은 데이터를 삭제할 수 있다. `w`로 저장하기 전에 `p`로 확인한다.

### parted

고급 파티션 관리 도구. GPT 파티션 테이블이나 2TB 이상 디스크에 사용한다.

```bash
parted /dev/sda print            # 파티션 정보
parted /dev/sda mkpart primary ext4 1MiB 100GiB
parted /dev/sda rm 1             # 파티션 삭제
parted /dev/sda resizepart 1 200GiB
parted /dev/sda set 1 boot on    # 부팅 플래그 설정
```

**GPT vs MBR:**
- MBR: 2TB 이하, 최대 4개 주 파티션
- GPT: 2TB 이상, 무제한 파티션

## 파일시스템 생성

### mkfs

새로운 파일시스템을 생성한다. 모든 데이터를 삭제한다.

```bash
mkfs.ext4 /dev/sdb1              # ext4 파일시스템
mkfs.xfs /dev/sdb1               # xfs 파일시스템
mkfs -t ext4 /dev/sdb1
mkfs.ext4 -L DATA /dev/sdb1      # 레이블 지정
mkfs.ext4 -m 1 /dev/sdb1        # 예약 공간 1%
mkfs.ext4 -i 8192 /dev/sdb1     # inode 비율
```

레이블을 지정하면 관리가 편하다.

### mke2fs

ext2/ext3/ext4 파일시스템을 생성한다.

```bash
mke2fs -t ext4 /dev/sdb1
mke2fs -j /dev/sdb1              # ext3 (저널링)
mke2fs -L MYDISK /dev/sdb1
mke2fs -m 1 /dev/sdb1            # 예약 공간 1%
mke2fs -i 8192 /dev/sdb1
mke2fs -O ^has_journal /dev/sdb1  # ext2
```

## 마운트

### mount

파일시스템을 마운트한다.

```bash
mount /dev/sdb1 /mnt
mount -t ext4 /dev/sdb1 /mnt
mount -o ro /dev/sdb1 /mnt       # 읽기 전용
mount -o noexec /dev/sdb1 /mnt   # 실행 불가
mount -o remount,rw /            # 재마운트
mount -a                         # /etc/fstab의 모든 항목 마운트
```

**마운트 옵션:**
- `ro`: 읽기 전용
- `rw`: 읽기/쓰기
- `noexec`: 실행 불가
- `nosuid`: setuid 비활성화
- `nodev`: 장치 파일 무시
- `noatime`: 접근 시간 업데이트 안 함
- `defaults`: 기본 옵션

`noatime`은 성능 향상에 도움이 된다.

### umount

파일시스템을 언마운트한다.

```bash
umount /mnt
umount -l /mnt                   # 지연 언마운트
umount -f /mnt                   # 강제 언마운트
```

**언마운트 실패 시:**
```bash
lsof /mnt                        # 사용 중인 프로세스 확인
fuser -m /mnt
fuser -km /mnt                   # 프로세스 종료
umount /mnt
```

사용 중인 파일시스템은 언마운트할 수 없다. `lsof`로 확인한다.

### /etc/fstab

부팅 시 자동 마운트 설정.

```bash
# /etc/fstab
# 장치명 마운트포인트 파일시스템 옵션 dump fsck
/dev/sdb1  /data  ext4  defaults  0  2
UUID=xxx   /data  ext4  defaults,noatime  0  2
tmpfs      /tmp   tmpfs defaults,size=1G  0  0
//server/share /mnt cifs credentials=/root/.smb,uid=1000 0 0
```

**필드:**
1. 장치명 또는 UUID
2. 마운트 포인트
3. 파일시스템 타입
4. 마운트 옵션
5. dump 백업 (0 또는 1)
6. 파일시스템 체크 순서 (0=체크 안 함, 1=루트, 2=기타)

**UUID 사용:**
```bash
blkid /dev/sda1                  # UUID 확인
UUID=12345678-1234-1234-1234-123456789abc /data ext4 defaults 0 2
```

**네트워크 파일시스템:**
```bash
# NFS
server:/export /mnt nfs defaults,_netdev 0 0

# CIFS/SMB
//server/share /mnt cifs credentials=/root/.smb,uid=1000,gid=1000,_netdev 0 0
```

UUID를 사용하면 장치명이 바뀌어도 안정적이다. 네트워크 파일시스템은 `_netdev` 옵션을 추가한다.

## LVM

논리 볼륨 관리. 디스크를 유연하게 관리할 수 있다.

### 물리 볼륨 (PV)

```bash
pvcreate /dev/sdb                # 물리 볼륨 생성
pvcreate /dev/sdc /dev/sdd       # 여러 디스크 동시 생성
pvdisplay                        # 물리 볼륨 정보
pvs                              # 간단한 정보
pvremove /dev/sdb
pvmove /dev/sdb                  # 데이터 이동
```

파티션을 사용하는 것이 권장된다.

### 볼륨 그룹 (VG)

```bash
vgcreate myvg /dev/sdb           # 볼륨 그룹 생성
vgdisplay
vgs
vgextend myvg /dev/sdc           # 볼륨 그룹 확장
vgreduce myvg /dev/sdc
vgremove myvg
```

**볼륨 그룹 확장:**
```bash
pvcreate /dev/sdc
vgextend myvg /dev/sdc
```

여러 물리 볼륨을 하나로 묶는다.

### 논리 볼륨 (LV)

```bash
lvcreate -L 10G -n mylv myvg      # 논리 볼륨 생성 (10GB)
lvcreate -l 100%FREE -n mylv myvg # 모든 공간 사용
lvcreate -l 50%VG -n mylv myvg
lvdisplay
lvs
lvextend -L +5G /dev/myvg/mylv   # 논리 볼륨 확장
lvextend -l +100%FREE /dev/myvg/mylv
lvreduce -L -5G /dev/myvg/mylv   # 축소 (주의)
lvremove /dev/myvg/mylv
```

**논리 볼륨 확장:**
```bash
lvextend -L +10G /dev/myvg/mylv
resize2fs /dev/myvg/mylv          # ext4
xfs_growfs /dev/myvg/mylv         # xfs
```

확장은 쉽지만 축소는 주의가 필요하다.

### LVM 스냅샷

```bash
lvcreate -L 1G -s -n snapshot /dev/myvg/mylv
lvremove /dev/myvg/snapshot
```

백업이나 테스트에 유용하다. 원본과 스냅샷이 같은 볼륨 그룹에 있어야 한다.

## 디스크 사용량

### df

파일시스템 사용량을 확인한다.

```bash
df                               # 기본 정보
df -h                            # 사람이 읽기 쉬운 형식
df -i                            # inode 사용량
df -T                            # 파일시스템 타입
df -h --total                    # 합계 포함
```

### du

디렉토리 사용량을 확인한다.

```bash
du /var
du -h /var
du -sh /var/*                    # 각 항목 크기
du -h --max-depth=1 /var
du -h | sort -h                  # 크기 순 정렬
```

**큰 파일 찾기:**
```bash
du -h * | sort -h | tail -10
du -h / 2>/dev/null | sort -h | tail -20
find /var -type f -size +100M -exec du -h {} \;
```

## 디스크 성능

### hdparm

하드 디스크 성능을 테스트한다.

```bash
hdparm -Tt /dev/sda              # 읽기 속도 테스트
hdparm -I /dev/sda               # 디스크 정보
hdparm -W 1 /dev/sda             # 쓰기 캐시 활성화
```

SSD에서는 의미가 제한적이다.

### dd

디스크 성능을 테스트한다.

```bash
# 쓰기 속도
dd if=/dev/zero of=/tmp/test bs=1M count=1000 oflag=direct

# 읽기 속도
dd if=/dev/sda of=/dev/null bs=1M count=1000 iflag=direct
```

주의: `of=/dev/sda` 같은 실제 디스크는 절대 사용하지 않는다. `/tmp`에 테스트 파일을 만든다.

## 디스크 문제 해결

### 파일시스템 점검

```bash
umount /dev/sdb1                 # 언마운트
fsck -y /dev/sdb1                # 자동 수리
fsck -f /dev/sdb1                # 강제 점검
mount /dev/sdb1 /mnt             # 재마운트
```

언마운트된 상태에서 점검한다. 루트 파일시스템은 부팅 시 자동 점검된다.

### 읽기 전용 파일시스템

```bash
dmesg | grep -i error            # 원인 확인
smartctl -a /dev/sda
fsck /dev/sda1
mount -o remount,rw /            # 재마운트
mount -o remount,force,rw /      # 강제 재마운트
```

원인: 파일시스템 에러, 디스크 오류, I/O 에러, 메모리 부족, 하드웨어 문제

### 디스크 공간 부족

```bash
du -h / | sort -h | tail -20     # 큰 파일 찾기
find / -type f -size +100M 2>/dev/null
find /var/log -type f -mtime +30 -delete  # 로그 정리
rm -rf /tmp/*
yum clean all                    # RHEL/CentOS
apt clean                        # Debian/Ubuntu
docker system prune -a
```

로그 파일과 임시 파일이 주요 원인이다.

### inode 부족

```bash
df -i                            # inode 사용량 확인
find /path -xdev -type f | cut -d "/" -f 2 | sort | uniq -c | sort -rn
find /path -type f -size -1k -delete
find /path -type f -empty -delete
```

디스크 공간은 충분한데 "No space left" 에러가 나면 inode 부족일 수 있다.

## 스왑 관리

### 스왑 파일 생성

```bash
dd if=/dev/zero of=/swapfile bs=1M count=1024
chmod 600 /swapfile
mkswap /swapfile
swapon /swapfile
```

### /etc/fstab에 추가

```bash
/swapfile none swap sw 0 0
```

### 스왑 확인

```bash
free -h
swapon --show
cat /proc/swaps
```

### 스왑 비활성화

```bash
swapoff /swapfile
swapoff -a
```

SSD에서는 스왑 파일이 스왑 파티션보다 관리가 쉽다. 스왑 크기는 메모리의 1-2배가 일반적이다.

## 새 디스크 추가

```bash
lsblk
fdisk -l
fdisk /dev/sdb                   # n, p, 1, Enter, Enter, w
mkfs.ext4 /dev/sdb1
mkdir /data
mount /dev/sdb1 /data
blkid /dev/sdb1                  # UUID 확인
# UUID를 /etc/fstab에 추가
mount -a                         # 테스트
```

UUID를 사용하면 장치명이 바뀌어도 안정적이다.

## LVM 디스크 확장

```bash
pvcreate /dev/sdc
vgextend myvg /dev/sdc
lvextend -l +100%FREE /dev/myvg/mylv
resize2fs /dev/myvg/mylv          # ext4
xfs_growfs /dev/myvg/mylv         # xfs
```

파일시스템 확장은 온라인으로 가능하다.
