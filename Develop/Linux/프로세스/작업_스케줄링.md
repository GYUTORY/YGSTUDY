---
title: 작업 스케줄링
tags: [linux, cron, at, systemd-timer, scheduling]
updated: 2025-12-08
---

# 작업 스케줄링

## 개요

작업을 자동으로 실행하도록 스케줄링하는 방법. 반복 작업은 cron으로, 일회성 작업은 at으로 스케줄링한다. systemd 타이머도 고려한다.

## cron

정기적으로 반복 실행되는 작업을 스케줄링한다.

### crontab 편집

```bash
crontab -e
crontab -l
crontab -r
crontab -u user -e               # 특정 사용자 crontab 편집 (root)
crontab -u user -l
```

**편집기 변경:**
```bash
export EDITOR=vim
crontab -e
```

### crontab 형식

```bash
# 분 시 일 월 요일 명령어
* * * * * command

# 예시
0 2 * * * /path/to/backup.sh      # 매일 새벽 2시
0 */6 * * * /path/to/check.sh     # 6시간마다
0 0 * * 0 /path/to/weekly.sh      # 매주 일요일 자정
0 0 1 * * /path/to/monthly.sh     # 매월 1일 자정
*/5 * * * * /path/to/check.sh     # 5분마다
0 9-17 * * 1-5 /path/to/work.sh   # 평일 9시-17시 매시 정각
0 0 1,15 * * /path/to/twice.sh    # 매월 1일, 15일
```

**필드 설명:**
- 분: 0-59
- 시: 0-23
- 일: 1-31
- 월: 1-12
- 요일: 0-7 (0과 7은 일요일)

**특수 문자:**
- `*`: 모든 값
- `,`: 값 목록 (예: 1,3,5)
- `-`: 범위 (예: 1-5)
- `/`: 간격 (예: */5)

요일과 일 필드를 함께 사용하면 주의가 필요하다. 둘 다 `*`이면 매일 실행된다.

### 환경 변수

```bash
# crontab 상단에 설정
PATH=/usr/bin:/usr/sbin:/usr/local/bin
SHELL=/bin/bash
MAILTO=admin@example.com
HOME=/home/user

0 2 * * * /path/to/backup.sh
```

**필수 환경 변수:**
- PATH: 명령어 경로
- SHELL: 쉘
- HOME: 홈 디렉토리
- MAILTO: 메일 수신자

cron은 최소한의 환경 변수만 가진다. 필요한 경로를 명시적으로 설정한다. 전체 경로를 사용하는 것이 안전하다.

### 출력 리다이렉션

```bash
# 출력을 파일로
0 2 * * * /path/to/backup.sh > /var/log/backup.log 2>&1

# 출력 버리기
0 2 * * * /path/to/backup.sh > /dev/null 2>&1

# 에러만 저장
0 2 * * * /path/to/backup.sh > /dev/null 2>/var/log/backup.error
```

출력을 리다이렉션하지 않으면 메일로 전송된다. 로그 파일로 저장하거나 버린다. `2>&1`로 에러도 함께 저장한다.

### 시스템 crontab

```bash
# /etc/crontab
SHELL=/bin/bash
PATH=/sbin:/bin:/usr/sbin:/usr/bin
MAILTO=root

0 2 * * * root /path/to/backup.sh
```

**필드 차이:**
- 사용자 crontab: 5개 필드 (분 시 일 월 요일)
- 시스템 crontab: 6개 필드 (분 시 일 월 요일 사용자)

### cron 디렉토리

```bash
/etc/cron.d/
/etc/cron.hourly/
/etc/cron.daily/
/etc/cron.weekly/
/etc/cron.monthly/
```

**디렉토리 사용:**
```bash
# 스크립트를 디렉토리에 배치
cp backup.sh /etc/cron.daily/
chmod +x /etc/cron.daily/backup.sh
```

스크립트를 해당 디렉토리에 넣으면 자동으로 실행된다. 실행 권한이 필요하다. 파일명에 확장자는 필요 없다.

### cron 로그

```bash
# cron 실행 로그 확인
grep CRON /var/log/syslog
journalctl -u cron
journalctl -u cron --since today

# cron 에러 확인
grep CRON /var/log/syslog | grep -i error
```

**로그 위치:**
- RHEL/CentOS: `/var/log/cron`
- Debian/Ubuntu: `/var/log/syslog`
- systemd: `journalctl -u cron`

## at

일회성 작업을 스케줄링한다.

### 작업 예약

```bash
at 14:30
at now + 1 hour
at now + 30 minutes
at 2025-01-01 10:00
at 10:00 Jan 1 2025
at teatime                       # 16:00
at midnight
at noon
```

**입력 후 명령어 입력:**
```bash
at 14:30
at> echo "Hello" > /tmp/hello.txt
at> date >> /tmp/hello.txt
at> <EOT>                        # Ctrl+D로 종료
```

**여러 명령어:**
```bash
at 14:30 <<EOF
echo "Starting backup"
/path/to/backup.sh
echo "Backup completed"
EOF
```

### 작업 확인

```bash
atq
at -l
```

### 작업 삭제

```bash
atrm 1
at -d 1
atrm -
```

### 작업 상세 확인

```bash
at -c 1
```

`at`은 일회성 작업에 유용하다. 반복 작업은 cron을 사용한다. `atd` 서비스가 실행 중이어야 한다.

## systemd 타이머

systemd 기반 시스템에서 작업을 스케줄링한다.

### 타이머 파일 생성

```bash
# /etc/systemd/system/backup.timer
[Unit]
Description=Daily Backup Timer
Requires=backup.service

[Timer]
OnCalendar=daily
OnCalendar=Mon..Fri 02:00
OnCalendar=*-*-01 00:00:00
OnCalendar=*-*-01,15 02:00
OnBootSec=5min
OnUnitActiveSec=1h
OnCalendar=hourly
OnCalendar=weekly
RandomizedDelaySec=300

[Install]
WantedBy=timers.target
```

### 서비스 파일 생성

```bash
# /etc/systemd/system/backup.service
[Unit]
Description=Backup Service
After=network.target

[Service]
Type=oneshot
ExecStart=/path/to/backup.sh
User=backup
WorkingDirectory=/backup
Environment="BACKUP_DIR=/backup"
StandardOutput=journal
StandardError=journal
```

### 타이머 활성화

```bash
systemctl enable backup.timer
systemctl start backup.timer
systemctl list-timers
systemctl status backup.timer
systemctl list-timers --all
```

**타이머 확인:**
```bash
systemctl list-timers
# NEXT                         LEFT          LAST                         PASSED       UNIT
# Mon 2025-01-01 02:00:00 KST  23h left     Sun 2025-01-01 02:00:00 KST 1h 30min ago backup.timer
```

systemd 타이머는 cron보다 정확하다. 최신 시스템에서 권장한다. 로그는 `journalctl -u backup.service`로 확인한다.

## 스케줄링 모범 사례

### 스크립트 작성

```bash
#!/bin/bash
set -euo pipefail

# 로그 파일
LOG_FILE="/var/log/backup.log"
ERROR_LOG="/var/log/backup.error"

# 함수 정의
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> $LOG_FILE
}

backup() {
    log "Starting backup"
    # 백업 작업
    if [ $? -eq 0 ]; then
        log "Backup completed"
    else
        log "Backup failed" >> $ERROR_LOG
        exit 1
    fi
}

# 실행
backup
```

스크립트는 에러 처리를 포함하고 로그를 남긴다. `set -euo pipefail`로 안전하게 실행한다.

### 잠금 파일

```bash
#!/bin/bash
LOCK_FILE="/var/run/backup.lock"

if [ -f $LOCK_FILE ]; then
    PID=$(cat $LOCK_FILE)
    if ps -p $PID > /dev/null 2>&1; then
        echo "Backup already running (PID: $PID)"
        exit 1
    else
        rm -f $LOCK_FILE
    fi
fi

trap "rm -f $LOCK_FILE" EXIT
echo $$ > $LOCK_FILE

# 작업 실행
```

중복 실행을 방지하기 위해 잠금 파일을 사용한다. PID를 저장하여 프로세스가 살아있는지 확인한다.

### 로그 관리

```bash
# 로그 로테이션 설정
# /etc/logrotate.d/backup
/var/log/backup.log {
    daily
    rotate 7
    compress
    delaycompress
    missingok
    notifempty
    create 0644 backup backup
    postrotate
        systemctl reload rsyslog > /dev/null 2>&1 || true
    endscript
}
```

### 알림 설정

```bash
#!/bin/bash
# 작업 완료 후 알림

if [ $? -eq 0 ]; then
    echo "Backup succeeded" | mail -s "Backup Success" admin@example.com
else
    echo "Backup failed" | mail -s "Backup Failed" admin@example.com
fi
```

## 일반적인 스케줄 작업

### 백업

```bash
# 매일 새벽 2시 백업
0 2 * * * /path/to/backup.sh

# 주말 백업
0 2 * * 0,6 /path/to/weekend_backup.sh
```

### 로그 정리

```bash
# 매일 자정 로그 정리
0 0 * * * find /var/log -type f -mtime +30 -delete

# 매주 일요일 로그 압축
0 3 * * 0 find /var/log -type f -mtime +7 -exec gzip {} \;
```

### 모니터링

```bash
# 5분마다 체크
*/5 * * * * /path/to/check.sh

# 업무시간만 체크
*/10 9-18 * * 1-5 /path/to/monitor.sh
```

### 데이터베이스 백업

```bash
# 매일 새벽 3시 DB 백업
0 3 * * * /path/to/db_backup.sh

# 매시간 증분 백업
0 * * * * /path/to/incremental_backup.sh
```

### 캐시 정리

```bash
# 매일 새벽 4시 캐시 정리
0 4 * * * /path/to/cache_clear.sh
```

## 문제 해결

### cron이 실행되지 않을 때

```bash
# 1. cron 서비스 확인
systemctl status cron
systemctl status crond

# 2. cron 로그 확인
grep CRON /var/log/syslog
journalctl -u cron

# 3. crontab 확인
crontab -l

# 4. 경로 확인
which command

# 5. 권한 확인
ls -l /path/to/script.sh

# 6. 수동 실행 테스트
/path/to/script.sh
```

### 권한 문제

```bash
# 스크립트 실행 권한
chmod +x /path/to/script.sh

# 파일 권한 확인
ls -l /path/to/script.sh

# 출력 파일 권한
touch /var/log/backup.log
chmod 666 /var/log/backup.log
```

### 환경 변수 문제

```bash
# crontab에 PATH 설정
PATH=/usr/bin:/usr/sbin

# 또는 스크립트에 전체 경로 사용
/usr/bin/command

# 스크립트 내부에서 환경 변수 설정
#!/bin/bash
export PATH=/usr/local/bin:$PATH
```

### 시간대 문제

```bash
# 시스템 시간 확인
date
timedatectl

# 시간대 설정
timedatectl set-timezone Asia/Seoul
```

cron 문제는 로그부터 확인한다. 환경 변수와 경로를 명시적으로 설정한다. 시간대도 확인한다.

### at 서비스 확인

```bash
# atd 서비스 확인
systemctl status atd

# atd 시작
systemctl start atd
systemctl enable atd
```
