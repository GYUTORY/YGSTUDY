---
title: 프로세스 관리
tags: [linux, process, ps, top, kill, jobs, bg, fg]
updated: 2025-12-08
---

# 프로세스 관리

## 개요

실행 중인 프로세스 확인 및 관리 방법. 프로세스 상태를 정기적으로 확인한다.

## 프로세스 확인

### ps (Process Status)

실행 중인 프로세스를 확인한다.

```bash
ps                          # 현재 터미널의 프로세스
ps aux                      # 모든 프로세스 (BSD 스타일)
ps -ef                      # 모든 프로세스 (표준 스타일)
ps aux | grep nginx
ps -p 1234
ps -u user
ps -o pid,ppid,cmd
ps -e
ps -f
ps -l
ps aux --sort=-%cpu
ps aux --sort=-%mem
```

**주요 필드:**
- PID: 프로세스 ID
- PPID: 부모 프로세스 ID
- USER: 실행 사용자
- %CPU: CPU 사용률
- %MEM: 메모리 사용률
- VSZ: 가상 메모리 크기
- RSS: 물리 메모리 크기
- TTY: 터미널
- STAT: 프로세스 상태
- START: 시작 시간
- TIME: CPU 사용 시간
- COMMAND: 실행 명령어

**프로세스 상태 (STAT):**
- R: 실행 중 (Running)
- S: 대기 중 (Sleeping)
- D: 디스크 대기 (Uninterruptible sleep)
- Z: 좀비 (Zombie)
- T: 정지됨 (Stopped)
- <: 높은 우선순위
- N: 낮은 우선순위

`ps aux`는 가장 자주 사용한다. `grep`과 조합하여 특정 프로세스를 찾는다. `--sort`로 정렬할 수 있다.

### top

실시간으로 프로세스 상태를 확인한다.

```bash
top
top -u user
top -p 1234,5678
top -b -n 1                 # 배치 모드 (1회 출력)
top -d 2
```

**top 내부 명령어:**
- `P`: CPU 사용률 순 정렬
- `M`: 메모리 사용률 순 정렬
- `T`: 실행 시간 순 정렬
- `k`: 프로세스 종료 (PID 입력)
- `r`: 우선순위 변경
- `f`: 필드 선택
- `o`: 정렬 필드 선택
- `q`: 종료
- `h`: 도움말
- `1`: CPU 코어별 표시
- `c`: 명령어 전체 경로 표시

시스템 부하를 빠르게 확인할 때 사용한다. `htop`이 더 사용하기 편하다. `top -b -n 1 > process.txt`로 스냅샷을 저장할 수 있다.

### htop

향상된 top.

```bash
htop
htop -u user
htop -p 1234,5678
```

**특징:**
- 색상 표시
- 마우스 지원
- 더 직관적인 인터페이스
- 트리 뷰 지원
- 프로세스 검색

**htop 명령어:**
- `F2`: 설정
- `F3`: 검색
- `F4`: 필터
- `F5`: 트리 뷰
- `F6`: 정렬
- `F7`: nice 값 감소
- `F8`: nice 값 증가
- `F9`: 프로세스 종료
- `F10`: 종료

설치 필요: `yum install htop` 또는 `apt install htop`. `top`보다 사용하기 편하다.

### pgrep

프로세스 이름으로 PID를 찾는다.

```bash
pgrep nginx
pgrep -u user nginx
pgrep -f "python app.py"
pgrep -l nginx
pgrep -c nginx
```

스크립트에서 프로세스 존재 여부를 확인할 때 유용하다. `pgrep -f`는 명령어 전체를 검색한다.

### pstree

프로세스를 트리 형태로 보여준다.

```bash
pstree
pstree -p                   # PID 포함
pstree -u                   # 사용자 정보 포함
pstree 1234
pstree -a
pstree -h
```

프로세스 간 부모-자식 관계를 파악할 때 유용하다. 프로세스 그룹을 확인할 수 있다.

## 프로세스 종료

### kill

프로세스에 시그널을 보낸다.

```bash
kill 1234                   # 기본 (SIGTERM)
kill -9 1234                # 강제 종료 (SIGKILL)
kill -15 1234               # 정상 종료 (SIGTERM)
kill -HUP 1234              # 재시작 신호
kill -l                     # 사용 가능한 시그널 목록
kill -s TERM 1234
```

**주요 시그널:**
- SIGTERM (15): 정상 종료 요청
- SIGKILL (9): 강제 종료 (무시 불가)
- SIGHUP (1): 재시작 신호
- SIGINT (2): 인터럽트 (Ctrl+C)
- SIGQUIT (3): 종료 및 코어 덤프
- SIGSTOP (19): 일시 정지
- SIGCONT (18): 재개

**시그널 전송 순서:**
```bash
# 1. 정상 종료 시도
kill -15 PID

# 2. 대기
sleep 5

# 3. 강제 종료
kill -9 PID
```

먼저 SIGTERM으로 정상 종료를 시도하고, 안 되면 SIGKILL을 사용한다. SIGKILL은 프로세스가 정리 작업을 할 수 없다.

### killall

프로세스 이름으로 종료한다.

```bash
killall nginx
killall -9 python
killall -u user process
killall -v nginx
killall -i nginx
```

여러 프로세스를 한 번에 종료할 때 유용하다. 신중하게 사용한다. 잘못된 이름을 입력하면 의도치 않은 프로세스가 종료될 수 있다.

### pkill

프로세스 이름 패턴으로 종료한다.

```bash
pkill nginx
pkill -9 -f "python app"
pkill -u user process
pkill -x process
pkill -f "pattern"
```

패턴 매칭이 가능하다. `-f` 옵션으로 명령어 라인 전체를 검색한다.

## 프로세스 우선순위

### nice

프로세스 실행 시 우선순위를 설정한다.

```bash
nice -n 10 command          # 낮은 우선순위로 실행
nice -n -10 command         # 높은 우선순위로 실행 (root 필요)
nice command
```

**nice 값:**
- -20 ~ 19 범위
- 낮을수록 높은 우선순위
- 기본값: 0
- 일반 사용자: 0 ~ 19
- root: -20 ~ 19

백그라운드 작업은 낮은 우선순위로 실행한다. `nice -n 10`으로 시스템에 영향을 최소화한다.

### renice

실행 중인 프로세스의 우선순위를 변경한다.

```bash
renice 10 1234
renice -5 -u user
renice +5 -p 1234            # 우선순위 증가 (낮은 우선순위)
renice -5 -p 1234            # 우선순위 감소 (높은 우선순위, root 필요)
```

실행 중인 프로세스의 우선순위를 조정할 때 사용한다. CPU 집약적 작업의 우선순위를 낮춘다.

## 백그라운드 작업

### jobs

현재 세션의 백그라운드 작업을 확인한다.

```bash
jobs
jobs -l                     # PID 포함
jobs -p                     # PID만
jobs -r                     # 실행 중인 작업만
jobs -s                     # 정지된 작업만
```

### bg / fg

작업을 백그라운드/포그라운드로 전환한다.

```bash
command &                   # 백그라운드로 실행
bg %1
fg %1
fg                          # 마지막 작업을 포그라운드로
```

**작업 제어:**
```bash
# 1. 작업 시작
command &

# 2. 작업 중지 (Ctrl+Z)
# 작업이 정지됨

# 3. 백그라운드로 전환
bg

# 4. 포그라운드로 전환
fg
```

`Ctrl+Z`로 실행 중인 작업을 중지하고, `bg`로 백그라운드로 전환할 수 있다. `jobs`로 작업 목록을 확인한다.

### nohup

터미널이 종료되어도 프로세스가 계속 실행되도록 한다.

```bash
nohup command &             # 백그라운드 실행, 출력은 nohup.out
nohup command > output.log 2>&1 &
nohup command > /dev/null 2>&1 &
```

**nohup 동작:**
- SIGHUP 시그널 무시
- 출력은 `nohup.out`에 저장
- 명시적 리다이렉션 가능

SSH 연결이 끊어져도 프로세스가 계속 실행되도록 할 때 사용한다. 장시간 실행되는 작업에 유용하다.

### screen / tmux

터미널 세션을 유지한다.

**screen:**
```bash
screen
screen -r
screen -ls
screen -S name
screen -r name
screen -d -r name
```

**screen 명령어 (Ctrl+A 후):**
- `d`: 세션 분리
- `c`: 새 윈도우
- `n`: 다음 윈도우
- `p`: 이전 윈도우
- `[`: 스크롤 모드

**tmux:**
```bash
tmux
tmux attach
tmux ls
tmux new -s name
tmux attach -t name
tmux kill-session -t name
```

**tmux 명령어 (Ctrl+B 후):**
- `d`: 세션 분리
- `c`: 새 윈도우
- `n`: 다음 윈도우
- `p`: 이전 윈도우
- `%`: 세로 분할
- `"`: 가로 분할

장시간 실행되는 작업에 유용하다. `tmux`가 더 기능이 많다. 세션 이름을 지정하면 관리가 편하다.

## 프로세스 모니터링

### watch

명령어를 주기적으로 실행하여 결과를 보여준다.

```bash
watch -n 1 'ps aux | grep nginx'
watch -d 'df -h'
watch -n 2 'free -h'
watch -t 'uptime'
```

시스템 상태를 지속적으로 모니터링할 때 사용한다. `-d` 옵션으로 변경 사항을 강조한다.

### pidof

프로세스 이름으로 PID를 찾는다.

```bash
pidof nginx
pidof -s nginx              # 첫 번째 PID만
pidof -x script.sh
```

## 프로세스 정보 확인

### /proc 파일시스템

프로세스 정보는 `/proc`에 저장된다.

```bash
cat /proc/1234/status
cat /proc/1234/cmdline
cat /proc/1234/environ
ls -l /proc/1234/fd
cat /proc/1234/maps
cat /proc/1234/limits
cat /proc/1234/stat
```

**주요 파일:**
- `status`: 프로세스 상태 정보
- `cmdline`: 명령어 라인
- `environ`: 환경 변수
- `fd/`: 열린 파일 디스크립터
- `maps`: 메모리 맵
- `limits`: 리소스 제한
- `stat`: 통계 정보
- `io`: I/O 통계

프로세스의 상세 정보를 확인할 때 사용한다. 스크립트에서 프로세스 정보를 읽을 때 유용하다.

### lsof

열린 파일을 확인한다.

```bash
lsof
lsof -p 1234
lsof -u user
lsof /var/log/app.log
lsof -i :80
lsof -i tcp:80
lsof -i udp:53
lsof -c nginx
lsof +D /var/log
lsof -a -u user -i
```

**lsof 출력 필드:**
- COMMAND: 명령어
- PID: 프로세스 ID
- USER: 사용자
- FD: 파일 디스크립터
- TYPE: 파일 타입
- DEVICE: 장치
- SIZE/OFF: 크기 또는 오프셋
- NODE: inode
- NAME: 파일명

파일이 사용 중이어서 삭제할 수 없을 때 어떤 프로세스가 사용하는지 확인한다. 포트 사용 프로세스 확인에 자주 사용한다.

## 프로세스 트러블슈팅

### 좀비 프로세스

부모 프로세스가 종료되지 않은 자식 프로세스를 정리하지 않으면 좀비가 된다.

```bash
ps aux | grep defunct
ps aux | grep ' Z '
```

**해결:**
- 부모 프로세스를 재시작
- 시스템 재부팅
- kill -CHLD 부모프로세스PID (일부 경우)

좀비 프로세스는 리소스를 사용하지 않지만 프로세스 테이블을 차지한다. 부모 프로세스를 재시작하면 정리된다.

### 고아 프로세스

부모 프로세스가 종료된 자식 프로세스는 init(1)이 부모가 된다.

일반적으로 문제가 되지 않는다. init이 정리한다. PPID가 1인 프로세스는 고아 프로세스일 수 있다.

### 프로세스가 응답하지 않을 때

```bash
# 1. 프로세스 확인
ps aux | grep process
ps -p PID -o pid,ppid,stat,cmd

# 2. 정상 종료 시도
kill -15 PID
sleep 5

# 3. 강제 종료
kill -9 PID

# 4. 그래도 안 되면
killall -9 process

# 5. 최후의 수단
kill -KILL PID
```

먼저 정상 종료를 시도하고, 필요할 때만 강제 종료한다. SIGKILL은 데이터 손실을 일으킬 수 있다.

### 프로세스가 CPU를 많이 사용할 때

```bash
# 1. CPU 사용률 확인
top
ps aux --sort=-%cpu | head -10

# 2. 프로세스 상세 정보
strace -p PID
perf top -p PID

# 3. 우선순위 조정
renice +10 PID

# 4. 필요시 종료
kill -15 PID
```

### 프로세스가 메모리를 많이 사용할 때

```bash
# 1. 메모리 사용 확인
ps aux --sort=-%mem | head -10
pmap PID

# 2. 메모리 누수 확인
valgrind --leak-check=full program

# 3. 필요시 종료
kill -15 PID
```

## 프로세스 관리 모범 사례

### 정기 모니터링

```bash
# CPU 사용률 상위 10개
ps aux --sort=-%cpu | head -11

# 메모리 사용률 상위 10개
ps aux --sort=-%mem | head -11

# 실행 시간이 긴 프로세스
ps -eo pid,etime,cmd | sort -t: -k2
```

### 프로세스 그룹 관리

```bash
# 프로세스 그룹 확인
ps -ejH
ps -eo pid,ppid,pgid,sid,cmd
```

프로세스 그룹은 관련된 프로세스를 함께 관리할 수 있다. kill로 프로세스 그룹 전체를 종료할 수 있다: `kill -TERM -PGID`.
