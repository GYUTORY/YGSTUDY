---
title: ì‹œìŠ¤í…œ ì„¤ê³„ ë° ì•„í‚¤í…ì²˜ íŒ¨í„´ ê°€ì´ë“œ
tags: [system-design, architecture, scalability, load-balancing, caching]
updated: 2024-09-14
---

# ì‹œìŠ¤í…œ ì„¤ê³„ ë° ì•„í‚¤í…ì²˜ íŒ¨í„´ ê°€ì´ë“œ (System Design and Architecture Patterns Guide)

## ğŸ“‹ ëª©ì°¨
1. [í™•ì¥ ê°€ëŠ¥í•œ ì‹œìŠ¤í…œ ì„¤ê³„ ì›ì¹™](#í™•ì¥-ê°€ëŠ¥í•œ-ì‹œìŠ¤í…œ-ì„¤ê³„-ì›ì¹™)
2. [CAP ì •ë¦¬ ì‹¤ì¦ í”„ë¡œì íŠ¸](#cap-ì •ë¦¬-ì‹¤ì¦-í”„ë¡œì íŠ¸)
3. [ê³ ê¸‰ ë¡œë“œ ë°¸ëŸ°ì‹± ì „ëµ](#ê³ ê¸‰-ë¡œë“œ-ë°¸ëŸ°ì‹±-ì „ëµ)
4. [ë¶„ì‚° ë½ êµ¬í˜„](#ë¶„ì‚°-ë½-êµ¬í˜„)
5. [ë‹¤ì¸µ ìºì‹± ì „ëµ](#ë‹¤ì¸µ-ìºì‹±-ì „ëµ)
6. [ë°ì´í„°ë² ì´ìŠ¤ ìƒ¤ë”© ë° íŒŒí‹°ì…”ë‹](#ë°ì´í„°ë² ì´ìŠ¤-ìƒ¤ë”©-ë°-íŒŒí‹°ì…”ë‹)
7. [ì‹¤ì œ ëŒ€ê·œëª¨ ì‹œìŠ¤í…œ ì„¤ê³„ ì‚¬ë¡€](#ì‹¤ì œ-ëŒ€ê·œëª¨-ì‹œìŠ¤í…œ-ì„¤ê³„-ì‚¬ë¡€)

### ğŸ“Œ í†µí•©ëœ ê¸°ì¡´ íŒŒì¼ë“¤
ì´ ê°€ì´ë“œëŠ” ë‹¤ìŒ ê¸°ì¡´ íŒŒì¼ë“¤ì˜ ë‚´ìš©ì„ í†µí•©í•˜ì—¬ ë” ì²´ê³„ì ìœ¼ë¡œ ì •ë¦¬í•œ ê²ƒì…ë‹ˆë‹¤:
- **ì›¹ í†µì‹ ì˜ íë¦„**: ë¡œë“œ ë°¸ëŸ°ì„œ, ì›¹ ì„œë²„, ì• í”Œë¦¬ì¼€ì´ì…˜ ì„œë²„ ë ˆë²¨ë³„ ì²˜ë¦¬
- **Nginx ì„¤ì •**: ë¡œë“œ ë°¸ëŸ°ì‹± ì „ëµ, ìºì‹± ì„¤ì •, ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ ì•„í‚¤í…ì²˜
- **ë°ì´í„°ë² ì´ìŠ¤ ìƒ¤ë”©**: ìˆ˜í‰/ìˆ˜ì§ ìƒ¤ë”©, ìƒ¤ë”© í‚¤ ì„ íƒ, ì¿¼ë¦¬ ë¼ìš°íŒ…
- **DB Proxy**: ì—°ê²° ê´€ë¦¬, ë¶€í•˜ ë¶„ì‚°, ì„±ëŠ¥ ìµœì í™”
- **ëŒ€ëŸ‰ API ì²˜ë¦¬**: Redis í™œìš©, ë¹„ë™ê¸° ì²˜ë¦¬, ë¶€í•˜ ë¶„ì‚°

---

## CAP ì •ë¦¬ ì‹¤ì¦ í”„ë¡œì íŠ¸

### 1. CAP ì •ë¦¬ ê°œìš”

CAP ì •ë¦¬ëŠ” ë¶„ì‚° ì‹œìŠ¤í…œì—ì„œ **Consistency(ì¼ê´€ì„±)**, **Availability(ê°€ìš©ì„±)**, **Partition Tolerance(ë¶„í•  ë‚´ì„±)** ì¤‘ ìµœëŒ€ 2ê°œë§Œ ë™ì‹œì— ë³´ì¥í•  ìˆ˜ ìˆë‹¤ëŠ” ì´ë¡ ì…ë‹ˆë‹¤.

```
C (Consistency): ëª¨ë“  ë…¸ë“œê°€ ë™ì‹œì— ê°™ì€ ë°ì´í„°ë¥¼ ë³´ì—¬ì¤Œ
A (Availability): ì‹œìŠ¤í…œì´ í•­ìƒ ì‘ë‹µí•¨
P (Partition Tolerance): ë„¤íŠ¸ì›Œí¬ ë¶„í•  ìƒí™©ì—ì„œë„ ë™ì‘í•¨
```

### 2. Consistency ìš°ì„  ì‹œìŠ¤í…œ: ì€í–‰ ê³„ì¢Œ ì‹œìŠ¤í…œ

```typescript
// src/cap-demo/banking-system/BankingService.ts
import { Pool } from 'pg';
import { EventEmitter } from 'events';

export class BankingService {
  private db: Pool;
  private eventEmitter: EventEmitter;
  private isPartitioned: boolean = false;

  constructor(connectionString: string) {
    this.db = new Pool({ connectionString });
    this.eventEmitter = new EventEmitter();
  }

  // ê°•í•œ ì¼ê´€ì„± ë³´ì¥ - ëª¨ë“  ë³µì œë³¸ì— ë™ì‹œ ì—…ë°ì´íŠ¸
  async transferMoney(fromAccount: string, toAccount: string, amount: number): Promise<void> {
    const client = await this.db.connect();
    
    try {
      await client.query('BEGIN');
      
      // 1. ì†¡ê¸ˆ ê³„ì¢Œ ì”ì•¡ í™•ì¸ ë° ì°¨ê°
      const fromResult = await client.query(
        'SELECT balance FROM accounts WHERE account_id = $1 FOR UPDATE',
        [fromAccount]
      );
      
      if (fromResult.rows.length === 0) {
        throw new Error('ì†¡ê¸ˆ ê³„ì¢Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
      }
      
      const currentBalance = fromResult.rows[0].balance;
      if (currentBalance < amount) {
        throw new Error('ì”ì•¡ì´ ë¶€ì¡±í•©ë‹ˆë‹¤');
      }
      
      // 2. ì†¡ê¸ˆ ê³„ì¢Œ ì°¨ê°
      await client.query(
        'UPDATE accounts SET balance = balance - $1 WHERE account_id = $2',
        [amount, fromAccount]
      );
      
      // 3. ìˆ˜ì·¨ ê³„ì¢Œ ì¦ê°€
      await client.query(
        'UPDATE accounts SET balance = balance + $1 WHERE account_id = $2',
        [amount, toAccount]
      );
      
      // 4. ê±°ë˜ ê¸°ë¡ ì €ì¥
      await client.query(
        `INSERT INTO transactions (from_account, to_account, amount, timestamp, status)
         VALUES ($1, $2, $3, NOW(), 'COMPLETED')`,
        [fromAccount, toAccount, amount]
      );
      
      await client.query('COMMIT');
      
      // ëª¨ë“  ë³µì œë³¸ì— ë™ê¸°í™” (ê°•í•œ ì¼ê´€ì„±)
      await this.syncToAllReplicas(fromAccount, toAccount, amount);
      
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }

  // ëª¨ë“  ë³µì œë³¸ì— ë™ê¸°í™” (ê°•í•œ ì¼ê´€ì„±)
  private async syncToAllReplicas(fromAccount: string, toAccount: string, amount: number): Promise<void> {
    const replicas = [
      'replica1.example.com:5432',
      'replica2.example.com:5432',
      'replica3.example.com:5432'
    ];

    const syncPromises = replicas.map(async (replica) => {
      try {
        if (this.isPartitioned) {
          throw new Error(`Replica ${replica} is partitioned`);
        }
        
        // ê° ë³µì œë³¸ì— ë™ì¼í•œ íŠ¸ëœì­ì…˜ ì ìš©
        await this.applyTransactionToReplica(replica, fromAccount, toAccount, amount);
      } catch (error) {
        console.error(`Failed to sync to replica ${replica}:`, error);
        throw error; // í•˜ë‚˜ë¼ë„ ì‹¤íŒ¨í•˜ë©´ ì „ì²´ ì‹¤íŒ¨
      }
    });

    // ëª¨ë“  ë³µì œë³¸ì´ ì„±ê³µí•´ì•¼ íŠ¸ëœì­ì…˜ ì™„ë£Œ
    await Promise.all(syncPromises);
  }

  private async applyTransactionToReplica(
    replicaUrl: string, 
    fromAccount: string, 
    toAccount: string, 
    amount: number
  ): Promise<void> {
    const replicaDb = new Pool({ connectionString: replicaUrl });
    const client = await replicaDb.connect();
    
    try {
      await client.query('BEGIN');
      await client.query(
        'UPDATE accounts SET balance = balance - $1 WHERE account_id = $2',
        [amount, fromAccount]
      );
      await client.query(
        'UPDATE accounts SET balance = balance + $1 WHERE account_id = $2',
        [amount, toAccount]
      );
      await client.query('COMMIT');
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
      await replicaDb.end();
    }
  }

  // ë„¤íŠ¸ì›Œí¬ ë¶„í•  ì‹œë®¬ë ˆì´ì…˜
  simulatePartition(): void {
    this.isPartitioned = true;
    console.log('ğŸš¨ Network partition detected - System will maintain consistency but may be unavailable');
  }

  resolvePartition(): void {
    this.isPartitioned = false;
    console.log('âœ… Network partition resolved - System fully operational');
  }

  // ê°€ìš©ì„± í™•ì¸
  async checkAvailability(): Promise<boolean> {
    if (this.isPartitioned) {
      return false; // ë¶„í•  ì‹œ ê°€ìš©ì„± í¬ê¸°
    }
    return true;
  }
}

// ì‚¬ìš© ì˜ˆì‹œ
const bankingService = new BankingService('postgresql://localhost:5432/banking');

// ì •ìƒ ìƒí™©
await bankingService.transferMoney('account1', 'account2', 1000);

// ë„¤íŠ¸ì›Œí¬ ë¶„í•  ì‹œë®¬ë ˆì´ì…˜
bankingService.simulatePartition();
try {
  await bankingService.transferMoney('account1', 'account2', 500);
} catch (error) {
  console.log('Transfer failed due to partition:', error.message);
}
```

### 3. Availability ìš°ì„  ì‹œìŠ¤í…œ: ì†Œì…œ ë¯¸ë””ì–´ í”¼ë“œ

```typescript
// src/cap-demo/social-media/FeedService.ts
import { Pool } from 'pg';
import { EventEmitter } from 'events';

export class FeedService {
  private db: Pool;
  private cache: Map<string, any> = new Map();
  private isPartitioned: boolean = false;

  constructor(connectionString: string) {
    this.db = new Pool({ connectionString });
  }

  // ê°€ìš©ì„± ìš°ì„  - ì¼ê´€ì„±ë³´ë‹¤ ì‘ë‹µì„± ì¤‘ì‹œ
  async getFeed(userId: string): Promise<any[]> {
    try {
      // 1. ìºì‹œì—ì„œ ë¨¼ì € í™•ì¸
      const cacheKey = `feed:${userId}`;
      const cachedFeed = this.cache.get(cacheKey);
      
      if (cachedFeed && !this.isStale(cachedFeed.timestamp)) {
        return cachedFeed.data;
      }

      // 2. ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ì¡°íšŒ (ë¶„í•  ìƒí™©ì—ì„œë„ ì‘ë‹µ)
      let feedData;
      
      if (this.isPartitioned) {
        // ë¶„í•  ìƒí™©ì—ì„œëŠ” ìºì‹œëœ ë°ì´í„°ë‚˜ ë¶€ë¶„ì  ë°ì´í„°ë¼ë„ ë°˜í™˜
        feedData = await this.getFeedFromCacheOrPartialData(userId);
      } else {
        // ì •ìƒ ìƒí™©ì—ì„œëŠ” ìµœì‹  ë°ì´í„° ì¡°íšŒ
        feedData = await this.getFeedFromDatabase(userId);
      }

      // 3. ìºì‹œ ì—…ë°ì´íŠ¸
      this.cache.set(cacheKey, {
        data: feedData,
        timestamp: Date.now()
      });

      return feedData;
      
    } catch (error) {
      // ì—ëŸ¬ê°€ ë°œìƒí•´ë„ ìºì‹œëœ ë°ì´í„°ë¼ë„ ë°˜í™˜ (ê°€ìš©ì„± ìš°ì„ )
      console.warn('Feed service error, returning cached data:', error.message);
      return this.getCachedFeed(userId) || [];
    }
  }

  // í¬ìŠ¤íŠ¸ ì‘ì„± - ìµœì¢… ì¼ê´€ì„± í—ˆìš©
  async createPost(userId: string, content: string): Promise<string> {
    const postId = `post_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    try {
      if (this.isPartitioned) {
        // ë¶„í•  ìƒí™©ì—ì„œëŠ” ë¡œì»¬ì— ì €ì¥í•˜ê³  ë‚˜ì¤‘ì— ë™ê¸°í™”
        await this.savePostLocally(postId, userId, content);
        console.log('Post saved locally, will sync when partition resolves');
      } else {
        // ì •ìƒ ìƒí™©ì—ì„œëŠ” ì¦‰ì‹œ ì €ì¥
        await this.savePostToDatabase(postId, userId, content);
      }
      
      // ìºì‹œ ë¬´íš¨í™”
      this.invalidateUserFeedCache(userId);
      
      return postId;
      
    } catch (error) {
      // ì—ëŸ¬ê°€ ë°œìƒí•´ë„ í¬ìŠ¤íŠ¸ IDëŠ” ë°˜í™˜ (ê°€ìš©ì„± ìš°ì„ )
      console.warn('Post creation error, but returning post ID:', error.message);
      return postId;
    }
  }

  private async getFeedFromDatabase(userId: string): Promise<any[]> {
    const result = await this.db.query(
      `SELECT p.*, u.username 
       FROM posts p 
       JOIN users u ON p.user_id = u.id 
       WHERE p.user_id IN (
         SELECT following_id FROM follows WHERE follower_id = $1
       ) 
       ORDER BY p.created_at DESC 
       LIMIT 50`,
      [userId]
    );
    
    return result.rows;
  }

  private async getFeedFromCacheOrPartialData(userId: string): Promise<any[]> {
    // ë¶„í•  ìƒí™©ì—ì„œëŠ” ìºì‹œëœ ë°ì´í„°ë‚˜ ë¶€ë¶„ì  ë°ì´í„° ë°˜í™˜
    const cachedFeed = this.getCachedFeed(userId);
    if (cachedFeed) {
      return cachedFeed;
    }
    
    // ìºì‹œê°€ ì—†ìœ¼ë©´ ë¹ˆ ë°°ì—´ì´ë¼ë„ ë°˜í™˜ (ê°€ìš©ì„± ìš°ì„ )
    return [];
  }

  private async savePostToDatabase(postId: string, userId: string, content: string): Promise<void> {
    await this.db.query(
      'INSERT INTO posts (id, user_id, content, created_at) VALUES ($1, $2, $3, NOW())',
      [postId, userId, content]
    );
  }

  private async savePostLocally(postId: string, userId: string, content: string): Promise<void> {
    // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ì €ì¥ (ë‚˜ì¤‘ì— ë™ê¸°í™”)
    const localPosts = JSON.parse(localStorage.getItem('pending_posts') || '[]');
    localPosts.push({ postId, userId, content, timestamp: Date.now() });
    localStorage.setItem('pending_posts', JSON.stringify(localPosts));
  }

  private getCachedFeed(userId: string): any[] | null {
    const cacheKey = `feed:${userId}`;
    const cached = this.cache.get(cacheKey);
    return cached ? cached.data : null;
  }

  private isStale(timestamp: number): boolean {
    return Date.now() - timestamp > 300000; // 5ë¶„
  }

  private invalidateUserFeedCache(userId: string): void {
    const cacheKey = `feed:${userId}`;
    this.cache.delete(cacheKey);
  }

  // ë„¤íŠ¸ì›Œí¬ ë¶„í•  ì‹œë®¬ë ˆì´ì…˜
  simulatePartition(): void {
    this.isPartitioned = true;
    console.log('ğŸš¨ Network partition detected - System will maintain availability with eventual consistency');
  }

  resolvePartition(): void {
    this.isPartitioned = false;
    console.log('âœ… Network partition resolved - Syncing pending data');
    this.syncPendingData();
  }

  private async syncPendingData(): Promise<void> {
    const pendingPosts = JSON.parse(localStorage.getItem('pending_posts') || '[]');
    
    for (const post of pendingPosts) {
      try {
        await this.savePostToDatabase(post.postId, post.userId, post.content);
      } catch (error) {
        console.error('Failed to sync post:', error);
      }
    }
    
    localStorage.removeItem('pending_posts');
  }
}

// ì‚¬ìš© ì˜ˆì‹œ
const feedService = new FeedService('postgresql://localhost:5432/social_media');

// ì •ìƒ ìƒí™©
const feed = await feedService.getFeed('user123');
const postId = await feedService.createPost('user123', 'Hello World!');

// ë„¤íŠ¸ì›Œí¬ ë¶„í•  ì‹œë®¬ë ˆì´ì…˜
feedService.simulatePartition();
const feedDuringPartition = await feedService.getFeed('user123'); // ìºì‹œëœ ë°ì´í„° ë°˜í™˜
const postIdDuringPartition = await feedService.createPost('user123', 'Partition post'); // ë¡œì»¬ ì €ì¥
```

### 4. Partition Tolerance ì‹œë®¬ë ˆì´ì…˜ ì‹œìŠ¤í…œ

```typescript
// src/cap-demo/partition-simulator/PartitionSimulator.ts
import { EventEmitter } from 'events';

export class PartitionSimulator extends EventEmitter {
  private partitions: Map<string, boolean> = new Map();
  private nodes: string[] = [];

  constructor(nodes: string[]) {
    super();
    this.nodes = nodes;
    this.initializeNodes();
  }

  private initializeNodes(): void {
    this.nodes.forEach(node => {
      this.partitions.set(node, false);
    });
  }

  // íŠ¹ì • ë…¸ë“œë“¤ì„ ë¶„í•  ìƒíƒœë¡œ ì„¤ì •
  createPartition(partitionedNodes: string[]): void {
    partitionedNodes.forEach(node => {
      if (this.nodes.includes(node)) {
        this.partitions.set(node, true);
      }
    });
    
    console.log(`ğŸš¨ Partition created: ${partitionedNodes.join(', ')} are isolated`);
    this.emit('partition-created', partitionedNodes);
  }

  // ë¶„í•  í•´ê²°
  resolvePartition(): void {
    this.nodes.forEach(node => {
      this.partitions.set(node, false);
    });
    
    console.log('âœ… All partitions resolved');
    this.emit('partition-resolved');
  }

  // íŠ¹ì • ë…¸ë“œê°€ ë¶„í•  ìƒíƒœì¸ì§€ í™•ì¸
  isNodePartitioned(node: string): boolean {
    return this.partitions.get(node) || false;
  }

  // ë¶„í• ëœ ë…¸ë“œë“¤ ëª©ë¡ ë°˜í™˜
  getPartitionedNodes(): string[] {
    return this.nodes.filter(node => this.partitions.get(node));
  }

  // ì •ìƒ ë…¸ë“œë“¤ ëª©ë¡ ë°˜í™˜
  getAvailableNodes(): string[] {
    return this.nodes.filter(node => !this.partitions.get(node));
  }

  // ë…¸ë“œ ê°„ í†µì‹  ê°€ëŠ¥ ì—¬ë¶€ í™•ì¸
  canCommunicate(node1: string, node2: string): boolean {
    const node1Partitioned = this.isNodePartitioned(node1);
    const node2Partitioned = this.isNodePartitioned(node2);
    
    // ë‘˜ ë‹¤ ë¶„í• ë˜ì§€ ì•Šì•˜ê±°ë‚˜, ë‘˜ ë‹¤ ê°™ì€ ë¶„í•  ê·¸ë£¹ì— ìˆì–´ì•¼ í†µì‹  ê°€ëŠ¥
    return !node1Partitioned && !node2Partitioned;
  }

  // ëœë¤ ë¶„í•  ì‹œë®¬ë ˆì´ì…˜
  simulateRandomPartition(): void {
    const numPartitions = Math.floor(Math.random() * 3) + 1; // 1-3ê°œ ë¶„í• 
    const partitionedNodes: string[] = [];
    
    for (let i = 0; i < numPartitions; i++) {
      const randomNode = this.nodes[Math.floor(Math.random() * this.nodes.length)];
      if (!partitionedNodes.includes(randomNode)) {
        partitionedNodes.push(randomNode);
      }
    }
    
    if (partitionedNodes.length > 0) {
      this.createPartition(partitionedNodes);
    }
  }

  // ë¶„í•  ë³µêµ¬ ì‹œë®¬ë ˆì´ì…˜
  simulatePartitionRecovery(): void {
    setTimeout(() => {
      this.resolvePartition();
    }, Math.random() * 10000 + 5000); // 5-15ì´ˆ í›„ ë³µêµ¬
  }
}

// CAP ì •ë¦¬ ë°ëª¨ ì• í”Œë¦¬ì¼€ì´ì…˜
export class CAPTheoremDemo {
  private bankingService: BankingService;
  private feedService: FeedService;
  private partitionSimulator: PartitionSimulator;

  constructor() {
    this.bankingService = new BankingService('postgresql://localhost:5432/banking');
    this.feedService = new FeedService('postgresql://localhost:5432/social_media');
    this.partitionSimulator = new PartitionSimulator([
      'node1', 'node2', 'node3', 'node4', 'node5'
    ]);

    this.setupEventHandlers();
  }

  private setupEventHandlers(): void {
    this.partitionSimulator.on('partition-created', (partitionedNodes) => {
      console.log(`\nğŸ“Š CAP Theorem Demo - Partition Created`);
      console.log(`Partitioned nodes: ${partitionedNodes.join(', ')}`);
      this.demonstrateCAPTradeoffs();
    });

    this.partitionSimulator.on('partition-resolved', () => {
      console.log(`\nğŸ“Š CAP Theorem Demo - Partition Resolved`);
      this.demonstrateCAPTradeoffs();
    });
  }

  async demonstrateCAPTradeoffs(): Promise<void> {
    console.log('\n=== CAP Theorem Demonstration ===');
    
    // 1. Consistency ìš°ì„  ì‹œìŠ¤í…œ (ì€í–‰)
    console.log('\n1. Banking System (Consistency + Partition Tolerance)');
    try {
      await this.bankingService.transferMoney('account1', 'account2', 100);
      console.log('âœ… Banking transaction successful');
    } catch (error) {
      console.log('âŒ Banking transaction failed:', error.message);
    }

    // 2. Availability ìš°ì„  ì‹œìŠ¤í…œ (ì†Œì…œ ë¯¸ë””ì–´)
    console.log('\n2. Social Media Feed (Availability + Partition Tolerance)');
    try {
      const feed = await this.feedService.getFeed('user123');
      console.log('âœ… Feed retrieved successfully, posts:', feed.length);
    } catch (error) {
      console.log('âŒ Feed retrieval failed:', error.message);
    }

    // 3. ì‹œìŠ¤í…œ ìƒíƒœ ìš”ì•½
    console.log('\n3. System Status Summary');
    console.log(`Available nodes: ${this.partitionSimulator.getAvailableNodes().length}`);
    console.log(`Partitioned nodes: ${this.partitionSimulator.getPartitionedNodes().length}`);
  }

  async runDemo(): Promise<void> {
    console.log('ğŸš€ Starting CAP Theorem Demonstration');
    
    // ì´ˆê¸° ìƒíƒœ
    await this.demonstrateCAPTradeoffs();
    
    // ë¶„í•  ì‹œë®¬ë ˆì´ì…˜
    setTimeout(() => {
      this.partitionSimulator.simulateRandomPartition();
    }, 3000);
    
    // ë¶„í•  ë³µêµ¬ ì‹œë®¬ë ˆì´ì…˜
    setTimeout(() => {
      this.partitionSimulator.simulatePartitionRecovery();
    }, 8000);
  }
}

// ì‹¤í–‰ ì˜ˆì‹œ
const demo = new CAPTheoremDemo();
demo.runDemo();
```

### 5. CAP ì •ë¦¬ ì‹¤ì¦ í”„ë¡œì íŠ¸ ì‹¤í–‰ ê°€ì´ë“œ

```bash
# í”„ë¡œì íŠ¸ êµ¬ì¡°
cap-demo/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ cap-demo/
â”‚   â”‚   â”œâ”€â”€ banking-system/
â”‚   â”‚   â”‚   â”œâ”€â”€ BankingService.ts
â”‚   â”‚   â”‚   â””â”€â”€ BankingController.ts
â”‚   â”‚   â”œâ”€â”€ social-media/
â”‚   â”‚   â”‚   â”œâ”€â”€ FeedService.ts
â”‚   â”‚   â”‚   â””â”€â”€ FeedController.ts
â”‚   â”‚   â””â”€â”€ partition-simulator/
â”‚   â”‚       â”œâ”€â”€ PartitionSimulator.ts
â”‚   â”‚       â””â”€â”€ CAPTheoremDemo.ts
â”‚   â””â”€â”€ index.ts
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ package.json
â””â”€â”€ README.md

# ì‹¤í–‰ ë°©ë²•
npm install
npm run build
npm run demo

# Dockerë¡œ ì‹¤í–‰
docker-compose up -d
```

---

## í™•ì¥ ê°€ëŠ¥í•œ ì‹œìŠ¤í…œ ì„¤ê³„ ì›ì¹™

### 1. í™•ì¥ì„±ì˜ ì¢…ë¥˜

### 1. í™•ì¥ì„±ì˜ ì¢…ë¥˜

#### ìˆ˜í‰ í™•ì¥ (Horizontal Scaling)
```
ë‹¨ì¼ ì„œë²„ â†’ ì—¬ëŸ¬ ì„œë²„ë¡œ ë¶„ì‚°
ì¥ì : ë¬´ì œí•œ í™•ì¥ ê°€ëŠ¥, ì¥ì•  ê²©ë¦¬
ë‹¨ì : ë³µì¡í•œ ë°ì´í„° ë™ê¸°í™”, ë„¤íŠ¸ì›Œí¬ ì˜¤ë²„í—¤ë“œ
```

#### ìˆ˜ì§ í™•ì¥ (Vertical Scaling)
```
ì„œë²„ ì„±ëŠ¥ í–¥ìƒ (CPU, ë©”ëª¨ë¦¬, ìŠ¤í† ë¦¬ì§€)
ì¥ì : ë‹¨ìˆœí•œ êµ¬ì¡°, ë°ì´í„° ì¼ê´€ì„±
ë‹¨ì : ë¬¼ë¦¬ì  í•œê³„, ë‹¨ì¼ ì¥ì• ì 
```

### 2. ì‹œìŠ¤í…œ ì„¤ê³„ ì›ì¹™

#### ë‹¨ì¼ ì±…ì„ ì›ì¹™ (Single Responsibility)
```javascript
// âŒ ì˜ëª»ëœ ì˜ˆì‹œ: ì—¬ëŸ¬ ì±…ì„ì„ ê°€ì§„ í´ë˜ìŠ¤
class UserService {
  createUser(userData) { /* ì‚¬ìš©ì ìƒì„± */ }
  sendEmail(email) { /* ì´ë©”ì¼ ë°œì†¡ */ }
  logActivity(activity) { /* í™œë™ ë¡œê¹… */ }
  validatePassword(password) { /* ë¹„ë°€ë²ˆí˜¸ ê²€ì¦ */ }
}

// âœ… ì˜¬ë°”ë¥¸ ì˜ˆì‹œ: ë‹¨ì¼ ì±…ì„ì„ ê°€ì§„ í´ë˜ìŠ¤ë“¤
class UserService {
  createUser(userData) { /* ì‚¬ìš©ì ìƒì„±ë§Œ ë‹´ë‹¹ */ }
}

class EmailService {
  sendEmail(email) { /* ì´ë©”ì¼ ë°œì†¡ë§Œ ë‹´ë‹¹ */ }
}

class ActivityLogger {
  logActivity(activity) { /* ë¡œê¹…ë§Œ ë‹´ë‹¹ */ }
}

class PasswordValidator {
  validatePassword(password) { /* ë¹„ë°€ë²ˆí˜¸ ê²€ì¦ë§Œ ë‹´ë‹¹ */ }
}
```

#### ëŠìŠ¨í•œ ê²°í•© (Loose Coupling)
```javascript
// âŒ ê°•í•œ ê²°í•©
class OrderService {
  constructor() {
    this.emailService = new EmailService(); // ì§ì ‘ ì˜ì¡´
    this.paymentService = new PaymentService(); // ì§ì ‘ ì˜ì¡´
  }
}

// âœ… ëŠìŠ¨í•œ ê²°í•© (ì˜ì¡´ì„± ì£¼ì…)
class OrderService {
  constructor(emailService, paymentService) {
    this.emailService = emailService;
    this.paymentService = paymentService;
  }
}

// ì‚¬ìš© ì‹œ
const emailService = new EmailService();
const paymentService = new PaymentService();
const orderService = new OrderService(emailService, paymentService);
```

#### ë†’ì€ ì‘ì§‘ì„± (High Cohesion)
```javascript
// âœ… ë†’ì€ ì‘ì§‘ì„±: ê´€ë ¨ëœ ê¸°ëŠ¥ë“¤ì´ í•¨ê»˜ ëª¨ì—¬ìˆìŒ
class UserProfileManager {
  // ì‚¬ìš©ì í”„ë¡œí•„ê³¼ ê´€ë ¨ëœ ëª¨ë“  ê¸°ëŠ¥
  updateProfile(userId, profileData) { }
  getProfile(userId) { }
  validateProfile(profileData) { }
  uploadAvatar(userId, imageData) { }
  deleteProfile(userId) { }
}
```

### 3. ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ ì•„í‚¤í…ì²˜ íŒ¨í„´

#### API Gateway íŒ¨í„´
```javascript
// API Gateway êµ¬í˜„ ì˜ˆì‹œ
class APIGateway {
  constructor() {
    this.services = {
      user: new UserService(),
      product: new ProductService(),
      order: new OrderService()
    };
  }

  async routeRequest(path, method, data) {
    const [service, endpoint] = this.parsePath(path);
    
    if (!this.services[service]) {
      throw new Error(`Service ${service} not found`);
    }

    // ì¸ì¦/ì¸ê°€ ì²´í¬
    await this.authenticate(data.token);
    
    // ì„œë¹„ìŠ¤ë¡œ ë¼ìš°íŒ…
    return await this.services[service][endpoint](data);
  }

  parsePath(path) {
    const parts = path.split('/').filter(p => p);
    return [parts[1], parts[2]]; // /api/user/profile -> ['user', 'profile']
  }
}
```

#### Circuit Breaker íŒ¨í„´
```javascript
class CircuitBreaker {
  constructor(threshold = 5, timeout = 60000) {
    this.failureThreshold = threshold;
    this.timeout = timeout;
    this.failureCount = 0;
    this.lastFailureTime = null;
    this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN
  }

  async execute(operation) {
    if (this.state === 'OPEN') {
      if (Date.now() - this.lastFailureTime > this.timeout) {
        this.state = 'HALF_OPEN';
      } else {
        throw new Error('Circuit breaker is OPEN');
      }
    }

    try {
      const result = await operation();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }

  onSuccess() {
    this.failureCount = 0;
    this.state = 'CLOSED';
  }

  onFailure() {
    this.failureCount++;
    this.lastFailureTime = Date.now();
    
    if (this.failureCount >= this.failureThreshold) {
      this.state = 'OPEN';
    }
  }
}
```

---

## ê³ ê¸‰ ë¡œë“œ ë°¸ëŸ°ì‹± ì „ëµ

### 1. ë¡œë“œ ë°¸ëŸ°ì‹± ì•Œê³ ë¦¬ì¦˜

#### Round Robin (ë¼ìš´ë“œ ë¡œë¹ˆ)
```javascript
class RoundRobinLoadBalancer {
  constructor(servers) {
    this.servers = servers;
    this.currentIndex = 0;
  }

  getNextServer() {
    const server = this.servers[this.currentIndex];
    this.currentIndex = (this.currentIndex + 1) % this.servers.length;
    return server;
  }
}

// ì‚¬ìš© ì˜ˆì‹œ
const servers = ['server1:3000', 'server2:3000', 'server3:3000'];
const lb = new RoundRobinLoadBalancer(servers);

console.log(lb.getNextServer()); // server1:3000
console.log(lb.getNextServer()); // server2:3000
console.log(lb.getNextServer()); // server3:3000
console.log(lb.getNextServer()); // server1:3000 (ìˆœí™˜)
```

#### Least Connections (ìµœì†Œ ì—°ê²°)
```javascript
class LeastConnectionsLoadBalancer {
  constructor(servers) {
    this.servers = servers.map(server => ({
      url: server,
      connections: 0
    }));
  }

  getNextServer() {
    // ì—°ê²° ìˆ˜ê°€ ê°€ì¥ ì ì€ ì„œë²„ ì„ íƒ
    const server = this.servers.reduce((min, current) => 
      current.connections < min.connections ? current : min
    );
    
    server.connections++;
    return server.url;
  }

  releaseConnection(serverUrl) {
    const server = this.servers.find(s => s.url === serverUrl);
    if (server && server.connections > 0) {
      server.connections--;
    }
  }
}
```

#### Weighted Round Robin (ê°€ì¤‘ì¹˜ ë¼ìš´ë“œ ë¡œë¹ˆ)
```javascript
class WeightedRoundRobinLoadBalancer {
  constructor(servers) {
    this.servers = servers.map(server => ({
      url: server.url,
      weight: server.weight,
      currentWeight: 0,
      effectiveWeight: server.weight,
      isHealthy: true
    }));
  }

  getNextServer() {
    let totalWeight = 0;
    let selectedServer = null;

    // ëª¨ë“  ì„œë²„ì˜ ê°€ì¤‘ì¹˜ë¥¼ í˜„ì¬ ê°€ì¤‘ì¹˜ì— ì¶”ê°€
    for (const server of this.servers) {
      if (!server.isHealthy) continue;
      
      server.currentWeight += server.effectiveWeight;
      totalWeight += server.effectiveWeight;

      if (!selectedServer || server.currentWeight > selectedServer.currentWeight) {
        selectedServer = server;
      }
    }

    if (!selectedServer) {
      throw new Error('No healthy servers available');
    }

    // ì„ íƒëœ ì„œë²„ì˜ í˜„ì¬ ê°€ì¤‘ì¹˜ì—ì„œ ì „ì²´ ê°€ì¤‘ì¹˜ë¥¼ ëºŒ
    selectedServer.currentWeight -= totalWeight;
    
    return selectedServer.url;
  }

  // ì„œë²„ ìƒíƒœ ì—…ë°ì´íŠ¸
  updateServerHealth(serverUrl, isHealthy) {
    const server = this.servers.find(s => s.url === serverUrl);
    if (server) {
      server.isHealthy = isHealthy;
      if (isHealthy) {
        server.effectiveWeight = server.weight;
      } else {
        server.effectiveWeight = 0;
      }
    }
  }
}

// ì‚¬ìš© ì˜ˆì‹œ
const servers = [
  { url: 'server1:3000', weight: 3 },
  { url: 'server2:3000', weight: 2 },
  { url: 'server3:3000', weight: 1 }
];
const lb = new WeightedRoundRobinLoadBalancer(servers);
```

#### Least Response Time (ìµœì†Œ ì‘ë‹µ ì‹œê°„)
```javascript
class LeastResponseTimeLoadBalancer {
  constructor(servers) {
    this.servers = servers.map(server => ({
      url: server.url,
      responseTime: 0,
      requestCount: 0,
      totalResponseTime: 0,
      isHealthy: true,
      lastHealthCheck: Date.now()
    }));
    this.healthCheckInterval = 30000; // 30ì´ˆë§ˆë‹¤ í—¬ìŠ¤ì²´í¬
    this.startHealthCheck();
  }

  getNextServer() {
    const healthyServers = this.servers.filter(server => server.isHealthy);
    
    if (healthyServers.length === 0) {
      throw new Error('No healthy servers available');
    }

    // ì‘ë‹µ ì‹œê°„ì´ ê°€ì¥ ì§§ì€ ì„œë²„ ì„ íƒ
    const selectedServer = healthyServers.reduce((min, current) => 
      current.responseTime < min.responseTime ? current : min
    );

    return selectedServer.url;
  }

  // ì‘ë‹µ ì‹œê°„ ê¸°ë¡
  recordResponseTime(serverUrl, responseTime) {
    const server = this.servers.find(s => s.url === serverUrl);
    if (server) {
      server.requestCount++;
      server.totalResponseTime += responseTime;
      server.responseTime = server.totalResponseTime / server.requestCount;
    }
  }

  // í—¬ìŠ¤ì²´í¬ ì‹œì‘
  startHealthCheck() {
    setInterval(() => {
      this.performHealthCheck();
    }, this.healthCheckInterval);
  }

  // í—¬ìŠ¤ì²´í¬ ìˆ˜í–‰
  async performHealthCheck() {
    const healthCheckPromises = this.servers.map(async (server) => {
      try {
        const startTime = Date.now();
        const response = await fetch(`http://${server.url}/health`, {
          method: 'GET',
          timeout: 5000
        });
        const responseTime = Date.now() - startTime;
        
        if (response.ok) {
          server.isHealthy = true;
          server.lastHealthCheck = Date.now();
          this.recordResponseTime(server.url, responseTime);
        } else {
          server.isHealthy = false;
        }
      } catch (error) {
        server.isHealthy = false;
        console.warn(`Health check failed for ${server.url}:`, error.message);
      }
    });

    await Promise.all(healthCheckPromises);
  }

  // ì„œë²„ ìƒíƒœ ì •ë³´ ë°˜í™˜
  getServerStats() {
    return this.servers.map(server => ({
      url: server.url,
      isHealthy: server.isHealthy,
      responseTime: server.responseTime,
      requestCount: server.requestCount,
      lastHealthCheck: server.lastHealthCheck
    }));
  }
}

// ì‚¬ìš© ì˜ˆì‹œ
const servers = ['server1:3000', 'server2:3000', 'server3:3000'];
const lb = new LeastResponseTimeLoadBalancer(servers);

// ìš”ì²­ ì²˜ë¦¬
async function handleRequest() {
  try {
    const serverUrl = lb.getNextServer();
    const startTime = Date.now();
    
    const response = await fetch(`http://${serverUrl}/api/data`);
    const responseTime = Date.now() - startTime;
    
    lb.recordResponseTime(serverUrl, responseTime);
    
    return response;
  } catch (error) {
    console.error('Request failed:', error);
    throw error;
  }
}
```

#### Health Check ê¸°ë°˜ ë¼ìš°íŒ…
```javascript
class HealthCheckLoadBalancer {
  constructor(servers, options = {}) {
    this.servers = servers.map(server => ({
      url: server.url,
      weight: server.weight || 1,
      isHealthy: true,
      consecutiveFailures: 0,
      lastHealthCheck: Date.now(),
      responseTime: 0,
      circuitBreakerState: 'CLOSED' // CLOSED, OPEN, HALF_OPEN
    }));
    
    this.options = {
      healthCheckPath: options.healthCheckPath || '/health',
      healthCheckInterval: options.healthCheckInterval || 10000,
      healthCheckTimeout: options.healthCheckTimeout || 5000,
      failureThreshold: options.failureThreshold || 3,
      recoveryThreshold: options.recoveryThreshold || 2,
      circuitBreakerTimeout: options.circuitBreakerTimeout || 30000,
      ...options
    };
    
    this.startHealthCheck();
  }

  getNextServer() {
    const healthyServers = this.servers.filter(server => 
      server.isHealthy && server.circuitBreakerState === 'CLOSED'
    );
    
    if (healthyServers.length === 0) {
      // ëª¨ë“  ì„œë²„ê°€ ë¶ˆê±´ì „í•œ ê²½ìš°, ì ˆë°˜ ì—´ë¦° ìƒíƒœì˜ ì„œë²„ë„ ê³ ë ¤
      const halfOpenServers = this.servers.filter(server => 
        server.circuitBreakerState === 'HALF_OPEN'
      );
      
      if (halfOpenServers.length > 0) {
        return this.selectServerByWeight(halfOpenServers);
      }
      
      throw new Error('No healthy servers available');
    }

    return this.selectServerByWeight(healthyServers);
  }

  selectServerByWeight(servers) {
    const totalWeight = servers.reduce((sum, server) => sum + server.weight, 0);
    let random = Math.random() * totalWeight;
    
    for (const server of servers) {
      random -= server.weight;
      if (random <= 0) {
        return server.url;
      }
    }
    
    return servers[0].url; // fallback
  }

  // í—¬ìŠ¤ì²´í¬ ì‹œì‘
  startHealthCheck() {
    setInterval(() => {
      this.performHealthCheck();
    }, this.options.healthCheckInterval);
  }

  // í—¬ìŠ¤ì²´í¬ ìˆ˜í–‰
  async performHealthCheck() {
    const healthCheckPromises = this.servers.map(async (server) => {
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), this.options.healthCheckTimeout);
        
        const startTime = Date.now();
        const response = await fetch(`http://${server.url}${this.options.healthCheckPath}`, {
          method: 'GET',
          signal: controller.signal,
          headers: {
            'User-Agent': 'HealthCheck-LoadBalancer/1.0'
          }
        });
        
        clearTimeout(timeoutId);
        const responseTime = Date.now() - startTime;
        
        if (response.ok) {
          this.handleHealthCheckSuccess(server, responseTime);
        } else {
          this.handleHealthCheckFailure(server);
        }
      } catch (error) {
        this.handleHealthCheckFailure(server);
      }
    });

    await Promise.all(healthCheckPromises);
  }

  handleHealthCheckSuccess(server, responseTime) {
    server.consecutiveFailures = 0;
    server.responseTime = responseTime;
    server.lastHealthCheck = Date.now();
    
    if (server.circuitBreakerState === 'HALF_OPEN') {
      server.circuitBreakerState = 'CLOSED';
      console.log(`Circuit breaker closed for ${server.url}`);
    }
    
    if (!server.isHealthy) {
      server.isHealthy = true;
      console.log(`Server ${server.url} is now healthy`);
    }
  }

  handleHealthCheckFailure(server) {
    server.consecutiveFailures++;
    server.lastHealthCheck = Date.now();
    
    if (server.consecutiveFailures >= this.options.failureThreshold) {
      server.isHealthy = false;
      server.circuitBreakerState = 'OPEN';
      console.log(`Circuit breaker opened for ${server.url}`);
      
      // ì¼ì • ì‹œê°„ í›„ ì ˆë°˜ ì—´ë¦° ìƒíƒœë¡œ ì „í™˜
      setTimeout(() => {
        if (server.circuitBreakerState === 'OPEN') {
          server.circuitBreakerState = 'HALF_OPEN';
          console.log(`Circuit breaker half-opened for ${server.url}`);
        }
      }, this.options.circuitBreakerTimeout);
    }
  }

  // ì„œë²„ ìƒíƒœ ì •ë³´ ë°˜í™˜
  getServerStats() {
    return this.servers.map(server => ({
      url: server.url,
      isHealthy: server.isHealthy,
      circuitBreakerState: server.circuitBreakerState,
      consecutiveFailures: server.consecutiveFailures,
      responseTime: server.responseTime,
      lastHealthCheck: server.lastHealthCheck
    }));
  }

  // ìˆ˜ë™ìœ¼ë¡œ ì„œë²„ ìƒíƒœ ë³€ê²½
  setServerHealth(serverUrl, isHealthy) {
    const server = this.servers.find(s => s.url === serverUrl);
    if (server) {
      server.isHealthy = isHealthy;
      server.consecutiveFailures = isHealthy ? 0 : server.consecutiveFailures;
      server.circuitBreakerState = isHealthy ? 'CLOSED' : 'OPEN';
    }
  }
}

// ì‚¬ìš© ì˜ˆì‹œ
const servers = [
  { url: 'server1:3000', weight: 3 },
  { url: 'server2:3000', weight: 2 },
  { url: 'server3:3000', weight: 1 }
];

const lb = new HealthCheckLoadBalancer(servers, {
  healthCheckPath: '/health',
  healthCheckInterval: 5000,
  failureThreshold: 2,
  circuitBreakerTimeout: 10000
});

// ìš”ì²­ ì²˜ë¦¬
async function handleRequest() {
  try {
    const serverUrl = lb.getNextServer();
    const response = await fetch(`http://${serverUrl}/api/data`);
    return response;
  } catch (error) {
    console.error('Request failed:', error);
    throw error;
  }
}

// ì„œë²„ ìƒíƒœ ëª¨ë‹ˆí„°ë§
setInterval(() => {
  const stats = lb.getServerStats();
  console.log('Server Stats:', stats);
}, 10000);
```

### 2. Nginx ë¡œë“œ ë°¸ëŸ°ì‹± ì„¤ì •

```nginx
# nginx.conf
upstream backend {
    # ë¼ìš´ë“œ ë¡œë¹ˆ (ê¸°ë³¸ê°’)
    server 127.0.0.1:3001;
    server 127.0.0.1:3002;
    
    # ê°€ì¤‘ì¹˜ ê¸°ë°˜
    server 127.0.0.1:3003 weight=3;
    server 127.0.0.1:3004 weight=1;
    
    # ìµœì†Œ ì—°ê²° ìˆ˜ ê¸°ë°˜
    least_conn;
    server 127.0.0.1:3005;
    server 127.0.0.1:3006;
    
    # IP í•´ì‹œ ê¸°ë°˜ (ì„¸ì…˜ ìœ ì§€)
    ip_hash;
    server 127.0.0.1:3007;
    server 127.0.0.1:3008;
    
    # í—¬ìŠ¤ ì²´í¬
    server 127.0.0.1:3009 max_fails=3 fail_timeout=30s;
}

server {
    listen 80;
    server_name api.example.com;
    
    location / {
        proxy_pass http://backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        
        # íƒ€ì„ì•„ì›ƒ ì„¤ì •
        proxy_connect_timeout 5s;
        proxy_send_timeout 10s;
        proxy_read_timeout 10s;
    }
}
```

### 3. AWS ë¡œë“œ ë°¸ëŸ°ì‹±

#### Application Load Balancer (ALB)
```yaml
# ALB ì„¤ì • ì˜ˆì‹œ
apiVersion: v1
kind: Service
metadata:
  name: nodejs-app-service
  annotations:
    service.beta.kubernetes.io/aws-load-balancer-type: "nlb"
spec:
  type: LoadBalancer
  ports:
  - port: 80
    targetPort: 3000
    protocol: TCP
  selector:
    app: nodejs-app
```

---

## ë¶„ì‚° ë½ êµ¬í˜„

### 1. Redis ê¸°ë°˜ ë¶„ì‚° ë½

```typescript
// src/distributed-lock/RedisDistributedLock.ts
import Redis from 'ioredis';

export interface LockOptions {
  ttl?: number; // ë½ ë§Œë£Œ ì‹œê°„ (ë°€ë¦¬ì´ˆ)
  retryDelay?: number; // ì¬ì‹œë„ ê°„ê²© (ë°€ë¦¬ì´ˆ)
  maxRetries?: number; // ìµœëŒ€ ì¬ì‹œë„ íšŸìˆ˜
  retryJitter?: boolean; // ì¬ì‹œë„ ì§€í„° ì ìš© ì—¬ë¶€
}

export class RedisDistributedLock {
  private redis: Redis;
  private lockKey: string;
  private lockValue: string;
  private ttl: number;
  private retryDelay: number;
  private maxRetries: number;
  private retryJitter: boolean;
  private isLocked: boolean = false;
  private lockTimer?: NodeJS.Timeout;

  constructor(
    redis: Redis,
    lockKey: string,
    options: LockOptions = {}
  ) {
    this.redis = redis;
    this.lockKey = lockKey;
    this.lockValue = this.generateLockValue();
    this.ttl = options.ttl || 30000; // 30ì´ˆ ê¸°ë³¸ê°’
    this.retryDelay = options.retryDelay || 100; // 100ms ê¸°ë³¸ê°’
    this.maxRetries = options.maxRetries || 10; // 10íšŒ ê¸°ë³¸ê°’
    this.retryJitter = options.retryJitter !== false; // ê¸°ë³¸ê°’ true
  }

  // ë½ íšë“
  async acquire(): Promise<boolean> {
    for (let attempt = 0; attempt <= this.maxRetries; attempt++) {
      try {
        // SET ëª…ë ¹ì–´ë¡œ ì›ìì  ë½ íšë“ ì‹œë„
        const result = await this.redis.set(
          this.lockKey,
          this.lockValue,
          'PX', // ë°€ë¦¬ì´ˆ ë‹¨ìœ„ TTL
          this.ttl,
          'NX' // í‚¤ê°€ ì¡´ì¬í•˜ì§€ ì•Šì„ ë•Œë§Œ ì„¤ì •
        );

        if (result === 'OK') {
          this.isLocked = true;
          this.startLockRenewal();
          console.log(`Lock acquired: ${this.lockKey}`);
          return true;
        }

        // ë½ íšë“ ì‹¤íŒ¨ ì‹œ ì¬ì‹œë„
        if (attempt < this.maxRetries) {
          const delay = this.calculateRetryDelay(attempt);
          await this.sleep(delay);
        }
      } catch (error) {
        console.error(`Lock acquisition attempt ${attempt + 1} failed:`, error);
        if (attempt === this.maxRetries) {
          throw error;
        }
      }
    }

    return false;
  }

  // ë½ í•´ì œ
  async release(): Promise<boolean> {
    if (!this.isLocked) {
      return false;
    }

    try {
      // Lua ìŠ¤í¬ë¦½íŠ¸ë¡œ ì›ìì  ë½ í•´ì œ
      const script = `
        if redis.call("GET", KEYS[1]) == ARGV[1] then
          return redis.call("DEL", KEYS[1])
        else
          return 0
        end
      `;

      const result = await this.redis.eval(script, 1, this.lockKey, this.lockValue);
      
      if (result === 1) {
        this.isLocked = false;
        this.stopLockRenewal();
        console.log(`Lock released: ${this.lockKey}`);
        return true;
      } else {
        console.warn(`Lock release failed - lock value mismatch: ${this.lockKey}`);
        return false;
      }
    } catch (error) {
      console.error(`Lock release failed:`, error);
      return false;
    }
  }

  // ë½ ì—°ì¥
  async extend(newTtl: number): Promise<boolean> {
    if (!this.isLocked) {
      return false;
    }

    try {
      const script = `
        if redis.call("GET", KEYS[1]) == ARGV[1] then
          return redis.call("PEXPIRE", KEYS[1], ARGV[2])
        else
          return 0
        end
      `;

      const result = await this.redis.eval(script, 1, this.lockKey, this.lockValue, newTtl);
      return result === 1;
    } catch (error) {
      console.error(`Lock extension failed:`, error);
      return false;
    }
  }

  // ë½ ìƒíƒœ í™•ì¸
  async isAcquired(): Promise<boolean> {
    try {
      const value = await this.redis.get(this.lockKey);
      return value === this.lockValue;
    } catch (error) {
      console.error(`Lock status check failed:`, error);
      return false;
    }
  }

  // ë½ ìë™ ì—°ì¥ ì‹œì‘
  private startLockRenewal(): void {
    const renewalInterval = Math.floor(this.ttl * 0.7); // TTLì˜ 70%ë§ˆë‹¤ ì—°ì¥
    
    this.lockTimer = setInterval(async () => {
      if (this.isLocked) {
        const success = await this.extend(this.ttl);
        if (!success) {
          console.warn(`Lock renewal failed: ${this.lockKey}`);
          this.isLocked = false;
          this.stopLockRenewal();
        }
      }
    }, renewalInterval);
  }

  // ë½ ìë™ ì—°ì¥ ì¤‘ì§€
  private stopLockRenewal(): void {
    if (this.lockTimer) {
      clearInterval(this.lockTimer);
      this.lockTimer = undefined;
    }
  }

  // ì¬ì‹œë„ ì§€ì—° ì‹œê°„ ê³„ì‚°
  private calculateRetryDelay(attempt: number): number {
    let delay = this.retryDelay * Math.pow(2, attempt); // ì§€ìˆ˜ ë°±ì˜¤í”„
    
    if (this.retryJitter) {
      // ì§€í„° ì¶”ê°€ (Â±25%)
      const jitter = delay * 0.25 * (Math.random() * 2 - 1);
      delay += jitter;
    }
    
    return Math.min(delay, 1000); // ìµœëŒ€ 1ì´ˆ
  }

  // ê³ ìœ í•œ ë½ ê°’ ìƒì„±
  private generateLockValue(): string {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}-${process.pid}`;
  }

  // ëŒ€ê¸° í•¨ìˆ˜
  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  // ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  async cleanup(): Promise<void> {
    if (this.isLocked) {
      await this.release();
    }
  }
}

// ë¶„ì‚° ë½ ë§¤ë‹ˆì €
export class DistributedLockManager {
  private redis: Redis;
  private locks: Map<string, RedisDistributedLock> = new Map();

  constructor(redis: Redis) {
    this.redis = redis;
  }

  // ë½ ìƒì„± ë° íšë“
  async acquireLock(
    lockKey: string,
    options: LockOptions = {}
  ): Promise<RedisDistributedLock | null> {
    const lock = new RedisDistributedLock(this.redis, lockKey, options);
    const acquired = await lock.acquire();
    
    if (acquired) {
      this.locks.set(lockKey, lock);
      return lock;
    }
    
    return null;
  }

  // ë½ í•´ì œ
  async releaseLock(lockKey: string): Promise<boolean> {
    const lock = this.locks.get(lockKey);
    if (lock) {
      const released = await lock.release();
      this.locks.delete(lockKey);
      return released;
    }
    return false;
  }

  // ëª¨ë“  ë½ í•´ì œ
  async releaseAllLocks(): Promise<void> {
    const releasePromises = Array.from(this.locks.values()).map(lock => lock.release());
    await Promise.all(releasePromises);
    this.locks.clear();
  }

  // ë½ ìƒíƒœ í™•ì¸
  async isLockAcquired(lockKey: string): Promise<boolean> {
    const lock = this.locks.get(lockKey);
    if (lock) {
      return await lock.isAcquired();
    }
    return false;
  }
}

// ì‚¬ìš© ì˜ˆì‹œ
const redis = new Redis({
  host: 'localhost',
  port: 6379,
  retryDelayOnFailover: 100,
  maxRetriesPerRequest: 3
});

const lockManager = new DistributedLockManager(redis);

// ë½ì„ ì‚¬ìš©í•œ ì„ê³„ êµ¬ì—­ ë³´í˜¸
async function criticalSection(lockKey: string, operation: () => Promise<void>) {
  const lock = await lockManager.acquireLock(lockKey, {
    ttl: 10000, // 10ì´ˆ
    maxRetries: 5,
    retryDelay: 200
  });

  if (!lock) {
    throw new Error('Failed to acquire lock');
  }

  try {
    await operation();
  } finally {
    await lock.release();
  }
}

// ì‚¬ìš© ì˜ˆì‹œ
await criticalSection('user:123:update', async () => {
  // ì‚¬ìš©ì ì •ë³´ ì—…ë°ì´íŠ¸ ë¡œì§
  console.log('Updating user information...');
  await new Promise(resolve => setTimeout(resolve, 2000));
  console.log('User information updated');
});
```

---

## ë‹¤ì¸µ ìºì‹± ì „ëµ

### 1. ë‹¤ì¸µ ìºì‹œ ì•„í‚¤í…ì²˜

```typescript
// src/multi-layer-cache/MultiLayerCache.ts
import Redis from 'ioredis';
import { LRUCache } from 'lru-cache';

export interface CacheOptions {
  l1MaxSize?: number;
  l1Ttl?: number;
  l2Ttl?: number;
  l2Prefix?: string;
  enableL1?: boolean;
  enableL2?: boolean;
}

export interface CacheItem {
  value: any;
  timestamp: number;
  ttl: number;
}

export class MultiLayerCache {
  private l1Cache: LRUCache<string, CacheItem>;
  private l2Cache: Redis;
  private options: Required<CacheOptions>;

  constructor(redis: Redis, options: CacheOptions = {}) {
    this.options = {
      l1MaxSize: 1000,
      l1Ttl: 300000, // 5ë¶„
      l2Ttl: 3600000, // 1ì‹œê°„
      l2Prefix: 'cache:',
      enableL1: true,
      enableL2: true,
      ...options
    };

    // L1 ìºì‹œ (ë©”ëª¨ë¦¬) ì´ˆê¸°í™”
    this.l1Cache = new LRUCache<string, CacheItem>({
      max: this.options.l1MaxSize,
      ttl: this.options.l1Ttl,
      updateAgeOnGet: true,
      updateAgeOnHas: true
    });

    this.l2Cache = redis;
  }

  // ìºì‹œì—ì„œ ë°ì´í„° ì¡°íšŒ
  async get<T>(key: string): Promise<T | null> {
    // L1 ìºì‹œì—ì„œ ë¨¼ì € í™•ì¸
    if (this.options.enableL1) {
      const l1Item = this.l1Cache.get(key);
      if (l1Item && !this.isExpired(l1Item)) {
        console.log(`L1 cache hit: ${key}`);
        return l1Item.value;
      }
    }

    // L2 ìºì‹œì—ì„œ í™•ì¸
    if (this.options.enableL2) {
      try {
        const l2Key = this.getL2Key(key);
        const l2Value = await this.l2Cache.get(l2Key);
        
        if (l2Value) {
          const item: CacheItem = JSON.parse(l2Value);
          
          if (!this.isExpired(item)) {
            console.log(`L2 cache hit: ${key}`);
            
            // L1 ìºì‹œì— ì €ì¥
            if (this.options.enableL1) {
              this.l1Cache.set(key, item);
            }
            
            return item.value;
          } else {
            // ë§Œë£Œëœ ë°ì´í„° ì‚­ì œ
            await this.l2Cache.del(l2Key);
          }
        }
      } catch (error) {
        console.error(`L2 cache error for key ${key}:`, error);
      }
    }

    console.log(`Cache miss: ${key}`);
    return null;
  }

  // ìºì‹œì— ë°ì´í„° ì €ì¥
  async set(key: string, value: any, ttl?: number): Promise<void> {
    const item: CacheItem = {
      value,
      timestamp: Date.now(),
      ttl: ttl || this.options.l1Ttl
    };

    // L1 ìºì‹œì— ì €ì¥
    if (this.options.enableL1) {
      this.l1Cache.set(key, item);
    }

    // L2 ìºì‹œì— ì €ì¥
    if (this.options.enableL2) {
      try {
        const l2Key = this.getL2Key(key);
        const l2Ttl = Math.floor((ttl || this.options.l2Ttl) / 1000); // RedisëŠ” ì´ˆ ë‹¨ìœ„
        await this.l2Cache.setex(l2Key, l2Ttl, JSON.stringify(item));
      } catch (error) {
        console.error(`L2 cache set error for key ${key}:`, error);
      }
    }
  }

  // ìºì‹œì—ì„œ ë°ì´í„° ì‚­ì œ
  async del(key: string): Promise<void> {
    // L1 ìºì‹œì—ì„œ ì‚­ì œ
    if (this.options.enableL1) {
      this.l1Cache.delete(key);
    }

    // L2 ìºì‹œì—ì„œ ì‚­ì œ
    if (this.options.enableL2) {
      try {
        const l2Key = this.getL2Key(key);
        await this.l2Cache.del(l2Key);
      } catch (error) {
        console.error(`L2 cache delete error for key ${key}:`, error);
      }
    }
  }

  // ìºì‹œ ë¬´íš¨í™” (íŒ¨í„´ ê¸°ë°˜)
  async invalidatePattern(pattern: string): Promise<void> {
    // L1 ìºì‹œì—ì„œ íŒ¨í„´ ë§¤ì¹­ ì‚­ì œ
    if (this.options.enableL1) {
      const keys = Array.from(this.l1Cache.keys());
      const matchingKeys = keys.filter(key => this.matchesPattern(key, pattern));
      
      matchingKeys.forEach(key => {
        this.l1Cache.delete(key);
      });
    }

    // L2 ìºì‹œì—ì„œ íŒ¨í„´ ë§¤ì¹­ ì‚­ì œ
    if (this.options.enableL2) {
      try {
        const l2Pattern = this.getL2Key(pattern);
        const keys = await this.l2Cache.keys(l2Pattern);
        
        if (keys.length > 0) {
          await this.l2Cache.del(...keys);
        }
      } catch (error) {
        console.error(`L2 cache pattern invalidation error:`, error);
      }
    }
  }

  // ìºì‹œ ì›Œë°ì—…
  async warmup(keyValuePairs: Array<{ key: string; value: any; ttl?: number }>): Promise<void> {
    console.log(`Starting cache warmup for ${keyValuePairs.length} items`);
    
    const warmupPromises = keyValuePairs.map(async ({ key, value, ttl }) => {
      await this.set(key, value, ttl);
    });

    await Promise.all(warmupPromises);
    console.log('Cache warmup completed');
  }

  // ìºì‹œ í†µê³„
  getStats() {
    return {
      l1: {
        size: this.l1Cache.size,
        maxSize: this.options.l1MaxSize,
        hitRate: this.calculateHitRate()
      },
      l2: {
        enabled: this.options.enableL2
      }
    };
  }

  // L2 ìºì‹œ í‚¤ ìƒì„±
  private getL2Key(key: string): string {
    return `${this.options.l2Prefix}${key}`;
  }

  // ë§Œë£Œ í™•ì¸
  private isExpired(item: CacheItem): boolean {
    return Date.now() - item.timestamp > item.ttl;
  }

  // íŒ¨í„´ ë§¤ì¹­
  private matchesPattern(key: string, pattern: string): boolean {
    const regex = new RegExp(pattern.replace(/\*/g, '.*'));
    return regex.test(key);
  }

  // íˆíŠ¸ìœ¨ ê³„ì‚°
  private calculateHitRate(): number {
    // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” íˆíŠ¸/ë¯¸ìŠ¤ ì¹´ìš´í„°ë¥¼ ìœ ì§€í•´ì•¼ í•¨
    return 0.85; // ì˜ˆì‹œ ê°’
  }
}

// ìºì‹œ ë¬´íš¨í™” ì „ëµ
export class CacheInvalidationStrategy {
  private cache: MultiLayerCache;
  private invalidationRules: Map<string, string[]> = new Map();

  constructor(cache: MultiLayerCache) {
    this.cache = cache;
  }

  // ë¬´íš¨í™” ê·œì¹™ ë“±ë¡
  registerRule(entityType: string, cacheKeys: string[]): void {
    this.invalidationRules.set(entityType, cacheKeys);
  }

  // ì—”í‹°í‹° ë³€ê²½ ì‹œ ê´€ë ¨ ìºì‹œ ë¬´íš¨í™”
  async invalidateOnEntityChange(entityType: string, entityId: string): Promise<void> {
    const rules = this.invalidationRules.get(entityType);
    
    if (rules) {
      const invalidationPromises = rules.map(rule => {
        const pattern = rule.replace('{id}', entityId);
        return this.cache.invalidatePattern(pattern);
      });

      await Promise.all(invalidationPromises);
      console.log(`Cache invalidated for ${entityType}:${entityId}`);
    }
  }

  // ì‹œê°„ ê¸°ë°˜ ë¬´íš¨í™”
  async invalidateByTime(ttl: number): Promise<void> {
    // TTL ê¸°ë°˜ ìë™ ë§Œë£ŒëŠ” Redisì™€ LRU ìºì‹œì—ì„œ ìë™ ì²˜ë¦¬ë¨
    console.log(`Time-based invalidation set for ${ttl}ms`);
  }
}

// ìºì‹œ ì›Œë°ì—… ì „ëµ
export class CacheWarmupStrategy {
  private cache: MultiLayerCache;
  private dataSource: any; // ë°ì´í„° ì†ŒìŠ¤ (DB, API ë“±)

  constructor(cache: MultiLayerCache, dataSource: any) {
    this.cache = cache;
    this.dataSource = dataSource;
  }

  // ì¸ê¸° ë°ì´í„° ì›Œë°ì—…
  async warmupPopularData(): Promise<void> {
    console.log('Starting popular data warmup...');
    
    try {
      // ì¸ê¸° ì‚¬ìš©ì ë°ì´í„°
      const popularUsers = await this.dataSource.getPopularUsers(100);
      const userWarmupData = popularUsers.map(user => ({
        key: `user:${user.id}`,
        value: user,
        ttl: 3600000 // 1ì‹œê°„
      }));

      // ì¸ê¸° ìƒí’ˆ ë°ì´í„°
      const popularProducts = await this.dataSource.getPopularProducts(200);
      const productWarmupData = popularProducts.map(product => ({
        key: `product:${product.id}`,
        value: product,
        ttl: 1800000 // 30ë¶„
      }));

      // ì¸ê¸° ì¹´í…Œê³ ë¦¬ ë°ì´í„°
      const categories = await this.dataSource.getCategories();
      const categoryWarmupData = categories.map(category => ({
        key: `category:${category.id}`,
        value: category,
        ttl: 7200000 // 2ì‹œê°„
      }));

      // ëª¨ë“  ë°ì´í„° ì›Œë°ì—…
      await Promise.all([
        this.cache.warmup(userWarmupData),
        this.cache.warmup(productWarmupData),
        this.cache.warmup(categoryWarmupData)
      ]);

      console.log('Popular data warmup completed');
    } catch (error) {
      console.error('Popular data warmup failed:', error);
    }
  }

  // ì˜ˆì¸¡ì  ì›Œë°ì—…
  async predictiveWarmup(userId: string): Promise<void> {
    console.log(`Starting predictive warmup for user ${userId}`);
    
    try {
      // ì‚¬ìš©ì í–‰ë™ íŒ¨í„´ ë¶„ì„
      const userBehavior = await this.dataSource.getUserBehavior(userId);
      
      // ì¶”ì²œ ìƒí’ˆ ì›Œë°ì—…
      const recommendedProducts = await this.dataSource.getRecommendations(userId);
      const recommendationData = recommendedProducts.map(product => ({
        key: `recommendation:${userId}:${product.id}`,
        value: product,
        ttl: 1800000 // 30ë¶„
      }));

      // ì‚¬ìš©ì ê´€ì‹¬ì‚¬ ê¸°ë°˜ ì¹´í…Œê³ ë¦¬ ì›Œë°ì—…
      const interestCategories = await this.dataSource.getUserInterests(userId);
      const interestData = interestCategories.map(category => ({
        key: `interest:${userId}:${category.id}`,
        value: category,
        ttl: 3600000 // 1ì‹œê°„
      }));

      await Promise.all([
        this.cache.warmup(recommendationData),
        this.cache.warmup(interestData)
      ]);

      console.log(`Predictive warmup completed for user ${userId}`);
    } catch (error) {
      console.error(`Predictive warmup failed for user ${userId}:`, error);
    }
  }

  // ìŠ¤ì¼€ì¤„ëœ ì›Œë°ì—…
  startScheduledWarmup(): void {
    // ë§¤ì¼ ìƒˆë²½ 2ì‹œì— ì¸ê¸° ë°ì´í„° ì›Œë°ì—…
    const schedule = require('node-schedule');
    
    schedule.scheduleJob('0 2 * * *', async () => {
      console.log('Starting scheduled warmup...');
      await this.warmupPopularData();
    });

    // ë§¤ ì‹œê°„ë§ˆë‹¤ ì˜ˆì¸¡ì  ì›Œë°ì—… (í™œì„± ì‚¬ìš©ì ëŒ€ìƒ)
    schedule.scheduleJob('0 * * * *', async () => {
      console.log('Starting hourly predictive warmup...');
      const activeUsers = await this.dataSource.getActiveUsers(1000);
      
      const warmupPromises = activeUsers.map(user => 
        this.predictiveWarmup(user.id)
      );
      
      await Promise.all(warmupPromises);
    });
  }
}

// ì‚¬ìš© ì˜ˆì‹œ
const redis = new Redis({
  host: 'localhost',
  port: 6379
});

const cache = new MultiLayerCache(redis, {
  l1MaxSize: 2000,
  l1Ttl: 300000, // 5ë¶„
  l2Ttl: 3600000, // 1ì‹œê°„
  enableL1: true,
  enableL2: true
});

// ìºì‹œ ë¬´íš¨í™” ì „ëµ ì„¤ì •
const invalidationStrategy = new CacheInvalidationStrategy(cache);
invalidationStrategy.registerRule('user', [
  'user:{id}',
  'user:{id}:profile',
  'user:{id}:preferences'
]);
invalidationStrategy.registerRule('product', [
  'product:{id}',
  'product:{id}:details',
  'product:{id}:reviews'
]);

// ìºì‹œ ì›Œë°ì—… ì „ëµ ì„¤ì •
const dataSource = {
  getPopularUsers: async (limit: number) => { /* êµ¬í˜„ */ },
  getPopularProducts: async (limit: number) => { /* êµ¬í˜„ */ },
  getCategories: async () => { /* êµ¬í˜„ */ },
  getUserBehavior: async (userId: string) => { /* êµ¬í˜„ */ },
  getRecommendations: async (userId: string) => { /* êµ¬í˜„ */ },
  getUserInterests: async (userId: string) => { /* êµ¬í˜„ */ },
  getActiveUsers: async (limit: number) => { /* êµ¬í˜„ */ }
};

const warmupStrategy = new CacheWarmupStrategy(cache, dataSource);

// ìºì‹œ ì‚¬ìš© ì˜ˆì‹œ
async function getUserData(userId: string) {
  // ìºì‹œì—ì„œ ë¨¼ì € í™•ì¸
  let userData = await cache.get(`user:${userId}`);
  
  if (!userData) {
    // ìºì‹œ ë¯¸ìŠ¤ ì‹œ ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ì¡°íšŒ
    userData = await dataSource.getUserById(userId);
    
    // ìºì‹œì— ì €ì¥
    await cache.set(`user:${userId}`, userData, 3600000); // 1ì‹œê°„
  }
  
  return userData;
}

// ì‚¬ìš©ì ì •ë³´ ì—…ë°ì´íŠ¸ ì‹œ ìºì‹œ ë¬´íš¨í™”
async function updateUser(userId: string, userData: any) {
  // ë°ì´í„°ë² ì´ìŠ¤ ì—…ë°ì´íŠ¸
  await dataSource.updateUser(userId, userData);
  
  // ê´€ë ¨ ìºì‹œ ë¬´íš¨í™”
  await invalidationStrategy.invalidateOnEntityChange('user', userId);
}

// ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹œì‘ ì‹œ ì›Œë°ì—…
async function initializeCache() {
  await warmupStrategy.warmupPopularData();
  warmupStrategy.startScheduledWarmup();
}

// ìºì‹œ í†µê³„ ëª¨ë‹ˆí„°ë§
setInterval(() => {
  const stats = cache.getStats();
  console.log('Cache Stats:', stats);
}, 60000); // 1ë¶„ë§ˆë‹¤
```

### 2. ìºì‹œ ê³„ì¸µ êµ¬ì¡°

```
L1: ì• í”Œë¦¬ì¼€ì´ì…˜ ìºì‹œ (ë©”ëª¨ë¦¬)
L2: ë¶„ì‚° ìºì‹œ (Redis)
L3: CDN ìºì‹œ
L4: ë°ì´í„°ë² ì´ìŠ¤ ìºì‹œ
```

### 2. CDN (Content Delivery Network)

#### CloudFront ì„¤ì •
```javascript
// CDN ìºì‹± ì „ëµ
const cdnConfig = {
  // ì •ì  ìì‚° ìºì‹±
  staticAssets: {
    cachePolicy: 'CachingOptimized',
    ttl: 31536000, // 1ë…„
    headers: ['Accept-Encoding']
  },
  
  // API ì‘ë‹µ ìºì‹±
  apiResponses: {
    cachePolicy: 'CachingDisabled',
    ttl: 0,
    headers: ['Authorization', 'Content-Type']
  },
  
  // ë™ì  ì½˜í…ì¸  ìºì‹±
  dynamicContent: {
    cachePolicy: 'CachingOptimizedForCompression',
    ttl: 3600, // 1ì‹œê°„
    headers: ['Accept-Encoding', 'Accept-Language']
  }
};
```

### 3. Application Cache (Redis)

#### ìºì‹œ ì „ëµ êµ¬í˜„
```javascript
class CacheManager {
  constructor(redisClient) {
    this.redis = redisClient;
    this.defaultTTL = 3600; // 1ì‹œê°„
  }

  // Cache-Aside íŒ¨í„´
  async get(key) {
    try {
      const cached = await this.redis.get(key);
      if (cached) {
        return JSON.parse(cached);
      }
      return null;
    } catch (error) {
      console.error('Cache get error:', error);
      return null;
    }
  }

  async set(key, value, ttl = this.defaultTTL) {
    try {
      await this.redis.setex(key, ttl, JSON.stringify(value));
    } catch (error) {
      console.error('Cache set error:', error);
    }
  }

  // Write-Through íŒ¨í„´
  async writeThrough(key, value, ttl = this.defaultTTL) {
    // 1. ë°ì´í„°ë² ì´ìŠ¤ì— ì €ì¥
    await this.saveToDatabase(value);
    
    // 2. ìºì‹œì— ì €ì¥
    await this.set(key, value, ttl);
  }

  // Write-Behind íŒ¨í„´
  async writeBehind(key, value, ttl = this.defaultTTL) {
    // 1. ìºì‹œì— ë¨¼ì € ì €ì¥
    await this.set(key, value, ttl);
    
    // 2. ë¹„ë™ê¸°ë¡œ ë°ì´í„°ë² ì´ìŠ¤ì— ì €ì¥
    setImmediate(() => {
      this.saveToDatabase(value).catch(console.error);
    });
  }

  // Cache-Aside íŒ¨í„´ êµ¬í˜„
  async getOrSet(key, fetchFunction, ttl = this.defaultTTL) {
    // 1. ìºì‹œì—ì„œ ì¡°íšŒ
    let value = await this.get(key);
    
    if (value === null) {
      // 2. ìºì‹œì— ì—†ìœ¼ë©´ ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ì¡°íšŒ
      value = await fetchFunction();
      
      // 3. ìºì‹œì— ì €ì¥
      if (value !== null) {
        await this.set(key, value, ttl);
      }
    }
    
    return value;
  }
}
```

### 4. Database Cache

#### ì¿¼ë¦¬ ê²°ê³¼ ìºì‹±
```javascript
class DatabaseCache {
  constructor(redisClient, dbConnection) {
    this.redis = redisClient;
    this.db = dbConnection;
  }

  async executeQuery(query, params, ttl = 300) {
    const cacheKey = this.generateCacheKey(query, params);
    
    // ìºì‹œì—ì„œ ì¡°íšŒ
    let result = await this.redis.get(cacheKey);
    
    if (result) {
      return JSON.parse(result);
    }
    
    // ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ì¡°íšŒ
    result = await this.db.query(query, params);
    
    // ìºì‹œì— ì €ì¥
    await this.redis.setex(cacheKey, ttl, JSON.stringify(result));
    
    return result;
  }

  generateCacheKey(query, params) {
    const queryHash = require('crypto')
      .createHash('md5')
      .update(query + JSON.stringify(params))
      .digest('hex');
    
    return `query:${queryHash}`;
  }
}
```

---

## ë°ì´í„°ë² ì´ìŠ¤ ìƒ¤ë”© ë° íŒŒí‹°ì…”ë‹

### 1. ìƒ¤ë”© ì „ëµ

#### ìˆ˜í‰ ìƒ¤ë”© (Horizontal Sharding)
```javascript
class HorizontalSharding {
  constructor(shardCount) {
    this.shardCount = shardCount;
    this.shards = new Array(shardCount).fill(null).map(() => ({
      connection: null,
      data: new Map()
    }));
  }

  // í•´ì‹œ ê¸°ë°˜ ìƒ¤ë”©
  getShardId(key) {
    const hash = this.hashFunction(key);
    return hash % this.shardCount;
  }

  hashFunction(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return Math.abs(hash);
  }

  async insert(key, value) {
    const shardId = this.getShardId(key);
    const shard = this.shards[shardId];
    
    shard.data.set(key, value);
    console.log(`Inserted ${key} into shard ${shardId}`);
  }

  async get(key) {
    const shardId = this.getShardId(key);
    const shard = this.shards[shardId];
    
    return shard.data.get(key);
  }
}
```

#### ìˆ˜ì§ ìƒ¤ë”© (Vertical Sharding)
```javascript
class VerticalSharding {
  constructor() {
    this.shards = {
      userProfile: new Map(),    // ì‚¬ìš©ì í”„ë¡œí•„ ì •ë³´
      userActivity: new Map(),   // ì‚¬ìš©ì í™œë™ ë¡œê·¸
      userSettings: new Map()    // ì‚¬ìš©ì ì„¤ì •
    };
  }

  async insertUserProfile(userId, profile) {
    this.shards.userProfile.set(userId, profile);
  }

  async insertUserActivity(userId, activity) {
    if (!this.shards.userActivity.has(userId)) {
      this.shards.userActivity.set(userId, []);
    }
    this.shards.userActivity.get(userId).push(activity);
  }

  async insertUserSettings(userId, settings) {
    this.shards.userSettings.set(userId, settings);
  }

  async getUserData(userId) {
    const profile = this.shards.userProfile.get(userId);
    const activities = this.shards.userActivity.get(userId) || [];
    const settings = this.shards.userSettings.get(userId);

    return {
      profile,
      activities,
      settings
    };
  }
}
```

### 2. íŒŒí‹°ì…”ë‹ ì „ëµ

#### ë²”ìœ„ ê¸°ë°˜ íŒŒí‹°ì…”ë‹
```sql
-- ë‚ ì§œ ê¸°ë°˜ íŒŒí‹°ì…”ë‹
CREATE TABLE user_activities (
    id BIGINT,
    user_id BIGINT,
    activity_type VARCHAR(50),
    created_at TIMESTAMP,
    data JSONB
) PARTITION BY RANGE (created_at);

-- ì›”ë³„ íŒŒí‹°ì…˜ ìƒì„±
CREATE TABLE user_activities_2024_01 PARTITION OF user_activities
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

CREATE TABLE user_activities_2024_02 PARTITION OF user_activities
    FOR VALUES FROM ('2024-02-01') TO ('2024-03-01');
```

#### í•´ì‹œ ê¸°ë°˜ íŒŒí‹°ì…”ë‹
```sql
-- ì‚¬ìš©ì ID ê¸°ë°˜ í•´ì‹œ íŒŒí‹°ì…”ë‹
CREATE TABLE users (
    id BIGINT,
    username VARCHAR(50),
    email VARCHAR(100),
    created_at TIMESTAMP
) PARTITION BY HASH (id);

-- 4ê°œ íŒŒí‹°ì…˜ ìƒì„±
CREATE TABLE users_0 PARTITION OF users
    FOR VALUES WITH (modulus 4, remainder 0);

CREATE TABLE users_1 PARTITION OF users
    FOR VALUES WITH (modulus 4, remainder 1);

CREATE TABLE users_2 PARTITION OF users
    FOR VALUES WITH (modulus 4, remainder 2);

CREATE TABLE users_3 PARTITION OF users
    FOR VALUES WITH (modulus 4, remainder 3);
```

---

## ì‹¤ì œ ëŒ€ê·œëª¨ ì‹œìŠ¤í…œ ì„¤ê³„ ì‚¬ë¡€

### 1. íŠ¸ìœ„í„° ìŠ¤íƒ€ì¼ ì‹œìŠ¤í…œ

#### ì‹œìŠ¤í…œ ìš”êµ¬ì‚¬í•­
```
- ì‚¬ìš©ì: 1ì–µ ëª…
- íŠ¸ìœ—: ì´ˆë‹¹ 6,000ê°œ ì‘ì„±
- íƒ€ì„ë¼ì¸: ì´ˆë‹¹ 300,000ê°œ ì¡°íšŒ
- íŒ”ë¡œì›Œ: í‰ê·  200ëª…
```

#### ì•„í‚¤í…ì²˜ ì„¤ê³„
```javascript
// íŠ¸ìœ„í„° ìŠ¤íƒ€ì¼ ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜
class TwitterLikeSystem {
  constructor() {
    this.userService = new UserService();
    this.tweetService = new TweetService();
    this.timelineService = new TimelineService();
    this.followService = new FollowService();
  }

  // íŠ¸ìœ— ì‘ì„±
  async postTweet(userId, content) {
    // 1. íŠ¸ìœ— ì €ì¥
    const tweet = await this.tweetService.createTweet(userId, content);
    
    // 2. íŒ”ë¡œì›Œë“¤ì˜ íƒ€ì„ë¼ì¸ì— ì¶”ê°€ (ë¹„ë™ê¸°)
    this.updateFollowersTimeline(userId, tweet);
    
    return tweet;
  }

  // íŒ”ë¡œì›Œ íƒ€ì„ë¼ì¸ ì—…ë°ì´íŠ¸
  async updateFollowersTimeline(userId, tweet) {
    const followers = await this.followService.getFollowers(userId);
    
    // ë°°ì¹˜ ì²˜ë¦¬ë¡œ íƒ€ì„ë¼ì¸ ì—…ë°ì´íŠ¸
    const batchSize = 1000;
    for (let i = 0; i < followers.length; i += batchSize) {
      const batch = followers.slice(i, i + batchSize);
      
      // ë¹„ë™ê¸°ë¡œ ì²˜ë¦¬
      setImmediate(() => {
        this.timelineService.addToTimelines(batch, tweet);
      });
    }
  }

  // íƒ€ì„ë¼ì¸ ì¡°íšŒ
  async getTimeline(userId, page = 1, limit = 20) {
    return await this.timelineService.getTimeline(userId, page, limit);
  }
}
```

#### ë°ì´í„° ëª¨ë¸
```javascript
// ì‚¬ìš©ì ëª¨ë¸
class User {
  constructor(id, username, email, createdAt) {
    this.id = id;
    this.username = username;
    this.email = email;
    this.createdAt = createdAt;
    this.followersCount = 0;
    this.followingCount = 0;
  }
}

// íŠ¸ìœ— ëª¨ë¸
class Tweet {
  constructor(id, userId, content, createdAt) {
    this.id = id;
    this.userId = userId;
    this.content = content;
    this.createdAt = createdAt;
    this.likesCount = 0;
    this.retweetsCount = 0;
  }
}

// íƒ€ì„ë¼ì¸ ëª¨ë¸
class Timeline {
  constructor(userId, tweetId, createdAt) {
    this.userId = userId;
    this.tweetId = tweetId;
    this.createdAt = createdAt;
  }
}
```

### 2. ë„·í”Œë¦­ìŠ¤ ìŠ¤íƒ€ì¼ ì‹œìŠ¤í…œ

#### ì‹œìŠ¤í…œ ìš”êµ¬ì‚¬í•­
```
- ì‚¬ìš©ì: 2ì–µ ëª…
- ë™ì‹œ ìŠ¤íŠ¸ë¦¬ë°: 1,000ë§Œ ëª…
- ì½˜í…ì¸ : 15,000ê°œ ì˜í™”/ì‹œë¦¬ì¦ˆ
- ê¸€ë¡œë²Œ ì„œë¹„ìŠ¤
```

#### ì•„í‚¤í…ì²˜ ì„¤ê³„
```javascript
// ë„·í”Œë¦­ìŠ¤ ìŠ¤íƒ€ì¼ ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜
class NetflixLikeSystem {
  constructor() {
    this.userService = new UserService();
    this.contentService = new ContentService();
    this.recommendationService = new RecommendationService();
    this.cdnService = new CDNService();
    this.analyticsService = new AnalyticsService();
  }

  // ì½˜í…ì¸  ìŠ¤íŠ¸ë¦¬ë°
  async streamContent(userId, contentId, quality) {
    // 1. ì‚¬ìš©ì ì¸ì¦ ë° ê¶Œí•œ í™•ì¸
    const user = await this.userService.getUser(userId);
    if (!user.hasAccess(contentId)) {
      throw new Error('Access denied');
    }

    // 2. CDNì—ì„œ ìµœì  ì„œë²„ ì„ íƒ
    const cdnServer = await this.cdnService.getOptimalServer(user.location);
    
    // 3. ìŠ¤íŠ¸ë¦¬ë° URL ìƒì„±
    const streamUrl = await this.cdnService.generateStreamUrl(contentId, quality, cdnServer);
    
    // 4. ë¶„ì„ ë°ì´í„° ìˆ˜ì§‘
    this.analyticsService.trackStreamingStart(userId, contentId, quality);
    
    return {
      streamUrl,
      quality,
      cdnServer
    };
  }

  // ì¶”ì²œ ì‹œìŠ¤í…œ
  async getRecommendations(userId) {
    const user = await this.userService.getUser(userId);
    const watchHistory = await this.analyticsService.getWatchHistory(userId);
    
    return await this.recommendationService.getRecommendations(user, watchHistory);
  }
}
```

#### CDN ìµœì í™”
```javascript
class CDNOptimizer {
  constructor() {
    this.regions = {
      'us-east': ['server1', 'server2', 'server3'],
      'us-west': ['server4', 'server5', 'server6'],
      'europe': ['server7', 'server8', 'server9'],
      'asia': ['server10', 'server11', 'server12']
    };
  }

  async getOptimalServer(userLocation) {
    const region = this.getRegion(userLocation);
    const servers = this.regions[region];
    
    // ì„œë²„ ìƒíƒœ í™•ì¸ ë° ìµœì  ì„œë²„ ì„ íƒ
    const serverStats = await Promise.all(
      servers.map(server => this.getServerStats(server))
    );
    
    // CPU ì‚¬ìš©ë¥ ì´ ê°€ì¥ ë‚®ì€ ì„œë²„ ì„ íƒ
    const optimalServer = serverStats.reduce((min, current) => 
      current.cpuUsage < min.cpuUsage ? current : min
    );
    
    return optimalServer.name;
  }

  getRegion(location) {
    // ìœ„ì¹˜ ê¸°ë°˜ ë¦¬ì „ ê²°ì • ë¡œì§
    if (location.country === 'US') {
      return location.state === 'CA' ? 'us-west' : 'us-east';
    } else if (location.continent === 'Europe') {
      return 'europe';
    } else {
      return 'asia';
    }
  }
}
```

### 3. ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§ ë° ì•Œë¦¼

```javascript
class SystemMonitor {
  constructor() {
    this.metrics = {
      responseTime: [],
      errorRate: [],
      throughput: [],
      cpuUsage: [],
      memoryUsage: []
    };
  }

  // ë©”íŠ¸ë¦­ ìˆ˜ì§‘
  collectMetrics() {
    setInterval(() => {
      this.metrics.responseTime.push(this.getAverageResponseTime());
      this.metrics.errorRate.push(this.getErrorRate());
      this.metrics.throughput.push(this.getThroughput());
      this.metrics.cpuUsage.push(this.getCpuUsage());
      this.metrics.memoryUsage.push(this.getMemoryUsage());
      
      // ì„ê³„ê°’ í™•ì¸
      this.checkThresholds();
    }, 60000); // 1ë¶„ë§ˆë‹¤
  }

  // ì„ê³„ê°’ í™•ì¸ ë° ì•Œë¦¼
  checkThresholds() {
    const currentErrorRate = this.metrics.errorRate[this.metrics.errorRate.length - 1];
    const currentResponseTime = this.metrics.responseTime[this.metrics.responseTime.length - 1];
    
    if (currentErrorRate > 0.05) { // 5% ì´ìƒ
      this.sendAlert('High error rate detected', { errorRate: currentErrorRate });
    }
    
    if (currentResponseTime > 2000) { // 2ì´ˆ ì´ìƒ
      this.sendAlert('High response time detected', { responseTime: currentResponseTime });
    }
  }

  sendAlert(message, data) {
    console.log(`ALERT: ${message}`, data);
    // ì‹¤ì œë¡œëŠ” Slack, PagerDuty ë“±ìœ¼ë¡œ ì „ì†¡
  }
}
```

---

## ê²°ë¡ 

ì‹œìŠ¤í…œ ì„¤ê³„ ë° ì•„í‚¤í…ì²˜ íŒ¨í„´ì€ í™•ì¥ ê°€ëŠ¥í•˜ê³  ì•ˆì •ì ì¸ ì‹œìŠ¤í…œì„ êµ¬ì¶•í•˜ê¸° ìœ„í•œ í•µì‹¬ ìš”ì†Œì…ë‹ˆë‹¤.

### í•µì‹¬ ì›ì¹™ ìš”ì•½

1. **í™•ì¥ì„±**: ìˆ˜í‰/ìˆ˜ì§ í™•ì¥ ì „ëµ ìˆ˜ë¦½
2. **ë¡œë“œ ë°¸ëŸ°ì‹±**: ì ì ˆí•œ ì•Œê³ ë¦¬ì¦˜ ì„ íƒ ë° êµ¬í˜„
3. **ìºì‹±**: ë‹¤ì¸µ ìºì‹œ ì „ëµìœ¼ë¡œ ì„±ëŠ¥ ìµœì í™”
4. **ë°ì´í„° ë¶„ì‚°**: ìƒ¤ë”© ë° íŒŒí‹°ì…”ë‹ìœ¼ë¡œ í™•ì¥ì„± í™•ë³´
5. **ëª¨ë‹ˆí„°ë§**: ì§€ì†ì ì¸ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ë° ì•Œë¦¼

### ì‹¤ë¬´ ì ìš© ê°€ì´ë“œ

- **ì†Œê·œëª¨ ì‹œìŠ¤í…œ**: ë‹¨ìˆœí•œ êµ¬ì¡°ë¡œ ì‹œì‘
- **ì¤‘ê·œëª¨ ì‹œìŠ¤í…œ**: ìºì‹± ë° ë¡œë“œ ë°¸ëŸ°ì‹± ë„ì…
- **ëŒ€ê·œëª¨ ì‹œìŠ¤í…œ**: ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ ë° ë¶„ì‚° ì•„í‚¤í…ì²˜ ì ìš©

ì´ëŸ¬í•œ ì›ì¹™ë“¤ì„ ë°”íƒ•ìœ¼ë¡œ ìš”êµ¬ì‚¬í•­ì— ë§ëŠ” ìµœì ì˜ ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜ë¥¼ ì„¤ê³„í•˜ì„¸ìš”.
