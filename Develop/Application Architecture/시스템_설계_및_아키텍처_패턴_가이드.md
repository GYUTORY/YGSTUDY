---
title: 시스템 설계 및 아키텍처 패턴 가이드
tags: [system-design, architecture, scalability, load-balancing, caching]
updated: 2024-09-14
---

# 시스템 설계 및 아키텍처 패턴 가이드 (System Design and Architecture Patterns Guide)

## 📋 목차
1. [확장 가능한 시스템 설계 원칙](#확장-가능한-시스템-설계-원칙)
2. [CAP 정리 실증 프로젝트](#cap-정리-실증-프로젝트)
3. [고급 로드 밸런싱 전략](#고급-로드-밸런싱-전략)
4. [분산 락 구현](#분산-락-구현)
5. [다층 캐싱 전략](#다층-캐싱-전략)
6. [데이터베이스 샤딩 및 파티셔닝](#데이터베이스-샤딩-및-파티셔닝)
7. [실제 대규모 시스템 설계 사례](#실제-대규모-시스템-설계-사례)

### 📌 통합된 기존 파일들
이 가이드는 다음 기존 파일들의 내용을 통합하여 더 체계적으로 정리한 것입니다:
- **웹 통신의 흐름**: 로드 밸런서, 웹 서버, 애플리케이션 서버 레벨별 처리
- **Nginx 설정**: 로드 밸런싱 전략, 캐싱 설정, 마이크로서비스 아키텍처
- **데이터베이스 샤딩**: 수평/수직 샤딩, 샤딩 키 선택, 쿼리 라우팅
- **DB Proxy**: 연결 관리, 부하 분산, 성능 최적화
- **대량 API 처리**: Redis 활용, 비동기 처리, 부하 분산

---

## CAP 정리 실증 프로젝트

### 1. CAP 정리 개요

CAP 정리는 분산 시스템에서 **Consistency(일관성)**, **Availability(가용성)**, **Partition Tolerance(분할 내성)** 중 최대 2개만 동시에 보장할 수 있다는 이론입니다.

```
C (Consistency): 모든 노드가 동시에 같은 데이터를 보여줌
A (Availability): 시스템이 항상 응답함
P (Partition Tolerance): 네트워크 분할 상황에서도 동작함
```

### 2. Consistency 우선 시스템: 은행 계좌 시스템

```typescript
// src/cap-demo/banking-system/BankingService.ts
import { Pool } from 'pg';
import { EventEmitter } from 'events';

export class BankingService {
  private db: Pool;
  private eventEmitter: EventEmitter;
  private isPartitioned: boolean = false;

  constructor(connectionString: string) {
    this.db = new Pool({ connectionString });
    this.eventEmitter = new EventEmitter();
  }

  // 강한 일관성 보장 - 모든 복제본에 동시 업데이트
  async transferMoney(fromAccount: string, toAccount: string, amount: number): Promise<void> {
    const client = await this.db.connect();
    
    try {
      await client.query('BEGIN');
      
      // 1. 송금 계좌 잔액 확인 및 차감
      const fromResult = await client.query(
        'SELECT balance FROM accounts WHERE account_id = $1 FOR UPDATE',
        [fromAccount]
      );
      
      if (fromResult.rows.length === 0) {
        throw new Error('송금 계좌를 찾을 수 없습니다');
      }
      
      const currentBalance = fromResult.rows[0].balance;
      if (currentBalance < amount) {
        throw new Error('잔액이 부족합니다');
      }
      
      // 2. 송금 계좌 차감
      await client.query(
        'UPDATE accounts SET balance = balance - $1 WHERE account_id = $2',
        [amount, fromAccount]
      );
      
      // 3. 수취 계좌 증가
      await client.query(
        'UPDATE accounts SET balance = balance + $1 WHERE account_id = $2',
        [amount, toAccount]
      );
      
      // 4. 거래 기록 저장
      await client.query(
        `INSERT INTO transactions (from_account, to_account, amount, timestamp, status)
         VALUES ($1, $2, $3, NOW(), 'COMPLETED')`,
        [fromAccount, toAccount, amount]
      );
      
      await client.query('COMMIT');
      
      // 모든 복제본에 동기화 (강한 일관성)
      await this.syncToAllReplicas(fromAccount, toAccount, amount);
      
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }

  // 모든 복제본에 동기화 (강한 일관성)
  private async syncToAllReplicas(fromAccount: string, toAccount: string, amount: number): Promise<void> {
    const replicas = [
      'replica1.example.com:5432',
      'replica2.example.com:5432',
      'replica3.example.com:5432'
    ];

    const syncPromises = replicas.map(async (replica) => {
      try {
        if (this.isPartitioned) {
          throw new Error(`Replica ${replica} is partitioned`);
        }
        
        // 각 복제본에 동일한 트랜잭션 적용
        await this.applyTransactionToReplica(replica, fromAccount, toAccount, amount);
      } catch (error) {
        console.error(`Failed to sync to replica ${replica}:`, error);
        throw error; // 하나라도 실패하면 전체 실패
      }
    });

    // 모든 복제본이 성공해야 트랜잭션 완료
    await Promise.all(syncPromises);
  }

  private async applyTransactionToReplica(
    replicaUrl: string, 
    fromAccount: string, 
    toAccount: string, 
    amount: number
  ): Promise<void> {
    const replicaDb = new Pool({ connectionString: replicaUrl });
    const client = await replicaDb.connect();
    
    try {
      await client.query('BEGIN');
      await client.query(
        'UPDATE accounts SET balance = balance - $1 WHERE account_id = $2',
        [amount, fromAccount]
      );
      await client.query(
        'UPDATE accounts SET balance = balance + $1 WHERE account_id = $2',
        [amount, toAccount]
      );
      await client.query('COMMIT');
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
      await replicaDb.end();
    }
  }

  // 네트워크 분할 시뮬레이션
  simulatePartition(): void {
    this.isPartitioned = true;
    console.log('🚨 Network partition detected - System will maintain consistency but may be unavailable');
  }

  resolvePartition(): void {
    this.isPartitioned = false;
    console.log('✅ Network partition resolved - System fully operational');
  }

  // 가용성 확인
  async checkAvailability(): Promise<boolean> {
    if (this.isPartitioned) {
      return false; // 분할 시 가용성 포기
    }
    return true;
  }
}

// 사용 예시
const bankingService = new BankingService('postgresql://localhost:5432/banking');

// 정상 상황
await bankingService.transferMoney('account1', 'account2', 1000);

// 네트워크 분할 시뮬레이션
bankingService.simulatePartition();
try {
  await bankingService.transferMoney('account1', 'account2', 500);
} catch (error) {
  console.log('Transfer failed due to partition:', error.message);
}
```

### 3. Availability 우선 시스템: 소셜 미디어 피드

```typescript
// src/cap-demo/social-media/FeedService.ts
import { Pool } from 'pg';
import { EventEmitter } from 'events';

export class FeedService {
  private db: Pool;
  private cache: Map<string, any> = new Map();
  private isPartitioned: boolean = false;

  constructor(connectionString: string) {
    this.db = new Pool({ connectionString });
  }

  // 가용성 우선 - 일관성보다 응답성 중시
  async getFeed(userId: string): Promise<any[]> {
    try {
      // 1. 캐시에서 먼저 확인
      const cacheKey = `feed:${userId}`;
      const cachedFeed = this.cache.get(cacheKey);
      
      if (cachedFeed && !this.isStale(cachedFeed.timestamp)) {
        return cachedFeed.data;
      }

      // 2. 데이터베이스에서 조회 (분할 상황에서도 응답)
      let feedData;
      
      if (this.isPartitioned) {
        // 분할 상황에서는 캐시된 데이터나 부분적 데이터라도 반환
        feedData = await this.getFeedFromCacheOrPartialData(userId);
      } else {
        // 정상 상황에서는 최신 데이터 조회
        feedData = await this.getFeedFromDatabase(userId);
      }

      // 3. 캐시 업데이트
      this.cache.set(cacheKey, {
        data: feedData,
        timestamp: Date.now()
      });

      return feedData;
      
    } catch (error) {
      // 에러가 발생해도 캐시된 데이터라도 반환 (가용성 우선)
      console.warn('Feed service error, returning cached data:', error.message);
      return this.getCachedFeed(userId) || [];
    }
  }

  // 포스트 작성 - 최종 일관성 허용
  async createPost(userId: string, content: string): Promise<string> {
    const postId = `post_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    try {
      if (this.isPartitioned) {
        // 분할 상황에서는 로컬에 저장하고 나중에 동기화
        await this.savePostLocally(postId, userId, content);
        console.log('Post saved locally, will sync when partition resolves');
      } else {
        // 정상 상황에서는 즉시 저장
        await this.savePostToDatabase(postId, userId, content);
      }
      
      // 캐시 무효화
      this.invalidateUserFeedCache(userId);
      
      return postId;
      
    } catch (error) {
      // 에러가 발생해도 포스트 ID는 반환 (가용성 우선)
      console.warn('Post creation error, but returning post ID:', error.message);
      return postId;
    }
  }

  private async getFeedFromDatabase(userId: string): Promise<any[]> {
    const result = await this.db.query(
      `SELECT p.*, u.username 
       FROM posts p 
       JOIN users u ON p.user_id = u.id 
       WHERE p.user_id IN (
         SELECT following_id FROM follows WHERE follower_id = $1
       ) 
       ORDER BY p.created_at DESC 
       LIMIT 50`,
      [userId]
    );
    
    return result.rows;
  }

  private async getFeedFromCacheOrPartialData(userId: string): Promise<any[]> {
    // 분할 상황에서는 캐시된 데이터나 부분적 데이터 반환
    const cachedFeed = this.getCachedFeed(userId);
    if (cachedFeed) {
      return cachedFeed;
    }
    
    // 캐시가 없으면 빈 배열이라도 반환 (가용성 우선)
    return [];
  }

  private async savePostToDatabase(postId: string, userId: string, content: string): Promise<void> {
    await this.db.query(
      'INSERT INTO posts (id, user_id, content, created_at) VALUES ($1, $2, $3, NOW())',
      [postId, userId, content]
    );
  }

  private async savePostLocally(postId: string, userId: string, content: string): Promise<void> {
    // 로컬 스토리지에 저장 (나중에 동기화)
    const localPosts = JSON.parse(localStorage.getItem('pending_posts') || '[]');
    localPosts.push({ postId, userId, content, timestamp: Date.now() });
    localStorage.setItem('pending_posts', JSON.stringify(localPosts));
  }

  private getCachedFeed(userId: string): any[] | null {
    const cacheKey = `feed:${userId}`;
    const cached = this.cache.get(cacheKey);
    return cached ? cached.data : null;
  }

  private isStale(timestamp: number): boolean {
    return Date.now() - timestamp > 300000; // 5분
  }

  private invalidateUserFeedCache(userId: string): void {
    const cacheKey = `feed:${userId}`;
    this.cache.delete(cacheKey);
  }

  // 네트워크 분할 시뮬레이션
  simulatePartition(): void {
    this.isPartitioned = true;
    console.log('🚨 Network partition detected - System will maintain availability with eventual consistency');
  }

  resolvePartition(): void {
    this.isPartitioned = false;
    console.log('✅ Network partition resolved - Syncing pending data');
    this.syncPendingData();
  }

  private async syncPendingData(): Promise<void> {
    const pendingPosts = JSON.parse(localStorage.getItem('pending_posts') || '[]');
    
    for (const post of pendingPosts) {
      try {
        await this.savePostToDatabase(post.postId, post.userId, post.content);
      } catch (error) {
        console.error('Failed to sync post:', error);
      }
    }
    
    localStorage.removeItem('pending_posts');
  }
}

// 사용 예시
const feedService = new FeedService('postgresql://localhost:5432/social_media');

// 정상 상황
const feed = await feedService.getFeed('user123');
const postId = await feedService.createPost('user123', 'Hello World!');

// 네트워크 분할 시뮬레이션
feedService.simulatePartition();
const feedDuringPartition = await feedService.getFeed('user123'); // 캐시된 데이터 반환
const postIdDuringPartition = await feedService.createPost('user123', 'Partition post'); // 로컬 저장
```

### 4. Partition Tolerance 시뮬레이션 시스템

```typescript
// src/cap-demo/partition-simulator/PartitionSimulator.ts
import { EventEmitter } from 'events';

export class PartitionSimulator extends EventEmitter {
  private partitions: Map<string, boolean> = new Map();
  private nodes: string[] = [];

  constructor(nodes: string[]) {
    super();
    this.nodes = nodes;
    this.initializeNodes();
  }

  private initializeNodes(): void {
    this.nodes.forEach(node => {
      this.partitions.set(node, false);
    });
  }

  // 특정 노드들을 분할 상태로 설정
  createPartition(partitionedNodes: string[]): void {
    partitionedNodes.forEach(node => {
      if (this.nodes.includes(node)) {
        this.partitions.set(node, true);
      }
    });
    
    console.log(`🚨 Partition created: ${partitionedNodes.join(', ')} are isolated`);
    this.emit('partition-created', partitionedNodes);
  }

  // 분할 해결
  resolvePartition(): void {
    this.nodes.forEach(node => {
      this.partitions.set(node, false);
    });
    
    console.log('✅ All partitions resolved');
    this.emit('partition-resolved');
  }

  // 특정 노드가 분할 상태인지 확인
  isNodePartitioned(node: string): boolean {
    return this.partitions.get(node) || false;
  }

  // 분할된 노드들 목록 반환
  getPartitionedNodes(): string[] {
    return this.nodes.filter(node => this.partitions.get(node));
  }

  // 정상 노드들 목록 반환
  getAvailableNodes(): string[] {
    return this.nodes.filter(node => !this.partitions.get(node));
  }

  // 노드 간 통신 가능 여부 확인
  canCommunicate(node1: string, node2: string): boolean {
    const node1Partitioned = this.isNodePartitioned(node1);
    const node2Partitioned = this.isNodePartitioned(node2);
    
    // 둘 다 분할되지 않았거나, 둘 다 같은 분할 그룹에 있어야 통신 가능
    return !node1Partitioned && !node2Partitioned;
  }

  // 랜덤 분할 시뮬레이션
  simulateRandomPartition(): void {
    const numPartitions = Math.floor(Math.random() * 3) + 1; // 1-3개 분할
    const partitionedNodes: string[] = [];
    
    for (let i = 0; i < numPartitions; i++) {
      const randomNode = this.nodes[Math.floor(Math.random() * this.nodes.length)];
      if (!partitionedNodes.includes(randomNode)) {
        partitionedNodes.push(randomNode);
      }
    }
    
    if (partitionedNodes.length > 0) {
      this.createPartition(partitionedNodes);
    }
  }

  // 분할 복구 시뮬레이션
  simulatePartitionRecovery(): void {
    setTimeout(() => {
      this.resolvePartition();
    }, Math.random() * 10000 + 5000); // 5-15초 후 복구
  }
}

// CAP 정리 데모 애플리케이션
export class CAPTheoremDemo {
  private bankingService: BankingService;
  private feedService: FeedService;
  private partitionSimulator: PartitionSimulator;

  constructor() {
    this.bankingService = new BankingService('postgresql://localhost:5432/banking');
    this.feedService = new FeedService('postgresql://localhost:5432/social_media');
    this.partitionSimulator = new PartitionSimulator([
      'node1', 'node2', 'node3', 'node4', 'node5'
    ]);

    this.setupEventHandlers();
  }

  private setupEventHandlers(): void {
    this.partitionSimulator.on('partition-created', (partitionedNodes) => {
      console.log(`\n📊 CAP Theorem Demo - Partition Created`);
      console.log(`Partitioned nodes: ${partitionedNodes.join(', ')}`);
      this.demonstrateCAPTradeoffs();
    });

    this.partitionSimulator.on('partition-resolved', () => {
      console.log(`\n📊 CAP Theorem Demo - Partition Resolved`);
      this.demonstrateCAPTradeoffs();
    });
  }

  async demonstrateCAPTradeoffs(): Promise<void> {
    console.log('\n=== CAP Theorem Demonstration ===');
    
    // 1. Consistency 우선 시스템 (은행)
    console.log('\n1. Banking System (Consistency + Partition Tolerance)');
    try {
      await this.bankingService.transferMoney('account1', 'account2', 100);
      console.log('✅ Banking transaction successful');
    } catch (error) {
      console.log('❌ Banking transaction failed:', error.message);
    }

    // 2. Availability 우선 시스템 (소셜 미디어)
    console.log('\n2. Social Media Feed (Availability + Partition Tolerance)');
    try {
      const feed = await this.feedService.getFeed('user123');
      console.log('✅ Feed retrieved successfully, posts:', feed.length);
    } catch (error) {
      console.log('❌ Feed retrieval failed:', error.message);
    }

    // 3. 시스템 상태 요약
    console.log('\n3. System Status Summary');
    console.log(`Available nodes: ${this.partitionSimulator.getAvailableNodes().length}`);
    console.log(`Partitioned nodes: ${this.partitionSimulator.getPartitionedNodes().length}`);
  }

  async runDemo(): Promise<void> {
    console.log('🚀 Starting CAP Theorem Demonstration');
    
    // 초기 상태
    await this.demonstrateCAPTradeoffs();
    
    // 분할 시뮬레이션
    setTimeout(() => {
      this.partitionSimulator.simulateRandomPartition();
    }, 3000);
    
    // 분할 복구 시뮬레이션
    setTimeout(() => {
      this.partitionSimulator.simulatePartitionRecovery();
    }, 8000);
  }
}

// 실행 예시
const demo = new CAPTheoremDemo();
demo.runDemo();
```

### 5. CAP 정리 실증 프로젝트 실행 가이드

```bash
# 프로젝트 구조
cap-demo/
├── src/
│   ├── cap-demo/
│   │   ├── banking-system/
│   │   │   ├── BankingService.ts
│   │   │   └── BankingController.ts
│   │   ├── social-media/
│   │   │   ├── FeedService.ts
│   │   │   └── FeedController.ts
│   │   └── partition-simulator/
│   │       ├── PartitionSimulator.ts
│   │       └── CAPTheoremDemo.ts
│   └── index.ts
├── docker-compose.yml
├── package.json
└── README.md

# 실행 방법
npm install
npm run build
npm run demo

# Docker로 실행
docker-compose up -d
```

---

## 확장 가능한 시스템 설계 원칙

### 1. 확장성의 종류

### 1. 확장성의 종류

#### 수평 확장 (Horizontal Scaling)
```
단일 서버 → 여러 서버로 분산
장점: 무제한 확장 가능, 장애 격리
단점: 복잡한 데이터 동기화, 네트워크 오버헤드
```

#### 수직 확장 (Vertical Scaling)
```
서버 성능 향상 (CPU, 메모리, 스토리지)
장점: 단순한 구조, 데이터 일관성
단점: 물리적 한계, 단일 장애점
```

### 2. 시스템 설계 원칙

#### 단일 책임 원칙 (Single Responsibility)
```javascript
// ❌ 잘못된 예시: 여러 책임을 가진 클래스
class UserService {
  createUser(userData) { /* 사용자 생성 */ }
  sendEmail(email) { /* 이메일 발송 */ }
  logActivity(activity) { /* 활동 로깅 */ }
  validatePassword(password) { /* 비밀번호 검증 */ }
}

// ✅ 올바른 예시: 단일 책임을 가진 클래스들
class UserService {
  createUser(userData) { /* 사용자 생성만 담당 */ }
}

class EmailService {
  sendEmail(email) { /* 이메일 발송만 담당 */ }
}

class ActivityLogger {
  logActivity(activity) { /* 로깅만 담당 */ }
}

class PasswordValidator {
  validatePassword(password) { /* 비밀번호 검증만 담당 */ }
}
```

#### 느슨한 결합 (Loose Coupling)
```javascript
// ❌ 강한 결합
class OrderService {
  constructor() {
    this.emailService = new EmailService(); // 직접 의존
    this.paymentService = new PaymentService(); // 직접 의존
  }
}

// ✅ 느슨한 결합 (의존성 주입)
class OrderService {
  constructor(emailService, paymentService) {
    this.emailService = emailService;
    this.paymentService = paymentService;
  }
}

// 사용 시
const emailService = new EmailService();
const paymentService = new PaymentService();
const orderService = new OrderService(emailService, paymentService);
```

#### 높은 응집성 (High Cohesion)
```javascript
// ✅ 높은 응집성: 관련된 기능들이 함께 모여있음
class UserProfileManager {
  // 사용자 프로필과 관련된 모든 기능
  updateProfile(userId, profileData) { }
  getProfile(userId) { }
  validateProfile(profileData) { }
  uploadAvatar(userId, imageData) { }
  deleteProfile(userId) { }
}
```

### 3. 마이크로서비스 아키텍처 패턴

#### API Gateway 패턴
```javascript
// API Gateway 구현 예시
class APIGateway {
  constructor() {
    this.services = {
      user: new UserService(),
      product: new ProductService(),
      order: new OrderService()
    };
  }

  async routeRequest(path, method, data) {
    const [service, endpoint] = this.parsePath(path);
    
    if (!this.services[service]) {
      throw new Error(`Service ${service} not found`);
    }

    // 인증/인가 체크
    await this.authenticate(data.token);
    
    // 서비스로 라우팅
    return await this.services[service][endpoint](data);
  }

  parsePath(path) {
    const parts = path.split('/').filter(p => p);
    return [parts[1], parts[2]]; // /api/user/profile -> ['user', 'profile']
  }
}
```

#### Circuit Breaker 패턴
```javascript
class CircuitBreaker {
  constructor(threshold = 5, timeout = 60000) {
    this.failureThreshold = threshold;
    this.timeout = timeout;
    this.failureCount = 0;
    this.lastFailureTime = null;
    this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN
  }

  async execute(operation) {
    if (this.state === 'OPEN') {
      if (Date.now() - this.lastFailureTime > this.timeout) {
        this.state = 'HALF_OPEN';
      } else {
        throw new Error('Circuit breaker is OPEN');
      }
    }

    try {
      const result = await operation();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }

  onSuccess() {
    this.failureCount = 0;
    this.state = 'CLOSED';
  }

  onFailure() {
    this.failureCount++;
    this.lastFailureTime = Date.now();
    
    if (this.failureCount >= this.failureThreshold) {
      this.state = 'OPEN';
    }
  }
}
```

---

## 고급 로드 밸런싱 전략

### 1. 로드 밸런싱 알고리즘

#### Round Robin (라운드 로빈)
```javascript
class RoundRobinLoadBalancer {
  constructor(servers) {
    this.servers = servers;
    this.currentIndex = 0;
  }

  getNextServer() {
    const server = this.servers[this.currentIndex];
    this.currentIndex = (this.currentIndex + 1) % this.servers.length;
    return server;
  }
}

// 사용 예시
const servers = ['server1:3000', 'server2:3000', 'server3:3000'];
const lb = new RoundRobinLoadBalancer(servers);

console.log(lb.getNextServer()); // server1:3000
console.log(lb.getNextServer()); // server2:3000
console.log(lb.getNextServer()); // server3:3000
console.log(lb.getNextServer()); // server1:3000 (순환)
```

#### Least Connections (최소 연결)
```javascript
class LeastConnectionsLoadBalancer {
  constructor(servers) {
    this.servers = servers.map(server => ({
      url: server,
      connections: 0
    }));
  }

  getNextServer() {
    // 연결 수가 가장 적은 서버 선택
    const server = this.servers.reduce((min, current) => 
      current.connections < min.connections ? current : min
    );
    
    server.connections++;
    return server.url;
  }

  releaseConnection(serverUrl) {
    const server = this.servers.find(s => s.url === serverUrl);
    if (server && server.connections > 0) {
      server.connections--;
    }
  }
}
```

#### Weighted Round Robin (가중치 라운드 로빈)
```javascript
class WeightedRoundRobinLoadBalancer {
  constructor(servers) {
    this.servers = servers.map(server => ({
      url: server.url,
      weight: server.weight,
      currentWeight: 0,
      effectiveWeight: server.weight,
      isHealthy: true
    }));
  }

  getNextServer() {
    let totalWeight = 0;
    let selectedServer = null;

    // 모든 서버의 가중치를 현재 가중치에 추가
    for (const server of this.servers) {
      if (!server.isHealthy) continue;
      
      server.currentWeight += server.effectiveWeight;
      totalWeight += server.effectiveWeight;

      if (!selectedServer || server.currentWeight > selectedServer.currentWeight) {
        selectedServer = server;
      }
    }

    if (!selectedServer) {
      throw new Error('No healthy servers available');
    }

    // 선택된 서버의 현재 가중치에서 전체 가중치를 뺌
    selectedServer.currentWeight -= totalWeight;
    
    return selectedServer.url;
  }

  // 서버 상태 업데이트
  updateServerHealth(serverUrl, isHealthy) {
    const server = this.servers.find(s => s.url === serverUrl);
    if (server) {
      server.isHealthy = isHealthy;
      if (isHealthy) {
        server.effectiveWeight = server.weight;
      } else {
        server.effectiveWeight = 0;
      }
    }
  }
}

// 사용 예시
const servers = [
  { url: 'server1:3000', weight: 3 },
  { url: 'server2:3000', weight: 2 },
  { url: 'server3:3000', weight: 1 }
];
const lb = new WeightedRoundRobinLoadBalancer(servers);
```

#### Least Response Time (최소 응답 시간)
```javascript
class LeastResponseTimeLoadBalancer {
  constructor(servers) {
    this.servers = servers.map(server => ({
      url: server.url,
      responseTime: 0,
      requestCount: 0,
      totalResponseTime: 0,
      isHealthy: true,
      lastHealthCheck: Date.now()
    }));
    this.healthCheckInterval = 30000; // 30초마다 헬스체크
    this.startHealthCheck();
  }

  getNextServer() {
    const healthyServers = this.servers.filter(server => server.isHealthy);
    
    if (healthyServers.length === 0) {
      throw new Error('No healthy servers available');
    }

    // 응답 시간이 가장 짧은 서버 선택
    const selectedServer = healthyServers.reduce((min, current) => 
      current.responseTime < min.responseTime ? current : min
    );

    return selectedServer.url;
  }

  // 응답 시간 기록
  recordResponseTime(serverUrl, responseTime) {
    const server = this.servers.find(s => s.url === serverUrl);
    if (server) {
      server.requestCount++;
      server.totalResponseTime += responseTime;
      server.responseTime = server.totalResponseTime / server.requestCount;
    }
  }

  // 헬스체크 시작
  startHealthCheck() {
    setInterval(() => {
      this.performHealthCheck();
    }, this.healthCheckInterval);
  }

  // 헬스체크 수행
  async performHealthCheck() {
    const healthCheckPromises = this.servers.map(async (server) => {
      try {
        const startTime = Date.now();
        const response = await fetch(`http://${server.url}/health`, {
          method: 'GET',
          timeout: 5000
        });
        const responseTime = Date.now() - startTime;
        
        if (response.ok) {
          server.isHealthy = true;
          server.lastHealthCheck = Date.now();
          this.recordResponseTime(server.url, responseTime);
        } else {
          server.isHealthy = false;
        }
      } catch (error) {
        server.isHealthy = false;
        console.warn(`Health check failed for ${server.url}:`, error.message);
      }
    });

    await Promise.all(healthCheckPromises);
  }

  // 서버 상태 정보 반환
  getServerStats() {
    return this.servers.map(server => ({
      url: server.url,
      isHealthy: server.isHealthy,
      responseTime: server.responseTime,
      requestCount: server.requestCount,
      lastHealthCheck: server.lastHealthCheck
    }));
  }
}

// 사용 예시
const servers = ['server1:3000', 'server2:3000', 'server3:3000'];
const lb = new LeastResponseTimeLoadBalancer(servers);

// 요청 처리
async function handleRequest() {
  try {
    const serverUrl = lb.getNextServer();
    const startTime = Date.now();
    
    const response = await fetch(`http://${serverUrl}/api/data`);
    const responseTime = Date.now() - startTime;
    
    lb.recordResponseTime(serverUrl, responseTime);
    
    return response;
  } catch (error) {
    console.error('Request failed:', error);
    throw error;
  }
}
```

#### Health Check 기반 라우팅
```javascript
class HealthCheckLoadBalancer {
  constructor(servers, options = {}) {
    this.servers = servers.map(server => ({
      url: server.url,
      weight: server.weight || 1,
      isHealthy: true,
      consecutiveFailures: 0,
      lastHealthCheck: Date.now(),
      responseTime: 0,
      circuitBreakerState: 'CLOSED' // CLOSED, OPEN, HALF_OPEN
    }));
    
    this.options = {
      healthCheckPath: options.healthCheckPath || '/health',
      healthCheckInterval: options.healthCheckInterval || 10000,
      healthCheckTimeout: options.healthCheckTimeout || 5000,
      failureThreshold: options.failureThreshold || 3,
      recoveryThreshold: options.recoveryThreshold || 2,
      circuitBreakerTimeout: options.circuitBreakerTimeout || 30000,
      ...options
    };
    
    this.startHealthCheck();
  }

  getNextServer() {
    const healthyServers = this.servers.filter(server => 
      server.isHealthy && server.circuitBreakerState === 'CLOSED'
    );
    
    if (healthyServers.length === 0) {
      // 모든 서버가 불건전한 경우, 절반 열린 상태의 서버도 고려
      const halfOpenServers = this.servers.filter(server => 
        server.circuitBreakerState === 'HALF_OPEN'
      );
      
      if (halfOpenServers.length > 0) {
        return this.selectServerByWeight(halfOpenServers);
      }
      
      throw new Error('No healthy servers available');
    }

    return this.selectServerByWeight(healthyServers);
  }

  selectServerByWeight(servers) {
    const totalWeight = servers.reduce((sum, server) => sum + server.weight, 0);
    let random = Math.random() * totalWeight;
    
    for (const server of servers) {
      random -= server.weight;
      if (random <= 0) {
        return server.url;
      }
    }
    
    return servers[0].url; // fallback
  }

  // 헬스체크 시작
  startHealthCheck() {
    setInterval(() => {
      this.performHealthCheck();
    }, this.options.healthCheckInterval);
  }

  // 헬스체크 수행
  async performHealthCheck() {
    const healthCheckPromises = this.servers.map(async (server) => {
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), this.options.healthCheckTimeout);
        
        const startTime = Date.now();
        const response = await fetch(`http://${server.url}${this.options.healthCheckPath}`, {
          method: 'GET',
          signal: controller.signal,
          headers: {
            'User-Agent': 'HealthCheck-LoadBalancer/1.0'
          }
        });
        
        clearTimeout(timeoutId);
        const responseTime = Date.now() - startTime;
        
        if (response.ok) {
          this.handleHealthCheckSuccess(server, responseTime);
        } else {
          this.handleHealthCheckFailure(server);
        }
      } catch (error) {
        this.handleHealthCheckFailure(server);
      }
    });

    await Promise.all(healthCheckPromises);
  }

  handleHealthCheckSuccess(server, responseTime) {
    server.consecutiveFailures = 0;
    server.responseTime = responseTime;
    server.lastHealthCheck = Date.now();
    
    if (server.circuitBreakerState === 'HALF_OPEN') {
      server.circuitBreakerState = 'CLOSED';
      console.log(`Circuit breaker closed for ${server.url}`);
    }
    
    if (!server.isHealthy) {
      server.isHealthy = true;
      console.log(`Server ${server.url} is now healthy`);
    }
  }

  handleHealthCheckFailure(server) {
    server.consecutiveFailures++;
    server.lastHealthCheck = Date.now();
    
    if (server.consecutiveFailures >= this.options.failureThreshold) {
      server.isHealthy = false;
      server.circuitBreakerState = 'OPEN';
      console.log(`Circuit breaker opened for ${server.url}`);
      
      // 일정 시간 후 절반 열린 상태로 전환
      setTimeout(() => {
        if (server.circuitBreakerState === 'OPEN') {
          server.circuitBreakerState = 'HALF_OPEN';
          console.log(`Circuit breaker half-opened for ${server.url}`);
        }
      }, this.options.circuitBreakerTimeout);
    }
  }

  // 서버 상태 정보 반환
  getServerStats() {
    return this.servers.map(server => ({
      url: server.url,
      isHealthy: server.isHealthy,
      circuitBreakerState: server.circuitBreakerState,
      consecutiveFailures: server.consecutiveFailures,
      responseTime: server.responseTime,
      lastHealthCheck: server.lastHealthCheck
    }));
  }

  // 수동으로 서버 상태 변경
  setServerHealth(serverUrl, isHealthy) {
    const server = this.servers.find(s => s.url === serverUrl);
    if (server) {
      server.isHealthy = isHealthy;
      server.consecutiveFailures = isHealthy ? 0 : server.consecutiveFailures;
      server.circuitBreakerState = isHealthy ? 'CLOSED' : 'OPEN';
    }
  }
}

// 사용 예시
const servers = [
  { url: 'server1:3000', weight: 3 },
  { url: 'server2:3000', weight: 2 },
  { url: 'server3:3000', weight: 1 }
];

const lb = new HealthCheckLoadBalancer(servers, {
  healthCheckPath: '/health',
  healthCheckInterval: 5000,
  failureThreshold: 2,
  circuitBreakerTimeout: 10000
});

// 요청 처리
async function handleRequest() {
  try {
    const serverUrl = lb.getNextServer();
    const response = await fetch(`http://${serverUrl}/api/data`);
    return response;
  } catch (error) {
    console.error('Request failed:', error);
    throw error;
  }
}

// 서버 상태 모니터링
setInterval(() => {
  const stats = lb.getServerStats();
  console.log('Server Stats:', stats);
}, 10000);
```

### 2. Nginx 로드 밸런싱 설정

```nginx
# nginx.conf
upstream backend {
    # 라운드 로빈 (기본값)
    server 127.0.0.1:3001;
    server 127.0.0.1:3002;
    
    # 가중치 기반
    server 127.0.0.1:3003 weight=3;
    server 127.0.0.1:3004 weight=1;
    
    # 최소 연결 수 기반
    least_conn;
    server 127.0.0.1:3005;
    server 127.0.0.1:3006;
    
    # IP 해시 기반 (세션 유지)
    ip_hash;
    server 127.0.0.1:3007;
    server 127.0.0.1:3008;
    
    # 헬스 체크
    server 127.0.0.1:3009 max_fails=3 fail_timeout=30s;
}

server {
    listen 80;
    server_name api.example.com;
    
    location / {
        proxy_pass http://backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        
        # 타임아웃 설정
        proxy_connect_timeout 5s;
        proxy_send_timeout 10s;
        proxy_read_timeout 10s;
    }
}
```

### 3. AWS 로드 밸런싱

#### Application Load Balancer (ALB)
```yaml
# ALB 설정 예시
apiVersion: v1
kind: Service
metadata:
  name: nodejs-app-service
  annotations:
    service.beta.kubernetes.io/aws-load-balancer-type: "nlb"
spec:
  type: LoadBalancer
  ports:
  - port: 80
    targetPort: 3000
    protocol: TCP
  selector:
    app: nodejs-app
```

---

## 분산 락 구현

### 1. Redis 기반 분산 락

```typescript
// src/distributed-lock/RedisDistributedLock.ts
import Redis from 'ioredis';

export interface LockOptions {
  ttl?: number; // 락 만료 시간 (밀리초)
  retryDelay?: number; // 재시도 간격 (밀리초)
  maxRetries?: number; // 최대 재시도 횟수
  retryJitter?: boolean; // 재시도 지터 적용 여부
}

export class RedisDistributedLock {
  private redis: Redis;
  private lockKey: string;
  private lockValue: string;
  private ttl: number;
  private retryDelay: number;
  private maxRetries: number;
  private retryJitter: boolean;
  private isLocked: boolean = false;
  private lockTimer?: NodeJS.Timeout;

  constructor(
    redis: Redis,
    lockKey: string,
    options: LockOptions = {}
  ) {
    this.redis = redis;
    this.lockKey = lockKey;
    this.lockValue = this.generateLockValue();
    this.ttl = options.ttl || 30000; // 30초 기본값
    this.retryDelay = options.retryDelay || 100; // 100ms 기본값
    this.maxRetries = options.maxRetries || 10; // 10회 기본값
    this.retryJitter = options.retryJitter !== false; // 기본값 true
  }

  // 락 획득
  async acquire(): Promise<boolean> {
    for (let attempt = 0; attempt <= this.maxRetries; attempt++) {
      try {
        // SET 명령어로 원자적 락 획득 시도
        const result = await this.redis.set(
          this.lockKey,
          this.lockValue,
          'PX', // 밀리초 단위 TTL
          this.ttl,
          'NX' // 키가 존재하지 않을 때만 설정
        );

        if (result === 'OK') {
          this.isLocked = true;
          this.startLockRenewal();
          console.log(`Lock acquired: ${this.lockKey}`);
          return true;
        }

        // 락 획득 실패 시 재시도
        if (attempt < this.maxRetries) {
          const delay = this.calculateRetryDelay(attempt);
          await this.sleep(delay);
        }
      } catch (error) {
        console.error(`Lock acquisition attempt ${attempt + 1} failed:`, error);
        if (attempt === this.maxRetries) {
          throw error;
        }
      }
    }

    return false;
  }

  // 락 해제
  async release(): Promise<boolean> {
    if (!this.isLocked) {
      return false;
    }

    try {
      // Lua 스크립트로 원자적 락 해제
      const script = `
        if redis.call("GET", KEYS[1]) == ARGV[1] then
          return redis.call("DEL", KEYS[1])
        else
          return 0
        end
      `;

      const result = await this.redis.eval(script, 1, this.lockKey, this.lockValue);
      
      if (result === 1) {
        this.isLocked = false;
        this.stopLockRenewal();
        console.log(`Lock released: ${this.lockKey}`);
        return true;
      } else {
        console.warn(`Lock release failed - lock value mismatch: ${this.lockKey}`);
        return false;
      }
    } catch (error) {
      console.error(`Lock release failed:`, error);
      return false;
    }
  }

  // 락 연장
  async extend(newTtl: number): Promise<boolean> {
    if (!this.isLocked) {
      return false;
    }

    try {
      const script = `
        if redis.call("GET", KEYS[1]) == ARGV[1] then
          return redis.call("PEXPIRE", KEYS[1], ARGV[2])
        else
          return 0
        end
      `;

      const result = await this.redis.eval(script, 1, this.lockKey, this.lockValue, newTtl);
      return result === 1;
    } catch (error) {
      console.error(`Lock extension failed:`, error);
      return false;
    }
  }

  // 락 상태 확인
  async isAcquired(): Promise<boolean> {
    try {
      const value = await this.redis.get(this.lockKey);
      return value === this.lockValue;
    } catch (error) {
      console.error(`Lock status check failed:`, error);
      return false;
    }
  }

  // 락 자동 연장 시작
  private startLockRenewal(): void {
    const renewalInterval = Math.floor(this.ttl * 0.7); // TTL의 70%마다 연장
    
    this.lockTimer = setInterval(async () => {
      if (this.isLocked) {
        const success = await this.extend(this.ttl);
        if (!success) {
          console.warn(`Lock renewal failed: ${this.lockKey}`);
          this.isLocked = false;
          this.stopLockRenewal();
        }
      }
    }, renewalInterval);
  }

  // 락 자동 연장 중지
  private stopLockRenewal(): void {
    if (this.lockTimer) {
      clearInterval(this.lockTimer);
      this.lockTimer = undefined;
    }
  }

  // 재시도 지연 시간 계산
  private calculateRetryDelay(attempt: number): number {
    let delay = this.retryDelay * Math.pow(2, attempt); // 지수 백오프
    
    if (this.retryJitter) {
      // 지터 추가 (±25%)
      const jitter = delay * 0.25 * (Math.random() * 2 - 1);
      delay += jitter;
    }
    
    return Math.min(delay, 1000); // 최대 1초
  }

  // 고유한 락 값 생성
  private generateLockValue(): string {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}-${process.pid}`;
  }

  // 대기 함수
  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  // 리소스 정리
  async cleanup(): Promise<void> {
    if (this.isLocked) {
      await this.release();
    }
  }
}

// 분산 락 매니저
export class DistributedLockManager {
  private redis: Redis;
  private locks: Map<string, RedisDistributedLock> = new Map();

  constructor(redis: Redis) {
    this.redis = redis;
  }

  // 락 생성 및 획득
  async acquireLock(
    lockKey: string,
    options: LockOptions = {}
  ): Promise<RedisDistributedLock | null> {
    const lock = new RedisDistributedLock(this.redis, lockKey, options);
    const acquired = await lock.acquire();
    
    if (acquired) {
      this.locks.set(lockKey, lock);
      return lock;
    }
    
    return null;
  }

  // 락 해제
  async releaseLock(lockKey: string): Promise<boolean> {
    const lock = this.locks.get(lockKey);
    if (lock) {
      const released = await lock.release();
      this.locks.delete(lockKey);
      return released;
    }
    return false;
  }

  // 모든 락 해제
  async releaseAllLocks(): Promise<void> {
    const releasePromises = Array.from(this.locks.values()).map(lock => lock.release());
    await Promise.all(releasePromises);
    this.locks.clear();
  }

  // 락 상태 확인
  async isLockAcquired(lockKey: string): Promise<boolean> {
    const lock = this.locks.get(lockKey);
    if (lock) {
      return await lock.isAcquired();
    }
    return false;
  }
}

// 사용 예시
const redis = new Redis({
  host: 'localhost',
  port: 6379,
  retryDelayOnFailover: 100,
  maxRetriesPerRequest: 3
});

const lockManager = new DistributedLockManager(redis);

// 락을 사용한 임계 구역 보호
async function criticalSection(lockKey: string, operation: () => Promise<void>) {
  const lock = await lockManager.acquireLock(lockKey, {
    ttl: 10000, // 10초
    maxRetries: 5,
    retryDelay: 200
  });

  if (!lock) {
    throw new Error('Failed to acquire lock');
  }

  try {
    await operation();
  } finally {
    await lock.release();
  }
}

// 사용 예시
await criticalSection('user:123:update', async () => {
  // 사용자 정보 업데이트 로직
  console.log('Updating user information...');
  await new Promise(resolve => setTimeout(resolve, 2000));
  console.log('User information updated');
});
```

---

## 다층 캐싱 전략

### 1. 다층 캐시 아키텍처

```typescript
// src/multi-layer-cache/MultiLayerCache.ts
import Redis from 'ioredis';
import { LRUCache } from 'lru-cache';

export interface CacheOptions {
  l1MaxSize?: number;
  l1Ttl?: number;
  l2Ttl?: number;
  l2Prefix?: string;
  enableL1?: boolean;
  enableL2?: boolean;
}

export interface CacheItem {
  value: any;
  timestamp: number;
  ttl: number;
}

export class MultiLayerCache {
  private l1Cache: LRUCache<string, CacheItem>;
  private l2Cache: Redis;
  private options: Required<CacheOptions>;

  constructor(redis: Redis, options: CacheOptions = {}) {
    this.options = {
      l1MaxSize: 1000,
      l1Ttl: 300000, // 5분
      l2Ttl: 3600000, // 1시간
      l2Prefix: 'cache:',
      enableL1: true,
      enableL2: true,
      ...options
    };

    // L1 캐시 (메모리) 초기화
    this.l1Cache = new LRUCache<string, CacheItem>({
      max: this.options.l1MaxSize,
      ttl: this.options.l1Ttl,
      updateAgeOnGet: true,
      updateAgeOnHas: true
    });

    this.l2Cache = redis;
  }

  // 캐시에서 데이터 조회
  async get<T>(key: string): Promise<T | null> {
    // L1 캐시에서 먼저 확인
    if (this.options.enableL1) {
      const l1Item = this.l1Cache.get(key);
      if (l1Item && !this.isExpired(l1Item)) {
        console.log(`L1 cache hit: ${key}`);
        return l1Item.value;
      }
    }

    // L2 캐시에서 확인
    if (this.options.enableL2) {
      try {
        const l2Key = this.getL2Key(key);
        const l2Value = await this.l2Cache.get(l2Key);
        
        if (l2Value) {
          const item: CacheItem = JSON.parse(l2Value);
          
          if (!this.isExpired(item)) {
            console.log(`L2 cache hit: ${key}`);
            
            // L1 캐시에 저장
            if (this.options.enableL1) {
              this.l1Cache.set(key, item);
            }
            
            return item.value;
          } else {
            // 만료된 데이터 삭제
            await this.l2Cache.del(l2Key);
          }
        }
      } catch (error) {
        console.error(`L2 cache error for key ${key}:`, error);
      }
    }

    console.log(`Cache miss: ${key}`);
    return null;
  }

  // 캐시에 데이터 저장
  async set(key: string, value: any, ttl?: number): Promise<void> {
    const item: CacheItem = {
      value,
      timestamp: Date.now(),
      ttl: ttl || this.options.l1Ttl
    };

    // L1 캐시에 저장
    if (this.options.enableL1) {
      this.l1Cache.set(key, item);
    }

    // L2 캐시에 저장
    if (this.options.enableL2) {
      try {
        const l2Key = this.getL2Key(key);
        const l2Ttl = Math.floor((ttl || this.options.l2Ttl) / 1000); // Redis는 초 단위
        await this.l2Cache.setex(l2Key, l2Ttl, JSON.stringify(item));
      } catch (error) {
        console.error(`L2 cache set error for key ${key}:`, error);
      }
    }
  }

  // 캐시에서 데이터 삭제
  async del(key: string): Promise<void> {
    // L1 캐시에서 삭제
    if (this.options.enableL1) {
      this.l1Cache.delete(key);
    }

    // L2 캐시에서 삭제
    if (this.options.enableL2) {
      try {
        const l2Key = this.getL2Key(key);
        await this.l2Cache.del(l2Key);
      } catch (error) {
        console.error(`L2 cache delete error for key ${key}:`, error);
      }
    }
  }

  // 캐시 무효화 (패턴 기반)
  async invalidatePattern(pattern: string): Promise<void> {
    // L1 캐시에서 패턴 매칭 삭제
    if (this.options.enableL1) {
      const keys = Array.from(this.l1Cache.keys());
      const matchingKeys = keys.filter(key => this.matchesPattern(key, pattern));
      
      matchingKeys.forEach(key => {
        this.l1Cache.delete(key);
      });
    }

    // L2 캐시에서 패턴 매칭 삭제
    if (this.options.enableL2) {
      try {
        const l2Pattern = this.getL2Key(pattern);
        const keys = await this.l2Cache.keys(l2Pattern);
        
        if (keys.length > 0) {
          await this.l2Cache.del(...keys);
        }
      } catch (error) {
        console.error(`L2 cache pattern invalidation error:`, error);
      }
    }
  }

  // 캐시 워밍업
  async warmup(keyValuePairs: Array<{ key: string; value: any; ttl?: number }>): Promise<void> {
    console.log(`Starting cache warmup for ${keyValuePairs.length} items`);
    
    const warmupPromises = keyValuePairs.map(async ({ key, value, ttl }) => {
      await this.set(key, value, ttl);
    });

    await Promise.all(warmupPromises);
    console.log('Cache warmup completed');
  }

  // 캐시 통계
  getStats() {
    return {
      l1: {
        size: this.l1Cache.size,
        maxSize: this.options.l1MaxSize,
        hitRate: this.calculateHitRate()
      },
      l2: {
        enabled: this.options.enableL2
      }
    };
  }

  // L2 캐시 키 생성
  private getL2Key(key: string): string {
    return `${this.options.l2Prefix}${key}`;
  }

  // 만료 확인
  private isExpired(item: CacheItem): boolean {
    return Date.now() - item.timestamp > item.ttl;
  }

  // 패턴 매칭
  private matchesPattern(key: string, pattern: string): boolean {
    const regex = new RegExp(pattern.replace(/\*/g, '.*'));
    return regex.test(key);
  }

  // 히트율 계산
  private calculateHitRate(): number {
    // 실제 구현에서는 히트/미스 카운터를 유지해야 함
    return 0.85; // 예시 값
  }
}

// 캐시 무효화 전략
export class CacheInvalidationStrategy {
  private cache: MultiLayerCache;
  private invalidationRules: Map<string, string[]> = new Map();

  constructor(cache: MultiLayerCache) {
    this.cache = cache;
  }

  // 무효화 규칙 등록
  registerRule(entityType: string, cacheKeys: string[]): void {
    this.invalidationRules.set(entityType, cacheKeys);
  }

  // 엔티티 변경 시 관련 캐시 무효화
  async invalidateOnEntityChange(entityType: string, entityId: string): Promise<void> {
    const rules = this.invalidationRules.get(entityType);
    
    if (rules) {
      const invalidationPromises = rules.map(rule => {
        const pattern = rule.replace('{id}', entityId);
        return this.cache.invalidatePattern(pattern);
      });

      await Promise.all(invalidationPromises);
      console.log(`Cache invalidated for ${entityType}:${entityId}`);
    }
  }

  // 시간 기반 무효화
  async invalidateByTime(ttl: number): Promise<void> {
    // TTL 기반 자동 만료는 Redis와 LRU 캐시에서 자동 처리됨
    console.log(`Time-based invalidation set for ${ttl}ms`);
  }
}

// 캐시 워밍업 전략
export class CacheWarmupStrategy {
  private cache: MultiLayerCache;
  private dataSource: any; // 데이터 소스 (DB, API 등)

  constructor(cache: MultiLayerCache, dataSource: any) {
    this.cache = cache;
    this.dataSource = dataSource;
  }

  // 인기 데이터 워밍업
  async warmupPopularData(): Promise<void> {
    console.log('Starting popular data warmup...');
    
    try {
      // 인기 사용자 데이터
      const popularUsers = await this.dataSource.getPopularUsers(100);
      const userWarmupData = popularUsers.map(user => ({
        key: `user:${user.id}`,
        value: user,
        ttl: 3600000 // 1시간
      }));

      // 인기 상품 데이터
      const popularProducts = await this.dataSource.getPopularProducts(200);
      const productWarmupData = popularProducts.map(product => ({
        key: `product:${product.id}`,
        value: product,
        ttl: 1800000 // 30분
      }));

      // 인기 카테고리 데이터
      const categories = await this.dataSource.getCategories();
      const categoryWarmupData = categories.map(category => ({
        key: `category:${category.id}`,
        value: category,
        ttl: 7200000 // 2시간
      }));

      // 모든 데이터 워밍업
      await Promise.all([
        this.cache.warmup(userWarmupData),
        this.cache.warmup(productWarmupData),
        this.cache.warmup(categoryWarmupData)
      ]);

      console.log('Popular data warmup completed');
    } catch (error) {
      console.error('Popular data warmup failed:', error);
    }
  }

  // 예측적 워밍업
  async predictiveWarmup(userId: string): Promise<void> {
    console.log(`Starting predictive warmup for user ${userId}`);
    
    try {
      // 사용자 행동 패턴 분석
      const userBehavior = await this.dataSource.getUserBehavior(userId);
      
      // 추천 상품 워밍업
      const recommendedProducts = await this.dataSource.getRecommendations(userId);
      const recommendationData = recommendedProducts.map(product => ({
        key: `recommendation:${userId}:${product.id}`,
        value: product,
        ttl: 1800000 // 30분
      }));

      // 사용자 관심사 기반 카테고리 워밍업
      const interestCategories = await this.dataSource.getUserInterests(userId);
      const interestData = interestCategories.map(category => ({
        key: `interest:${userId}:${category.id}`,
        value: category,
        ttl: 3600000 // 1시간
      }));

      await Promise.all([
        this.cache.warmup(recommendationData),
        this.cache.warmup(interestData)
      ]);

      console.log(`Predictive warmup completed for user ${userId}`);
    } catch (error) {
      console.error(`Predictive warmup failed for user ${userId}:`, error);
    }
  }

  // 스케줄된 워밍업
  startScheduledWarmup(): void {
    // 매일 새벽 2시에 인기 데이터 워밍업
    const schedule = require('node-schedule');
    
    schedule.scheduleJob('0 2 * * *', async () => {
      console.log('Starting scheduled warmup...');
      await this.warmupPopularData();
    });

    // 매 시간마다 예측적 워밍업 (활성 사용자 대상)
    schedule.scheduleJob('0 * * * *', async () => {
      console.log('Starting hourly predictive warmup...');
      const activeUsers = await this.dataSource.getActiveUsers(1000);
      
      const warmupPromises = activeUsers.map(user => 
        this.predictiveWarmup(user.id)
      );
      
      await Promise.all(warmupPromises);
    });
  }
}

// 사용 예시
const redis = new Redis({
  host: 'localhost',
  port: 6379
});

const cache = new MultiLayerCache(redis, {
  l1MaxSize: 2000,
  l1Ttl: 300000, // 5분
  l2Ttl: 3600000, // 1시간
  enableL1: true,
  enableL2: true
});

// 캐시 무효화 전략 설정
const invalidationStrategy = new CacheInvalidationStrategy(cache);
invalidationStrategy.registerRule('user', [
  'user:{id}',
  'user:{id}:profile',
  'user:{id}:preferences'
]);
invalidationStrategy.registerRule('product', [
  'product:{id}',
  'product:{id}:details',
  'product:{id}:reviews'
]);

// 캐시 워밍업 전략 설정
const dataSource = {
  getPopularUsers: async (limit: number) => { /* 구현 */ },
  getPopularProducts: async (limit: number) => { /* 구현 */ },
  getCategories: async () => { /* 구현 */ },
  getUserBehavior: async (userId: string) => { /* 구현 */ },
  getRecommendations: async (userId: string) => { /* 구현 */ },
  getUserInterests: async (userId: string) => { /* 구현 */ },
  getActiveUsers: async (limit: number) => { /* 구현 */ }
};

const warmupStrategy = new CacheWarmupStrategy(cache, dataSource);

// 캐시 사용 예시
async function getUserData(userId: string) {
  // 캐시에서 먼저 확인
  let userData = await cache.get(`user:${userId}`);
  
  if (!userData) {
    // 캐시 미스 시 데이터베이스에서 조회
    userData = await dataSource.getUserById(userId);
    
    // 캐시에 저장
    await cache.set(`user:${userId}`, userData, 3600000); // 1시간
  }
  
  return userData;
}

// 사용자 정보 업데이트 시 캐시 무효화
async function updateUser(userId: string, userData: any) {
  // 데이터베이스 업데이트
  await dataSource.updateUser(userId, userData);
  
  // 관련 캐시 무효화
  await invalidationStrategy.invalidateOnEntityChange('user', userId);
}

// 애플리케이션 시작 시 워밍업
async function initializeCache() {
  await warmupStrategy.warmupPopularData();
  warmupStrategy.startScheduledWarmup();
}

// 캐시 통계 모니터링
setInterval(() => {
  const stats = cache.getStats();
  console.log('Cache Stats:', stats);
}, 60000); // 1분마다
```

### 2. 캐시 계층 구조

```
L1: 애플리케이션 캐시 (메모리)
L2: 분산 캐시 (Redis)
L3: CDN 캐시
L4: 데이터베이스 캐시
```

### 2. CDN (Content Delivery Network)

#### CloudFront 설정
```javascript
// CDN 캐싱 전략
const cdnConfig = {
  // 정적 자산 캐싱
  staticAssets: {
    cachePolicy: 'CachingOptimized',
    ttl: 31536000, // 1년
    headers: ['Accept-Encoding']
  },
  
  // API 응답 캐싱
  apiResponses: {
    cachePolicy: 'CachingDisabled',
    ttl: 0,
    headers: ['Authorization', 'Content-Type']
  },
  
  // 동적 콘텐츠 캐싱
  dynamicContent: {
    cachePolicy: 'CachingOptimizedForCompression',
    ttl: 3600, // 1시간
    headers: ['Accept-Encoding', 'Accept-Language']
  }
};
```

### 3. Application Cache (Redis)

#### 캐시 전략 구현
```javascript
class CacheManager {
  constructor(redisClient) {
    this.redis = redisClient;
    this.defaultTTL = 3600; // 1시간
  }

  // Cache-Aside 패턴
  async get(key) {
    try {
      const cached = await this.redis.get(key);
      if (cached) {
        return JSON.parse(cached);
      }
      return null;
    } catch (error) {
      console.error('Cache get error:', error);
      return null;
    }
  }

  async set(key, value, ttl = this.defaultTTL) {
    try {
      await this.redis.setex(key, ttl, JSON.stringify(value));
    } catch (error) {
      console.error('Cache set error:', error);
    }
  }

  // Write-Through 패턴
  async writeThrough(key, value, ttl = this.defaultTTL) {
    // 1. 데이터베이스에 저장
    await this.saveToDatabase(value);
    
    // 2. 캐시에 저장
    await this.set(key, value, ttl);
  }

  // Write-Behind 패턴
  async writeBehind(key, value, ttl = this.defaultTTL) {
    // 1. 캐시에 먼저 저장
    await this.set(key, value, ttl);
    
    // 2. 비동기로 데이터베이스에 저장
    setImmediate(() => {
      this.saveToDatabase(value).catch(console.error);
    });
  }

  // Cache-Aside 패턴 구현
  async getOrSet(key, fetchFunction, ttl = this.defaultTTL) {
    // 1. 캐시에서 조회
    let value = await this.get(key);
    
    if (value === null) {
      // 2. 캐시에 없으면 데이터베이스에서 조회
      value = await fetchFunction();
      
      // 3. 캐시에 저장
      if (value !== null) {
        await this.set(key, value, ttl);
      }
    }
    
    return value;
  }
}
```

### 4. Database Cache

#### 쿼리 결과 캐싱
```javascript
class DatabaseCache {
  constructor(redisClient, dbConnection) {
    this.redis = redisClient;
    this.db = dbConnection;
  }

  async executeQuery(query, params, ttl = 300) {
    const cacheKey = this.generateCacheKey(query, params);
    
    // 캐시에서 조회
    let result = await this.redis.get(cacheKey);
    
    if (result) {
      return JSON.parse(result);
    }
    
    // 데이터베이스에서 조회
    result = await this.db.query(query, params);
    
    // 캐시에 저장
    await this.redis.setex(cacheKey, ttl, JSON.stringify(result));
    
    return result;
  }

  generateCacheKey(query, params) {
    const queryHash = require('crypto')
      .createHash('md5')
      .update(query + JSON.stringify(params))
      .digest('hex');
    
    return `query:${queryHash}`;
  }
}
```

---

## 데이터베이스 샤딩 및 파티셔닝

### 1. 샤딩 전략

#### 수평 샤딩 (Horizontal Sharding)
```javascript
class HorizontalSharding {
  constructor(shardCount) {
    this.shardCount = shardCount;
    this.shards = new Array(shardCount).fill(null).map(() => ({
      connection: null,
      data: new Map()
    }));
  }

  // 해시 기반 샤딩
  getShardId(key) {
    const hash = this.hashFunction(key);
    return hash % this.shardCount;
  }

  hashFunction(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return Math.abs(hash);
  }

  async insert(key, value) {
    const shardId = this.getShardId(key);
    const shard = this.shards[shardId];
    
    shard.data.set(key, value);
    console.log(`Inserted ${key} into shard ${shardId}`);
  }

  async get(key) {
    const shardId = this.getShardId(key);
    const shard = this.shards[shardId];
    
    return shard.data.get(key);
  }
}
```

#### 수직 샤딩 (Vertical Sharding)
```javascript
class VerticalSharding {
  constructor() {
    this.shards = {
      userProfile: new Map(),    // 사용자 프로필 정보
      userActivity: new Map(),   // 사용자 활동 로그
      userSettings: new Map()    // 사용자 설정
    };
  }

  async insertUserProfile(userId, profile) {
    this.shards.userProfile.set(userId, profile);
  }

  async insertUserActivity(userId, activity) {
    if (!this.shards.userActivity.has(userId)) {
      this.shards.userActivity.set(userId, []);
    }
    this.shards.userActivity.get(userId).push(activity);
  }

  async insertUserSettings(userId, settings) {
    this.shards.userSettings.set(userId, settings);
  }

  async getUserData(userId) {
    const profile = this.shards.userProfile.get(userId);
    const activities = this.shards.userActivity.get(userId) || [];
    const settings = this.shards.userSettings.get(userId);

    return {
      profile,
      activities,
      settings
    };
  }
}
```

### 2. 파티셔닝 전략

#### 범위 기반 파티셔닝
```sql
-- 날짜 기반 파티셔닝
CREATE TABLE user_activities (
    id BIGINT,
    user_id BIGINT,
    activity_type VARCHAR(50),
    created_at TIMESTAMP,
    data JSONB
) PARTITION BY RANGE (created_at);

-- 월별 파티션 생성
CREATE TABLE user_activities_2024_01 PARTITION OF user_activities
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

CREATE TABLE user_activities_2024_02 PARTITION OF user_activities
    FOR VALUES FROM ('2024-02-01') TO ('2024-03-01');
```

#### 해시 기반 파티셔닝
```sql
-- 사용자 ID 기반 해시 파티셔닝
CREATE TABLE users (
    id BIGINT,
    username VARCHAR(50),
    email VARCHAR(100),
    created_at TIMESTAMP
) PARTITION BY HASH (id);

-- 4개 파티션 생성
CREATE TABLE users_0 PARTITION OF users
    FOR VALUES WITH (modulus 4, remainder 0);

CREATE TABLE users_1 PARTITION OF users
    FOR VALUES WITH (modulus 4, remainder 1);

CREATE TABLE users_2 PARTITION OF users
    FOR VALUES WITH (modulus 4, remainder 2);

CREATE TABLE users_3 PARTITION OF users
    FOR VALUES WITH (modulus 4, remainder 3);
```

---

## 실제 대규모 시스템 설계 사례

### 1. 트위터 스타일 시스템

#### 시스템 요구사항
```
- 사용자: 1억 명
- 트윗: 초당 6,000개 작성
- 타임라인: 초당 300,000개 조회
- 팔로워: 평균 200명
```

#### 아키텍처 설계
```javascript
// 트위터 스타일 시스템 아키텍처
class TwitterLikeSystem {
  constructor() {
    this.userService = new UserService();
    this.tweetService = new TweetService();
    this.timelineService = new TimelineService();
    this.followService = new FollowService();
  }

  // 트윗 작성
  async postTweet(userId, content) {
    // 1. 트윗 저장
    const tweet = await this.tweetService.createTweet(userId, content);
    
    // 2. 팔로워들의 타임라인에 추가 (비동기)
    this.updateFollowersTimeline(userId, tweet);
    
    return tweet;
  }

  // 팔로워 타임라인 업데이트
  async updateFollowersTimeline(userId, tweet) {
    const followers = await this.followService.getFollowers(userId);
    
    // 배치 처리로 타임라인 업데이트
    const batchSize = 1000;
    for (let i = 0; i < followers.length; i += batchSize) {
      const batch = followers.slice(i, i + batchSize);
      
      // 비동기로 처리
      setImmediate(() => {
        this.timelineService.addToTimelines(batch, tweet);
      });
    }
  }

  // 타임라인 조회
  async getTimeline(userId, page = 1, limit = 20) {
    return await this.timelineService.getTimeline(userId, page, limit);
  }
}
```

#### 데이터 모델
```javascript
// 사용자 모델
class User {
  constructor(id, username, email, createdAt) {
    this.id = id;
    this.username = username;
    this.email = email;
    this.createdAt = createdAt;
    this.followersCount = 0;
    this.followingCount = 0;
  }
}

// 트윗 모델
class Tweet {
  constructor(id, userId, content, createdAt) {
    this.id = id;
    this.userId = userId;
    this.content = content;
    this.createdAt = createdAt;
    this.likesCount = 0;
    this.retweetsCount = 0;
  }
}

// 타임라인 모델
class Timeline {
  constructor(userId, tweetId, createdAt) {
    this.userId = userId;
    this.tweetId = tweetId;
    this.createdAt = createdAt;
  }
}
```

### 2. 넷플릭스 스타일 시스템

#### 시스템 요구사항
```
- 사용자: 2억 명
- 동시 스트리밍: 1,000만 명
- 콘텐츠: 15,000개 영화/시리즈
- 글로벌 서비스
```

#### 아키텍처 설계
```javascript
// 넷플릭스 스타일 시스템 아키텍처
class NetflixLikeSystem {
  constructor() {
    this.userService = new UserService();
    this.contentService = new ContentService();
    this.recommendationService = new RecommendationService();
    this.cdnService = new CDNService();
    this.analyticsService = new AnalyticsService();
  }

  // 콘텐츠 스트리밍
  async streamContent(userId, contentId, quality) {
    // 1. 사용자 인증 및 권한 확인
    const user = await this.userService.getUser(userId);
    if (!user.hasAccess(contentId)) {
      throw new Error('Access denied');
    }

    // 2. CDN에서 최적 서버 선택
    const cdnServer = await this.cdnService.getOptimalServer(user.location);
    
    // 3. 스트리밍 URL 생성
    const streamUrl = await this.cdnService.generateStreamUrl(contentId, quality, cdnServer);
    
    // 4. 분석 데이터 수집
    this.analyticsService.trackStreamingStart(userId, contentId, quality);
    
    return {
      streamUrl,
      quality,
      cdnServer
    };
  }

  // 추천 시스템
  async getRecommendations(userId) {
    const user = await this.userService.getUser(userId);
    const watchHistory = await this.analyticsService.getWatchHistory(userId);
    
    return await this.recommendationService.getRecommendations(user, watchHistory);
  }
}
```

#### CDN 최적화
```javascript
class CDNOptimizer {
  constructor() {
    this.regions = {
      'us-east': ['server1', 'server2', 'server3'],
      'us-west': ['server4', 'server5', 'server6'],
      'europe': ['server7', 'server8', 'server9'],
      'asia': ['server10', 'server11', 'server12']
    };
  }

  async getOptimalServer(userLocation) {
    const region = this.getRegion(userLocation);
    const servers = this.regions[region];
    
    // 서버 상태 확인 및 최적 서버 선택
    const serverStats = await Promise.all(
      servers.map(server => this.getServerStats(server))
    );
    
    // CPU 사용률이 가장 낮은 서버 선택
    const optimalServer = serverStats.reduce((min, current) => 
      current.cpuUsage < min.cpuUsage ? current : min
    );
    
    return optimalServer.name;
  }

  getRegion(location) {
    // 위치 기반 리전 결정 로직
    if (location.country === 'US') {
      return location.state === 'CA' ? 'us-west' : 'us-east';
    } else if (location.continent === 'Europe') {
      return 'europe';
    } else {
      return 'asia';
    }
  }
}
```

### 3. 시스템 모니터링 및 알림

```javascript
class SystemMonitor {
  constructor() {
    this.metrics = {
      responseTime: [],
      errorRate: [],
      throughput: [],
      cpuUsage: [],
      memoryUsage: []
    };
  }

  // 메트릭 수집
  collectMetrics() {
    setInterval(() => {
      this.metrics.responseTime.push(this.getAverageResponseTime());
      this.metrics.errorRate.push(this.getErrorRate());
      this.metrics.throughput.push(this.getThroughput());
      this.metrics.cpuUsage.push(this.getCpuUsage());
      this.metrics.memoryUsage.push(this.getMemoryUsage());
      
      // 임계값 확인
      this.checkThresholds();
    }, 60000); // 1분마다
  }

  // 임계값 확인 및 알림
  checkThresholds() {
    const currentErrorRate = this.metrics.errorRate[this.metrics.errorRate.length - 1];
    const currentResponseTime = this.metrics.responseTime[this.metrics.responseTime.length - 1];
    
    if (currentErrorRate > 0.05) { // 5% 이상
      this.sendAlert('High error rate detected', { errorRate: currentErrorRate });
    }
    
    if (currentResponseTime > 2000) { // 2초 이상
      this.sendAlert('High response time detected', { responseTime: currentResponseTime });
    }
  }

  sendAlert(message, data) {
    console.log(`ALERT: ${message}`, data);
    // 실제로는 Slack, PagerDuty 등으로 전송
  }
}
```

---

## 결론

시스템 설계 및 아키텍처 패턴은 확장 가능하고 안정적인 시스템을 구축하기 위한 핵심 요소입니다.

### 핵심 원칙 요약

1. **확장성**: 수평/수직 확장 전략 수립
2. **로드 밸런싱**: 적절한 알고리즘 선택 및 구현
3. **캐싱**: 다층 캐시 전략으로 성능 최적화
4. **데이터 분산**: 샤딩 및 파티셔닝으로 확장성 확보
5. **모니터링**: 지속적인 성능 모니터링 및 알림

### 실무 적용 가이드

- **소규모 시스템**: 단순한 구조로 시작
- **중규모 시스템**: 캐싱 및 로드 밸런싱 도입
- **대규모 시스템**: 마이크로서비스 및 분산 아키텍처 적용

이러한 원칙들을 바탕으로 요구사항에 맞는 최적의 시스템 아키텍처를 설계하세요.
