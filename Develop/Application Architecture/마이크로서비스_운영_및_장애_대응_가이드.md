# ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ ìš´ì˜ ë° ì¥ì•  ëŒ€ì‘ ê°€ì´ë“œ (Microservices Operations and Incident Response Guide)

## ëª©ì°¨ (Table of Contents)
1. [ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ ìš´ì˜ ê°œìš” (Microservices Operations Overview)](#ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤-ìš´ì˜-ê°œìš”)
2. [ì„œí‚· ë¸Œë ˆì´ì»¤ íŒ¨í„´ êµ¬í˜„ (Circuit Breaker Pattern Implementation)](#ì„œí‚·-ë¸Œë ˆì´ì»¤-íŒ¨í„´-êµ¬í˜„)
3. [ë¶„ì‚° ì¶”ì  ë° ë¡œê·¸ ì§‘ê³„ (Distributed Tracing and Log Aggregation)](#ë¶„ì‚°-ì¶”ì -ë°-ë¡œê·¸-ì§‘ê³„)
4. [ì¥ì•  ì „íŒŒ ë°©ì§€ ë° ê²©ë¦¬ ì „ëµ (Failure Propagation Prevention and Isolation Strategies)](#ì¥ì• -ì „íŒŒ-ë°©ì§€-ë°-ê²©ë¦¬-ì „ëµ)
5. [ë¬´ì¤‘ë‹¨ ë°°í¬ ì „ëµ (Zero-Downtime Deployment Strategies)](#ë¬´ì¤‘ë‹¨-ë°°í¬-ì „ëµ)
6. [ì‹¤ì œ ì¥ì•  ì‚¬ë¡€ ë¶„ì„ ë° ëŒ€ì‘ ë°©ë²• (Real Incident Case Analysis and Response Methods)](#ì‹¤ì œ-ì¥ì• -ì‚¬ë¡€-ë¶„ì„-ë°-ëŒ€ì‘-ë°©ë²•)

### ğŸ“Œ í†µí•©ëœ ê¸°ì¡´ íŒŒì¼ë“¤
ì´ ê°€ì´ë“œëŠ” ë‹¤ìŒ ê¸°ì¡´ íŒŒì¼ë“¤ì˜ ë‚´ìš©ì„ í†µí•©í•˜ì—¬ ë” ì²´ê³„ì ìœ¼ë¡œ ì •ë¦¬í•œ ê²ƒì…ë‹ˆë‹¤:
- **MSA ì•„í‚¤í…ì²˜**: ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ ì„¤ê³„ ì›ì¹™, ì„œë¹„ìŠ¤ ê°„ í†µì‹ , ì„œí‚· ë¸Œë ˆì´ì»¤ ê¸°ë³¸ êµ¬í˜„
- **ë¬´ì¤‘ë‹¨ ë°°í¬**: Blue-Green ë°°í¬ ì „ëµ, íŠ¸ë˜í”½ ì „í™˜, ë¡¤ë°± ë°©ë²•
- **ë¶„ì‚° ì¶”ì **: OpenTelemetry ê¸°ë°˜ ë¶„ì‚° ì¶”ì , íŠ¸ë ˆì´ìŠ¤ ìˆ˜ì§‘ ë° ë¶„ì„
- **ì„œë¹„ìŠ¤ ë©”ì‹œ**: Istio ê¸°ë°˜ ê´€ì°° ê°€ëŠ¥ì„±, ë©”íŠ¸ë¦­ ìˆ˜ì§‘, ë¡œê·¸ ì§‘ê³„
- **ë²Œí¬í—¤ë“œ**: ì¥ì•  ê²©ë¦¬ ì „ëµ, ë¦¬ì†ŒìŠ¤ ë¶„ë¦¬, ìŠ¤ë ˆë“œ í’€ ê´€ë¦¬
- **ì‹œìŠ¤í…œ ì„¤ê³„**: Circuit Breaker íŒ¨í„´, ì¥ì•  ëŒ€ì‘ ì „ëµ

## ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ ìš´ì˜ ê°œìš” (Microservices Operations Overview)

ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ ìš´ì˜ì€ ë¶„ì‚° ì‹œìŠ¤í…œì˜ ë³µì¡ì„±ì„ ê´€ë¦¬í•˜ê³ , ì¥ì•  ìƒí™©ì—ì„œ ì‹ ì†í•œ ëŒ€ì‘ì„ ìœ„í•œ ì²´ê³„ì ì¸ ì ‘ê·¼ ë°©ì‹ì…ë‹ˆë‹¤.

### ìš´ì˜ì˜ í•µì‹¬ ëª©í‘œ

1. **ê°€ìš©ì„± (Availability)**: 99.9% ì´ìƒì˜ ì„œë¹„ìŠ¤ ê°€ìš©ì„± ìœ ì§€
2. **ì•ˆì •ì„± (Reliability)**: ì¥ì•  ìƒí™©ì—ì„œì˜ ì‹ ì†í•œ ë³µêµ¬
3. **ê´€ì°° ê°€ëŠ¥ì„± (Observability)**: ì‹œìŠ¤í…œ ìƒíƒœì˜ ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§
4. **í™•ì¥ì„± (Scalability)**: íŠ¸ë˜í”½ ì¦ê°€ì— ë”°ë¥¸ ìœ ì—°í•œ ëŒ€ì‘

### ìš´ì˜ ëª¨ë¸ (Operations Model)

```mermaid
graph TD
    A[ëª¨ë‹ˆí„°ë§] --> B[ì•Œë¦¼]
    B --> C[ì¥ì•  ê°ì§€]
    C --> D[ëŒ€ì‘ ì¡°ì¹˜]
    D --> E[ë³µêµ¬]
    E --> F[ì‚¬í›„ ë¶„ì„]
    F --> G[ê°œì„ ]
    G --> A
```

## ì„œí‚· ë¸Œë ˆì´ì»¤ íŒ¨í„´ êµ¬í˜„ (Circuit Breaker Pattern Implementation)

### 1. Hystrix ê¸°ë°˜ êµ¬í˜„

```javascript
const HystrixCommand = require('hystrixjs').commandFactory;

// Hystrix ì„œí‚· ë¸Œë ˆì´ì»¤ ì„¤ì •
const paymentServiceCommand = HystrixCommand.getOrCreate('PaymentService')
  .circuitBreakerRequestVolumeThreshold(20)
  .circuitBreakerSleepWindowInMilliseconds(5000)
  .circuitBreakerErrorThresholdPercentage(50)
  .timeout(3000)
  .run(async () => {
    const response = await fetch('http://payment-service/api/process', {
      method: 'POST',
      body: JSON.stringify(paymentData)
    });
    
    if (!response.ok) {
      throw new Error(`Payment failed: ${response.status}`);
    }
    
    return await response.json();
  })
  .fallbackTo(() => {
    // í´ë°± ì²˜ë¦¬
    return {
      success: false,
      message: 'Payment service is temporarily unavailable'
    };
  });

// ì‚¬ìš© ì˜ˆì‹œ
async function processPayment(paymentData) {
  try {
    const result = await paymentServiceCommand.execute();
    return result;
  } catch (error) {
    console.error('Payment processing failed:', error);
    throw error;
  }
}
```

### 2. Resilience4j ê¸°ë°˜ êµ¬í˜„

```javascript
const { CircuitBreaker, Retry, Timeout } = require('resilience4js');

// ì„œí‚· ë¸Œë ˆì´ì»¤ ì„¤ì •
const circuitBreaker = new CircuitBreaker({
  failureRateThreshold: 50,
  waitDurationInOpenState: 5000,
  minimumNumberOfCalls: 20,
  slidingWindowSize: 10
});

// ì¬ì‹œë„ ì„¤ì •
const retry = new Retry({
  maxAttempts: 3,
  waitDuration: 1000,
  exponentialBackoffMultiplier: 2
});

// íƒ€ì„ì•„ì›ƒ ì„¤ì •
const timeout = new Timeout({
  duration: 3000
});

// ì„œë¹„ìŠ¤ í˜¸ì¶œ ë˜í•‘
async function callUserService(userId) {
  const decoratedFunction = circuitBreaker.decorate(
    retry.decorate(
      timeout.decorate(async () => {
        const response = await fetch(`http://user-service/api/users/${userId}`);
        return await response.json();
      })
    )
  );
  
  return await decoratedFunction();
}
```

### 3. ì»¤ìŠ¤í…€ ì„œí‚· ë¸Œë ˆì´ì»¤

```javascript
class AdvancedCircuitBreaker {
  constructor(options = {}) {
    this.failureThreshold = options.failureThreshold || 5;
    this.timeout = options.timeout || 60000;
    this.resetTimeout = options.resetTimeout || 30000;
    this.monitoringPeriod = options.monitoringPeriod || 10000;
    
    this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN
    this.failureCount = 0;
    this.successCount = 0;
    this.lastFailureTime = null;
    this.metrics = {
      totalRequests: 0,
      failedRequests: 0,
      successfulRequests: 0
    };
  }
  
  async execute(operation, fallback = null) {
    this.metrics.totalRequests++;
    
    if (this.state === 'OPEN') {
      if (this.shouldAttemptReset()) {
        this.state = 'HALF_OPEN';
        console.log('Circuit breaker transitioning to HALF_OPEN');
      } else {
        this.metrics.failedRequests++;
        if (fallback) {
          return await fallback();
        }
        throw new Error('Circuit breaker is OPEN');
      }
    }
    
    try {
      const result = await this.withTimeout(operation, this.timeout);
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      if (fallback && this.state === 'OPEN') {
        return await fallback();
      }
      throw error;
    }
  }
  
  onSuccess() {
    this.successCount++;
    this.metrics.successfulRequests++;
    
    if (this.state === 'HALF_OPEN') {
      this.state = 'CLOSED';
      this.failureCount = 0;
      console.log('Circuit breaker transitioning to CLOSED');
    }
  }
  
  onFailure() {
    this.failureCount++;
    this.lastFailureTime = Date.now();
    this.metrics.failedRequests++;
    
    if (this.failureCount >= this.failureThreshold) {
      this.state = 'OPEN';
      console.log('Circuit breaker transitioning to OPEN');
    }
  }
  
  shouldAttemptReset() {
    return Date.now() - this.lastFailureTime >= this.resetTimeout;
  }
  
  async withTimeout(operation, timeout) {
    return Promise.race([
      operation(),
      new Promise((_, reject) => 
        setTimeout(() => reject(new Error('Operation timeout')), timeout)
      )
    ]);
  }
  
  getMetrics() {
    return {
      state: this.state,
      failureCount: this.failureCount,
      successCount: this.successCount,
      metrics: this.metrics
    };
  }
}
```

## ë¶„ì‚° ì¶”ì  ë° ë¡œê·¸ ì§‘ê³„ (Distributed Tracing and Log Aggregation)

### 1. OpenTelemetry ê¸°ë°˜ ë¶„ì‚° ì¶”ì 

```javascript
const { NodeTracerProvider } = require('@opentelemetry/sdk-node');
const { getNodeAutoInstrumentations } = require('@opentelemetry/auto-instrumentations-node');
const { JaegerExporter } = require('@opentelemetry/exporter-jaeger');

// OpenTelemetry ì„¤ì •
const tracerProvider = new NodeTracerProvider({
  resource: new Resource({
    [SemanticResourceAttributes.SERVICE_NAME]: 'user-service',
    [SemanticResourceAttributes.SERVICE_VERSION]: '1.0.0'
  })
});

const jaegerExporter = new JaegerExporter({
  endpoint: 'http://jaeger:14268/api/traces'
});

tracerProvider.addSpanProcessor(new BatchSpanProcessor(jaegerExporter));
tracerProvider.register();

// ìë™ ê³„ì¸¡ í™œì„±í™”
registerInstrumentations({
  instrumentations: [getNodeAutoInstrumentations()]
});

// ìˆ˜ë™ ì¶”ì 
const tracer = trace.getTracer('user-service');

async function createUser(userData) {
  const span = tracer.startSpan('createUser');
  
  try {
    span.setAttributes({
      'user.email': userData.email,
      'user.name': userData.name
    });
    
    const user = await userRepository.save(userData);
    span.setStatus({ code: SpanStatusCode.OK });
    
    return user;
  } catch (error) {
    span.setStatus({ 
      code: SpanStatusCode.ERROR, 
      message: error.message 
    });
    span.recordException(error);
    throw error;
  } finally {
    span.end();
  }
}
```

### 2. ELK Stack ë¡œê·¸ ì§‘ê³„

#### Logstash ì„¤ì •
```ruby
# logstash.conf
input {
  beats {
    port => 5044
  }
}

filter {
  if [fields][service] {
    mutate {
      add_tag => ["microservice"]
    }
  }
  
  grok {
    match => { "message" => "%{TIMESTAMP_ISO8601:timestamp} \[%{DATA:level}\] %{DATA:service} %{GREEDYDATA:log_message}" }
  }
  
  date {
    match => [ "timestamp", "ISO8601" ]
  }
}

output {
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "microservices-%{+YYYY.MM.dd}"
  }
}
```

#### Node.js ë¡œê¹… ì„¤ì •
```javascript
const winston = require('winston');
const { ElasticsearchTransport } = require('winston-elasticsearch');

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  defaultMeta: {
    service: 'user-service',
    version: '1.0.0'
  },
  transports: [
    new winston.transports.Console({
      format: winston.format.simple()
    }),
    new ElasticsearchTransport({
      clientOpts: { node: 'http://elasticsearch:9200' },
      index: 'microservices-logs'
    })
  ]
});

// êµ¬ì¡°í™”ëœ ë¡œê¹…
logger.info('User created successfully', {
  userId: user.id,
  email: user.email,
  duration: Date.now() - startTime,
  traceId: trace.getActiveSpan()?.spanContext().traceId
});
```

### 3. ë¡œê·¸ ë¶„ì„ ë° ëª¨ë‹ˆí„°ë§

```javascript
class LogAnalyzer {
  constructor(elasticsearchClient) {
    this.es = elasticsearchClient;
  }
  
  async analyzeErrorPatterns(timeRange = '1h') {
    const query = {
      index: 'microservices-*',
      body: {
        query: {
          bool: {
            must: [
              { range: { '@timestamp': { gte: `now-${timeRange}` } } },
              { term: { level: 'error' } }
            ]
          }
        },
        aggs: {
          errors_by_service: {
            terms: { field: 'service.keyword' },
            aggs: {
              error_types: {
                terms: { field: 'log_message.keyword' }
              }
            }
          }
        }
      }
    };
    
    const response = await this.es.search(query);
    return response.aggregations.errors_by_service.buckets;
  }
  
  async getServiceHealthMetrics(serviceName) {
    const query = {
      index: `microservices-*`,
      body: {
        query: {
          bool: {
            must: [
              { term: { service: serviceName } },
              { range: { '@timestamp': { gte: 'now-1h' } } }
            ]
          }
        },
        aggs: {
          response_times: {
            percentiles: {
              field: 'duration',
              percents: [50, 95, 99]
            }
          },
          error_rate: {
            filters: {
              filters: {
                errors: { term: { level: 'error' } },
                all: { match_all: {} }
              }
            }
          }
        }
      }
    };
    
    return await this.es.search(query);
  }
}
```

## ì¥ì•  ì „íŒŒ ë°©ì§€ ë° ê²©ë¦¬ ì „ëµ (Failure Propagation Prevention and Isolation Strategies)

### 1. ë²Œí¬í—¤ë“œ íŒ¨í„´ (Bulkhead Pattern)

```javascript
class BulkheadIsolation {
  constructor() {
    this.threadPools = new Map();
    this.maxPoolSize = 10;
    this.queueSize = 100;
  }
  
  createThreadPool(name, maxSize = this.maxPoolSize) {
    const pool = {
      name,
      maxSize,
      active: 0,
      queue: [],
      tasks: new Set()
    };
    
    this.threadPools.set(name, pool);
    return pool;
  }
  
  async execute(taskName, operation) {
    const pool = this.threadPools.get(taskName);
    
    if (!pool) {
      throw new Error(`Thread pool '${taskName}' not found`);
    }
    
    return new Promise((resolve, reject) => {
      const task = { operation, resolve, reject };
      
      if (pool.active < pool.maxSize) {
        this.executeTask(pool, task);
      } else if (pool.queue.length < this.queueSize) {
        pool.queue.push(task);
      } else {
        reject(new Error(`Thread pool '${taskName}' is full`));
      }
    });
  }
  
  async executeTask(pool, task) {
    pool.active++;
    pool.tasks.add(task);
    
    try {
      const result = await task.operation();
      task.resolve(result);
    } catch (error) {
      task.reject(error);
    } finally {
      pool.active--;
      pool.tasks.delete(task);
      
      // íì—ì„œ ë‹¤ìŒ ì‘ì—… ì²˜ë¦¬
      if (pool.queue.length > 0) {
        const nextTask = pool.queue.shift();
        this.executeTask(pool, nextTask);
      }
    }
  }
  
  getPoolMetrics(name) {
    const pool = this.threadPools.get(name);
    if (!pool) return null;
    
    return {
      name: pool.name,
      active: pool.active,
      maxSize: pool.maxSize,
      queued: pool.queue.length,
      queueSize: this.queueSize,
      utilization: (pool.active / pool.maxSize) * 100
    };
  }
}

// ì‚¬ìš© ì˜ˆì‹œ
const bulkhead = new BulkheadIsolation();

// ê° ê¸°ëŠ¥ë³„ë¡œ ë…ë¦½ì ì¸ ìŠ¤ë ˆë“œ í’€ ìƒì„±
bulkhead.createThreadPool('payment', 5);
bulkhead.createThreadPool('notification', 3);
bulkhead.createThreadPool('analytics', 2);

// ê²°ì œ ì²˜ë¦¬ëŠ” ìµœëŒ€ 5ê°œ ë™ì‹œ ì‹¤í–‰
async function processPayment(paymentData) {
  return bulkhead.execute('payment', async () => {
    return await paymentService.process(paymentData);
  });
}

// ì•Œë¦¼ ë°œì†¡ì€ ìµœëŒ€ 3ê°œ ë™ì‹œ ì‹¤í–‰
async function sendNotification(userId, message) {
  return bulkhead.execute('notification', async () => {
    return await notificationService.send(userId, message);
  });
}
```

### 2. íƒ€ì„ì•„ì›ƒ ë° ì¬ì‹œë„ ì „ëµ

```javascript
class ResilienceStrategies {
  static async withTimeout(operation, timeoutMs = 5000) {
    return Promise.race([
      operation(),
      new Promise((_, reject) => 
        setTimeout(() => reject(new Error('Operation timeout')), timeoutMs)
      )
    ]);
  }
  
  static async withRetry(operation, maxRetries = 3, delay = 1000) {
    let lastError;
    
    for (let i = 0; i <= maxRetries; i++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error;
        
        if (i === maxRetries) {
          break;
        }
        
        // ì§€ìˆ˜ ë°±ì˜¤í”„
        const waitTime = delay * Math.pow(2, i);
        await new Promise(resolve => setTimeout(resolve, waitTime));
      }
    }
    
    throw lastError;
  }
  
  static async withFallback(operation, fallbackOperation) {
    try {
      return await operation();
    } catch (error) {
      console.warn('Primary operation failed, using fallback:', error.message);
      return await fallbackOperation();
    }
  }
}

// ì‚¬ìš© ì˜ˆì‹œ
async function resilientServiceCall(serviceUrl, data) {
  return ResilienceStrategies.withFallback(
    // ì£¼ìš” ì‘ì—…
    () => ResilienceStrategies.withTimeout(
      () => ResilienceStrategies.withRetry(
        async () => {
          const response = await fetch(serviceUrl, {
            method: 'POST',
            body: JSON.stringify(data)
          });
          
          if (!response.ok) {
            throw new Error(`Service call failed: ${response.status}`);
          }
          
          return await response.json();
        },
        3, // ìµœëŒ€ 3íšŒ ì¬ì‹œë„
        1000 // 1ì´ˆë¶€í„° ì‹œì‘
      ),
      5000 // 5ì´ˆ íƒ€ì„ì•„ì›ƒ
    ),
    // í´ë°± ì‘ì—…
    async () => {
      return {
        success: false,
        message: 'Service temporarily unavailable',
        cached: true,
        timestamp: Date.now()
      };
    }
  );
}
```

## ë¬´ì¤‘ë‹¨ ë°°í¬ ì „ëµ (Zero-Downtime Deployment Strategies)

### 1. Blue-Green ë°°í¬

```yaml
# blue-green-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: app-blue
  labels:
    version: blue
spec:
  replicas: 3
  selector:
    matchLabels:
      app: microservice-app
      version: blue
  template:
    metadata:
      labels:
        app: microservice-app
        version: blue
    spec:
      containers:
      - name: app
        image: microservice-app:blue-v1.0.0
        ports:
        - containerPort: 3000
---
apiVersion: v1
kind: Service
metadata:
  name: app-service
spec:
  selector:
    app: microservice-app
    version: blue  # í˜„ì¬ Blue í™˜ê²½ì„ ê°€ë¦¬í‚´
  ports:
  - port: 80
    targetPort: 3000
```

```bash
# Blue-Green ë°°í¬ ìŠ¤í¬ë¦½íŠ¸
#!/bin/bash

NAMESPACE="microservices"
APP_NAME="microservice-app"
NEW_VERSION="green-v1.0.1"

echo "ğŸš€ Blue-Green ë°°í¬ ì‹œì‘..."

# 1. Green í™˜ê²½ ë°°í¬
echo "ğŸ“¦ Green í™˜ê²½ ë°°í¬ ì¤‘..."
kubectl apply -f green-deployment.yaml

# 2. Green í™˜ê²½ í—¬ìŠ¤ ì²´í¬
echo "ğŸ¥ Green í™˜ê²½ í—¬ìŠ¤ ì²´í¬ ì¤‘..."
for i in {1..30}; do
  if kubectl get pods -l version=green --no-headers | grep -q "Running"; then
    echo "âœ… Green í™˜ê²½ ì¤€ë¹„ ì™„ë£Œ"
    break
  fi
  echo "â³ ëŒ€ê¸° ì¤‘... ($i/30)"
  sleep 10
done

# 3. íŠ¸ë˜í”½ ì „í™˜
echo "ğŸ”„ íŠ¸ë˜í”½ì„ Greenìœ¼ë¡œ ì „í™˜ ì¤‘..."
kubectl patch service app-service -p '{"spec":{"selector":{"version":"green"}}}'

# 4. Green í™˜ê²½ ì•ˆì •ì„± í™•ì¸
echo "ğŸ” Green í™˜ê²½ ì•ˆì •ì„± í™•ì¸ ì¤‘..."
sleep 60

# 5. Blue í™˜ê²½ ì •ë¦¬ (ì„ íƒì )
read -p "Blue í™˜ê²½ì„ ì •ë¦¬í•˜ì‹œê² ìŠµë‹ˆê¹Œ? (y/n): " -n 1 -r
echo
if [[ $REPLY =~ ^[Yy]$ ]]; then
  echo "ğŸ§¹ Blue í™˜ê²½ ì •ë¦¬ ì¤‘..."
  kubectl delete deployment app-blue
fi

echo "âœ… Blue-Green ë°°í¬ ì™„ë£Œ!"
```

### 2. Canary ë°°í¬

```yaml
# canary-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: app-canary
  labels:
    version: canary
spec:
  replicas: 1  # ì†Œìˆ˜ì˜ ì¸ìŠ¤í„´ìŠ¤ë¡œ ì‹œì‘
  selector:
    matchLabels:
      app: microservice-app
      version: canary
  template:
    metadata:
      labels:
        app: microservice-app
        version: canary
    spec:
      containers:
      - name: app
        image: microservice-app:canary-v1.0.1
        ports:
        - containerPort: 3000
---
# íŠ¸ë˜í”½ ë¶„í• ì„ ìœ„í•œ Virtual Service (Istio)
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: app-virtual-service
spec:
  http:
  - match:
    - headers:
        canary-user:
          exact: "true"
    route:
    - destination:
        host: app-service
        subset: canary
      weight: 100
  - route:
    - destination:
        host: app-service
        subset: stable
      weight: 90
    - destination:
        host: app-service
        subset: canary
      weight: 10
```

```javascript
// Canary ë°°í¬ë¥¼ ìœ„í•œ í”„ë¡ íŠ¸ì—”ë“œ ë¼ìš°íŒ…
class CanaryRouter {
  constructor() {
    this.canaryPercentage = 10; // 10% íŠ¸ë˜í”½ì„ canaryë¡œ
    this.canaryUsers = new Set(); // ìºì‹œëœ canary ì‚¬ìš©ì
  }
  
  shouldRouteToCanary(userId) {
    // íŠ¹ë³„ í—¤ë”ê°€ ìˆëŠ” ê²½ìš°
    if (this.isCanaryUser(userId)) {
      return true;
    }
    
    // í¼ì„¼íŠ¸ ê¸°ë°˜ ë¼ìš°íŒ…
    const hash = this.hashUserId(userId);
    return hash % 100 < this.canaryPercentage;
  }
  
  hashUserId(userId) {
    let hash = 0;
    for (let i = 0; i < userId.length; i++) {
      hash = ((hash << 5) - hash + userId.charCodeAt(i)) & 0xffffffff;
    }
    return Math.abs(hash);
  }
  
  isCanaryUser(userId) {
    return this.canaryUsers.has(userId);
  }
  
  addCanaryUser(userId) {
    this.canaryUsers.add(userId);
  }
}
```

### 3. Rolling ë°°í¬

```yaml
# rolling-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: app-rolling
spec:
  replicas: 5
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1  # ìµœëŒ€ 1ê°œ ì¸ìŠ¤í„´ìŠ¤ë§Œ ë™ì‹œì— ë‹¤ìš´
      maxSurge: 1        # ìµœëŒ€ 1ê°œ ì¸ìŠ¤í„´ìŠ¤ë§Œ ë™ì‹œì— ì¶”ê°€
  selector:
    matchLabels:
      app: microservice-app
  template:
    metadata:
      labels:
        app: microservice-app
    spec:
      containers:
      - name: app
        image: microservice-app:rolling-v1.0.1
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5
```

## ì‹¤ì œ ì¥ì•  ì‚¬ë¡€ ë¶„ì„ ë° ëŒ€ì‘ ë°©ë²• (Real Incident Case Analysis and Response Methods)

### 1. ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° í’€ ê³ ê°ˆ ì‚¬ë¡€

#### ë¬¸ì œ ìƒí™©
```javascript
// ë¬¸ì œê°€ ìˆëŠ” ì½”ë“œ
class DatabaseService {
  constructor() {
    this.pool = new Pool({
      connectionLimit: 10,
      acquireTimeoutMillis: 30000
    });
  }
  
  async query(sql, params) {
    // ì—°ê²°ì„ ì œëŒ€ë¡œ ë°˜í™˜í•˜ì§€ ì•ŠìŒ
    const connection = await this.pool.getConnection();
    const result = await connection.query(sql, params);
    // connection.release() ëˆ„ë½!
    return result;
  }
}
```

#### í•´ê²° ë°©ì•ˆ
```javascript
class ImprovedDatabaseService {
  constructor() {
    this.pool = new Pool({
      connectionLimit: 20,
      acquireTimeoutMillis: 5000,
      timeout: 30000,
      idleTimeoutMillis: 300000
    });
    
    // ì—°ê²° í’€ ëª¨ë‹ˆí„°ë§
    setInterval(() => {
      console.log('Pool status:', {
        total: this.pool.totalConnections,
        idle: this.pool.idleConnections,
        queued: this.pool.queuedRequests
      });
    }, 10000);
  }
  
  async query(sql, params) {
    let connection;
    try {
      connection = await this.pool.getConnection();
      const result = await connection.query(sql, params);
      return result;
    } catch (error) {
      console.error('Database query failed:', error);
      throw error;
    } finally {
      if (connection) {
        connection.release();
      }
    }
  }
  
  async withTransaction(operation) {
    let connection;
    try {
      connection = await this.pool.getConnection();
      await connection.beginTransaction();
      
      const result = await operation(connection);
      
      await connection.commit();
      return result;
    } catch (error) {
      if (connection) {
        await connection.rollback();
      }
      throw error;
    } finally {
      if (connection) {
        connection.release();
      }
    }
  }
}
```

### 2. ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ì‚¬ë¡€

#### ë¬¸ì œ ìƒí™©
```javascript
// ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ê°€ ìˆëŠ” ì½”ë“œ
class EventService {
  constructor() {
    this.eventHandlers = new Map();
  }
  
  subscribe(eventType, handler) {
    // ë©”ëª¨ë¦¬ ëˆ„ìˆ˜: êµ¬ë… í•´ì œê°€ ì—†ìŒ
    if (!this.eventHandlers.has(eventType)) {
      this.eventHandlers.set(eventType, []);
    }
    this.eventHandlers.get(eventType).push(handler);
  }
  
  // unsubscribe ë©”ì„œë“œê°€ ì—†ìŒ!
}
```

#### í•´ê²° ë°©ì•ˆ
```javascript
class ImprovedEventService {
  constructor() {
    this.eventHandlers = new Map();
    this.weakRefs = new WeakMap(); // WeakMapìœ¼ë¡œ ì°¸ì¡° ê´€ë¦¬
  }
  
  subscribe(eventType, handler) {
    if (!this.eventHandlers.has(eventType)) {
      this.eventHandlers.set(eventType, new Set());
    }
    
    const handlerSet = this.eventHandlers.get(eventType);
    handlerSet.add(handler);
    
    // WeakMapì„ ì‚¬ìš©í•˜ì—¬ ì •ë¦¬ ì¶”ì 
    this.weakRefs.set(handler, { eventType, handlerSet });
    
    // ìë™ ì •ë¦¬ ê¸°ëŠ¥
    return {
      unsubscribe: () => this.unsubscribe(eventType, handler)
    };
  }
  
  unsubscribe(eventType, handler) {
    const handlerSet = this.eventHandlers.get(eventType);
    if (handlerSet) {
      handlerSet.delete(handler);
      
      // ë¹ˆ Set ì •ë¦¬
      if (handlerSet.size === 0) {
        this.eventHandlers.delete(eventType);
      }
    }
    
    this.weakRefs.delete(handler);
  }
  
  // ì •ê¸°ì ì¸ ë©”ëª¨ë¦¬ ì •ë¦¬
  cleanup() {
    const beforeSize = this.eventHandlers.size;
    
    for (const [eventType, handlers] of this.eventHandlers) {
      if (handlers.size === 0) {
        this.eventHandlers.delete(eventType);
      }
    }
    
    const afterSize = this.eventHandlers.size;
    console.log(`Cleaned up ${beforeSize - afterSize} empty event types`);
  }
}
```

### 3. ì¥ì•  ëŒ€ì‘ ì²´í¬ë¦¬ìŠ¤íŠ¸

```javascript
class IncidentResponseChecklist {
  static async handleIncident(incident) {
    console.log('ğŸš¨ ì¥ì•  ëŒ€ì‘ ì‹œì‘:', incident);
    
    // 1. ì´ˆê¸° ëŒ€ì‘ (0-5ë¶„)
    await this.initialResponse(incident);
    
    // 2. ë¬¸ì œ ì¡°ì‚¬ (5-15ë¶„)
    await this.investigateIssue(incident);
    
    // 3. í•´ê²° ì‹œë„ (15-30ë¶„)
    await this.attemptResolution(incident);
    
    // 4. ì‚¬í›„ ë¶„ì„ (30ë¶„ ì´í›„)
    await this.postIncidentAnalysis(incident);
  }
  
  static async initialResponse(incident) {
    console.log('1ï¸âƒ£ ì´ˆê¸° ëŒ€ì‘ ë‹¨ê³„');
    
    // ì•Œë¦¼ ë°œì†¡
    await this.sendAlert(incident);
    
    // ì˜í–¥ ë²”ìœ„ íŒŒì•…
    const impact = await this.assessImpact(incident);
    
    // ìš°ì„ ìˆœìœ„ ê²°ì •
    const priority = this.calculatePriority(incident, impact);
    
    console.log(`ìš°ì„ ìˆœìœ„: ${priority}, ì˜í–¥: ${impact}`);
  }
  
  static async investigateIssue(incident) {
    console.log('2ï¸âƒ£ ë¬¸ì œ ì¡°ì‚¬ ë‹¨ê³„');
    
    // ë¡œê·¸ ìˆ˜ì§‘
    const logs = await this.collectLogs(incident);
    
    // ë©”íŠ¸ë¦­ í™•ì¸
    const metrics = await this.checkMetrics(incident);
    
    // íŠ¸ë ˆì´ìŠ¤ ì¶”ì 
    const traces = await this.analyzeTraces(incident);
    
    console.log('ì¡°ì‚¬ ì™„ë£Œ:', { logs: logs.length, metrics, traces });
  }
  
  static async attemptResolution(incident) {
    console.log('3ï¸âƒ£ í•´ê²° ì‹œë„ ë‹¨ê³„');
    
    const resolutionSteps = [
      'ì„œë¹„ìŠ¤ ì¬ì‹œì‘',
      'ë¡œë“œ ë°¸ëŸ°ì„œì—ì„œ ì œê±°',
      'ë¡¤ë°± ë°°í¬',
      'ë¦¬ì†ŒìŠ¤ ìŠ¤ì¼€ì¼ë§',
      'ì„¤ì • ë³€ê²½'
    ];
    
    for (const step of resolutionSteps) {
      console.log(`ì‹œë„ ì¤‘: ${step}`);
      const result = await this.executeResolutionStep(step, incident);
      
      if (result.success) {
        console.log(`âœ… í•´ê²° ì™„ë£Œ: ${step}`);
        break;
      } else {
        console.log(`âŒ ì‹¤íŒ¨: ${step}, ë‹¤ìŒ ë‹¨ê³„ ì‹œë„`);
      }
    }
  }
  
  static async postIncidentAnalysis(incident) {
    console.log('4ï¸âƒ£ ì‚¬í›„ ë¶„ì„ ë‹¨ê³„');
    
    // ì›ì¸ ë¶„ì„
    const rootCause = await this.analyzeRootCause(incident);
    
    // ì˜í–¥ë„ ë¶„ì„
    const impactAnalysis = await this.analyzeImpact(incident);
    
    // ê°œì„  ì‚¬í•­ ë„ì¶œ
    const improvements = await this.deriveImprovements(incident);
    
    // ë³´ê³ ì„œ ìƒì„±
    await this.generateIncidentReport({
      incident,
      rootCause,
      impactAnalysis,
      improvements
    });
  }
}
```

## ê²°ë¡ 

ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ ìš´ì˜ ë° ì¥ì•  ëŒ€ì‘ì€ ì‹œìŠ¤í…œì˜ ì•ˆì •ì„±ê³¼ ê°€ìš©ì„±ì„ ë³´ì¥í•˜ëŠ” í•µì‹¬ ìš”ì†Œì…ë‹ˆë‹¤. ì„œí‚· ë¸Œë ˆì´ì»¤, ë¶„ì‚° ì¶”ì , ì¥ì•  ê²©ë¦¬ ì „ëµ, ë¬´ì¤‘ë‹¨ ë°°í¬ ë“±ì„ í†µí•´ ì§€ì†ì ìœ¼ë¡œ ê°œì„ í•´ë‚˜ê°€ì•¼ í•©ë‹ˆë‹¤.

### í•µì‹¬ ì›ì¹™ ìš”ì•½

1. **ì˜ˆë°©**: ì„œí‚· ë¸Œë ˆì´ì»¤ì™€ ë²Œí¬í—¤ë“œë¡œ ì¥ì•  ì „íŒŒ ë°©ì§€
2. **ê´€ì°°**: ë¶„ì‚° ì¶”ì ê³¼ ë¡œê·¸ ì§‘ê³„ë¡œ ì‹œìŠ¤í…œ ìƒíƒœ íŒŒì•…
3. **ê²©ë¦¬**: ì¥ì• ì˜ ì˜í–¥ì„ ìµœì†Œí™”í•˜ëŠ” ê²©ë¦¬ ì „ëµ
4. **ë³µêµ¬**: ì‹ ì†í•œ ë¡¤ë°±ê³¼ ë¬´ì¤‘ë‹¨ ë°°í¬
5. **í•™ìŠµ**: ì‚¬í›„ ë¶„ì„ì„ í†µí•œ ì§€ì†ì  ê°œì„ 

ì´ëŸ¬í•œ ì›ì¹™ë“¤ì„ ë°”íƒ•ìœ¼ë¡œ ì•ˆì •ì ì´ê³  ì‹ ë¢°í•  ìˆ˜ ìˆëŠ” ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ ì‹œìŠ¤í…œì„ ìš´ì˜í•˜ì„¸ìš”.
