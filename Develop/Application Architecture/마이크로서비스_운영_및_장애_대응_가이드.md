# ÎßàÏù¥ÌÅ¨Î°úÏÑúÎπÑÏä§ Ïö¥ÏòÅ Î∞è Ïû•Ïï† ÎåÄÏùë Í∞ÄÏù¥Îìú (Microservices Operations and Incident Response Guide)

## Î™©Ï∞® (Table of Contents)
1. [ÎßàÏù¥ÌÅ¨Î°úÏÑúÎπÑÏä§ Ïö¥ÏòÅ Í∞úÏöî (Microservices Operations Overview)](#ÎßàÏù¥ÌÅ¨Î°úÏÑúÎπÑÏä§-Ïö¥ÏòÅ-Í∞úÏöî)
2. [ÏÑúÌÇ∑ Î∏åÎ†àÏù¥Ïª§ Ìå®ÌÑ¥ Íµ¨ÌòÑ (Circuit Breaker Pattern Implementation)](#ÏÑúÌÇ∑-Î∏åÎ†àÏù¥Ïª§-Ìå®ÌÑ¥-Íµ¨ÌòÑ)
3. [Î∂ÑÏÇ∞ Ï∂îÏ†Å Î∞è Î°úÍ∑∏ ÏßëÍ≥Ñ (Distributed Tracing and Log Aggregation)](#Î∂ÑÏÇ∞-Ï∂îÏ†Å-Î∞è-Î°úÍ∑∏-ÏßëÍ≥Ñ)
4. [Ïû•Ïï† Ï†ÑÌåå Î∞©ÏßÄ Î∞è Í≤©Î¶¨ Ï†ÑÎûµ (Failure Propagation Prevention and Isolation Strategies)](#Ïû•Ïï†-Ï†ÑÌåå-Î∞©ÏßÄ-Î∞è-Í≤©Î¶¨-Ï†ÑÎûµ)
5. [Î¨¥Ï§ëÎã® Î∞∞Ìè¨ Ï†ÑÎûµ (Zero-Downtime Deployment Strategies)](#Î¨¥Ï§ëÎã®-Î∞∞Ìè¨-Ï†ÑÎûµ)
6. [Ïã§Ï†ú Ïû•Ïï† ÏÇ¨Î°Ä Î∂ÑÏÑù Î∞è ÎåÄÏùë Î∞©Î≤ï (Real Incident Case Analysis and Response Methods)](#Ïã§Ï†ú-Ïû•Ïï†-ÏÇ¨Î°Ä-Î∂ÑÏÑù-Î∞è-ÎåÄÏùë-Î∞©Î≤ï)

### üìå ÌÜµÌï©Îêú Í∏∞Ï°¥ ÌååÏùºÎì§
Ïù¥ Í∞ÄÏù¥ÎìúÎäî Îã§Ïùå Í∏∞Ï°¥ ÌååÏùºÎì§Ïùò ÎÇ¥Ïö©ÏùÑ ÌÜµÌï©ÌïòÏó¨ Îçî Ï≤¥Í≥ÑÏ†ÅÏúºÎ°ú Ï†ïÎ¶¨Ìïú Í≤ÉÏûÖÎãàÎã§:
- **MSA ÏïÑÌÇ§ÌÖçÏ≤ò**: ÎßàÏù¥ÌÅ¨Î°úÏÑúÎπÑÏä§ ÏÑ§Í≥Ñ ÏõêÏπô, ÏÑúÎπÑÏä§ Í∞Ñ ÌÜµÏã†, ÏÑúÌÇ∑ Î∏åÎ†àÏù¥Ïª§ Í∏∞Î≥∏ Íµ¨ÌòÑ
- **Î¨¥Ï§ëÎã® Î∞∞Ìè¨**: Blue-Green Î∞∞Ìè¨ Ï†ÑÎûµ, Ìä∏ÎûòÌîΩ Ï†ÑÌôò, Î°§Î∞± Î∞©Î≤ï
- **Î∂ÑÏÇ∞ Ï∂îÏ†Å**: OpenTelemetry Í∏∞Î∞ò Î∂ÑÏÇ∞ Ï∂îÏ†Å, Ìä∏Î†àÏù¥Ïä§ ÏàòÏßë Î∞è Î∂ÑÏÑù
- **ÏÑúÎπÑÏä§ Î©îÏãú**: Istio Í∏∞Î∞ò Í¥ÄÏ∞∞ Í∞ÄÎä•ÏÑ±, Î©îÌä∏Î¶≠ ÏàòÏßë, Î°úÍ∑∏ ÏßëÍ≥Ñ
- **Î≤åÌÅ¨Ìó§Îìú**: Ïû•Ïï† Í≤©Î¶¨ Ï†ÑÎûµ, Î¶¨ÏÜåÏä§ Î∂ÑÎ¶¨, Ïä§Î†àÎìú ÌíÄ Í¥ÄÎ¶¨
- **ÏãúÏä§ÌÖú ÏÑ§Í≥Ñ**: Circuit Breaker Ìå®ÌÑ¥, Ïû•Ïï† ÎåÄÏùë Ï†ÑÎûµ

## ÎßàÏù¥ÌÅ¨Î°úÏÑúÎπÑÏä§ Ïö¥ÏòÅ Í∞úÏöî (Microservices Operations Overview)

ÎßàÏù¥ÌÅ¨Î°úÏÑúÎπÑÏä§ Ïö¥ÏòÅÏùÄ Î∂ÑÏÇ∞ ÏãúÏä§ÌÖúÏùò Î≥µÏû°ÏÑ±ÏùÑ Í¥ÄÎ¶¨ÌïòÍ≥†, Ïû•Ïï† ÏÉÅÌô©ÏóêÏÑú Ïã†ÏÜçÌïú ÎåÄÏùëÏùÑ ÏúÑÌïú Ï≤¥Í≥ÑÏ†ÅÏù∏ Ï†ëÍ∑º Î∞©ÏãùÏûÖÎãàÎã§.

### Ïö¥ÏòÅÏùò ÌïµÏã¨ Î™©Ìëú

1. **Í∞ÄÏö©ÏÑ± (Availability)**: 99.9% Ïù¥ÏÉÅÏùò ÏÑúÎπÑÏä§ Í∞ÄÏö©ÏÑ± Ïú†ÏßÄ
2. **ÏïàÏ†ïÏÑ± (Reliability)**: Ïû•Ïï† ÏÉÅÌô©ÏóêÏÑúÏùò Ïã†ÏÜçÌïú Î≥µÍµ¨
3. **Í¥ÄÏ∞∞ Í∞ÄÎä•ÏÑ± (Observability)**: ÏãúÏä§ÌÖú ÏÉÅÌÉúÏùò Ïã§ÏãúÍ∞Ñ Î™®ÎãàÌÑ∞ÎßÅ
4. **ÌôïÏû•ÏÑ± (Scalability)**: Ìä∏ÎûòÌîΩ Ï¶ùÍ∞ÄÏóê Îî∞Î•∏ Ïú†Ïó∞Ìïú ÎåÄÏùë

### Ïö¥ÏòÅ Î™®Îç∏ (Operations Model)

```mermaid
graph TD
    A[Î™®ÎãàÌÑ∞ÎßÅ] --> B[ÏïåÎ¶º]
    B --> C[Ïû•Ïï† Í∞êÏßÄ]
    C --> D[ÎåÄÏùë Ï°∞Ïπò]
    D --> E[Î≥µÍµ¨]
    E --> F[ÏÇ¨ÌõÑ Î∂ÑÏÑù]
    F --> G[Í∞úÏÑ†]
    G --> A
```

## ÏÑúÌÇ∑ Î∏åÎ†àÏù¥Ïª§ Ìå®ÌÑ¥ Íµ¨ÌòÑ (Circuit Breaker Pattern Implementation)

### 1. Hystrix Í∏∞Î∞ò Íµ¨ÌòÑ

```javascript
const HystrixCommand = require('hystrixjs').commandFactory;

// Hystrix ÏÑúÌÇ∑ Î∏åÎ†àÏù¥Ïª§ ÏÑ§Ï†ï
const paymentServiceCommand = HystrixCommand.getOrCreate('PaymentService')
  .circuitBreakerRequestVolumeThreshold(20)
  .circuitBreakerSleepWindowInMilliseconds(5000)
  .circuitBreakerErrorThresholdPercentage(50)
  .timeout(3000)
  .run(async () => {
    const response = await fetch('http://payment-service/api/process', {
      method: 'POST',
      body: JSON.stringify(paymentData)
    });
    
    if (!response.ok) {
      throw new Error(`Payment failed: ${response.status}`);
    }
    
    return await response.json();
  })
  .fallbackTo(() => {
    // Ìè¥Î∞± Ï≤òÎ¶¨
    return {
      success: false,
      message: 'Payment service is temporarily unavailable'
    };
  });

// ÏÇ¨Ïö© ÏòàÏãú
async function processPayment(paymentData) {
  try {
    const result = await paymentServiceCommand.execute();
    return result;
  } catch (error) {
    console.error('Payment processing failed:', error);
    throw error;
  }
}
```

### 2. Resilience4j Í∏∞Î∞ò Íµ¨ÌòÑ

```javascript
const { CircuitBreaker, Retry, Timeout } = require('resilience4js');

// ÏÑúÌÇ∑ Î∏åÎ†àÏù¥Ïª§ ÏÑ§Ï†ï
const circuitBreaker = new CircuitBreaker({
  failureRateThreshold: 50,
  waitDurationInOpenState: 5000,
  minimumNumberOfCalls: 20,
  slidingWindowSize: 10
});

// Ïû¨ÏãúÎèÑ ÏÑ§Ï†ï
const retry = new Retry({
  maxAttempts: 3,
  waitDuration: 1000,
  exponentialBackoffMultiplier: 2
});

// ÌÉÄÏûÑÏïÑÏõÉ ÏÑ§Ï†ï
const timeout = new Timeout({
  duration: 3000
});

// ÏÑúÎπÑÏä§ Ìò∏Ï∂ú ÎûòÌïë
async function callUserService(userId) {
  const decoratedFunction = circuitBreaker.decorate(
    retry.decorate(
      timeout.decorate(async () => {
        const response = await fetch(`http://user-service/api/users/${userId}`);
        return await response.json();
      })
    )
  );
  
  return await decoratedFunction();
}
```

### 3. Ïª§Ïä§ÌÖÄ ÏÑúÌÇ∑ Î∏åÎ†àÏù¥Ïª§

```javascript
class AdvancedCircuitBreaker {
  constructor(options = {}) {
    this.failureThreshold = options.failureThreshold || 5;
    this.timeout = options.timeout || 60000;
    this.resetTimeout = options.resetTimeout || 30000;
    this.monitoringPeriod = options.monitoringPeriod || 10000;
    
    this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN
    this.failureCount = 0;
    this.successCount = 0;
    this.lastFailureTime = null;
    this.metrics = {
      totalRequests: 0,
      failedRequests: 0,
      successfulRequests: 0
    };
  }
  
  async execute(operation, fallback = null) {
    this.metrics.totalRequests++;
    
    if (this.state === 'OPEN') {
      if (this.shouldAttemptReset()) {
        this.state = 'HALF_OPEN';
        console.log('Circuit breaker transitioning to HALF_OPEN');
      } else {
        this.metrics.failedRequests++;
        if (fallback) {
          return await fallback();
        }
        throw new Error('Circuit breaker is OPEN');
      }
    }
    
    try {
      const result = await this.withTimeout(operation, this.timeout);
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      if (fallback && this.state === 'OPEN') {
        return await fallback();
      }
      throw error;
    }
  }
  
  onSuccess() {
    this.successCount++;
    this.metrics.successfulRequests++;
    
    if (this.state === 'HALF_OPEN') {
      this.state = 'CLOSED';
      this.failureCount = 0;
      console.log('Circuit breaker transitioning to CLOSED');
    }
  }
  
  onFailure() {
    this.failureCount++;
    this.lastFailureTime = Date.now();
    this.metrics.failedRequests++;
    
    if (this.failureCount >= this.failureThreshold) {
      this.state = 'OPEN';
      console.log('Circuit breaker transitioning to OPEN');
    }
  }
  
  shouldAttemptReset() {
    return Date.now() - this.lastFailureTime >= this.resetTimeout;
  }
  
  async withTimeout(operation, timeout) {
    return Promise.race([
      operation(),
      new Promise((_, reject) => 
        setTimeout(() => reject(new Error('Operation timeout')), timeout)
      )
    ]);
  }
  
  getMetrics() {
    return {
      state: this.state,
      failureCount: this.failureCount,
      successCount: this.successCount,
      metrics: this.metrics
    };
  }
}
```

## Î∂ÑÏÇ∞ Ï∂îÏ†Å Î∞è Î°úÍ∑∏ ÏßëÍ≥Ñ (Distributed Tracing and Log Aggregation)

### 1. OpenTelemetry Í∏∞Î∞ò Î∂ÑÏÇ∞ Ï∂îÏ†Å

```javascript
const { NodeTracerProvider } = require('@opentelemetry/sdk-node');
const { getNodeAutoInstrumentations } = require('@opentelemetry/auto-instrumentations-node');
const { JaegerExporter } = require('@opentelemetry/exporter-jaeger');

// OpenTelemetry ÏÑ§Ï†ï
const tracerProvider = new NodeTracerProvider({
  resource: new Resource({
    [SemanticResourceAttributes.SERVICE_NAME]: 'user-service',
    [SemanticResourceAttributes.SERVICE_VERSION]: '1.0.0'
  })
});

const jaegerExporter = new JaegerExporter({
  endpoint: 'http://jaeger:14268/api/traces'
});

tracerProvider.addSpanProcessor(new BatchSpanProcessor(jaegerExporter));
tracerProvider.register();

// ÏûêÎèô Í≥ÑÏ∏° ÌôúÏÑ±Ìôî
registerInstrumentations({
  instrumentations: [getNodeAutoInstrumentations()]
});

// ÏàòÎèô Ï∂îÏ†Å
const tracer = trace.getTracer('user-service');

async function createUser(userData) {
  const span = tracer.startSpan('createUser');
  
  try {
    span.setAttributes({
      'user.email': userData.email,
      'user.name': userData.name
    });
    
    const user = await userRepository.save(userData);
    span.setStatus({ code: SpanStatusCode.OK });
    
    return user;
  } catch (error) {
    span.setStatus({ 
      code: SpanStatusCode.ERROR, 
      message: error.message 
    });
    span.recordException(error);
    throw error;
  } finally {
    span.end();
  }
}
```

### 2. ELK Stack Î°úÍ∑∏ ÏßëÍ≥Ñ

#### Logstash ÏÑ§Ï†ï
```ruby
# logstash.conf
input {
  beats {
    port => 5044
  }
}

filter {
  if [fields][service] {
    mutate {
      add_tag => ["microservice"]
    }
  }
  
  grok {
    match => { "message" => "%{TIMESTAMP_ISO8601:timestamp} \[%{DATA:level}\] %{DATA:service} %{GREEDYDATA:log_message}" }
  }
  
  date {
    match => [ "timestamp", "ISO8601" ]
  }
}

output {
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "microservices-%{+YYYY.MM.dd}"
  }
}
```

#### Node.js Î°úÍπÖ ÏÑ§Ï†ï
```javascript
const winston = require('winston');
const { ElasticsearchTransport } = require('winston-elasticsearch');

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  defaultMeta: {
    service: 'user-service',
    version: '1.0.0'
  },
  transports: [
    new winston.transports.Console({
      format: winston.format.simple()
    }),
    new ElasticsearchTransport({
      clientOpts: { node: 'http://elasticsearch:9200' },
      index: 'microservices-logs'
    })
  ]
});

// Íµ¨Ï°∞ÌôîÎêú Î°úÍπÖ
logger.info('User created successfully', {
  userId: user.id,
  email: user.email,
  duration: Date.now() - startTime,
  traceId: trace.getActiveSpan()?.spanContext().traceId
});
```

### 3. Î°úÍ∑∏ Î∂ÑÏÑù Î∞è Î™®ÎãàÌÑ∞ÎßÅ

```javascript
class LogAnalyzer {
  constructor(elasticsearchClient) {
    this.es = elasticsearchClient;
  }
  
  async analyzeErrorPatterns(timeRange = '1h') {
    const query = {
      index: 'microservices-*',
      body: {
        query: {
          bool: {
            must: [
              { range: { '@timestamp': { gte: `now-${timeRange}` } } },
              { term: { level: 'error' } }
            ]
          }
        },
        aggs: {
          errors_by_service: {
            terms: { field: 'service.keyword' },
            aggs: {
              error_types: {
                terms: { field: 'log_message.keyword' }
              }
            }
          }
        }
      }
    };
    
    const response = await this.es.search(query);
    return response.aggregations.errors_by_service.buckets;
  }
  
  async getServiceHealthMetrics(serviceName) {
    const query = {
      index: `microservices-*`,
      body: {
        query: {
          bool: {
            must: [
              { term: { service: serviceName } },
              { range: { '@timestamp': { gte: 'now-1h' } } }
            ]
          }
        },
        aggs: {
          response_times: {
            percentiles: {
              field: 'duration',
              percents: [50, 95, 99]
            }
          },
          error_rate: {
            filters: {
              filters: {
                errors: { term: { level: 'error' } },
                all: { match_all: {} }
              }
            }
          }
        }
      }
    };
    
    return await this.es.search(query);
  }
}
```

## Ïû•Ïï† Ï†ÑÌåå Î∞©ÏßÄ Î∞è Í≤©Î¶¨ Ï†ÑÎûµ (Failure Propagation Prevention and Isolation Strategies)

### 1. Î≤åÌÅ¨Ìó§Îìú Ìå®ÌÑ¥ (Bulkhead Pattern)

```javascript
class BulkheadIsolation {
  constructor() {
    this.threadPools = new Map();
    this.maxPoolSize = 10;
    this.queueSize = 100;
  }
  
  createThreadPool(name, maxSize = this.maxPoolSize) {
    const pool = {
      name,
      maxSize,
      active: 0,
      queue: [],
      tasks: new Set()
    };
    
    this.threadPools.set(name, pool);
    return pool;
  }
  
  async execute(taskName, operation) {
    const pool = this.threadPools.get(taskName);
    
    if (!pool) {
      throw new Error(`Thread pool '${taskName}' not found`);
    }
    
    return new Promise((resolve, reject) => {
      const task = { operation, resolve, reject };
      
      if (pool.active < pool.maxSize) {
        this.executeTask(pool, task);
      } else if (pool.queue.length < this.queueSize) {
        pool.queue.push(task);
      } else {
        reject(new Error(`Thread pool '${taskName}' is full`));
      }
    });
  }
  
  async executeTask(pool, task) {
    pool.active++;
    pool.tasks.add(task);
    
    try {
      const result = await task.operation();
      task.resolve(result);
    } catch (error) {
      task.reject(error);
    } finally {
      pool.active--;
      pool.tasks.delete(task);
      
      // ÌÅêÏóêÏÑú Îã§Ïùå ÏûëÏóÖ Ï≤òÎ¶¨
      if (pool.queue.length > 0) {
        const nextTask = pool.queue.shift();
        this.executeTask(pool, nextTask);
      }
    }
  }
  
  getPoolMetrics(name) {
    const pool = this.threadPools.get(name);
    if (!pool) return null;
    
    return {
      name: pool.name,
      active: pool.active,
      maxSize: pool.maxSize,
      queued: pool.queue.length,
      queueSize: this.queueSize,
      utilization: (pool.active / pool.maxSize) * 100
    };
  }
}

// ÏÇ¨Ïö© ÏòàÏãú
const bulkhead = new BulkheadIsolation();

// Í∞Å Í∏∞Îä•Î≥ÑÎ°ú ÎèÖÎ¶ΩÏ†ÅÏù∏ Ïä§Î†àÎìú ÌíÄ ÏÉùÏÑ±
bulkhead.createThreadPool('payment', 5);
bulkhead.createThreadPool('notification', 3);
bulkhead.createThreadPool('analytics', 2);

// Í≤∞Ï†ú Ï≤òÎ¶¨Îäî ÏµúÎåÄ 5Í∞ú ÎèôÏãú Ïã§Ìñâ
async function processPayment(paymentData) {
  return bulkhead.execute('payment', async () => {
    return await paymentService.process(paymentData);
  });
}

// ÏïåÎ¶º Î∞úÏÜ°ÏùÄ ÏµúÎåÄ 3Í∞ú ÎèôÏãú Ïã§Ìñâ
async function sendNotification(userId, message) {
  return bulkhead.execute('notification', async () => {
    return await notificationService.send(userId, message);
  });
}
```

### 2. ÌÉÄÏûÑÏïÑÏõÉ Î∞è Ïû¨ÏãúÎèÑ Ï†ÑÎûµ

```javascript
class ResilienceStrategies {
  static async withTimeout(operation, timeoutMs = 5000) {
    return Promise.race([
      operation(),
      new Promise((_, reject) => 
        setTimeout(() => reject(new Error('Operation timeout')), timeoutMs)
      )
    ]);
  }
  
  static async withRetry(operation, maxRetries = 3, delay = 1000) {
    let lastError;
    
    for (let i = 0; i <= maxRetries; i++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error;
        
        if (i === maxRetries) {
          break;
        }
        
        // ÏßÄÏàò Î∞±Ïò§ÌîÑ
        const waitTime = delay * Math.pow(2, i);
        await new Promise(resolve => setTimeout(resolve, waitTime));
      }
    }
    
    throw lastError;
  }
  
  static async withFallback(operation, fallbackOperation) {
    try {
      return await operation();
    } catch (error) {
      console.warn('Primary operation failed, using fallback:', error.message);
      return await fallbackOperation();
    }
  }
}

// ÏÇ¨Ïö© ÏòàÏãú
async function resilientServiceCall(serviceUrl, data) {
  return ResilienceStrategies.withFallback(
    // Ï£ºÏöî ÏûëÏóÖ
    () => ResilienceStrategies.withTimeout(
      () => ResilienceStrategies.withRetry(
        async () => {
          const response = await fetch(serviceUrl, {
            method: 'POST',
            body: JSON.stringify(data)
          });
          
          if (!response.ok) {
            throw new Error(`Service call failed: ${response.status}`);
          }
          
          return await response.json();
        },
        3, // ÏµúÎåÄ 3Ìöå Ïû¨ÏãúÎèÑ
        1000 // 1Ï¥àÎ∂ÄÌÑ∞ ÏãúÏûë
      ),
      5000 // 5Ï¥à ÌÉÄÏûÑÏïÑÏõÉ
    ),
    // Ìè¥Î∞± ÏûëÏóÖ
    async () => {
      return {
        success: false,
        message: 'Service temporarily unavailable',
        cached: true,
        timestamp: Date.now()
      };
    }
  );
}
```

## Î¨¥Ï§ëÎã® Î∞∞Ìè¨ Ï†ÑÎûµ (Zero-Downtime Deployment Strategies)

### 1. Blue-Green Î∞∞Ìè¨

```yaml
# blue-green-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: app-blue
  labels:
    version: blue
spec:
  replicas: 3
  selector:
    matchLabels:
      app: microservice-app
      version: blue
  template:
    metadata:
      labels:
        app: microservice-app
        version: blue
    spec:
      containers:
      - name: app
        image: microservice-app:blue-v1.0.0
        ports:
        - containerPort: 3000
---
apiVersion: v1
kind: Service
metadata:
  name: app-service
spec:
  selector:
    app: microservice-app
    version: blue  # ÌòÑÏû¨ Blue ÌôòÍ≤ΩÏùÑ Í∞ÄÎ¶¨ÌÇ¥
  ports:
  - port: 80
    targetPort: 3000
```

```bash
# Blue-Green Î∞∞Ìè¨ Ïä§ÌÅ¨Î¶ΩÌä∏
#!/bin/bash

NAMESPACE="microservices"
APP_NAME="microservice-app"
NEW_VERSION="green-v1.0.1"

echo "üöÄ Blue-Green Î∞∞Ìè¨ ÏãúÏûë..."

# 1. Green ÌôòÍ≤Ω Î∞∞Ìè¨
echo "üì¶ Green ÌôòÍ≤Ω Î∞∞Ìè¨ Ï§ë..."
kubectl apply -f green-deployment.yaml

# 2. Green ÌôòÍ≤Ω Ìó¨Ïä§ Ï≤¥ÌÅ¨
echo "üè• Green ÌôòÍ≤Ω Ìó¨Ïä§ Ï≤¥ÌÅ¨ Ï§ë..."
for i in {1..30}; do
  if kubectl get pods -l version=green --no-headers | grep -q "Running"; then
    echo "‚úÖ Green ÌôòÍ≤Ω Ï§ÄÎπÑ ÏôÑÎ£å"
    break
  fi
  echo "‚è≥ ÎåÄÍ∏∞ Ï§ë... ($i/30)"
  sleep 10
done

# 3. Ìä∏ÎûòÌîΩ Ï†ÑÌôò
echo "üîÑ Ìä∏ÎûòÌîΩÏùÑ GreenÏúºÎ°ú Ï†ÑÌôò Ï§ë..."
kubectl patch service app-service -p '{"spec":{"selector":{"version":"green"}}}'

# 4. Green ÌôòÍ≤Ω ÏïàÏ†ïÏÑ± ÌôïÏù∏
echo "üîç Green ÌôòÍ≤Ω ÏïàÏ†ïÏÑ± ÌôïÏù∏ Ï§ë..."
sleep 60

# 5. Blue ÌôòÍ≤Ω Ï†ïÎ¶¨ (ÏÑ†ÌÉùÏ†Å)
read -p "Blue ÌôòÍ≤ΩÏùÑ Ï†ïÎ¶¨ÌïòÏãúÍ≤†ÏäµÎãàÍπå? (y/n): " -n 1 -r
echo
if [[ $REPLY =~ ^[Yy]$ ]]; then
  echo "üßπ Blue ÌôòÍ≤Ω Ï†ïÎ¶¨ Ï§ë..."
  kubectl delete deployment app-blue
fi

echo "‚úÖ Blue-Green Î∞∞Ìè¨ ÏôÑÎ£å!"
```

### 2. Canary Î∞∞Ìè¨

```yaml
# canary-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: app-canary
  labels:
    version: canary
spec:
  replicas: 1  # ÏÜåÏàòÏùò Ïù∏Ïä§ÌÑ¥Ïä§Î°ú ÏãúÏûë
  selector:
    matchLabels:
      app: microservice-app
      version: canary
  template:
    metadata:
      labels:
        app: microservice-app
        version: canary
    spec:
      containers:
      - name: app
        image: microservice-app:canary-v1.0.1
        ports:
        - containerPort: 3000
---
# Ìä∏ÎûòÌîΩ Î∂ÑÌï†ÏùÑ ÏúÑÌïú Virtual Service (Istio)
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: app-virtual-service
spec:
  http:
  - match:
    - headers:
        canary-user:
          exact: "true"
    route:
    - destination:
        host: app-service
        subset: canary
      weight: 100
  - route:
    - destination:
        host: app-service
        subset: stable
      weight: 90
    - destination:
        host: app-service
        subset: canary
      weight: 10
```

```javascript
// Canary Î∞∞Ìè¨Î•º ÏúÑÌïú ÌîÑÎ°†Ìä∏ÏóîÎìú ÎùºÏö∞ÌåÖ
class CanaryRouter {
  constructor() {
    this.canaryPercentage = 10; // 10% Ìä∏ÎûòÌîΩÏùÑ canaryÎ°ú
    this.canaryUsers = new Set(); // Ï∫êÏãúÎêú canary ÏÇ¨Ïö©Ïûê
  }
  
  shouldRouteToCanary(userId) {
    // ÌäπÎ≥Ñ Ìó§ÎçîÍ∞Ä ÏûàÎäî Í≤ΩÏö∞
    if (this.isCanaryUser(userId)) {
      return true;
    }
    
    // ÌçºÏÑºÌä∏ Í∏∞Î∞ò ÎùºÏö∞ÌåÖ
    const hash = this.hashUserId(userId);
    return hash % 100 < this.canaryPercentage;
  }
  
  hashUserId(userId) {
    let hash = 0;
    for (let i = 0; i < userId.length; i++) {
      hash = ((hash << 5) - hash + userId.charCodeAt(i)) & 0xffffffff;
    }
    return Math.abs(hash);
  }
  
  isCanaryUser(userId) {
    return this.canaryUsers.has(userId);
  }
  
  addCanaryUser(userId) {
    this.canaryUsers.add(userId);
  }
}
```

### 3. Rolling Î∞∞Ìè¨

```yaml
# rolling-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: app-rolling
spec:
  replicas: 5
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1  # ÏµúÎåÄ 1Í∞ú Ïù∏Ïä§ÌÑ¥Ïä§Îßå ÎèôÏãúÏóê Îã§Ïö¥
      maxSurge: 1        # ÏµúÎåÄ 1Í∞ú Ïù∏Ïä§ÌÑ¥Ïä§Îßå ÎèôÏãúÏóê Ï∂îÍ∞Ä
  selector:
    matchLabels:
      app: microservice-app
  template:
    metadata:
      labels:
        app: microservice-app
    spec:
      containers:
      - name: app
        image: microservice-app:rolling-v1.0.1
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5
```

## Ïã§Ï†ú Ïû•Ïï† ÏÇ¨Î°Ä Î∂ÑÏÑù Î∞è ÎåÄÏùë Î∞©Î≤ï (Real Incident Case Analysis and Response Methods)

### 1. Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ ÌíÄ Í≥†Í∞à ÏÇ¨Î°Ä

#### Î¨∏Ï†ú ÏÉÅÌô©
```javascript
// Î¨∏Ï†úÍ∞Ä ÏûàÎäî ÏΩîÎìú
class DatabaseService {
  constructor() {
    this.pool = new Pool({
      connectionLimit: 10,
      acquireTimeoutMillis: 30000
    });
  }
  
  async query(sql, params) {
    // Ïó∞Í≤∞ÏùÑ Ï†úÎåÄÎ°ú Î∞òÌôòÌïòÏßÄ ÏïäÏùå
    const connection = await this.pool.getConnection();
    const result = await connection.query(sql, params);
    // connection.release() ÎàÑÎùΩ!
    return result;
  }
}
```

#### Ìï¥Í≤∞ Î∞©Ïïà
```javascript
class ImprovedDatabaseService {
  constructor() {
    this.pool = new Pool({
      connectionLimit: 20,
      acquireTimeoutMillis: 5000,
      timeout: 30000,
      idleTimeoutMillis: 300000
    });
    
    // Ïó∞Í≤∞ ÌíÄ Î™®ÎãàÌÑ∞ÎßÅ
    setInterval(() => {
      console.log('Pool status:', {
        total: this.pool.totalConnections,
        idle: this.pool.idleConnections,
        queued: this.pool.queuedRequests
      });
    }, 10000);
  }
  
  async query(sql, params) {
    let connection;
    try {
      connection = await this.pool.getConnection();
      const result = await connection.query(sql, params);
      return result;
    } catch (error) {
      console.error('Database query failed:', error);
      throw error;
    } finally {
      if (connection) {
        connection.release();
      }
    }
  }
  
  async withTransaction(operation) {
    let connection;
    try {
      connection = await this.pool.getConnection();
      await connection.beginTransaction();
      
      const result = await operation(connection);
      
      await connection.commit();
      return result;
    } catch (error) {
      if (connection) {
        await connection.rollback();
      }
      throw error;
    } finally {
      if (connection) {
        connection.release();
      }
    }
  }
}
```

### 2. Î©îÎ™®Î¶¨ ÎàÑÏàò ÏÇ¨Î°Ä

#### Î¨∏Ï†ú ÏÉÅÌô©
```javascript
// Î©îÎ™®Î¶¨ ÎàÑÏàòÍ∞Ä ÏûàÎäî ÏΩîÎìú
class EventService {
  constructor() {
    this.eventHandlers = new Map();
  }
  
  subscribe(eventType, handler) {
    // Î©îÎ™®Î¶¨ ÎàÑÏàò: Íµ¨ÎèÖ Ìï¥Ï†úÍ∞Ä ÏóÜÏùå
    if (!this.eventHandlers.has(eventType)) {
      this.eventHandlers.set(eventType, []);
    }
    this.eventHandlers.get(eventType).push(handler);
  }
  
  // unsubscribe Î©îÏÑúÎìúÍ∞Ä ÏóÜÏùå!
}
```

#### Ìï¥Í≤∞ Î∞©Ïïà
```javascript
class ImprovedEventService {
  constructor() {
    this.eventHandlers = new Map();
    this.weakRefs = new WeakMap(); // WeakMapÏúºÎ°ú Ï∞∏Ï°∞ Í¥ÄÎ¶¨
  }
  
  subscribe(eventType, handler) {
    if (!this.eventHandlers.has(eventType)) {
      this.eventHandlers.set(eventType, new Set());
    }
    
    const handlerSet = this.eventHandlers.get(eventType);
    handlerSet.add(handler);
    
    // WeakMapÏùÑ ÏÇ¨Ïö©ÌïòÏó¨ Ï†ïÎ¶¨ Ï∂îÏ†Å
    this.weakRefs.set(handler, { eventType, handlerSet });
    
    // ÏûêÎèô Ï†ïÎ¶¨ Í∏∞Îä•
    return {
      unsubscribe: () => this.unsubscribe(eventType, handler)
    };
  }
  
  unsubscribe(eventType, handler) {
    const handlerSet = this.eventHandlers.get(eventType);
    if (handlerSet) {
      handlerSet.delete(handler);
      
      // Îπà Set Ï†ïÎ¶¨
      if (handlerSet.size === 0) {
        this.eventHandlers.delete(eventType);
      }
    }
    
    this.weakRefs.delete(handler);
  }
  
  // Ï†ïÍ∏∞Ï†ÅÏù∏ Î©îÎ™®Î¶¨ Ï†ïÎ¶¨
  cleanup() {
    const beforeSize = this.eventHandlers.size;
    
    for (const [eventType, handlers] of this.eventHandlers) {
      if (handlers.size === 0) {
        this.eventHandlers.delete(eventType);
      }
    }
    
    const afterSize = this.eventHandlers.size;
    console.log(`Cleaned up ${beforeSize - afterSize} empty event types`);
  }
}
```

### 3. Ïû•Ïï† ÎåÄÏùë Ï≤¥ÌÅ¨Î¶¨Ïä§Ìä∏

```javascript
class IncidentResponseChecklist {
  static async handleIncident(incident) {
    console.log('üö® Ïû•Ïï† ÎåÄÏùë ÏãúÏûë:', incident);
    
    // 1. Ï¥àÍ∏∞ ÎåÄÏùë (0-5Î∂Ñ)
    await this.initialResponse(incident);
    
    // 2. Î¨∏Ï†ú Ï°∞ÏÇ¨ (5-15Î∂Ñ)
    await this.investigateIssue(incident);
    
    // 3. Ìï¥Í≤∞ ÏãúÎèÑ (15-30Î∂Ñ)
    await this.attemptResolution(incident);
    
    // 4. ÏÇ¨ÌõÑ Î∂ÑÏÑù (30Î∂Ñ Ïù¥ÌõÑ)
    await this.postIncidentAnalysis(incident);
  }
  
  static async initialResponse(incident) {
    console.log('1Ô∏è‚É£ Ï¥àÍ∏∞ ÎåÄÏùë Îã®Í≥Ñ');
    
    // ÏïåÎ¶º Î∞úÏÜ°
    await this.sendAlert(incident);
    
    // ÏòÅÌñ• Î≤îÏúÑ ÌååÏïÖ
    const impact = await this.assessImpact(incident);
    
    // Ïö∞ÏÑ†ÏàúÏúÑ Í≤∞Ï†ï
    const priority = this.calculatePriority(incident, impact);
    
    console.log(`Ïö∞ÏÑ†ÏàúÏúÑ: ${priority}, ÏòÅÌñ•: ${impact}`);
  }
  
  static async investigateIssue(incident) {
    console.log('2Ô∏è‚É£ Î¨∏Ï†ú Ï°∞ÏÇ¨ Îã®Í≥Ñ');
    
    // Î°úÍ∑∏ ÏàòÏßë
    const logs = await this.collectLogs(incident);
    
    // Î©îÌä∏Î¶≠ ÌôïÏù∏
    const metrics = await this.checkMetrics(incident);
    
    // Ìä∏Î†àÏù¥Ïä§ Ï∂îÏ†Å
    const traces = await this.analyzeTraces(incident);
    
    console.log('Ï°∞ÏÇ¨ ÏôÑÎ£å:', { logs: logs.length, metrics, traces });
  }
  
  static async attemptResolution(incident) {
    console.log('3Ô∏è‚É£ Ìï¥Í≤∞ ÏãúÎèÑ Îã®Í≥Ñ');
    
    const resolutionSteps = [
      'ÏÑúÎπÑÏä§ Ïû¨ÏãúÏûë',
      'Î°úÎìú Î∞∏Îü∞ÏÑúÏóêÏÑú Ï†úÍ±∞',
      'Î°§Î∞± Î∞∞Ìè¨',
      'Î¶¨ÏÜåÏä§ Ïä§ÏºÄÏùºÎßÅ',
      'ÏÑ§Ï†ï Î≥ÄÍ≤Ω'
    ];
    
    for (const step of resolutionSteps) {
      console.log(`ÏãúÎèÑ Ï§ë: ${step}`);
      const result = await this.executeResolutionStep(step, incident);
      
      if (result.success) {
        console.log(`‚úÖ Ìï¥Í≤∞ ÏôÑÎ£å: ${step}`);
        break;
      } else {
        console.log(`‚ùå Ïã§Ìå®: ${step}, Îã§Ïùå Îã®Í≥Ñ ÏãúÎèÑ`);
      }
    }
  }
  
  static async postIncidentAnalysis(incident) {
    console.log('4Ô∏è‚É£ ÏÇ¨ÌõÑ Î∂ÑÏÑù Îã®Í≥Ñ');
    
    // ÏõêÏù∏ Î∂ÑÏÑù
    const rootCause = await this.analyzeRootCause(incident);
    
    // ÏòÅÌñ•ÎèÑ Î∂ÑÏÑù
    const impactAnalysis = await this.analyzeImpact(incident);
    
    // Í∞úÏÑ† ÏÇ¨Ìï≠ ÎèÑÏ∂ú
    const improvements = await this.deriveImprovements(incident);
    
    // Î≥¥Í≥†ÏÑú ÏÉùÏÑ±
    await this.generateIncidentReport({
      incident,
      rootCause,
      impactAnalysis,
      improvements
    });
  }
}
```

## Í≤∞Î°†

ÎßàÏù¥ÌÅ¨Î°úÏÑúÎπÑÏä§ Ïö¥ÏòÅ Î∞è Ïû•Ïï† ÎåÄÏùëÏùÄ ÏãúÏä§ÌÖúÏùò ÏïàÏ†ïÏÑ±Í≥º Í∞ÄÏö©ÏÑ±ÏùÑ Î≥¥Ïû•ÌïòÎäî ÌïµÏã¨ ÏöîÏÜåÏûÖÎãàÎã§. ÏÑúÌÇ∑ Î∏åÎ†àÏù¥Ïª§, Î∂ÑÏÇ∞ Ï∂îÏ†Å, Ïû•Ïï† Í≤©Î¶¨ Ï†ÑÎûµ, Î¨¥Ï§ëÎã® Î∞∞Ìè¨ Îì±ÏùÑ ÌÜµÌï¥ ÏßÄÏÜçÏ†ÅÏúºÎ°ú Í∞úÏÑ†Ìï¥ÎÇòÍ∞ÄÏïº Ìï©ÎãàÎã§.

### ÌïµÏã¨ ÏõêÏπô ÏöîÏïΩ

1. **ÏòàÎ∞©**: ÏÑúÌÇ∑ Î∏åÎ†àÏù¥Ïª§ÏôÄ Î≤åÌÅ¨Ìó§ÎìúÎ°ú Ïû•Ïï† Ï†ÑÌåå Î∞©ÏßÄ
2. **Í¥ÄÏ∞∞**: Î∂ÑÏÇ∞ Ï∂îÏ†ÅÍ≥º Î°úÍ∑∏ ÏßëÍ≥ÑÎ°ú ÏãúÏä§ÌÖú ÏÉÅÌÉú ÌååÏïÖ
3. **Í≤©Î¶¨**: Ïû•Ïï†Ïùò ÏòÅÌñ•ÏùÑ ÏµúÏÜåÌôîÌïòÎäî Í≤©Î¶¨ Ï†ÑÎûµ
4. **Î≥µÍµ¨**: Ïã†ÏÜçÌïú Î°§Î∞±Í≥º Î¨¥Ï§ëÎã® Î∞∞Ìè¨
5. **ÌïôÏäµ**: ÏÇ¨ÌõÑ Î∂ÑÏÑùÏùÑ ÌÜµÌïú ÏßÄÏÜçÏ†Å Í∞úÏÑ†

Ïù¥Îü¨Ìïú ÏõêÏπôÎì§ÏùÑ Î∞îÌÉïÏúºÎ°ú ÏïàÏ†ïÏ†ÅÏù¥Í≥† Ïã†Î¢∞Ìï† Ïàò ÏûàÎäî ÎßàÏù¥ÌÅ¨Î°úÏÑúÎπÑÏä§ ÏãúÏä§ÌÖúÏùÑ Ïö¥ÏòÅÌïòÏÑ∏Ïöî.
