# 메시지 큐 및 분산 락 가이드 (Message Queue & Distributed Lock Guide)

> **📌 통합된 기존 파일들**: 이 가이드는 다음 기존 파일들의 내용을 통합하여 더 체계적으로 정리한 것입니다.
> - SELECT FOR UPDATE, LOCK IN SHARE MODE 상세 설명
> - 트랜잭션 격리 수준과 락의 관계
> - 데드락 방지 방법과 실제 예제
> - 락 성능 최적화 기법

## 목차 (Table of Contents)
1. [메시지 큐 활용 (Message Queue Usage)](#메시지-큐-활용-message-queue-usage)
2. [데이터베이스 락 시스템 (Database Lock System)](#데이터베이스-락-시스템-database-lock-system)
3. [분산 락 및 동시성 제어 (Distributed Lock and Concurrency Control)](#분산-락-및-동시성-제어-distributed-lock-and-concurrency-control)

## 메시지 큐 활용 (Message Queue Usage)

### 1. RabbitMQ 구현

```javascript
const amqp = require('amqplib');

class RabbitMQService {
  constructor(connectionString) {
    this.connectionString = connectionString;
    this.connection = null;
    this.channel = null;
  }
  
  async connect() {
    this.connection = await amqp.connect(this.connectionString);
    this.channel = await this.connection.createChannel();
    
    // 연결 종료 시 정리
    this.connection.on('close', () => {
      console.log('RabbitMQ connection closed');
    });
  }
  
  async publishMessage(exchange, routingKey, message, options = {}) {
    if (!this.channel) {
      throw new Error('Channel not initialized');
    }
    
    const messageBuffer = Buffer.from(JSON.stringify(message));
    
    return this.channel.publish(exchange, routingKey, messageBuffer, {
      persistent: true,
      messageId: options.messageId || this.generateMessageId(),
      timestamp: Date.now(),
      ...options
    });
  }
  
  async consumeMessages(queue, handler, options = {}) {
    if (!this.channel) {
      throw new Error('Channel not initialized');
    }
    
    await this.channel.assertQueue(queue, {
      durable: true,
      arguments: {
        'x-dead-letter-exchange': options.deadLetterExchange || 'dlx',
        'x-message-ttl': options.messageTtl || 300000 // 5분
      }
    });
    
    await this.channel.prefetch(options.prefetch || 1);
    
    return this.channel.consume(queue, async (msg) => {
      if (msg) {
        try {
          const message = JSON.parse(msg.content.toString());
          await handler(message, msg);
          this.channel.ack(msg);
        } catch (error) {
          console.error('Message processing failed:', error);
          this.channel.nack(msg, false, false); // DLQ로 이동
        }
      }
    });
  }
  
  async createExchange(exchangeName, type = 'topic') {
    return this.channel.assertExchange(exchangeName, type, {
      durable: true
    });
  }
  
  async bindQueue(queue, exchange, routingKey) {
    return this.channel.bindQueue(queue, exchange, routingKey);
  }
  
  generateMessageId() {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
  
  async close() {
    if (this.channel) {
      await this.channel.close();
    }
    if (this.connection) {
      await this.connection.close();
    }
  }
}

// 사용 예시
class OrderService {
  constructor(rabbitMQ) {
    this.rabbitMQ = rabbitMQ;
  }
  
  async createOrder(orderData) {
    // 주문 생성
    const order = await this.saveOrder(orderData);
    
    // 이벤트 발행
    await this.rabbitMQ.publishMessage(
      'order.events',
      'order.created',
      {
        orderId: order.id,
        userId: order.userId,
        amount: order.amount,
        timestamp: new Date()
      }
    );
    
    return order;
  }
  
  async handlePaymentCompleted(message, msg) {
    console.log('Payment completed for order:', message.orderId);
    
    // 주문 상태 업데이트
    await this.updateOrderStatus(message.orderId, 'paid');
    
    // 재고 차감 이벤트 발행
    await this.rabbitMQ.publishMessage(
      'inventory.events',
      'inventory.reserve',
      {
        orderId: message.orderId,
        items: message.items
      }
    );
  }
}
```

### 2. Apache Kafka 구현

```javascript
const kafka = require('kafkajs');

class KafkaService {
  constructor(config) {
    this.kafka = kafka.kafka(config);
    this.producer = null;
    this.consumer = null;
  }
  
  async createProducer() {
    this.producer = this.kafka.producer();
    await this.producer.connect();
    return this.producer;
  }
  
  async createConsumer(groupId) {
    this.consumer = this.kafka.consumer({ groupId });
    await this.consumer.connect();
    return this.consumer;
  }
  
  async publishMessage(topic, message, partition = null) {
    if (!this.producer) {
      throw new Error('Producer not initialized');
    }
    
    return this.producer.send({
      topic,
      messages: [{
        key: message.key || null,
        value: JSON.stringify(message.value),
        partition: partition || null,
        headers: message.headers || {}
      }]
    });
  }
  
  async consumeMessages(topic, handler) {
    if (!this.consumer) {
      throw new Error('Consumer not initialized');
    }
    
    await this.consumer.subscribe({ topic });
    
    await this.consumer.run({
      eachMessage: async ({ topic, partition, message }) => {
        try {
          const messageData = {
            key: message.key?.toString(),
            value: JSON.parse(message.value.toString()),
            headers: message.headers,
            topic,
            partition,
            offset: message.offset
          };
          
          await handler(messageData);
        } catch (error) {
          console.error('Message processing failed:', error);
        }
      }
    });
  }
  
  async close() {
    if (this.producer) {
      await this.producer.disconnect();
    }
    if (this.consumer) {
      await this.consumer.disconnect();
    }
  }
}

// 사용 예시
class EventStreamService {
  constructor(kafkaService) {
    this.kafka = kafkaService;
  }
  
  async publishUserEvent(eventType, userData) {
    await this.kafka.publishMessage('user-events', {
      key: userData.id,
      value: {
        eventType,
        userId: userData.id,
        data: userData,
        timestamp: new Date().toISOString()
      }
    });
  }
  
  async handleUserEvents() {
    await this.kafka.consumeMessages('user-events', async (message) => {
      const { eventType, userId, data } = message.value;
      
      switch (eventType) {
        case 'USER_CREATED':
          await this.handleUserCreated(userId, data);
          break;
        case 'USER_UPDATED':
          await this.handleUserUpdated(userId, data);
          break;
        case 'USER_DELETED':
          await this.handleUserDeleted(userId);
          break;
      }
    });
  }
}
```

### 3. 메시지 큐 패턴

```javascript
// 발행/구독 패턴 (Pub/Sub)
class PubSubPattern {
  constructor(messageQueue) {
    this.mq = messageQueue;
  }
  
  async publishEvent(eventType, eventData) {
    await this.mq.publishMessage('events', eventType, {
      eventType,
      data: eventData,
      timestamp: new Date()
    });
  }
  
  async subscribeToEvents(eventTypes, handler) {
    for (const eventType of eventTypes) {
      await this.mq.consumeMessages(`events.${eventType}`, handler);
    }
  }
}

// 요청/응답 패턴 (Request/Reply)
class RequestReplyPattern {
  constructor(messageQueue) {
    this.mq = messageQueue;
    this.pendingRequests = new Map();
  }
  
  async sendRequest(requestData, timeout = 30000) {
    const requestId = this.generateRequestId();
    const replyQueue = `reply.${requestId}`;
    
    // 응답 큐 생성
    await this.mq.createQueue(replyQueue, { exclusive: true, autoDelete: true });
    
    // 응답 대기
    const responsePromise = new Promise((resolve, reject) => {
      const timeoutId = setTimeout(() => {
        this.pendingRequests.delete(requestId);
        reject(new Error('Request timeout'));
      }, timeout);
      
      this.pendingRequests.set(requestId, { resolve, reject, timeoutId });
    });
    
    // 요청 발송
    await this.mq.publishMessage('requests', 'process', {
      requestId,
      replyTo: replyQueue,
      data: requestData
    });
    
    // 응답 수신
    await this.mq.consumeMessages(replyQueue, (message) => {
      const { requestId: responseRequestId, result, error } = message;
      const pending = this.pendingRequests.get(responseRequestId);
      
      if (pending) {
        clearTimeout(pending.timeoutId);
        this.pendingRequests.delete(responseRequestId);
        
        if (error) {
          pending.reject(new Error(error));
        } else {
          pending.resolve(result);
        }
      }
    });
    
    return responsePromise;
  }
  
  generateRequestId() {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
}

// 워크플로우 패턴 (Workflow)
class WorkflowPattern {
  constructor(messageQueue) {
    this.mq = messageQueue;
    this.workflows = new Map();
  }
  
  async startWorkflow(workflowType, initialData) {
    const workflowId = this.generateWorkflowId();
    const workflow = {
      id: workflowId,
      type: workflowType,
      status: 'RUNNING',
      currentStep: 0,
      data: initialData,
      steps: this.workflows.get(workflowType) || []
    };
    
    await this.mq.publishMessage('workflows', 'start', workflow);
    return workflowId;
  }
  
  async executeStep(workflowId, stepData) {
    await this.mq.publishMessage('workflows', 'step', {
      workflowId,
      stepData
    });
  }
  
  async completeWorkflow(workflowId, result) {
    await this.mq.publishMessage('workflows', 'complete', {
      workflowId,
      result
    });
  }
  
  generateWorkflowId() {
    return `workflow-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
}
```

## 데이터베이스 락 시스템 (Database Lock System)

### 1. SELECT 문에서 락이 발생하는 경우

#### 1.1 SELECT FOR UPDATE
- **행 레벨 락(Row-Level Lock)**을 발생시킴
- 데이터 조회와 동시에 **해당 데이터의 수정을 위해 잠금**
- 다른 트랜잭션에서 해당 행을 읽거나 수정하는 것을 차단

```sql
-- 기본 사용법
SELECT * FROM employees 
WHERE department = 'IT' 
FOR UPDATE;

-- 특정 컬럼만 선택하여 락
SELECT employee_id, salary FROM employees 
WHERE department = 'IT' 
FOR UPDATE;

-- NOWAIT 옵션 사용 (락 획득 실패 시 즉시 에러 반환)
SELECT * FROM employees 
WHERE department = 'IT' 
FOR UPDATE NOWAIT;

-- SKIP LOCKED 옵션 사용 (락이 걸린 행은 건너뛰기)
SELECT * FROM employees 
WHERE department = 'IT' 
FOR UPDATE SKIP LOCKED;
```

**사용 사례:**
1. **급여 조정 시스템**
```sql
BEGIN;
-- 특정 부서의 직원 급여 조회 및 잠금
SELECT * FROM employees 
WHERE department = 'IT' 
FOR UPDATE;

-- 급여 인상 처리
UPDATE employees 
SET salary = salary * 1.1 
WHERE department = 'IT';

COMMIT;
```

2. **재고 관리 시스템**
```sql
BEGIN;
-- 특정 상품의 재고 확인 및 잠금
SELECT * FROM inventory 
WHERE product_id = 123 
FOR UPDATE;

-- 재고 감소 처리
UPDATE inventory 
SET quantity = quantity - 1 
WHERE product_id = 123;

COMMIT;
```

**주의사항:**
- FOR UPDATE는 성능에 영향을 줄 수 있으므로 필요한 경우에만 사용
- 데드락 발생 가능성이 있으므로 락 획득 순서에 주의
- 트랜잭션을 최대한 짧게 유지

#### 1.2 SELECT LOCK IN SHARE MODE
- **공유 락(Shared Lock)** 발생
- 다른 트랜잭션에서 **읽기만 가능**하고, 쓰기는 불가능
- 여러 트랜잭션이 동시에 공유 락을 가질 수 있음

```sql
-- 기본 사용법
SELECT * FROM products 
WHERE category = 'Electronics' 
LOCK IN SHARE MODE;

-- 특정 컬럼만 선택하여 락
SELECT product_id, price FROM products 
WHERE category = 'Electronics' 
LOCK IN SHARE MODE;
```

**사용 사례:**
1. **상품 정보 조회 시스템**
```sql
BEGIN;
-- 상품 정보 조회 및 공유 락
SELECT * FROM products 
WHERE product_id = 456 
LOCK IN SHARE MODE;

-- 상품 정보 표시
-- 다른 트랜잭션에서도 동시에 읽기 가능
COMMIT;
```

2. **데이터 분석 시스템**
```sql
BEGIN;
-- 특정 기간의 주문 데이터 조회
SELECT * FROM orders 
WHERE order_date BETWEEN '2024-01-01' AND '2024-01-31'
LOCK IN SHARE MODE;

-- 데이터 분석 수행
-- 다른 트랜잭션에서도 동시에 읽기 가능
COMMIT;
```

**주의사항:**
- 공유 락은 배타적 락과 충돌할 수 있음
- 너무 많은 공유 락은 성능 저하를 일으킬 수 있음
- 필요한 경우에만 사용하고 트랜잭션을 짧게 유지

### 2. 트랜잭션 격리 수준과 락의 관계

**트랜잭션 격리 수준(Isolation Level)**에 따라 락의 발생 여부와 동작이 달라집니다.

| **격리 수준** | **특징** | **락 발생 가능성** | **동시성** | **일관성** |
|---------------|----------|-------------------|------------|------------|
| READ UNCOMMITTED | 커밋되지 않은 데이터 읽기 허용 | 거의 없음 | 매우 높음 | 매우 낮음 |
| READ COMMITTED | 커밋된 데이터만 읽기 가능 | 낮음 | 높음 | 낮음 |
| REPEATABLE READ | 동일 트랜잭션 내에서 일관된 데이터 | 중간 | 중간 | 중간 |
| SERIALIZABLE | 가장 높은 일관성, 모든 접근 차단 | 높음 | 낮음 | 매우 높음 |

**격리 수준 설정 예제:**
```sql
-- 세션 레벨 설정
SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;

-- 트랜잭션 레벨 설정
START TRANSACTION;
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
SELECT * FROM orders;
COMMIT;
```

**각 격리 수준별 특징:**
1. **READ UNCOMMITTED**
   - Dirty Read 가능
   - Non-repeatable Read 가능
   - Phantom Read 가능
   - 성능은 가장 좋지만 일관성 보장이 가장 낮음

2. **READ COMMITTED**
   - Dirty Read 방지
   - Non-repeatable Read 가능
   - Phantom Read 가능
   - 대부분의 DBMS의 기본 격리 수준

3. **REPEATABLE READ**
   - Dirty Read 방지
   - Non-repeatable Read 방지
   - Phantom Read 가능
   - MySQL의 기본 격리 수준

4. **SERIALIZABLE**
   - Dirty Read 방지
   - Non-repeatable Read 방지
   - Phantom Read 방지
   - 가장 높은 일관성 보장

### 3. 락 관련 실제 예제

#### 3.1 SELECT FOR UPDATE 사용 예제
```sql
-- 계좌 이체 시스템
BEGIN;

-- 출금 계좌 잠금
SELECT * FROM accounts 
WHERE account_id = 1 
FOR UPDATE;

-- 입금 계좌 잠금
SELECT * FROM accounts 
WHERE account_id = 2 
FOR UPDATE;

-- 출금 처리
UPDATE accounts 
SET balance = balance - 100 
WHERE account_id = 1;

-- 입금 처리
UPDATE accounts 
SET balance = balance + 100 
WHERE account_id = 2;

COMMIT;
```

**주의사항:**
- 계좌 잠금 순서를 일관되게 유지하여 데드락 방지
- 트랜잭션을 최대한 짧게 유지
- 에러 발생 시 롤백 처리

#### 3.2 SELECT LOCK IN SHARE MODE 사용 예제
```sql
-- 상품 가격 조회 및 수정 시스템
BEGIN;

-- 상품 정보 조회 및 공유 락
SELECT * FROM products 
WHERE product_id = 1 
LOCK IN SHARE MODE;

-- 가격 수정을 위한 배타적 락
SELECT * FROM products 
WHERE product_id = 1 
FOR UPDATE;

-- 가격 수정
UPDATE products 
SET price = price + 10 
WHERE product_id = 1;

COMMIT;
```

**주의사항:**
- 공유 락에서 배타적 락으로의 전환 시 주의
- 트랜잭션 격리 수준에 따른 동작 차이 확인
- 락 획득 실패 시 적절한 에러 처리

### 4. 데드락 방지 방법

#### 4.1 데드락 발생 시나리오
```sql
-- 데드락 발생 시나리오
-- 세션 1
BEGIN;
SELECT * FROM orders WHERE order_id = 1 FOR UPDATE;

-- 세션 2
BEGIN;
SELECT * FROM orders WHERE order_id = 2 FOR UPDATE;

-- 세션 1 (데드락 발생)
UPDATE orders SET status = 'Shipped' WHERE order_id = 2;

-- 세션 2 (데드락 발생)
UPDATE orders SET status = 'Shipped' WHERE order_id = 1;
```

#### 4.2 데드락 방지 방법
1. **락 획득 순서 통일**
```sql
-- 올바른 락 획득 순서
BEGIN;
-- 항상 작은 ID부터 락 획득
SELECT * FROM orders WHERE order_id = 1 FOR UPDATE;
SELECT * FROM orders WHERE order_id = 2 FOR UPDATE;
```

2. **타임아웃 설정**
```sql
-- 타임아웃 설정
SET innodb_lock_wait_timeout = 50; -- 50초
```

3. **NOWAIT 옵션 사용**
```sql
SELECT * FROM orders 
WHERE order_id = 1 
FOR UPDATE NOWAIT;
```

4. **SKIP LOCKED 옵션 사용**
```sql
SELECT * FROM orders 
WHERE order_id = 1 
FOR UPDATE SKIP LOCKED;
```

### 5. 락 해제 방법

#### 5.1 명시적 락 해제
1. **명시적 커밋**
```sql
BEGIN;
-- 트랜잭션 작업 수행
COMMIT; -- 모든 락 해제
```

2. **롤백**
```sql
BEGIN;
-- 트랜잭션 작업 수행
ROLLBACK; -- 모든 락 해제
```

3. **세션 종료**
- 세션이 종료되면 모든 락이 자동으로 해제됨

### 6. 락 성능 최적화 기법

#### 6.1 트랜잭션 최적화
- 트랜잭션을 최대한 짧게 유지
- 불필요한 락 사용 피하기
- 적절한 격리 수준 선택

#### 6.2 인덱스 최적화
```sql
-- 적절한 인덱스 생성
CREATE INDEX idx_department ON employees(department);
CREATE INDEX idx_product_category ON products(category);
```

#### 6.3 락 타임아웃 설정
```sql
-- 락 대기 시간 설정
SET innodb_lock_wait_timeout = 30;
```

#### 6.4 배치 처리 최적화
```sql
-- 대량 업데이트 시 배치 처리
UPDATE employees 
SET salary = salary * 1.1 
WHERE department = 'IT' 
LIMIT 1000;
```

### 7. SELECT 락의 장단점

| **구분** | **장점** | **단점** | **사용 시나리오** |
|----------|----------|----------|-------------------|
| **FOR UPDATE** | 데이터 일관성 유지, 경합 방지 | 동시성 저하 | 계좌 이체, 재고 관리 |
| **LOCK IN SHARE MODE** | 읽기 가능, 수정 제한 | 업데이트 충돌 가능성 존재 | 데이터 조회, 보고서 생성 |
| **SERIALIZABLE** | 최대 일관성 보장 | 성능 저하, 데드락 발생 위험 | 금융 거래, 정확성 요구 시스템 |

### 8. 결론

1. **SELECT 문도 특정 상황에서 락을 발생시킬 수 있으며, 이는 데이터베이스의 일관성과 동시성 제어에 중요합니다.**
2. **트랜잭션 격리 수준과 명시적인 FOR UPDATE 사용 시 주의해야 합니다.**
3. **데드락 방지 및 성능 최적화를 위해 적절한 트랜잭션 설계가 중요합니다.**
4. **실제 시스템에서는 다음과 같은 원칙을 지켜야 합니다:**
   - 필요한 경우에만 락 사용
   - 트랜잭션을 최대한 짧게 유지
   - 적절한 격리 수준 선택
   - 인덱스 최적화
   - 락 획득 순서 통일
   - 타임아웃 설정
   - 에러 처리 구현

## 분산 락 및 동시성 제어 (Distributed Lock and Concurrency Control)

### 1. Redis 분산 락

```javascript
class DistributedLock {
  constructor(redisClient) {
    this.redis = redisClient;
  }
  
  async acquireLock(lockKey, ttl = 10000, retryDelay = 100) {
    const lockValue = Date.now() + Math.random();
    const lockName = `lock:${lockKey}`;
    
    // SET NX EX 명령으로 원자적 락 획득
    const result = await this.redis.set(lockName, lockValue, 'PX', ttl, 'NX');
    
    if (result === 'OK') {
      return {
        success: true,
        lockValue,
        release: () => this.releaseLock(lockName, lockValue)
      };
    }
    
    return { success: false };
  }
  
  async releaseLock(lockName, lockValue) {
    const script = `
      if redis.call("get", KEYS[1]) == ARGV[1] then
        return redis.call("del", KEYS[1])
      else
        return 0
      end
    `;
    
    return await this.redis.eval(script, 1, lockName, lockValue);
  }
  
  async withLock(lockKey, work, ttl = 10000) {
    const lock = await this.acquireLock(lockKey, ttl);
    
    if (!lock.success) {
      throw new Error('락 획득 실패');
    }
    
    try {
      return await work();
    } finally {
      await lock.release();
    }
  }
  
  async acquireLockWithRetry(lockKey, ttl = 10000, maxRetries = 10, retryDelay = 100) {
    for (let i = 0; i < maxRetries; i++) {
      const lock = await this.acquireLock(lockKey, ttl);
      
      if (lock.success) {
        return lock;
      }
      
      await new Promise(resolve => setTimeout(resolve, retryDelay));
    }
    
    throw new Error('락 획득 최대 재시도 횟수 초과');
  }
}

// 사용 예시
class InventoryService {
  constructor(redisClient) {
    this.lock = new DistributedLock(redisClient);
  }
  
  async reserveInventory(productId, quantity) {
    return await this.lock.withLock(`inventory:${productId}`, async () => {
      const currentStock = await this.getCurrentStock(productId);
      
      if (currentStock < quantity) {
        throw new Error('재고 부족');
      }
      
      await this.updateStock(productId, currentStock - quantity);
      return { productId, reservedQuantity: quantity };
    });
  }
}
```

### 2. 데이터베이스 분산 락

```javascript
class DatabaseDistributedLock {
  constructor(database) {
    this.db = database;
  }
  
  async acquireLock(lockKey, ttl = 30000) {
    const lockId = this.generateLockId();
    const expiresAt = new Date(Date.now() + ttl);
    
    try {
      await this.db.query(
        'INSERT INTO distributed_locks (lock_key, lock_id, expires_at) VALUES (?, ?, ?)',
        [lockKey, lockId, expiresAt]
      );
      
      return {
        success: true,
        lockId,
        release: () => this.releaseLock(lockKey, lockId)
      };
    } catch (error) {
      if (error.code === 'ER_DUP_ENTRY') {
        return { success: false };
      }
      throw error;
    }
  }
  
  async releaseLock(lockKey, lockId) {
    const result = await this.db.query(
      'DELETE FROM distributed_locks WHERE lock_key = ? AND lock_id = ?',
      [lockKey, lockId]
    );
    
    return result.affectedRows > 0;
  }
  
  async cleanupExpiredLocks() {
    await this.db.query(
      'DELETE FROM distributed_locks WHERE expires_at < NOW()'
    );
  }
  
  generateLockId() {
    return `${process.pid}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
}
```

### 3. 분산 락 패턴

```javascript
// Redlock 알고리즘 구현
class Redlock {
  constructor(redisClients) {
    this.redisClients = redisClients;
    this.quorum = Math.floor(redisClients.length / 2) + 1;
  }
  
  async lock(resource, ttl = 10000) {
    const lockValue = this.generateLockValue();
    const startTime = Date.now();
    const lockPromises = this.redisClients.map(client => 
      this.acquireLockOnClient(client, resource, lockValue, ttl)
    );
    
    const results = await Promise.allSettled(lockPromises);
    const successCount = results.filter(result => 
      result.status === 'fulfilled' && result.value === true
    ).length;
    
    if (successCount >= this.quorum) {
      const validityTime = ttl - (Date.now() - startTime) - 100; // 100ms 버퍼
      return {
        success: true,
        lockValue,
        validityTime,
        release: () => this.unlock(resource, lockValue)
      };
    }
    
    // 실패한 경우 획득한 락들 해제
    await this.unlock(resource, lockValue);
    return { success: false };
  }
  
  async unlock(resource, lockValue) {
    const unlockPromises = this.redisClients.map(client =>
      this.releaseLockOnClient(client, resource, lockValue)
    );
    
    await Promise.allSettled(unlockPromises);
  }
  
  async acquireLockOnClient(client, resource, lockValue, ttl) {
    try {
      const result = await client.set(`lock:${resource}`, lockValue, 'PX', ttl, 'NX');
      return result === 'OK';
    } catch (error) {
      return false;
    }
  }
  
  async releaseLockOnClient(client, resource, lockValue) {
    const script = `
      if redis.call("get", KEYS[1]) == ARGV[1] then
        return redis.call("del", KEYS[1])
      else
        return 0
      end
    `;
    
    try {
      return await client.eval(script, 1, `lock:${resource}`, lockValue);
    } catch (error) {
      return 0;
    }
  }
  
  generateLockValue() {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
}

// 분산 세마포어
class DistributedSemaphore {
  constructor(redisClient, semaphoreName, maxCount) {
    this.redis = redisClient;
    this.semaphoreName = semaphoreName;
    this.maxCount = maxCount;
  }
  
  async acquire(timeout = 10000) {
    const permitId = this.generatePermitId();
    const startTime = Date.now();
    
    while (Date.now() - startTime < timeout) {
      const currentCount = await this.redis.llen(this.semaphoreName);
      
      if (currentCount < this.maxCount) {
        await this.redis.lpush(this.semaphoreName, permitId);
        return {
          success: true,
          permitId,
          release: () => this.release(permitId)
        };
      }
      
      // 잠시 대기 후 재시도
      await new Promise(resolve => setTimeout(resolve, 100));
    }
    
    return { success: false };
  }
  
  async release(permitId) {
    return await this.redis.lrem(this.semaphoreName, 1, permitId);
  }
  
  generatePermitId() {
    return `${process.pid}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
}
```

## 결론

메시지 큐와 분산 락은 분산 시스템에서 핵심적인 역할을 합니다. 메시지 큐를 통해 서비스 간 느슨한 결합을 구현하고, 분산 락을 통해 동시성 제어와 데이터 일관성을 보장할 수 있습니다.

### 핵심 원칙 요약

1. **메시지 큐**: 비동기 통신으로 서비스 간 느슨한 결합 구현
2. **분산 락**: 분산 환경에서의 동시성 제어 및 데이터 일관성 보장
3. **패턴 활용**: 발행/구독, 요청/응답, 워크플로우 등 다양한 패턴 적용
4. **안정성**: 재시도, 타임아웃, 데드레터 큐 등을 통한 안정성 확보

이러한 기술들을 적절히 조합하여 안정적이고 확장 가능한 분산 시스템을 구축하세요.
