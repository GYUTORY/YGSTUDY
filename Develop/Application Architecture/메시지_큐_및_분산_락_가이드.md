# ë©”ì‹œì§€ í ë° ë¶„ì‚° ë½ ê°€ì´ë“œ (Message Queue & Distributed Lock Guide)

> **ğŸ“Œ í†µí•©ëœ ê¸°ì¡´ íŒŒì¼ë“¤**: ì´ ê°€ì´ë“œëŠ” ë‹¤ìŒ ê¸°ì¡´ íŒŒì¼ë“¤ì˜ ë‚´ìš©ì„ í†µí•©í•˜ì—¬ ë” ì²´ê³„ì ìœ¼ë¡œ ì •ë¦¬í•œ ê²ƒì…ë‹ˆë‹¤.
> - SELECT FOR UPDATE, LOCK IN SHARE MODE ìƒì„¸ ì„¤ëª…
> - íŠ¸ëœì­ì…˜ ê²©ë¦¬ ìˆ˜ì¤€ê³¼ ë½ì˜ ê´€ê³„
> - ë°ë“œë½ ë°©ì§€ ë°©ë²•ê³¼ ì‹¤ì œ ì˜ˆì œ
> - ë½ ì„±ëŠ¥ ìµœì í™” ê¸°ë²•

## ëª©ì°¨ (Table of Contents)
1. [ë©”ì‹œì§€ í í™œìš© (Message Queue Usage)](#ë©”ì‹œì§€-í-í™œìš©-message-queue-usage)
2. [ë°ì´í„°ë² ì´ìŠ¤ ë½ ì‹œìŠ¤í…œ (Database Lock System)](#ë°ì´í„°ë² ì´ìŠ¤-ë½-ì‹œìŠ¤í…œ-database-lock-system)
3. [ë¶„ì‚° ë½ ë° ë™ì‹œì„± ì œì–´ (Distributed Lock and Concurrency Control)](#ë¶„ì‚°-ë½-ë°-ë™ì‹œì„±-ì œì–´-distributed-lock-and-concurrency-control)

## ë©”ì‹œì§€ í í™œìš© (Message Queue Usage)

### 1. RabbitMQ êµ¬í˜„

```javascript
const amqp = require('amqplib');

class RabbitMQService {
  constructor(connectionString) {
    this.connectionString = connectionString;
    this.connection = null;
    this.channel = null;
  }
  
  async connect() {
    this.connection = await amqp.connect(this.connectionString);
    this.channel = await this.connection.createChannel();
    
    // ì—°ê²° ì¢…ë£Œ ì‹œ ì •ë¦¬
    this.connection.on('close', () => {
      console.log('RabbitMQ connection closed');
    });
  }
  
  async publishMessage(exchange, routingKey, message, options = {}) {
    if (!this.channel) {
      throw new Error('Channel not initialized');
    }
    
    const messageBuffer = Buffer.from(JSON.stringify(message));
    
    return this.channel.publish(exchange, routingKey, messageBuffer, {
      persistent: true,
      messageId: options.messageId || this.generateMessageId(),
      timestamp: Date.now(),
      ...options
    });
  }
  
  async consumeMessages(queue, handler, options = {}) {
    if (!this.channel) {
      throw new Error('Channel not initialized');
    }
    
    await this.channel.assertQueue(queue, {
      durable: true,
      arguments: {
        'x-dead-letter-exchange': options.deadLetterExchange || 'dlx',
        'x-message-ttl': options.messageTtl || 300000 // 5ë¶„
      }
    });
    
    await this.channel.prefetch(options.prefetch || 1);
    
    return this.channel.consume(queue, async (msg) => {
      if (msg) {
        try {
          const message = JSON.parse(msg.content.toString());
          await handler(message, msg);
          this.channel.ack(msg);
        } catch (error) {
          console.error('Message processing failed:', error);
          this.channel.nack(msg, false, false); // DLQë¡œ ì´ë™
        }
      }
    });
  }
  
  async createExchange(exchangeName, type = 'topic') {
    return this.channel.assertExchange(exchangeName, type, {
      durable: true
    });
  }
  
  async bindQueue(queue, exchange, routingKey) {
    return this.channel.bindQueue(queue, exchange, routingKey);
  }
  
  generateMessageId() {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
  
  async close() {
    if (this.channel) {
      await this.channel.close();
    }
    if (this.connection) {
      await this.connection.close();
    }
  }
}

// ì‚¬ìš© ì˜ˆì‹œ
class OrderService {
  constructor(rabbitMQ) {
    this.rabbitMQ = rabbitMQ;
  }
  
  async createOrder(orderData) {
    // ì£¼ë¬¸ ìƒì„±
    const order = await this.saveOrder(orderData);
    
    // ì´ë²¤íŠ¸ ë°œí–‰
    await this.rabbitMQ.publishMessage(
      'order.events',
      'order.created',
      {
        orderId: order.id,
        userId: order.userId,
        amount: order.amount,
        timestamp: new Date()
      }
    );
    
    return order;
  }
  
  async handlePaymentCompleted(message, msg) {
    console.log('Payment completed for order:', message.orderId);
    
    // ì£¼ë¬¸ ìƒíƒœ ì—…ë°ì´íŠ¸
    await this.updateOrderStatus(message.orderId, 'paid');
    
    // ì¬ê³  ì°¨ê° ì´ë²¤íŠ¸ ë°œí–‰
    await this.rabbitMQ.publishMessage(
      'inventory.events',
      'inventory.reserve',
      {
        orderId: message.orderId,
        items: message.items
      }
    );
  }
}
```

### 2. Apache Kafka êµ¬í˜„

```javascript
const kafka = require('kafkajs');

class KafkaService {
  constructor(config) {
    this.kafka = kafka.kafka(config);
    this.producer = null;
    this.consumer = null;
  }
  
  async createProducer() {
    this.producer = this.kafka.producer();
    await this.producer.connect();
    return this.producer;
  }
  
  async createConsumer(groupId) {
    this.consumer = this.kafka.consumer({ groupId });
    await this.consumer.connect();
    return this.consumer;
  }
  
  async publishMessage(topic, message, partition = null) {
    if (!this.producer) {
      throw new Error('Producer not initialized');
    }
    
    return this.producer.send({
      topic,
      messages: [{
        key: message.key || null,
        value: JSON.stringify(message.value),
        partition: partition || null,
        headers: message.headers || {}
      }]
    });
  }
  
  async consumeMessages(topic, handler) {
    if (!this.consumer) {
      throw new Error('Consumer not initialized');
    }
    
    await this.consumer.subscribe({ topic });
    
    await this.consumer.run({
      eachMessage: async ({ topic, partition, message }) => {
        try {
          const messageData = {
            key: message.key?.toString(),
            value: JSON.parse(message.value.toString()),
            headers: message.headers,
            topic,
            partition,
            offset: message.offset
          };
          
          await handler(messageData);
        } catch (error) {
          console.error('Message processing failed:', error);
        }
      }
    });
  }
  
  async close() {
    if (this.producer) {
      await this.producer.disconnect();
    }
    if (this.consumer) {
      await this.consumer.disconnect();
    }
  }
}

// ì‚¬ìš© ì˜ˆì‹œ
class EventStreamService {
  constructor(kafkaService) {
    this.kafka = kafkaService;
  }
  
  async publishUserEvent(eventType, userData) {
    await this.kafka.publishMessage('user-events', {
      key: userData.id,
      value: {
        eventType,
        userId: userData.id,
        data: userData,
        timestamp: new Date().toISOString()
      }
    });
  }
  
  async handleUserEvents() {
    await this.kafka.consumeMessages('user-events', async (message) => {
      const { eventType, userId, data } = message.value;
      
      switch (eventType) {
        case 'USER_CREATED':
          await this.handleUserCreated(userId, data);
          break;
        case 'USER_UPDATED':
          await this.handleUserUpdated(userId, data);
          break;
        case 'USER_DELETED':
          await this.handleUserDeleted(userId);
          break;
      }
    });
  }
}
```

### 3. ë©”ì‹œì§€ í íŒ¨í„´

```javascript
// ë°œí–‰/êµ¬ë… íŒ¨í„´ (Pub/Sub)
class PubSubPattern {
  constructor(messageQueue) {
    this.mq = messageQueue;
  }
  
  async publishEvent(eventType, eventData) {
    await this.mq.publishMessage('events', eventType, {
      eventType,
      data: eventData,
      timestamp: new Date()
    });
  }
  
  async subscribeToEvents(eventTypes, handler) {
    for (const eventType of eventTypes) {
      await this.mq.consumeMessages(`events.${eventType}`, handler);
    }
  }
}

// ìš”ì²­/ì‘ë‹µ íŒ¨í„´ (Request/Reply)
class RequestReplyPattern {
  constructor(messageQueue) {
    this.mq = messageQueue;
    this.pendingRequests = new Map();
  }
  
  async sendRequest(requestData, timeout = 30000) {
    const requestId = this.generateRequestId();
    const replyQueue = `reply.${requestId}`;
    
    // ì‘ë‹µ í ìƒì„±
    await this.mq.createQueue(replyQueue, { exclusive: true, autoDelete: true });
    
    // ì‘ë‹µ ëŒ€ê¸°
    const responsePromise = new Promise((resolve, reject) => {
      const timeoutId = setTimeout(() => {
        this.pendingRequests.delete(requestId);
        reject(new Error('Request timeout'));
      }, timeout);
      
      this.pendingRequests.set(requestId, { resolve, reject, timeoutId });
    });
    
    // ìš”ì²­ ë°œì†¡
    await this.mq.publishMessage('requests', 'process', {
      requestId,
      replyTo: replyQueue,
      data: requestData
    });
    
    // ì‘ë‹µ ìˆ˜ì‹ 
    await this.mq.consumeMessages(replyQueue, (message) => {
      const { requestId: responseRequestId, result, error } = message;
      const pending = this.pendingRequests.get(responseRequestId);
      
      if (pending) {
        clearTimeout(pending.timeoutId);
        this.pendingRequests.delete(responseRequestId);
        
        if (error) {
          pending.reject(new Error(error));
        } else {
          pending.resolve(result);
        }
      }
    });
    
    return responsePromise;
  }
  
  generateRequestId() {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
}

// ì›Œí¬í”Œë¡œìš° íŒ¨í„´ (Workflow)
class WorkflowPattern {
  constructor(messageQueue) {
    this.mq = messageQueue;
    this.workflows = new Map();
  }
  
  async startWorkflow(workflowType, initialData) {
    const workflowId = this.generateWorkflowId();
    const workflow = {
      id: workflowId,
      type: workflowType,
      status: 'RUNNING',
      currentStep: 0,
      data: initialData,
      steps: this.workflows.get(workflowType) || []
    };
    
    await this.mq.publishMessage('workflows', 'start', workflow);
    return workflowId;
  }
  
  async executeStep(workflowId, stepData) {
    await this.mq.publishMessage('workflows', 'step', {
      workflowId,
      stepData
    });
  }
  
  async completeWorkflow(workflowId, result) {
    await this.mq.publishMessage('workflows', 'complete', {
      workflowId,
      result
    });
  }
  
  generateWorkflowId() {
    return `workflow-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
}
```

## ë°ì´í„°ë² ì´ìŠ¤ ë½ ì‹œìŠ¤í…œ (Database Lock System)

### 1. SELECT ë¬¸ì—ì„œ ë½ì´ ë°œìƒí•˜ëŠ” ê²½ìš°

#### 1.1 SELECT FOR UPDATE
- **í–‰ ë ˆë²¨ ë½(Row-Level Lock)**ì„ ë°œìƒì‹œí‚´
- ë°ì´í„° ì¡°íšŒì™€ ë™ì‹œì— **í•´ë‹¹ ë°ì´í„°ì˜ ìˆ˜ì •ì„ ìœ„í•´ ì ê¸ˆ**
- ë‹¤ë¥¸ íŠ¸ëœì­ì…˜ì—ì„œ í•´ë‹¹ í–‰ì„ ì½ê±°ë‚˜ ìˆ˜ì •í•˜ëŠ” ê²ƒì„ ì°¨ë‹¨

```sql
-- ê¸°ë³¸ ì‚¬ìš©ë²•
SELECT * FROM employees 
WHERE department = 'IT' 
FOR UPDATE;

-- íŠ¹ì • ì»¬ëŸ¼ë§Œ ì„ íƒí•˜ì—¬ ë½
SELECT employee_id, salary FROM employees 
WHERE department = 'IT' 
FOR UPDATE;

-- NOWAIT ì˜µì…˜ ì‚¬ìš© (ë½ íšë“ ì‹¤íŒ¨ ì‹œ ì¦‰ì‹œ ì—ëŸ¬ ë°˜í™˜)
SELECT * FROM employees 
WHERE department = 'IT' 
FOR UPDATE NOWAIT;

-- SKIP LOCKED ì˜µì…˜ ì‚¬ìš© (ë½ì´ ê±¸ë¦° í–‰ì€ ê±´ë„ˆë›°ê¸°)
SELECT * FROM employees 
WHERE department = 'IT' 
FOR UPDATE SKIP LOCKED;
```

**ì‚¬ìš© ì‚¬ë¡€:**
1. **ê¸‰ì—¬ ì¡°ì • ì‹œìŠ¤í…œ**
```sql
BEGIN;
-- íŠ¹ì • ë¶€ì„œì˜ ì§ì› ê¸‰ì—¬ ì¡°íšŒ ë° ì ê¸ˆ
SELECT * FROM employees 
WHERE department = 'IT' 
FOR UPDATE;

-- ê¸‰ì—¬ ì¸ìƒ ì²˜ë¦¬
UPDATE employees 
SET salary = salary * 1.1 
WHERE department = 'IT';

COMMIT;
```

2. **ì¬ê³  ê´€ë¦¬ ì‹œìŠ¤í…œ**
```sql
BEGIN;
-- íŠ¹ì • ìƒí’ˆì˜ ì¬ê³  í™•ì¸ ë° ì ê¸ˆ
SELECT * FROM inventory 
WHERE product_id = 123 
FOR UPDATE;

-- ì¬ê³  ê°ì†Œ ì²˜ë¦¬
UPDATE inventory 
SET quantity = quantity - 1 
WHERE product_id = 123;

COMMIT;
```

**ì£¼ì˜ì‚¬í•­:**
- FOR UPDATEëŠ” ì„±ëŠ¥ì— ì˜í–¥ì„ ì¤„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ í•„ìš”í•œ ê²½ìš°ì—ë§Œ ì‚¬ìš©
- ë°ë“œë½ ë°œìƒ ê°€ëŠ¥ì„±ì´ ìˆìœ¼ë¯€ë¡œ ë½ íšë“ ìˆœì„œì— ì£¼ì˜
- íŠ¸ëœì­ì…˜ì„ ìµœëŒ€í•œ ì§§ê²Œ ìœ ì§€

#### 1.2 SELECT LOCK IN SHARE MODE
- **ê³µìœ  ë½(Shared Lock)** ë°œìƒ
- ë‹¤ë¥¸ íŠ¸ëœì­ì…˜ì—ì„œ **ì½ê¸°ë§Œ ê°€ëŠ¥**í•˜ê³ , ì“°ê¸°ëŠ” ë¶ˆê°€ëŠ¥
- ì—¬ëŸ¬ íŠ¸ëœì­ì…˜ì´ ë™ì‹œì— ê³µìœ  ë½ì„ ê°€ì§ˆ ìˆ˜ ìˆìŒ

```sql
-- ê¸°ë³¸ ì‚¬ìš©ë²•
SELECT * FROM products 
WHERE category = 'Electronics' 
LOCK IN SHARE MODE;

-- íŠ¹ì • ì»¬ëŸ¼ë§Œ ì„ íƒí•˜ì—¬ ë½
SELECT product_id, price FROM products 
WHERE category = 'Electronics' 
LOCK IN SHARE MODE;
```

**ì‚¬ìš© ì‚¬ë¡€:**
1. **ìƒí’ˆ ì •ë³´ ì¡°íšŒ ì‹œìŠ¤í…œ**
```sql
BEGIN;
-- ìƒí’ˆ ì •ë³´ ì¡°íšŒ ë° ê³µìœ  ë½
SELECT * FROM products 
WHERE product_id = 456 
LOCK IN SHARE MODE;

-- ìƒí’ˆ ì •ë³´ í‘œì‹œ
-- ë‹¤ë¥¸ íŠ¸ëœì­ì…˜ì—ì„œë„ ë™ì‹œì— ì½ê¸° ê°€ëŠ¥
COMMIT;
```

2. **ë°ì´í„° ë¶„ì„ ì‹œìŠ¤í…œ**
```sql
BEGIN;
-- íŠ¹ì • ê¸°ê°„ì˜ ì£¼ë¬¸ ë°ì´í„° ì¡°íšŒ
SELECT * FROM orders 
WHERE order_date BETWEEN '2024-01-01' AND '2024-01-31'
LOCK IN SHARE MODE;

-- ë°ì´í„° ë¶„ì„ ìˆ˜í–‰
-- ë‹¤ë¥¸ íŠ¸ëœì­ì…˜ì—ì„œë„ ë™ì‹œì— ì½ê¸° ê°€ëŠ¥
COMMIT;
```

**ì£¼ì˜ì‚¬í•­:**
- ê³µìœ  ë½ì€ ë°°íƒ€ì  ë½ê³¼ ì¶©ëŒí•  ìˆ˜ ìˆìŒ
- ë„ˆë¬´ ë§ì€ ê³µìœ  ë½ì€ ì„±ëŠ¥ ì €í•˜ë¥¼ ì¼ìœ¼í‚¬ ìˆ˜ ìˆìŒ
- í•„ìš”í•œ ê²½ìš°ì—ë§Œ ì‚¬ìš©í•˜ê³  íŠ¸ëœì­ì…˜ì„ ì§§ê²Œ ìœ ì§€

### 2. íŠ¸ëœì­ì…˜ ê²©ë¦¬ ìˆ˜ì¤€ê³¼ ë½ì˜ ê´€ê³„

**íŠ¸ëœì­ì…˜ ê²©ë¦¬ ìˆ˜ì¤€(Isolation Level)**ì— ë”°ë¼ ë½ì˜ ë°œìƒ ì—¬ë¶€ì™€ ë™ì‘ì´ ë‹¬ë¼ì§‘ë‹ˆë‹¤.

| **ê²©ë¦¬ ìˆ˜ì¤€** | **íŠ¹ì§•** | **ë½ ë°œìƒ ê°€ëŠ¥ì„±** | **ë™ì‹œì„±** | **ì¼ê´€ì„±** |
|---------------|----------|-------------------|------------|------------|
| READ UNCOMMITTED | ì»¤ë°‹ë˜ì§€ ì•Šì€ ë°ì´í„° ì½ê¸° í—ˆìš© | ê±°ì˜ ì—†ìŒ | ë§¤ìš° ë†’ìŒ | ë§¤ìš° ë‚®ìŒ |
| READ COMMITTED | ì»¤ë°‹ëœ ë°ì´í„°ë§Œ ì½ê¸° ê°€ëŠ¥ | ë‚®ìŒ | ë†’ìŒ | ë‚®ìŒ |
| REPEATABLE READ | ë™ì¼ íŠ¸ëœì­ì…˜ ë‚´ì—ì„œ ì¼ê´€ëœ ë°ì´í„° | ì¤‘ê°„ | ì¤‘ê°„ | ì¤‘ê°„ |
| SERIALIZABLE | ê°€ì¥ ë†’ì€ ì¼ê´€ì„±, ëª¨ë“  ì ‘ê·¼ ì°¨ë‹¨ | ë†’ìŒ | ë‚®ìŒ | ë§¤ìš° ë†’ìŒ |

**ê²©ë¦¬ ìˆ˜ì¤€ ì„¤ì • ì˜ˆì œ:**
```sql
-- ì„¸ì…˜ ë ˆë²¨ ì„¤ì •
SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;

-- íŠ¸ëœì­ì…˜ ë ˆë²¨ ì„¤ì •
START TRANSACTION;
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
SELECT * FROM orders;
COMMIT;
```

**ê° ê²©ë¦¬ ìˆ˜ì¤€ë³„ íŠ¹ì§•:**
1. **READ UNCOMMITTED**
   - Dirty Read ê°€ëŠ¥
   - Non-repeatable Read ê°€ëŠ¥
   - Phantom Read ê°€ëŠ¥
   - ì„±ëŠ¥ì€ ê°€ì¥ ì¢‹ì§€ë§Œ ì¼ê´€ì„± ë³´ì¥ì´ ê°€ì¥ ë‚®ìŒ

2. **READ COMMITTED**
   - Dirty Read ë°©ì§€
   - Non-repeatable Read ê°€ëŠ¥
   - Phantom Read ê°€ëŠ¥
   - ëŒ€ë¶€ë¶„ì˜ DBMSì˜ ê¸°ë³¸ ê²©ë¦¬ ìˆ˜ì¤€

3. **REPEATABLE READ**
   - Dirty Read ë°©ì§€
   - Non-repeatable Read ë°©ì§€
   - Phantom Read ê°€ëŠ¥
   - MySQLì˜ ê¸°ë³¸ ê²©ë¦¬ ìˆ˜ì¤€

4. **SERIALIZABLE**
   - Dirty Read ë°©ì§€
   - Non-repeatable Read ë°©ì§€
   - Phantom Read ë°©ì§€
   - ê°€ì¥ ë†’ì€ ì¼ê´€ì„± ë³´ì¥

### 3. ë½ ê´€ë ¨ ì‹¤ì œ ì˜ˆì œ

#### 3.1 SELECT FOR UPDATE ì‚¬ìš© ì˜ˆì œ
```sql
-- ê³„ì¢Œ ì´ì²´ ì‹œìŠ¤í…œ
BEGIN;

-- ì¶œê¸ˆ ê³„ì¢Œ ì ê¸ˆ
SELECT * FROM accounts 
WHERE account_id = 1 
FOR UPDATE;

-- ì…ê¸ˆ ê³„ì¢Œ ì ê¸ˆ
SELECT * FROM accounts 
WHERE account_id = 2 
FOR UPDATE;

-- ì¶œê¸ˆ ì²˜ë¦¬
UPDATE accounts 
SET balance = balance - 100 
WHERE account_id = 1;

-- ì…ê¸ˆ ì²˜ë¦¬
UPDATE accounts 
SET balance = balance + 100 
WHERE account_id = 2;

COMMIT;
```

**ì£¼ì˜ì‚¬í•­:**
- ê³„ì¢Œ ì ê¸ˆ ìˆœì„œë¥¼ ì¼ê´€ë˜ê²Œ ìœ ì§€í•˜ì—¬ ë°ë“œë½ ë°©ì§€
- íŠ¸ëœì­ì…˜ì„ ìµœëŒ€í•œ ì§§ê²Œ ìœ ì§€
- ì—ëŸ¬ ë°œìƒ ì‹œ ë¡¤ë°± ì²˜ë¦¬

#### 3.2 SELECT LOCK IN SHARE MODE ì‚¬ìš© ì˜ˆì œ
```sql
-- ìƒí’ˆ ê°€ê²© ì¡°íšŒ ë° ìˆ˜ì • ì‹œìŠ¤í…œ
BEGIN;

-- ìƒí’ˆ ì •ë³´ ì¡°íšŒ ë° ê³µìœ  ë½
SELECT * FROM products 
WHERE product_id = 1 
LOCK IN SHARE MODE;

-- ê°€ê²© ìˆ˜ì •ì„ ìœ„í•œ ë°°íƒ€ì  ë½
SELECT * FROM products 
WHERE product_id = 1 
FOR UPDATE;

-- ê°€ê²© ìˆ˜ì •
UPDATE products 
SET price = price + 10 
WHERE product_id = 1;

COMMIT;
```

**ì£¼ì˜ì‚¬í•­:**
- ê³µìœ  ë½ì—ì„œ ë°°íƒ€ì  ë½ìœ¼ë¡œì˜ ì „í™˜ ì‹œ ì£¼ì˜
- íŠ¸ëœì­ì…˜ ê²©ë¦¬ ìˆ˜ì¤€ì— ë”°ë¥¸ ë™ì‘ ì°¨ì´ í™•ì¸
- ë½ íšë“ ì‹¤íŒ¨ ì‹œ ì ì ˆí•œ ì—ëŸ¬ ì²˜ë¦¬

### 4. ë°ë“œë½ ë°©ì§€ ë°©ë²•

#### 4.1 ë°ë“œë½ ë°œìƒ ì‹œë‚˜ë¦¬ì˜¤
```sql
-- ë°ë“œë½ ë°œìƒ ì‹œë‚˜ë¦¬ì˜¤
-- ì„¸ì…˜ 1
BEGIN;
SELECT * FROM orders WHERE order_id = 1 FOR UPDATE;

-- ì„¸ì…˜ 2
BEGIN;
SELECT * FROM orders WHERE order_id = 2 FOR UPDATE;

-- ì„¸ì…˜ 1 (ë°ë“œë½ ë°œìƒ)
UPDATE orders SET status = 'Shipped' WHERE order_id = 2;

-- ì„¸ì…˜ 2 (ë°ë“œë½ ë°œìƒ)
UPDATE orders SET status = 'Shipped' WHERE order_id = 1;
```

#### 4.2 ë°ë“œë½ ë°©ì§€ ë°©ë²•
1. **ë½ íšë“ ìˆœì„œ í†µì¼**
```sql
-- ì˜¬ë°”ë¥¸ ë½ íšë“ ìˆœì„œ
BEGIN;
-- í•­ìƒ ì‘ì€ IDë¶€í„° ë½ íšë“
SELECT * FROM orders WHERE order_id = 1 FOR UPDATE;
SELECT * FROM orders WHERE order_id = 2 FOR UPDATE;
```

2. **íƒ€ì„ì•„ì›ƒ ì„¤ì •**
```sql
-- íƒ€ì„ì•„ì›ƒ ì„¤ì •
SET innodb_lock_wait_timeout = 50; -- 50ì´ˆ
```

3. **NOWAIT ì˜µì…˜ ì‚¬ìš©**
```sql
SELECT * FROM orders 
WHERE order_id = 1 
FOR UPDATE NOWAIT;
```

4. **SKIP LOCKED ì˜µì…˜ ì‚¬ìš©**
```sql
SELECT * FROM orders 
WHERE order_id = 1 
FOR UPDATE SKIP LOCKED;
```

### 5. ë½ í•´ì œ ë°©ë²•

#### 5.1 ëª…ì‹œì  ë½ í•´ì œ
1. **ëª…ì‹œì  ì»¤ë°‹**
```sql
BEGIN;
-- íŠ¸ëœì­ì…˜ ì‘ì—… ìˆ˜í–‰
COMMIT; -- ëª¨ë“  ë½ í•´ì œ
```

2. **ë¡¤ë°±**
```sql
BEGIN;
-- íŠ¸ëœì­ì…˜ ì‘ì—… ìˆ˜í–‰
ROLLBACK; -- ëª¨ë“  ë½ í•´ì œ
```

3. **ì„¸ì…˜ ì¢…ë£Œ**
- ì„¸ì…˜ì´ ì¢…ë£Œë˜ë©´ ëª¨ë“  ë½ì´ ìë™ìœ¼ë¡œ í•´ì œë¨

### 6. ë½ ì„±ëŠ¥ ìµœì í™” ê¸°ë²•

#### 6.1 íŠ¸ëœì­ì…˜ ìµœì í™”
- íŠ¸ëœì­ì…˜ì„ ìµœëŒ€í•œ ì§§ê²Œ ìœ ì§€
- ë¶ˆí•„ìš”í•œ ë½ ì‚¬ìš© í”¼í•˜ê¸°
- ì ì ˆí•œ ê²©ë¦¬ ìˆ˜ì¤€ ì„ íƒ

#### 6.2 ì¸ë±ìŠ¤ ìµœì í™”
```sql
-- ì ì ˆí•œ ì¸ë±ìŠ¤ ìƒì„±
CREATE INDEX idx_department ON employees(department);
CREATE INDEX idx_product_category ON products(category);
```

#### 6.3 ë½ íƒ€ì„ì•„ì›ƒ ì„¤ì •
```sql
-- ë½ ëŒ€ê¸° ì‹œê°„ ì„¤ì •
SET innodb_lock_wait_timeout = 30;
```

#### 6.4 ë°°ì¹˜ ì²˜ë¦¬ ìµœì í™”
```sql
-- ëŒ€ëŸ‰ ì—…ë°ì´íŠ¸ ì‹œ ë°°ì¹˜ ì²˜ë¦¬
UPDATE employees 
SET salary = salary * 1.1 
WHERE department = 'IT' 
LIMIT 1000;
```

### 7. SELECT ë½ì˜ ì¥ë‹¨ì 

| **êµ¬ë¶„** | **ì¥ì ** | **ë‹¨ì ** | **ì‚¬ìš© ì‹œë‚˜ë¦¬ì˜¤** |
|----------|----------|----------|-------------------|
| **FOR UPDATE** | ë°ì´í„° ì¼ê´€ì„± ìœ ì§€, ê²½í•© ë°©ì§€ | ë™ì‹œì„± ì €í•˜ | ê³„ì¢Œ ì´ì²´, ì¬ê³  ê´€ë¦¬ |
| **LOCK IN SHARE MODE** | ì½ê¸° ê°€ëŠ¥, ìˆ˜ì • ì œí•œ | ì—…ë°ì´íŠ¸ ì¶©ëŒ ê°€ëŠ¥ì„± ì¡´ì¬ | ë°ì´í„° ì¡°íšŒ, ë³´ê³ ì„œ ìƒì„± |
| **SERIALIZABLE** | ìµœëŒ€ ì¼ê´€ì„± ë³´ì¥ | ì„±ëŠ¥ ì €í•˜, ë°ë“œë½ ë°œìƒ ìœ„í—˜ | ê¸ˆìœµ ê±°ë˜, ì •í™•ì„± ìš”êµ¬ ì‹œìŠ¤í…œ |

### 8. ê²°ë¡ 

1. **SELECT ë¬¸ë„ íŠ¹ì • ìƒí™©ì—ì„œ ë½ì„ ë°œìƒì‹œí‚¬ ìˆ˜ ìˆìœ¼ë©°, ì´ëŠ” ë°ì´í„°ë² ì´ìŠ¤ì˜ ì¼ê´€ì„±ê³¼ ë™ì‹œì„± ì œì–´ì— ì¤‘ìš”í•©ë‹ˆë‹¤.**
2. **íŠ¸ëœì­ì…˜ ê²©ë¦¬ ìˆ˜ì¤€ê³¼ ëª…ì‹œì ì¸ FOR UPDATE ì‚¬ìš© ì‹œ ì£¼ì˜í•´ì•¼ í•©ë‹ˆë‹¤.**
3. **ë°ë“œë½ ë°©ì§€ ë° ì„±ëŠ¥ ìµœì í™”ë¥¼ ìœ„í•´ ì ì ˆí•œ íŠ¸ëœì­ì…˜ ì„¤ê³„ê°€ ì¤‘ìš”í•©ë‹ˆë‹¤.**
4. **ì‹¤ì œ ì‹œìŠ¤í…œì—ì„œëŠ” ë‹¤ìŒê³¼ ê°™ì€ ì›ì¹™ì„ ì§€ì¼œì•¼ í•©ë‹ˆë‹¤:**
   - í•„ìš”í•œ ê²½ìš°ì—ë§Œ ë½ ì‚¬ìš©
   - íŠ¸ëœì­ì…˜ì„ ìµœëŒ€í•œ ì§§ê²Œ ìœ ì§€
   - ì ì ˆí•œ ê²©ë¦¬ ìˆ˜ì¤€ ì„ íƒ
   - ì¸ë±ìŠ¤ ìµœì í™”
   - ë½ íšë“ ìˆœì„œ í†µì¼
   - íƒ€ì„ì•„ì›ƒ ì„¤ì •
   - ì—ëŸ¬ ì²˜ë¦¬ êµ¬í˜„

## ë¶„ì‚° ë½ ë° ë™ì‹œì„± ì œì–´ (Distributed Lock and Concurrency Control)

### 1. Redis ë¶„ì‚° ë½

```javascript
class DistributedLock {
  constructor(redisClient) {
    this.redis = redisClient;
  }
  
  async acquireLock(lockKey, ttl = 10000, retryDelay = 100) {
    const lockValue = Date.now() + Math.random();
    const lockName = `lock:${lockKey}`;
    
    // SET NX EX ëª…ë ¹ìœ¼ë¡œ ì›ìì  ë½ íšë“
    const result = await this.redis.set(lockName, lockValue, 'PX', ttl, 'NX');
    
    if (result === 'OK') {
      return {
        success: true,
        lockValue,
        release: () => this.releaseLock(lockName, lockValue)
      };
    }
    
    return { success: false };
  }
  
  async releaseLock(lockName, lockValue) {
    const script = `
      if redis.call("get", KEYS[1]) == ARGV[1] then
        return redis.call("del", KEYS[1])
      else
        return 0
      end
    `;
    
    return await this.redis.eval(script, 1, lockName, lockValue);
  }
  
  async withLock(lockKey, work, ttl = 10000) {
    const lock = await this.acquireLock(lockKey, ttl);
    
    if (!lock.success) {
      throw new Error('ë½ íšë“ ì‹¤íŒ¨');
    }
    
    try {
      return await work();
    } finally {
      await lock.release();
    }
  }
  
  async acquireLockWithRetry(lockKey, ttl = 10000, maxRetries = 10, retryDelay = 100) {
    for (let i = 0; i < maxRetries; i++) {
      const lock = await this.acquireLock(lockKey, ttl);
      
      if (lock.success) {
        return lock;
      }
      
      await new Promise(resolve => setTimeout(resolve, retryDelay));
    }
    
    throw new Error('ë½ íšë“ ìµœëŒ€ ì¬ì‹œë„ íšŸìˆ˜ ì´ˆê³¼');
  }
}

// ì‚¬ìš© ì˜ˆì‹œ
class InventoryService {
  constructor(redisClient) {
    this.lock = new DistributedLock(redisClient);
  }
  
  async reserveInventory(productId, quantity) {
    return await this.lock.withLock(`inventory:${productId}`, async () => {
      const currentStock = await this.getCurrentStock(productId);
      
      if (currentStock < quantity) {
        throw new Error('ì¬ê³  ë¶€ì¡±');
      }
      
      await this.updateStock(productId, currentStock - quantity);
      return { productId, reservedQuantity: quantity };
    });
  }
}
```

### 2. ë°ì´í„°ë² ì´ìŠ¤ ë¶„ì‚° ë½

```javascript
class DatabaseDistributedLock {
  constructor(database) {
    this.db = database;
  }
  
  async acquireLock(lockKey, ttl = 30000) {
    const lockId = this.generateLockId();
    const expiresAt = new Date(Date.now() + ttl);
    
    try {
      await this.db.query(
        'INSERT INTO distributed_locks (lock_key, lock_id, expires_at) VALUES (?, ?, ?)',
        [lockKey, lockId, expiresAt]
      );
      
      return {
        success: true,
        lockId,
        release: () => this.releaseLock(lockKey, lockId)
      };
    } catch (error) {
      if (error.code === 'ER_DUP_ENTRY') {
        return { success: false };
      }
      throw error;
    }
  }
  
  async releaseLock(lockKey, lockId) {
    const result = await this.db.query(
      'DELETE FROM distributed_locks WHERE lock_key = ? AND lock_id = ?',
      [lockKey, lockId]
    );
    
    return result.affectedRows > 0;
  }
  
  async cleanupExpiredLocks() {
    await this.db.query(
      'DELETE FROM distributed_locks WHERE expires_at < NOW()'
    );
  }
  
  generateLockId() {
    return `${process.pid}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
}
```

### 3. ë¶„ì‚° ë½ íŒ¨í„´

```javascript
// Redlock ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„
class Redlock {
  constructor(redisClients) {
    this.redisClients = redisClients;
    this.quorum = Math.floor(redisClients.length / 2) + 1;
  }
  
  async lock(resource, ttl = 10000) {
    const lockValue = this.generateLockValue();
    const startTime = Date.now();
    const lockPromises = this.redisClients.map(client => 
      this.acquireLockOnClient(client, resource, lockValue, ttl)
    );
    
    const results = await Promise.allSettled(lockPromises);
    const successCount = results.filter(result => 
      result.status === 'fulfilled' && result.value === true
    ).length;
    
    if (successCount >= this.quorum) {
      const validityTime = ttl - (Date.now() - startTime) - 100; // 100ms ë²„í¼
      return {
        success: true,
        lockValue,
        validityTime,
        release: () => this.unlock(resource, lockValue)
      };
    }
    
    // ì‹¤íŒ¨í•œ ê²½ìš° íšë“í•œ ë½ë“¤ í•´ì œ
    await this.unlock(resource, lockValue);
    return { success: false };
  }
  
  async unlock(resource, lockValue) {
    const unlockPromises = this.redisClients.map(client =>
      this.releaseLockOnClient(client, resource, lockValue)
    );
    
    await Promise.allSettled(unlockPromises);
  }
  
  async acquireLockOnClient(client, resource, lockValue, ttl) {
    try {
      const result = await client.set(`lock:${resource}`, lockValue, 'PX', ttl, 'NX');
      return result === 'OK';
    } catch (error) {
      return false;
    }
  }
  
  async releaseLockOnClient(client, resource, lockValue) {
    const script = `
      if redis.call("get", KEYS[1]) == ARGV[1] then
        return redis.call("del", KEYS[1])
      else
        return 0
      end
    `;
    
    try {
      return await client.eval(script, 1, `lock:${resource}`, lockValue);
    } catch (error) {
      return 0;
    }
  }
  
  generateLockValue() {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
}

// ë¶„ì‚° ì„¸ë§ˆí¬ì–´
class DistributedSemaphore {
  constructor(redisClient, semaphoreName, maxCount) {
    this.redis = redisClient;
    this.semaphoreName = semaphoreName;
    this.maxCount = maxCount;
  }
  
  async acquire(timeout = 10000) {
    const permitId = this.generatePermitId();
    const startTime = Date.now();
    
    while (Date.now() - startTime < timeout) {
      const currentCount = await this.redis.llen(this.semaphoreName);
      
      if (currentCount < this.maxCount) {
        await this.redis.lpush(this.semaphoreName, permitId);
        return {
          success: true,
          permitId,
          release: () => this.release(permitId)
        };
      }
      
      // ì ì‹œ ëŒ€ê¸° í›„ ì¬ì‹œë„
      await new Promise(resolve => setTimeout(resolve, 100));
    }
    
    return { success: false };
  }
  
  async release(permitId) {
    return await this.redis.lrem(this.semaphoreName, 1, permitId);
  }
  
  generatePermitId() {
    return `${process.pid}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
}
```

## ê²°ë¡ 

ë©”ì‹œì§€ íì™€ ë¶„ì‚° ë½ì€ ë¶„ì‚° ì‹œìŠ¤í…œì—ì„œ í•µì‹¬ì ì¸ ì—­í• ì„ í•©ë‹ˆë‹¤. ë©”ì‹œì§€ íë¥¼ í†µí•´ ì„œë¹„ìŠ¤ ê°„ ëŠìŠ¨í•œ ê²°í•©ì„ êµ¬í˜„í•˜ê³ , ë¶„ì‚° ë½ì„ í†µí•´ ë™ì‹œì„± ì œì–´ì™€ ë°ì´í„° ì¼ê´€ì„±ì„ ë³´ì¥í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### í•µì‹¬ ì›ì¹™ ìš”ì•½

1. **ë©”ì‹œì§€ í**: ë¹„ë™ê¸° í†µì‹ ìœ¼ë¡œ ì„œë¹„ìŠ¤ ê°„ ëŠìŠ¨í•œ ê²°í•© êµ¬í˜„
2. **ë¶„ì‚° ë½**: ë¶„ì‚° í™˜ê²½ì—ì„œì˜ ë™ì‹œì„± ì œì–´ ë° ë°ì´í„° ì¼ê´€ì„± ë³´ì¥
3. **íŒ¨í„´ í™œìš©**: ë°œí–‰/êµ¬ë…, ìš”ì²­/ì‘ë‹µ, ì›Œí¬í”Œë¡œìš° ë“± ë‹¤ì–‘í•œ íŒ¨í„´ ì ìš©
4. **ì•ˆì •ì„±**: ì¬ì‹œë„, íƒ€ì„ì•„ì›ƒ, ë°ë“œë ˆí„° í ë“±ì„ í†µí•œ ì•ˆì •ì„± í™•ë³´

ì´ëŸ¬í•œ ê¸°ìˆ ë“¤ì„ ì ì ˆíˆ ì¡°í•©í•˜ì—¬ ì•ˆì •ì ì´ê³  í™•ì¥ ê°€ëŠ¥í•œ ë¶„ì‚° ì‹œìŠ¤í…œì„ êµ¬ì¶•í•˜ì„¸ìš”.
