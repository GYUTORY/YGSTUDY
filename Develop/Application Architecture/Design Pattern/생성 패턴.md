# 생성 패턴 (Creational Patterns)

생성 패턴은 객체의 생성 과정을 추상화하고, 객체의 인스턴스화를 유연하게 처리하는 방법을 제공하는 디자인 패턴입니다. 이 패턴들은 객체 생성에 관련된 복잡성을 줄이고, 객체 간의 의존성을 최소화하며, 코드의 재사용성과 유지보수성을 향상시킵니다.

## 1. 싱글톤 패턴 (Singleton Pattern)

### 정의
- 클래스의 인스턴스가 오직 하나만 생성되도록 보장하고, 이 인스턴스에 대한 전역적인 접근을 제공하는 패턴입니다.
- 전역 상태를 관리하거나 리소스를 공유해야 하는 경우에 특히 유용합니다.

### 구현 방법
```java
public class DatabaseConnection {
    private static DatabaseConnection instance;
    private Connection connection;
    
    private DatabaseConnection() {
        // 데이터베이스 연결 초기화
    }
    
    public static synchronized DatabaseConnection getInstance() {
        if (instance == null) {
            instance = new DatabaseConnection();
        }
        return instance;
    }
    
    // 더블 체크드 락킹을 사용한 최적화된 버전
    public static DatabaseConnection getInstanceOptimized() {
        if (instance == null) {
            synchronized (DatabaseConnection.class) {
                if (instance == null) {
                    instance = new DatabaseConnection();
                }
            }
        }
        return instance;
    }
}
```

### 특징
- private 생성자를 사용하여 외부에서의 직접적인 인스턴스 생성을 방지
- static 메서드를 통해 유일한 인스턴스에 접근
- 멀티스레드 환경에서의 동시성 문제 해결을 위한 동기화 처리 필요
- 지연 초기화(Lazy Initialization)를 통한 리소스 최적화

### 실제 사용 사례
1. **데이터베이스 연결 관리**
   - 데이터베이스 연결 풀 관리
   - 연결 상태 모니터링
   - 연결 재사용 최적화

2. **로깅 시스템**
   - 로그 파일 관리
   - 로그 레벨 제어
   - 로그 포맷팅

3. **설정 관리**
   - 애플리케이션 설정 로드
   - 환경별 설정 관리
   - 설정 변경 감지

4. **캐시 시스템**
   - 메모리 캐시 관리
   - 캐시 정책 구현
   - 캐시 무효화 처리

### 장점
- 메모리 효율성 (단일 인스턴스만 사용)
- 전역 접근성
- 리소스 공유 용이
- 상태 관리 용이

### 단점
- 테스트 어려움 (의존성 주입이 어려움)
- 멀티스레드 환경에서의 복잡성
- 전역 상태로 인한 의존성 증가
- 단일 책임 원칙 위반 가능성

## 2. 팩토리 메서드 패턴 (Factory Method Pattern)

### 정의
- 객체 생성을 서브클래스로 위임하는 패턴으로, 슈퍼클래스에서는 객체 생성의 인터페이스를 정의하고, 서브클래스에서 실제 객체 생성을 구현합니다.
- 객체 생성 로직을 캡슐화하여 클라이언트 코드와 생성되는 객체 간의 결합도를 낮춥니다.

### 구현 예시
```java
// 추상 제품
interface Document {
    void open();
    void save();
}

// 구체적인 제품들
class PDFDocument implements Document {
    @Override
    public void open() { /* PDF 열기 구현 */ }
    @Override
    public void save() { /* PDF 저장 구현 */ }
}

class WordDocument implements Document {
    @Override
    public void open() { /* Word 열기 구현 */ }
    @Override
    public void save() { /* Word 저장 구현 */ }
}

// 추상 팩토리
abstract class DocumentFactory {
    abstract Document createDocument();
    
    // 템플릿 메서드
    public Document newDocument() {
        Document doc = createDocument();
        // 공통 초기화 로직
        return doc;
    }
}

// 구체적인 팩토리들
class PDFFactory extends DocumentFactory {
    @Override
    Document createDocument() {
        return new PDFDocument();
    }
}

class WordFactory extends DocumentFactory {
    @Override
    Document createDocument() {
        return new WordDocument();
    }
}
```

### 실제 사용 사례
1. **UI 프레임워크**
   - 플랫폼별 UI 컴포넌트 생성
   - 테마별 컴포넌트 스타일링
   - 반응형 UI 요소 생성

2. **게임 엔진**
   - 캐릭터 타입별 생성
   - 아이템 생성 시스템
   - 레벨별 적 생성

3. **데이터베이스 접근**
   - 데이터베이스 타입별 연결 객체 생성
   - 쿼리 빌더 생성
   - ORM 매핑 객체 생성

### 장점
- 코드의 유연성 향상
- 확장성 용이
- 단일 책임 원칙 준수
- 의존성 역전 원칙 준수

### 단점
- 클래스 수 증가
- 복잡성 증가 가능성
- 상속 구조로 인한 제약

## 3. 추상 팩토리 패턴 (Abstract Factory Pattern)

### 정의
- 서로 관련이 있는 여러 객체들의 생성을 담당하는 인터페이스를 제공하는 패턴입니다.
- 구체적인 팩토리 클래스들은 이 인터페이스를 구현하여 관련 객체군을 생성합니다.

### 구현 예시
```java
// 추상 제품들
interface Button {
    void render();
}

interface TextBox {
    void render();
}

// 구체적인 제품들
class WindowsButton implements Button {
    @Override
    public void render() { /* Windows 스타일 버튼 렌더링 */ }
}

class MacButton implements Button {
    @Override
    public void render() { /* Mac 스타일 버튼 렌더링 */ }
}

// 추상 팩토리
interface GUIFactory {
    Button createButton();
    TextBox createTextBox();
}

// 구체적인 팩토리들
class WindowsFactory implements GUIFactory {
    @Override
    public Button createButton() {
        return new WindowsButton();
    }
    
    @Override
    public TextBox createTextBox() {
        return new WindowsTextBox();
    }
}

class MacFactory implements GUIFactory {
    @Override
    public Button createButton() {
        return new MacButton();
    }
    
    @Override
    public TextBox createTextBox() {
        return new MacTextBox();
    }
}
```

### 실제 사용 사례
1. **크로스 플랫폼 UI 개발**
   - OS별 네이티브 컴포넌트 생성
   - 플랫폼별 스타일링
   - 테마 시스템 구현

2. **데이터베이스 추상화**
   - 데이터베이스 벤더별 연결 관리
   - 쿼리 빌더 생성
   - 트랜잭션 관리

3. **게임 엔진**
   - 그래픽스 API별 렌더링 시스템
   - 물리 엔진 구현
   - 사운드 시스템

### 장점
- 제품군의 일관성 보장
- 구체적인 클래스와의 결합도 감소
- 제품군 교체 용이
- 확장성과 유연성

### 단점
- 새로운 제품 추가 시 인터페이스 변경 필요
- 복잡성 증가
- 클래스 수 증가

## 4. 빌더 패턴 (Builder Pattern)

### 정의
- 복잡한 객체의 생성 과정을 단계별로 분리하여, 동일한 생성 과정에서 서로 다른 표현을 만들 수 있도록 하는 패턴입니다.
- 객체 생성의 유연성을 높이고 가독성을 개선합니다.

### 구현 예시
```java
class Computer {
    private String cpu;
    private String ram;
    private String storage;
    private String gpu;
    
    private Computer(Builder builder) {
        this.cpu = builder.cpu;
        this.ram = builder.ram;
        this.storage = builder.storage;
        this.gpu = builder.gpu;
    }
    
    public static class Builder {
        private String cpu;
        private String ram;
        private String storage;
        private String gpu;
        
        public Builder cpu(String cpu) {
            this.cpu = cpu;
            return this;
        }
        
        public Builder ram(String ram) {
            this.ram = ram;
            return this;
        }
        
        public Builder storage(String storage) {
            this.storage = storage;
            return this;
        }
        
        public Builder gpu(String gpu) {
            this.gpu = gpu;
            return this;
        }
        
        public Computer build() {
            return new Computer(this);
        }
    }
}

// 사용 예시
Computer gamingPC = new Computer.Builder()
    .cpu("Intel i9")
    .ram("32GB")
    .storage("1TB SSD")
    .gpu("RTX 3080")
    .build();
```

### 실제 사용 사례
1. **문서 생성**
   - HTML 문서 빌더
   - PDF 문서 생성
   - 이메일 메시지 구성

2. **쿼리 빌더**
   - SQL 쿼리 생성
   - MongoDB 쿼리 빌더
   - GraphQL 쿼리 생성

3. **설정 객체**
   - 애플리케이션 설정
   - 데이터베이스 설정
   - 네트워크 설정

### 장점
- 객체 생성 과정의 유연성
- 코드 가독성 향상
- 매개변수 선택적 설정 가능
- 불변 객체 생성 용이

### 단점
- 빌더 클래스 추가로 인한 코드량 증가
- 간단한 객체의 경우 오버헤드 발생 가능
- 유지보수 비용 증가

## 5. 프로토타입 패턴 (Prototype Pattern)

### 정의
- 기존 객체를 복제하여 새로운 객체를 생성하는 패턴으로, 객체 생성 비용이 높은 경우나 객체의 상태가 동적으로 변하는 경우에 유용합니다.
- 객체의 초기화 과정을 단순화하고 성능을 최적화합니다.

### 구현 예시
```java
interface Prototype {
    Prototype clone();
}

class Document implements Prototype {
    private String content;
    private String format;
    
    public Document(String content, String format) {
        this.content = content;
        this.format = format;
    }
    
    @Override
    public Document clone() {
        return new Document(this.content, this.format);
    }
    
    // 깊은 복사를 위한 메서드
    public Document deepClone() {
        Document clone = new Document(new String(this.content), new String(this.format));
        return clone;
    }
}

// 사용 예시
Document original = new Document("Hello", "PDF");
Document copy = original.clone();
```

### 실제 사용 사례
1. **게임 개발**
   - 게임 오브젝트 복제
   - 파티클 시스템
   - 레벨 디자인

2. **문서 처리**
   - 템플릿 기반 문서 생성
   - 문서 버전 관리
   - 문서 변환

3. **캐시 시스템**
   - 객체 캐싱
   - 메모리 최적화
   - 상태 관리

### 장점
- 객체 생성 비용 감소
- 동적 객체 생성 용이
- 초기화 과정 단순화
- 메모리 효율성

### 단점
- 복잡한 객체의 경우 복제 구현이 어려움
- 순환 참조 처리 필요
- 깊은 복사 시 성능 저하 가능성
- 객체 상태 관리의 복잡성