---
title: 생성 패턴 (Creational Patterns) 완벽 가이드
tags: [application-architecture, design-pattern, creational-patterns, singleton, factory, builder]
updated: 2025-08-16
---

# 생성 패턴 (Creational Patterns) 완벽 가이드

## 배경

### 생성 패턴이란?
생성 패턴은 객체 생성 과정을 추상화하고 유연하게 만드는 디자인 패턴입니다. 객체 생성의 복잡성을 숨기고, 클라이언트 코드가 구체적인 클래스에 의존하지 않도록 하여 코드의 유지보수성과 확장성을 향상시킵니다.

### 생성 패턴의 필요성
- **객체 생성 복잡성 감소**: 복잡한 객체 생성 과정을 단순화
- **의존성 분리**: 클라이언트가 구체적인 클래스에 직접 의존하지 않음
- **유연성 향상**: 런타임에 객체 타입을 결정할 수 있음
- **코드 재사용성**: 객체 생성 로직을 재사용 가능

### 기본 개념
- **추상화**: 객체 생성 과정을 추상 인터페이스로 정의
- **캡슐화**: 객체 생성 로직을 별도로 분리
- **다형성**: 다양한 타입의 객체를 동일한 인터페이스로 생성
- **결합도 감소**: 클라이언트와 구체 클래스 간의 결합도 최소화

## 핵심

### 1. Singleton Pattern (싱글톤 패턴)

#### 개념
애플리케이션 전체에서 단 하나의 인스턴스만 존재하도록 보장하는 패턴입니다. 전역적으로 하나의 인스턴스만 필요한 경우에 사용됩니다.

#### 기본 구현
```javascript
class Singleton {
    constructor() {
        if (Singleton.instance) {
            return Singleton.instance;
        }
        
        this.data = "싱글톤 데이터";
        Singleton.instance = this;
    }

    getData() {
        return this.data;
    }

    setData(newData) {
        this.data = newData;
    }
}

// 사용 예시
const instance1 = new Singleton();
const instance2 = new Singleton();

console.log(instance1 === instance2); // true
console.log(instance1.getData()); // "싱글톤 데이터"
```

#### 실제 사용 사례

**데이터베이스 연결 관리**
```javascript
class DatabaseConnection {
    constructor() {
        if (DatabaseConnection.instance) {
            return DatabaseConnection.instance;
        }
        
        this.connection = null;
        this.isConnected = false;
        DatabaseConnection.instance = this;
    }

    connect() {
        if (!this.isConnected) {
            this.connection = "데이터베이스 연결됨";
            this.isConnected = true;
            console.log("데이터베이스에 연결되었습니다.");
        }
        return this.connection;
    }

    disconnect() {
        if (this.isConnected) {
            this.connection = null;
            this.isConnected = false;
            console.log("데이터베이스 연결이 해제되었습니다.");
        }
    }
}

// 애플리케이션 전체에서 동일한 연결 사용
const db1 = new DatabaseConnection();
const db2 = new DatabaseConnection();
console.log(db1 === db2); // true
```

**로깅 시스템**
```javascript
class Logger {
    constructor() {
        if (Logger.instance) {
            return Logger.instance;
        }
        
        this.logs = [];
        Logger.instance = this;
    }

    log(message, level = 'INFO') {
        const timestamp = new Date().toISOString();
        const logEntry = `[${timestamp}] [${level}] ${message}`;
        this.logs.push(logEntry);
        console.log(logEntry);
    }

    getLogs() {
        return [...this.logs];
    }

    clearLogs() {
        this.logs = [];
    }
}

// 전역 로거 사용
const logger = new Logger();
logger.log("애플리케이션 시작");
logger.log("사용자 로그인", "DEBUG");
```

#### 장단점
**장점**
- 메모리 효율성: 하나의 인스턴스만 사용
- 전역 접근: 어디서든 동일한 인스턴스에 접근 가능
- 리소스 공유: 여러 부분에서 동일한 리소스 공유

**단점**
- 테스트 어려움: 전역 상태로 인한 테스트 복잡성
- 동시성 문제: 멀티스레드 환경에서 주의 필요
- 의존성 증가: 전역 상태에 대한 의존성

### 2. Factory Method Pattern (팩토리 메서드 패턴)

#### 개념
객체 생성을 서브클래스에 위임하는 패턴입니다. 클라이언트는 어떤 객체가 생성되는지 알 필요 없이, 팩토리 메서드를 통해 객체를 생성할 수 있습니다.

#### 기본 구현
```javascript
// 추상 제품
class Document {
    open() {
        throw new Error("open 메서드를 구현해야 합니다.");
    }
    
    save() {
        throw new Error("save 메서드를 구현해야 합니다.");
    }
}

// 구체적인 제품들
class PDFDocument extends Document {
    open() {
        console.log("PDF 문서를 엽니다.");
    }
    
    save() {
        console.log("PDF 문서를 저장합니다.");
    }
}

class WordDocument extends Document {
    open() {
        console.log("Word 문서를 엽니다.");
    }
    
    save() {
        console.log("Word 문서를 저장합니다.");
    }
}

// 추상 팩토리
class DocumentFactory {
    createDocument() {
        throw new Error("createDocument 메서드를 구현해야 합니다.");
    }
    
    newDocument() {
        const document = this.createDocument();
        console.log("새 문서가 생성되었습니다.");
        return document;
    }
}

// 구체적인 팩토리들
class PDFFactory extends DocumentFactory {
    createDocument() {
        return new PDFDocument();
    }
}

class WordFactory extends DocumentFactory {
    createDocument() {
        return new WordDocument();
    }
}

// 사용 예시
const pdfFactory = new PDFFactory();
const wordFactory = new WordFactory();

const pdfDoc = pdfFactory.newDocument();
const wordDoc = wordFactory.newDocument();

pdfDoc.open();  // "PDF 문서를 엽니다."
wordDoc.save(); // "Word 문서를 저장합니다."
```

#### 실제 사용 사례

**UI 컴포넌트 생성**
```javascript
class Button {
    render() {
        throw new Error("render 메서드를 구현해야 합니다.");
    }
}

class PrimaryButton extends Button {
    render() {
        return '<button class="btn btn-primary">Primary Button</button>';
    }
}

class SecondaryButton extends Button {
    render() {
        return '<button class="btn btn-secondary">Secondary Button</button>';
    }
}

class DangerButton extends Button {
    render() {
        return '<button class="btn btn-danger">Danger Button</button>';
    }
}

class ButtonFactory {
    createButton(type) {
        switch(type) {
            case 'primary':
                return new PrimaryButton();
            case 'secondary':
                return new SecondaryButton();
            case 'danger':
                return new DangerButton();
            default:
                throw new Error('알 수 없는 버튼 타입입니다.');
        }
    }
}

// 사용 예시
const buttonFactory = new ButtonFactory();
const primaryBtn = buttonFactory.createButton('primary');
const dangerBtn = buttonFactory.createButton('danger');

console.log(primaryBtn.render());
console.log(dangerBtn.render());
```

#### 장단점
**장점**
- 유연성: 새로운 제품 타입 추가 용이
- 확장성: 기존 코드 수정 없이 새로운 팩토리 추가 가능
- 단일 책임: 각 팩토리는 특정 제품 생성에만 책임

**단점**
- 클래스 증가: 팩토리 클래스가 많아짐
- 복잡성: 패턴 적용으로 인한 코드 복잡성 증가

### 3. Abstract Factory Pattern (추상 팩토리 패턴)

#### 개념
관련된 여러 객체들을 함께 생성하는 패턴입니다. 서로 연관된 제품군을 일관성 있게 생성할 때 사용합니다.

#### 기본 구현
```javascript
// 추상 제품들
class Button {
    render() {
        throw new Error("render 메서드를 구현해야 합니다.");
    }
}

class TextBox {
    render() {
        throw new Error("render 메서드를 구현해야 합니다.");
    }
}

// Windows 제품군
class WindowsButton extends Button {
    render() {
        return '<button style="background: blue; color: white;">Windows Button</button>';
    }
}

class WindowsTextBox extends TextBox {
    render() {
        return '<input type="text" style="border: 2px solid blue;">';
    }
}

// Mac 제품군
class MacButton extends Button {
    render() {
        return '<button style="background: gray; color: black;">Mac Button</button>';
    }
}

class MacTextBox extends TextBox {
    render() {
        return '<input type="text" style="border: 2px solid gray;">';
    }
}

// 추상 팩토리
class GUIFactory {
    createButton() {
        throw new Error("createButton 메서드를 구현해야 합니다.");
    }
    
    createTextBox() {
        throw new Error("createTextBox 메서드를 구현해야 합니다.");
    }
}

// 구체적인 팩토리들
class WindowsFactory extends GUIFactory {
    createButton() {
        return new WindowsButton();
    }
    
    createTextBox() {
        return new WindowsTextBox();
    }
}

class MacFactory extends GUIFactory {
    createButton() {
        return new MacButton();
    }
    
    createTextBox() {
        return new MacTextBox();
    }
}

// 사용 예시
function createUI(factory) {
    const button = factory.createButton();
    const textBox = factory.createTextBox();
    
    console.log(button.render());
    console.log(textBox.render());
}

// 운영체제에 따라 적절한 팩토리 선택
const os = "Windows"; // 또는 "Mac"
const factory = os === "Windows" ? new WindowsFactory() : new MacFactory();
createUI(factory);
```

#### 실제 사용 사례

**데이터베이스 연결 관리**
```javascript
class DatabaseConnection {
    connect() {
        throw new Error("connect 메서드를 구현해야 합니다.");
    }
}

class QueryBuilder {
    build() {
        throw new Error("build 메서드를 구현해야 합니다.");
    }
}

// MySQL 제품군
class MySQLConnection extends DatabaseConnection {
    connect() {
        return "MySQL 데이터베이스에 연결됨";
    }
}

class MySQLQueryBuilder extends QueryBuilder {
    build() {
        return "SELECT * FROM users WHERE id = ?";
    }
}

// PostgreSQL 제품군
class PostgreSQLConnection extends DatabaseConnection {
    connect() {
        return "PostgreSQL 데이터베이스에 연결됨";
    }
}

class PostgreSQLQueryBuilder extends QueryBuilder {
    build() {
        return "SELECT * FROM users WHERE id = $1";
    }
}

class DatabaseFactory {
    createConnection() {
        throw new Error("createConnection 메서드를 구현해야 합니다.");
    }
    
    createQueryBuilder() {
        throw new Error("createQueryBuilder 메서드를 구현해야 합니다.");
    }
}

class MySQLFactory extends DatabaseFactory {
    createConnection() {
        return new MySQLConnection();
    }
    
    createQueryBuilder() {
        return new MySQLQueryBuilder();
    }
}

class PostgreSQLFactory extends DatabaseFactory {
    createConnection() {
        return new PostgreSQLConnection();
    }
    
    createQueryBuilder() {
        return new PostgreSQLQueryBuilder();
    }
}
```

#### 장단점
**장점**
- 일관성: 관련 제품들이 일관되게 생성됨
- 확장성: 새로운 제품군 추가 용이
- 결합도 감소: 구체적인 클래스와의 의존성 제거

**단점**
- 복잡성: 많은 인터페이스와 클래스 필요
- 확장 어려움: 새로운 제품 추가 시 모든 팩토리 수정 필요

### 4. Builder Pattern (빌더 패턴)

#### 개념
복잡한 객체의 생성 과정을 단계별로 분리하는 패턴입니다. 많은 매개변수를 가진 객체를 생성할 때 유용하며, 가독성과 유연성을 제공합니다.

#### 기본 구현
```javascript
class Computer {
    constructor(builder) {
        this.cpu = builder.cpu;
        this.ram = builder.ram;
        this.storage = builder.storage;
        this.gpu = builder.gpu;
        this.monitor = builder.monitor;
    }
    
    static get Builder() {
        return class Builder {
            constructor() {
                this.cpu = "기본 CPU";
                this.ram = "8GB";
                this.storage = "256GB SSD";
                this.gpu = "내장 그래픽";
                this.monitor = "기본 모니터";
            }
            
            setCpu(cpu) {
                this.cpu = cpu;
                return this;
            }
            
            setRam(ram) {
                this.ram = ram;
                return this;
            }
            
            setStorage(storage) {
                this.storage = storage;
                return this;
            }
            
            setGpu(gpu) {
                this.gpu = gpu;
                return this;
            }
            
            setMonitor(monitor) {
                this.monitor = monitor;
                return this;
            }
            
            build() {
                return new Computer(this);
            }
        };
    }
    
    getSpecs() {
        return {
            cpu: this.cpu,
            ram: this.ram,
            storage: this.storage,
            gpu: this.gpu,
            monitor: this.monitor
        };
    }
}

// 사용 예시
const gamingPC = new Computer.Builder()
    .setCpu("Intel i9-12900K")
    .setRam("32GB DDR5")
    .setStorage("2TB NVMe SSD")
    .setGpu("RTX 4080")
    .setMonitor("27인치 4K")
    .build();

const officePC = new Computer.Builder()
    .setCpu("Intel i5-12400")
    .setRam("16GB DDR4")
    .setStorage("512GB SSD")
    .build();

console.log(gamingPC.getSpecs());
console.log(officePC.getSpecs());
```

#### 실제 사용 사례

**사용자 프로필 생성**
```javascript
class UserProfile {
    constructor(builder) {
        this.name = builder.name;
        this.email = builder.email;
        this.age = builder.age;
        this.address = builder.address;
        this.phone = builder.phone;
        this.bio = builder.bio;
    }
    
    static get Builder() {
        return class Builder {
            constructor() {
                this.name = "";
                this.email = "";
                this.age = 0;
                this.address = "";
                this.phone = "";
                this.bio = "";
            }
            
            setName(name) {
                this.name = name;
                return this;
            }
            
            setEmail(email) {
                this.email = email;
                return this;
            }
            
            setAge(age) {
                this.age = age;
                return this;
            }
            
            setAddress(address) {
                this.address = address;
                return this;
            }
            
            setPhone(phone) {
                this.phone = phone;
                return this;
            }
            
            setBio(bio) {
                this.bio = bio;
                return this;
            }
            
            build() {
                // 필수 필드 검증
                if (!this.name || !this.email) {
                    throw new Error("이름과 이메일은 필수입니다.");
                }
                return new UserProfile(this);
            }
        };
    }
    
    toString() {
        return `UserProfile { name: ${this.name}, email: ${this.email}, age: ${this.age} }`;
    }
}

// 사용 예시
const user1 = new UserProfile.Builder()
    .setName("홍길동")
    .setEmail("hong@example.com")
    .setAge(30)
    .setAddress("서울시 강남구")
    .build();

const user2 = new UserProfile.Builder()
    .setName("김철수")
    .setEmail("kim@example.com")
    .build();

console.log(user1.toString());
console.log(user2.toString());
```

#### 장단점
**장점**
- 가독성: 메서드 체이닝으로 명확한 객체 생성
- 유연성: 선택적 매개변수 처리 용이
- 불변성: 객체 생성 후 변경 불가
- 검증: build() 메서드에서 유효성 검사 가능

**단점**
- 복잡성: 많은 메서드와 클래스 필요
- 오버헤드: 단순한 객체에는 과도한 복잡성

## 예시

### 1. 실제 프로젝트에서의 활용

#### 웹 애플리케이션의 컴포넌트 생성
```javascript
// 컴포넌트 팩토리
class ComponentFactory {
    createComponent(type, props) {
        switch(type) {
            case 'button':
                return new ButtonComponent(props);
            case 'input':
                return new InputComponent(props);
            case 'modal':
                return new ModalComponent(props);
            default:
                throw new Error(`알 수 없는 컴포넌트 타입: ${type}`);
        }
    }
}

// 사용 예시
const factory = new ComponentFactory();
const button = factory.createComponent('button', { text: '클릭', onClick: () => {} });
const input = factory.createComponent('input', { placeholder: '입력하세요' });
```

#### 설정 관리 시스템
```javascript
// 설정 싱글톤
class ConfigManager {
    constructor() {
        if (ConfigManager.instance) {
            return ConfigManager.instance;
        }
        
        this.config = {
            apiUrl: process.env.API_URL || 'http://localhost:3000',
            timeout: parseInt(process.env.TIMEOUT) || 5000,
            retryCount: parseInt(process.env.RETRY_COUNT) || 3
        };
        
        ConfigManager.instance = this;
    }
    
    get(key) {
        return this.config[key];
    }
    
    set(key, value) {
        this.config[key] = value;
    }
    
    getAll() {
        return { ...this.config };
    }
}

// 전역 설정 사용
const config = new ConfigManager();
console.log(config.get('apiUrl'));
```

### 2. 패턴 조합 활용

#### 팩토리와 빌더 패턴 조합
```javascript
class UserBuilder {
    constructor() {
        this.user = {};
    }
    
    setName(name) {
        this.user.name = name;
        return this;
    }
    
    setEmail(email) {
        this.user.email = email;
        return this;
    }
    
    setRole(role) {
        this.user.role = role;
        return this;
    }
    
    build() {
        return new User(this.user);
    }
}

class UserFactory {
    createAdmin() {
        return new UserBuilder()
            .setRole('admin')
            .build();
    }
    
    createUser() {
        return new UserBuilder()
            .setRole('user')
            .build();
    }
}

// 사용 예시
const userFactory = new UserFactory();
const admin = userFactory.createAdmin().setName('관리자').setEmail('admin@example.com');
const user = userFactory.createUser().setName('사용자').setEmail('user@example.com');
```

## 운영 팁

### 1. 패턴 선택 가이드

| 상황 | 권장 패턴 | 이유 |
|------|-----------|------|
| 단일 인스턴스 필요 | Singleton | 전역 상태 관리 |
| 객체 생성 로직 복잡 | Factory Method | 생성 로직 캡슐화 |
| 관련 객체군 생성 | Abstract Factory | 일관성 보장 |
| 많은 매개변수 | Builder | 가독성과 유연성 |
| 런타임 타입 결정 | Factory Method | 동적 객체 생성 |

### 2. 성능 고려사항

#### 메모리 사용량
- Singleton: 메모리 효율적이지만 전역 상태 관리 필요
- Factory: 객체 생성 오버헤드 있지만 유연성 제공
- Builder: 메서드 체이닝으로 인한 임시 객체 생성

#### 실행 속도
- Singleton: 빠른 접근, 한 번만 초기화
- Factory: 런타임 타입 검사로 인한 약간의 오버헤드
- Builder: 단계별 검증으로 인한 추가 처리 시간

### 3. 테스트 전략

#### 단위 테스트
```javascript
// Factory 테스트
describe('ButtonFactory', () => {
    it('should create primary button', () => {
        const factory = new ButtonFactory();
        const button = factory.createButton('primary');
        expect(button).toBeInstanceOf(PrimaryButton);
    });
});

// Singleton 테스트
describe('Logger', () => {
    beforeEach(() => {
        // 테스트 간 격리를 위해 인스턴스 초기화
        Logger.instance = null;
    });
    
    it('should return same instance', () => {
        const logger1 = new Logger();
        const logger2 = new Logger();
        expect(logger1).toBe(logger2);
    });
});
```

## 참고

### 패턴 간 비교

| 패턴 | 목적 | 복잡도 | 유연성 | 재사용성 |
|------|------|--------|--------|----------|
| **Singleton** | 단일 인스턴스 보장 | 낮음 | 낮음 | 높음 |
| **Factory Method** | 객체 생성 캡슐화 | 중간 | 높음 | 높음 |
| **Abstract Factory** | 관련 객체군 생성 | 높음 | 높음 | 중간 |
| **Builder** | 복잡한 객체 생성 | 중간 | 높음 | 중간 |

### 모범 사례

1. **적절한 패턴 선택**: 문제에 맞는 패턴 선택
2. **과도한 사용 방지**: 단순한 경우 패턴 사용 자제
3. **일관성 유지**: 프로젝트 내 동일한 패턴 사용
4. **문서화**: 패턴 사용 의도와 방법 문서화

### 결론
생성 패턴은 객체 생성의 복잡성을 관리하고 코드의 유지보수성을 향상시키는 강력한 도구입니다. 각 패턴의 특징과 사용 시기를 이해하여 적절한 패턴을 선택하는 것이 중요합니다. 실제 프로젝트에서는 여러 패턴을 조합하여 사용하는 경우가 많으며, 성능과 유지보수성을 고려한 균형잡힌 설계가 필요합니다.
