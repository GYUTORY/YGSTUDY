---
title: 모노레포(Monorepo) 완벽 가이드
tags: [monorepo, architecture, devops, repository, workspace]
updated: 2024-12-19
---

# 모노레포(Monorepo) 완벽 가이드

## 배경

### 모노레포의 필요성
모노레포(Monorepo)는 여러 개의 프로젝트를 하나의 저장소(Repository)에 통합하여 관리하는 소프트웨어 개발 방식입니다. 대규모 소프트웨어 개발 환경에서 다양한 코드베이스를 하나의 저장소로 통합하여, 협업과 관리 효율성을 증대시키는 데 사용됩니다.

### 기본 개념
- **워크스페이스**: 모노레포 내의 개별 프로젝트
- **패키지**: 재사용 가능한 코드 단위
- **의존성 그래프**: 패키지 간의 의존 관계
- **빌드 캐시**: 변경된 패키지만 빌드하는 최적화
- **공유 설정**: 린트, 테스트, 빌드 설정의 통합

## 핵심

### 1. 모노레포 vs 멀티레포 비교

#### 아키텍처 비교
| 측면 | 모노레포 | 멀티레포 |
|------|----------|----------|
| **저장소 구조** | 단일 저장소 | 다중 저장소 |
| **코드 공유** | 쉬움 | 어려움 |
| **의존성 관리** | 중앙화 | 분산화 |
| **버전 관리** | 통합 | 독립적 |
| **빌드 시스템** | 통합 | 분산 |
| **팀 협업** | 높음 | 제한적 |
| **복잡성** | 높음 | 낮음 |

#### 모노레포 구조 예시
```
monorepo/
├── packages/
│   ├── shared/
│   │   ├── utils/
│   │   ├── components/
│   │   └── types/
│   ├── frontend/
│   │   ├── web-app/
│   │   └── mobile-app/
│   ├── backend/
│   │   ├── api-service/
│   │   ├── auth-service/
│   │   └── payment-service/
│   └── tools/
│       ├── eslint-config/
│       └── typescript-config/
├── apps/
│   ├── admin-dashboard/
│   └── user-portal/
├── package.json
├── lerna.json
├── nx.json
└── tsconfig.json
```

### 2. 모노레포 도구

#### Lerna (JavaScript/TypeScript)
```json
// lerna.json 설정
{
  "version": "independent",
  "npmClient": "yarn",
  "useWorkspaces": true,
  "packages": [
    "packages/*",
    "apps/*"
  ],
  "command": {
    "publish": {
      "conventionalCommits": true,
      "message": "chore(release): publish"
    }
  }
}
```

```json
// package.json (루트)
{
  "name": "my-monorepo",
  "private": true,
  "workspaces": [
    "packages/*",
    "apps/*"
  ],
  "scripts": {
    "build": "lerna run build",
    "test": "lerna run test",
    "lint": "lerna run lint",
    "clean": "lerna clean"
  },
  "devDependencies": {
    "lerna": "^4.0.0"
  }
}
```

#### Nx (다중 언어 지원)
```json
// nx.json 설정
{
  "npmScope": "myorg",
  "affected": {
    "defaultBase": "main"
  },
  "tasksRunnerOptions": {
    "default": {
      "runner": "nx/tasks-runners/default",
      "options": {
        "cacheableOperations": ["build", "test", "lint"]
      }
    }
  },
  "targetDefaults": {
    "build": {
      "dependsOn": ["^build"]
    },
    "test": {
      "dependsOn": ["^build"]
    }
  }
}
```

```json
// package.json (워크스페이스)
{
  "name": "@myorg/shared-utils",
  "version": "1.0.0",
  "scripts": {
    "build": "tsc",
    "test": "jest",
    "lint": "eslint src"
  },
  "dependencies": {
    "@myorg/types": "workspace:*"
  }
}
```

#### Yarn Workspaces
```json
// package.json (루트)
{
  "name": "my-monorepo",
  "private": true,
  "workspaces": [
    "packages/*",
    "apps/*"
  ],
  "scripts": {
    "build": "yarn workspaces run build",
    "test": "yarn workspaces run test",
    "lint": "yarn workspaces run lint"
  }
}
```

```json
// packages/shared/package.json
{
  "name": "@myorg/shared",
  "version": "1.0.0",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "scripts": {
    "build": "tsc",
    "dev": "tsc --watch"
  }
}
```

```json
// apps/web-app/package.json
{
  "name": "@myorg/web-app",
  "version": "1.0.0",
  "dependencies": {
    "@myorg/shared": "workspace:*",
    "react": "^18.0.0"
  },
  "scripts": {
    "dev": "vite",
    "build": "vite build"
  }
}
```

### 3. 의존성 관리

#### 워크스페이스 의존성
```javascript
// 패키지 간 의존성 설정
// packages/ui/package.json
{
  "name": "@myorg/ui",
  "version": "1.0.0",
  "dependencies": {
    "@myorg/shared": "workspace:*"
  }
}

// apps/admin/package.json
{
  "name": "@myorg/admin",
  "version": "1.0.0",
  "dependencies": {
    "@myorg/ui": "workspace:*",
    "@myorg/shared": "workspace:*"
  }
}
```

#### 의존성 그래프 관리
```javascript
// nx.json에서 의존성 그래프 설정
{
  "targetDefaults": {
    "build": {
      "dependsOn": ["^build"]
    },
    "test": {
      "dependsOn": ["^build"]
    }
  }
}

// 빌드 순서 자동 관리
// 1. shared 패키지 빌드
// 2. ui 패키지 빌드 (shared 의존)
// 3. admin 앱 빌드 (ui, shared 의존)
```

## 예시

### 1. 실제 사용 사례

#### React + Node.js 모노레포
```javascript
// packages/shared/types/index.ts
export interface User {
  id: string;
  name: string;
  email: string;
}

export interface ApiResponse<T> {
  data: T;
  message: string;
  success: boolean;
}

// packages/shared/utils/index.ts
export function formatDate(date: Date): string {
  return date.toISOString().split('T')[0];
}

export function validateEmail(email: string): boolean {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
}
```

```javascript
// packages/frontend/components/UserCard.tsx
import React from 'react';
import { User, formatDate } from '@myorg/shared';

interface UserCardProps {
  user: User;
}

export const UserCard: React.FC<UserCardProps> = ({ user }) => {
  return (
    <div className="user-card">
      <h3>{user.name}</h3>
      <p>{user.email}</p>
      <small>Created: {formatDate(new Date())}</small>
    </div>
  );
};
```

```javascript
// packages/backend/services/userService.ts
import { User, ApiResponse } from '@myorg/shared';

export class UserService {
  async getUser(id: string): Promise<ApiResponse<User>> {
    // 실제 데이터베이스 조회 로직
    const user: User = {
      id,
      name: 'John Doe',
      email: 'john@example.com'
    };

    return {
      data: user,
      message: 'User retrieved successfully',
      success: true
    };
  }
}
```

### 2. 고급 패턴

#### 조건부 빌드
```javascript
// nx.json에서 조건부 빌드 설정
{
  "targetDefaults": {
    "build": {
      "dependsOn": ["^build"],
      "inputs": ["default", "^default"]
    }
  },
  "affected": {
    "defaultBase": "main"
  }
}

// 변경된 패키지만 빌드
// nx affected:build --base=main --head=HEAD
```

#### 공유 설정
```javascript
// packages/eslint-config/index.js
module.exports = {
  extends: [
    'eslint:recommended',
    '@typescript-eslint/recommended'
  ],
  rules: {
    'no-console': 'warn',
    'prefer-const': 'error'
  }
};

// packages/typescript-config/base.json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  }
}
```

## 운영 팁

### 1. 성능 최적화

#### 빌드 캐싱
```javascript
// nx.json에서 캐싱 설정
{
  "tasksRunnerOptions": {
    "default": {
      "runner": "nx/tasks-runners/default",
      "options": {
        "cacheableOperations": ["build", "test", "lint"],
        "parallel": 3
      }
    }
  }
}

// 캐시 활용
// nx run-many --target=build --all --parallel=3
```

#### 의존성 최적화
```javascript
// package.json에서 peer dependencies 관리
{
  "name": "@myorg/ui",
  "peerDependencies": {
    "react": "^18.0.0",
    "react-dom": "^18.0.0"
  },
  "devDependencies": {
    "react": "^18.0.0",
    "react-dom": "^18.0.0"
  }
}
```

### 2. 버전 관리

#### 독립적 버전 관리
```javascript
// lerna.json에서 독립적 버전 관리
{
  "version": "independent",
  "command": {
    "publish": {
      "conventionalCommits": true,
      "message": "chore(release): publish"
    }
  }
}

// 패키지별 버전 관리
// packages/shared/package.json
{
  "name": "@myorg/shared",
  "version": "1.2.0"
}

// packages/ui/package.json
{
  "name": "@myorg/ui",
  "version": "2.1.0"
}
```

#### 통합 버전 관리
```javascript
// lerna.json에서 통합 버전 관리
{
  "version": "2.0.0",
  "command": {
    "publish": {
      "conventionalCommits": true
    }
  }
}

// 모든 패키지가 동일한 버전 사용
```

### 3. CI/CD 파이프라인

#### GitHub Actions 예시
```yaml
# .github/workflows/ci.yml
name: CI

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'yarn'
    
    - name: Install dependencies
      run: yarn install --frozen-lockfile
    
    - name: Lint
      run: yarn lint
    
    - name: Test
      run: yarn test
    
    - name: Build
      run: yarn build
```

## 참고

### 모노레포 vs 멀티레포 비교

| 측면 | 모노레포 | 멀티레포 |
|------|----------|----------|
| **코드 공유** | 쉬움 | 어려움 |
| **의존성 관리** | 중앙화 | 분산화 |
| **버전 관리** | 통합/독립 | 독립적 |
| **빌드 시스템** | 통합 | 분산 |
| **팀 협업** | 높음 | 제한적 |
| **복잡성** | 높음 | 낮음 |
| **확장성** | 제한적 | 우수 |

### 모노레포 도입 단계

| 단계 | 내용 | 목표 |
|------|------|------|
| **1단계** | 기존 프로젝트 분석 | 통합 대상 식별 |
| **2단계** | 도구 선택 및 설정 | Lerna, Nx, Yarn Workspaces |
| **3단계** | 패키지 구조 설계 | 의존성 관계 정의 |
| **4단계** | 공유 설정 통합 | ESLint, TypeScript, 빌드 설정 |
| **5단계** | CI/CD 파이프라인 구축 | 자동화된 빌드 및 배포 |

### 결론
모노레포는 코드 공유와 의존성 관리의 효율성을 크게 향상시킬 수 있는 강력한 개발 방식입니다. 적절한 도구 선택과 구조 설계를 통해 팀 협업과 개발 생산성을 향상시킬 수 있습니다. 다만 복잡성 관리와 성능 최적화에 주의를 기울여야 합니다.





