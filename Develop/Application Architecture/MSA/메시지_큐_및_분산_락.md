---
title: 메시지 큐 및 분산 락
tags: [backend, messaging, rabbitmq, kafka, sqs, mysql, innodb, lock, deadlock, redis, distributed-lock]
updated: 2026-01-24
---

# 메시지 큐 및 분산 락

## 개요

이 문서는 메시지 큐와 락을 함께 다룬다. 두 개념은 서로 다른 문제를 해결하지만, 실무에서는 함께 사용되는 경우가 많다.

**메시지 큐의 역할:**
- 비동기 처리 파이프라인 구축
- 처리량 확보와 장애 격리
- 시스템 간 느슨한 결합

**락의 역할:**
- 동시성 충돌 방지
- 데이터 정합성 보장
- 리소스 접근 제어

**두 개념의 관계:**
메시지 큐를 사용하면 여러 소비자가 동시에 메시지를 처리한다. 이때 같은 데이터를 수정하면 동시성 충돌이 발생한다. 락은 이런 충돌을 방지한다.

## 목차

1. 메시지 큐 기초
2. 메시지 큐 운영
3. 데이터베이스 락
4. 분산 락
5. 메시지 큐와 락의 통합 사용

## 메시지 큐 기초

### 메시지 큐를 사용하는 이유

동기 호출 체인이 길어질수록 장애 전파가 빨라진다. 한 서비스가 느려지면 전체 체인이 느려진다.

**메시지 큐의 효과:**
- 호출자와 처리자 분리: 호출자는 즉시 응답하고, 처리는 백그라운드에서 수행
- 처리 지연 흡수: 큐가 버퍼 역할을 해 트래픽 급증 시에도 안정적
- 장애 격리: 한 소비자가 장애가 나도 다른 소비자는 계속 처리
- 확장성: 소비자를 늘려 처리량을 확보

**실무에서 주의할 점:**
메시지 큐를 도입하면 "전달 보장"과 "중복 처리" 문제가 생긴다. 이 두 가지를 해결하는 방법을 먼저 정해야 한다.

### 전달 보장 모델

메시지 큐는 전달 보장 수준에 따라 세 가지로 나뉜다.

**at-most-once (최대 1회 전달):**
- 중복은 없지만 유실 가능성이 있다
- 재시도 없이 한 번만 전송
- 실무에서 거의 사용하지 않는다

**at-least-once (최소 1회 전달):**
- 유실은 줄이지만 중복이 생길 수 있다
- 재시도로 유실을 방지하지만 중복 전달 가능
- 실무에서 가장 많이 사용한다
- 소비자에서 멱등성 보장이 필수다

**exactly-once (정확히 1회 전달):**
- 중복도 없고 유실도 없다
- 시스템 전체에서 보장하려면 제약이 크다
- Kafka의 트랜잭션 기능, SQS FIFO 큐 등이 있지만 제약이 있다
- 실무에서는 at-least-once + 멱등성 조합을 더 많이 사용한다

**실무 선택:**
운영에서는 at-least-once를 전제로 설계한다. 중복 처리를 소비자 쪽에서 막는 형태로 마감한다.

### 중복 처리의 원인

중복은 여러 원인으로 발생한다. 원인을 이해해야 해결 방법을 선택할 수 있다.

**소비자 장애:**
- 소비자가 처리 완료 전에 죽어서 ack를 못 보낸다
- 메시지가 다시 큐에 나타나 다른 소비자가 처리한다
- 실제로는 첫 번째 소비자가 처리했을 수 있다

**타임아웃 설정 문제:**
- 처리 시간보다 visibility timeout(또는 ack timeout)이 짧다
- 처리 중 타임아웃이 지나 메시지가 다시 보인다
- 다른 소비자가 같은 메시지를 처리한다

**네트워크 문제:**
- 네트워크 단절로 ack가 유실된다
- 실제 처리는 끝났지만 큐는 처리되지 않은 것으로 본다
- 메시지가 재전달된다

**퍼블리셔 재시도:**
- 퍼블리셔가 재시도 로직을 메시지 ID 없이 동작시킨다
- 같은 메시지가 여러 번 전송된다

**중복 처리 방지:**
중복을 허용하지 않는 작업(재고 차감, 포인트 적립)은 멱등성을 강제해야 한다.

### 멱등성 보장 방법

멱등성은 같은 작업을 여러 번 수행해도 결과가 같아야 한다는 성질이다.

**멱등성 키 생성 방법:**

**1. 비즈니스 키 기반:**
- `orderId + eventType` 조합
- 주문 생성 이벤트는 `order-123-create` 같은 키 사용
- 간단하지만 이벤트 타입이 많으면 관리가 복잡해진다

**2. 이벤트 ID 기반:**
- 메시지에 고유한 `eventId`를 넣는다
- 소비자가 처리 기록을 저장한다
- 이벤트 ID는 UUID나 타임스탬프 기반 시퀀스 사용

**3. DB 유니크 인덱스 기반:**
- 처리 기록 테이블에 `event_id` 유니크 인덱스를 건다
- 같은 이벤트를 다시 처리하려고 하면 유니크 제약으로 실패한다
- 가장 단순하고 확실한 방법이다

**처리 기록 테이블 설계:**
- `event_id` 컬럼에 유니크 인덱스
- `processed_at` 컬럼으로 처리 시간 기록
- TTL 설정으로 오래된 기록 자동 삭제

**TTL의 중요성:**
처리 기록 테이블은 반드시 TTL이 필요하다. TTL이 없으면 몇 달 지나서 테이블이 병목이 된다. 멱등성 키는 보통 며칠에서 몇 주면 충분하다.

### 순서 보장

순서 보장은 생각보다 비용이 크다.

**순서 보장의 비용:**
- FIFO 큐를 쓰면 처리량이 떨어진다
- 파티션 키(또는 메시지 그룹) 설계가 틀리면 한 키에 몰려 큐가 막힌다
- 순서가 필요한 범위를 과하게 잡으면 병렬성이 사라진다

**순서 보장 범위:**
실무에서는 "전체 순서"가 아니라 "주문 단위 순서", "객실 단위 순서"처럼 범위를 줄여 잡는다.

**예시:**
- 주문 처리: 주문 ID별로 순서 보장, 다른 주문은 병렬 처리
- 객실 예약: 객실 ID별로 순서 보장, 다른 객실은 병렬 처리

**파티션 키 설계:**
- 파티션 키가 잘못되면 한 파티션에 트래픽이 몰린다
- 파티션 키는 가능한 한 균등하게 분산되어야 한다
- 핫키가 생기면 해당 파티션만 병목이 된다

## 메시지 큐 운영

### 재시도 전략

재시도는 두 레이어에서 발생한다. 둘을 같이 쓰면 재시도 폭발이 나기 쉽다.

**큐 레벨 재시도:**
- 소비 실패 시 큐가 자동으로 재전달한다
- 설정 가능한 재시도 횟수와 지연 시간
- 모든 메시지 큐가 지원한다

**애플리케이션 레벨 재시도:**
- 외부 API 호출 실패 시 애플리케이션에서 재시도한다
- 지수 백오프 등 세밀한 제어 가능
- 비즈니스 로직에 따라 재시도 여부 결정

**재시도 폭발 방지:**
애플리케이션 레벨 재시도를 넣는다면 큐 레벨 재시도 횟수는 줄이는 편이 낫다. 둘 다 재시도하면 재시도 횟수가 곱해진다.

**재시도 전략 예시:**
- 큐 레벨: 최대 3회 재시도
- 애플리케이션 레벨: 외부 API 호출 실패 시 2회 재시도
- 총 최대 9회 시도 가능 (너무 많음)
- 큐 레벨을 1회로 줄이면 총 3회 시도 (적절함)

### Dead Letter Queue (DLQ)

DLQ는 처리에 실패한 메시지를 격리하는 특별한 큐다.

**DLQ의 역할:**
- 무한 재시도 방지
- 실패한 메시지 분석
- 수동 재처리

**DLQ 운영의 문제점:**
DLQ는 "나중에 보자"로 끝나는 경우가 많다. DLQ가 쌓이기 시작하면 이미 데이터 정합성이 깨졌을 가능성이 크다.

**실패 원인 분류:**
DLQ 운영에서 중요한 것은 "왜 실패했는지 분류"다.

**1. 포맷 불일치:**
- 소비자 배포 순서 문제: 새 메시지 형식을 먼저 배포
- 스키마 버전 처리 누락: 이전 버전 메시지 처리 불가

**2. 외부 의존성 장애:**
- 결제 서비스 장애
- 이메일 서비스 장애
- 문자 발송 서비스 장애

**3. 데이터 조건 실패:**
- 이미 취소된 주문을 다시 처리
- 존재하지 않는 사용자에게 알림 발송
- 만료된 쿠폰 사용

**4. 리소스 병목:**
- DB 락 대기
- 커넥션 풀 고갈
- 메모리 부족

**DLQ 활용:**
DLQ는 "재처리 버튼"이 아니라 "실패 원인 분석 버퍼"로 봐야 한다. 실패 원인을 분석하고 해결한 후 재처리한다.

### 소비자 병렬성과 백프레셔

소비자는 보통 "스레드/프로세스 늘리면 된다"로 시작한다. 운영에서는 다른 병목이 생긴다.

**병목 지점:**

**1. DB 커넥션 수:**
- 커넥션 풀 크기가 제한적이다
- 소비자를 너무 늘리면 커넥션 부족으로 대기한다
- 커넥션 풀 크기를 먼저 확인한다

**2. 외부 API rate limit:**
- 외부 API가 초당 요청 수를 제한한다
- 소비자를 늘려도 rate limit에 걸린다
- 배치 처리나 요청 큐잉이 필요하다

**3. IO 바운드 작업:**
- CPU보다 IO가 지배적인 작업에서 동시성이 과다하다
- 디스크나 네트워크 IO가 병목이 된다
- 동시성을 줄이는 편이 낫다

**4. 핫키 락 경합:**
- 같은 핫키에 대한 락 경합이 발생한다
- 소비자를 늘려도 락 대기만 늘어난다
- 핫키를 분산하거나 순서를 보장해야 한다

**prefetch/batch size:**
prefetch나 batch size를 키우면 처리량이 늘기도 하지만, 실패 시 재처리 단위가 커진다. 배치 단위가 커질수록 "부분 실패" 처리가 필요해진다.

**백프레셔:**
큐 깊이가 증가하면 처리 속도를 높이고, 감소하면 처리 속도를 낮춘다. 큐 깊이에 따라 동적으로 조절한다.

### 메시지 큐 제품별 운영 포인트

**RabbitMQ:**
- 라우팅과 큐 조합이 편하다
- 운영 포인트: ack 관리, prefetch 설정, 소비자 장애 시 재전달, TTL/DLX 구성
- ack를 제대로 하지 않으면 메시지가 유실되거나 중복된다

**Kafka:**
- 로그 스트림에 가깝다
- 리플레이가 자연스럽고, 소비자 그룹 기준으로 스케일된다
- 운영 포인트: 파티션 키 설계, consumer lag 모니터링, 리밸런싱 시 처리 지연, 오프셋 커밋 타이밍
- 파티션 키가 잘못되면 한 파티션에 트래픽이 몰린다

**SQS:**
- 관리 부담이 적다
- 운영 포인트: visibility timeout 설정, DLQ maxReceiveCount, 배치 처리, oldest message age 모니터링
- visibility timeout이 짧으면 중복 처리가 발생한다

### 메시지 큐 관측 포인트

**주요 메트릭:**

**큐 길이:**
- 대기 중인 메시지 수
- 계속 증가하면 소비자 처리 속도가 느린 것이다

**oldest message age:**
- 가장 오래된 메시지의 대기 시간
- 큐 길이만 보고 판단하면 늦다
- oldest message age가 증가하는 순간부터 사용자 영향이 시작될 수 있다

**소비 처리량:**
- 초당 처리 건수
- 처리량이 떨어지면 병목이 생긴 것이다

**DLQ 유입률:**
- DLQ로 이동하는 메시지 비율
- 증가하면 처리 로직에 문제가 있는 것이다

**소비자 에러율:**
- 소비자가 처리 실패하는 비율
- 증가하면 외부 의존성이나 데이터 문제일 수 있다

**알람 설정:**
- 큐 길이가 임계값을 초과하면 알람
- oldest message age가 증가하면 알람
- DLQ 유입률이 증가하면 알람

## 데이터베이스 락

### 락의 기본 개념

데이터베이스 락은 동시에 같은 데이터를 수정하는 것을 방지한다. 여러 트랜잭션이 같은 행을 수정하려고 하면 락 경합이 발생한다.

**락의 필요성:**
- 동시 수정 충돌 방지
- 데이터 정합성 보장
- 트랜잭션 격리 수준 보장

**락의 종류:**
- 공유 락(Shared Lock): 읽기 락, 다른 트랜잭션의 읽기는 허용하지만 수정은 막는다
- 배타 락(Exclusive Lock): 쓰기 락, 다른 트랜잭션의 읽기와 수정을 모두 막는다

### SELECT에서 락이 생기는 조건

읽기라고 해서 락이 없는 건 아니다. 명시적으로 락을 걸 수 있다.

**SELECT ... FOR UPDATE:**
- 배타 락을 잡고 수정 가능 상태로 만든다
- 다른 트랜잭션이 해당 행을 수정할 수 없다
- UPDATE 전에 현재 값을 확인하고 수정할 때 사용한다

**SELECT ... LOCK IN SHARE MODE (MySQL 8에서는 FOR SHARE):**
- 공유 락을 잡고 다른 트랜잭션의 수정을 막는다
- 읽기만 하고 수정하지 않을 때 사용한다
- 다른 트랜잭션도 읽기는 가능하다

**주의사항:**
핫 테이블에서 이 구문이 늘어나면 "CPU는 멀쩡한데 TPS가 갑자기 죽는" 상황이 자주 난다. 락 대기로 인한 지연이다.

### InnoDB에서 락이 커지는 패턴

운영에서 자주 보는 케이스다.

**1. 인덱스를 못 타는 조건으로 FOR UPDATE를 걸었을 때:**
- 행 락이라고 생각하고 썼는데, 실제로는 범위 락(갭/넥스트키)이 넓게 잡힌다
- 인덱스가 없으면 테이블 스캔이 발생하고 락 범위가 커진다
- 인덱스를 추가하거나 쿼리 조건을 수정해야 한다

**2. 같은 테이블을 다른 순서로 락 잡는 트랜잭션이 섞였을 때:**
- 데드락이 터진다
- 트랜잭션 A가 행 1을 락 잡고 행 2를 기다리고, 트랜잭션 B가 행 2를 락 잡고 행 1을 기다린다
- 항상 같은 순서로 락을 잡아야 한다

**3. 트랜잭션이 길어졌을 때:**
- 락 유지 시간이 길어지고 대기열이 생긴다
- "조회 후 외부 API 호출" 같은 흐름이 대표적이다
- 외부 호출은 트랜잭션 밖에서 하거나 타임아웃을 짧게 설정한다

### 격리 수준과 락의 관계

MySQL InnoDB 기준으로 자주 부딪히는 부분만 적는다.

**READ COMMITTED:**
- 범위 락이 줄어드는 방향이라 경합이 완화되는 경우가 있다
- 같은 트랜잭션에서 같은 SELECT를 해도 결과가 바뀔 수 있어, 로직이 그걸 전제로 짜여 있어야 한다
- 팬텀 리드가 발생할 수 있다

**REPEATABLE READ (MySQL 기본값):**
- 넥스트키 락과 맞물려 락 범위가 커지는 케이스가 난다
- "존재 여부 확인 후 INSERT" 패턴에서 갭 락 때문에 막히는 상황을 자주 본다
- 팬텀 리드는 방지하지만 락 범위가 넓어진다

**SERIALIZABLE:**
- 성능 희생이 크다
- 운영에서 기본값으로 쓰는 경우는 드물다

**격리 수준 조정:**
격리 수준 조정은 최후 수단에 가깝다. 대부분은 쿼리 조건과 인덱스, 트랜잭션 길이 문제에서 출발한다.

### 데드락

데드락은 "둘 다 락을 잡고 있는데 서로가 가진 락을 기다린다" 상태다. InnoDB는 데드락을 감지하면 한 트랜잭션을 죽인다.

**데드락의 특징:**
운영에서 중요한 건 "데드락은 에러로 끝나지 않는다"다. 죽은 트랜잭션이 실패한 비즈니스 작업을 재시도해야 한다.

**데드락이 자주 생기는 구조:**
- 동일 테이블 여러 행을 업데이트
- 업데이트 순서가 요청마다 다름
- 트랜잭션이 길어서 락 유지가 오래감

**해결 방법:**
해결은 "순서 통일"이 제일 많이 먹힌다.

- 항상 작은 ID부터 락을 잡는다
- 정렬 기준이 하나로 고정되어야 한다
- 복합 키면 정렬 키도 같이 고정해야 한다

**예시:**
- 주문 ID가 100, 200인 행을 업데이트할 때
- 항상 작은 ID(100)부터 락을 잡는다
- 모든 트랜잭션이 같은 순서를 따르면 데드락이 발생하지 않는다

### 락 대기 시간과 타임아웃

`innodb_lock_wait_timeout`은 "락 대기 최대 시간"이다. 이 값이 길면 장애가 오래 끌고, 짧으면 실패가 늘어난다.

**타임아웃 설정:**
운영에서는 "짧게 실패시키고 애플리케이션에서 재시도"가 더 관리 가능한 경우가 많다. 단, 재시도가 무조건 좋은 건 아니다. 같은 락 경합을 더 키울 수 있다.

**NOWAIT와 SKIP LOCKED:**
`NOWAIT`, `SKIP LOCKED`는 상황을 명확히 나눈다.

**NOWAIT:**
- 락을 못 잡으면 즉시 실패한다
- 호출자가 다른 흐름을 선택해야 한다
- 락 경합이 예상될 때 사용한다

**SKIP LOCKED:**
- 락 걸린 행을 건너뛴다
- 워커/배치에서 자주 쓴다
- 처리 가능한 행만 처리한다

**SKIP LOCKED의 제약:**
`SKIP LOCKED`는 "정확히 모든 데이터를 한 번씩 처리해야 한다"에는 맞지 않다. 처리 누락을 별도로 보정하는 설계가 필요하다.

### 락 성능 문제를 만드는 대표 패턴

**핫 로우:**
- 한 행을 모든 요청이 건드리는 구조(시퀀스 테이블, 단일 카운터)
- 락 경합이 집중된다
- 핫 로우는 락이 아니라 "구조 변경"이 필요하다
- 샤딩 카운터, 적재 후 집계, 메시지로 직렬화 같은 형태가 더 현실적이다

**테이블 스캔 + FOR UPDATE:**
- 인덱스 미스로 테이블 전체를 스캔한다
- 락 범위가 넓어진다
- 인덱스를 추가하거나 쿼리를 수정해야 한다

**긴 트랜잭션:**
- 조회 후 외부 호출, 파일 IO, 대기
- 락 유지 시간이 길어진다
- 외부 호출은 트랜잭션 밖에서 하거나 타임아웃을 짧게 설정한다

**배치 업데이트:**
- 너무 큰 단위로 한 번에 변경한다
- 락 유지 시간이 길어진다
- 작은 단위로 나눠 처리한다

### DB 락 관측 포인트

**주요 메트릭:**

**락 대기 시간:**
- 락을 기다리는 시간
- 증가하면 락 경합이 심한 것이다

**데드락 발생 횟수:**
- 데드락이 발생하는 빈도
- 증가하면 락 순서 문제일 수 있다

**슬로우 쿼리:**
- `FOR UPDATE` 등이 포함된 쿼리
- 락 대기로 인한 지연일 수 있다

**커넥션 풀 대기:**
- 커넥션을 기다리는 시간
- 락 대기로 커넥션이 오래 유지될 수 있다

**모니터링 방법:**
MySQL 기준으로는 `SHOW ENGINE INNODB STATUS`가 자주 쓰인다. deadlock 로그는 보통 여기에 난다. 운영 환경에서는 수집 주기와 보관이 필요하다.

## 분산 락

### 분산 락이 필요한 경우

분산 락은 여러 서버나 프로세스가 같은 자원에 접근할 때 사용한다. 다음 조건이 동시에 성립할 때만 분산 락을 본다.

**필요 조건:**
- 여러 서버가 같은 자원을 수정한다
- 자원을 한 번에 하나만 처리해야 한다
- DB 트랜잭션만으로 해결이 안 된다

**사용 예시:**
- 같은 주문을 두 워커가 동시에 처리할 수 있는 구조
- 스케줄러가 여러 인스턴스에서 동시에 돌 수 있는 구조
- 외부 API가 "동일 키 중복 호출 금지" 제약이 강함

**분산 락이 필요 없는 경우:**
반대로, DB에서 유니크 제약이나 조건부 업데이트로 해결되면 분산 락은 안 쓰는 편이 낫다. DB 트랜잭션이 더 단순하고 확실하다.

### Redis 기반 락

가장 흔한 구현은 `SET key value NX PX ttl`이다. 여기서 사고가 많이 난다.

**구현 방식:**
- `NX`: 키가 없을 때만 설정 (Not eXists)
- `PX`: 밀리초 단위 TTL 설정
- 키가 락을 나타내고, 값은 락을 잡은 프로세스 식별자

**TTL 설정의 딜레마:**
- TTL이 짧으면 작업 중 락이 풀리고 다른 프로세스가 들어온다
- TTL이 길면 장애 시 자원이 오래 막힌다
- 작업 시간이 들쭉날쭉하면 TTL 설정이 애매해진다
- GC pause, 이벤트 루프 stall 때문에 갱신이 늦어지는 케이스가 난다

**락 해제:**
락 해제는 반드시 "내가 잡은 락만 해제"해야 한다. 값 비교 후 삭제가 필요하고, Lua 스크립트로 원자 처리한다. 잘못된 프로세스가 락을 해제하면 다른 프로세스의 락이 풀린다.

**주의사항:**
Redis 락으로 "정확히 한 번 처리"를 기대하면 사고가 난다. Redis는 분산 합의 시스템이 아니다. 네트워크 분할이나 Redis 장애 시 락이 깨질 수 있다.

**운영 고려사항:**
운영에서 Redis 락을 쓰면, 실패 시 어떤 상태로 롤백되는지가 먼저 정해져 있어야 한다. 락을 잡은 후 작업이 실패하면 롤백 로직이 필요하다.

### 펜싱 토큰

Redis 락의 대표적인 구멍은 "락이 만료된 뒤에도 이전 작업이 계속 진행"이다. 이 경우 새 작업과 옛 작업이 동시에 DB를 건드릴 수 있다.

**문제 시나리오:**
1. 프로세스 A가 락을 잡고 작업을 시작한다
2. 작업이 오래 걸려 TTL이 만료된다
3. 프로세스 B가 락을 잡고 작업을 시작한다
4. 프로세스 A의 작업이 끝나 DB를 업데이트한다
5. 프로세스 B의 작업도 끝나 DB를 업데이트한다
6. 프로세스 A의 오래된 업데이트가 프로세스 B의 최신 업데이트를 덮어쓴다

**펜싱 토큰 해결책:**
이 문제를 줄이는 방식이 펜싱 토큰이다.

- 락을 잡을 때 증가하는 토큰을 함께 받는다
- DB 업데이트 시 토큰 조건을 붙인다
- 낮은 토큰의 업데이트는 거절된다

**동작 원리:**
1. 프로세스 A가 락을 잡고 토큰 1을 받는다
2. 프로세스 A가 작업 중 TTL이 만료된다
3. 프로세스 B가 락을 잡고 토큰 2를 받는다
4. 프로세스 A가 토큰 1로 DB를 업데이트하려고 하면 거절된다
5. 프로세스 B가 토큰 2로 DB를 업데이트하면 성공한다

**전제 조건:**
이 구조는 "DB가 최종 권위"인 전제가 있어야 성립한다. DB에 토큰을 저장하고 비교해야 한다.

### Redlock

Redlock은 여러 Redis 노드에 락을 잡아 쿼럼으로 판단하는 방식으로 소개된다. 현장에서 Redlock로 사고를 막아냈다는 케이스보다, 구성 복잡도만 늘린 케이스를 더 자주 봤다.

**문제점:**
- 네트워크 분할, 노드 지연 같은 상황에서 판단이 흔들릴 수 있다
- "락을 잡았다고 믿었는데"가 가장 위험하다
- 구성이 복잡해지고 운영 부담이 커진다

**대안:**
멀티 노드 Redis 락이 필요할 정도면, 요구사항 자체를 다시 보는 편이 낫다. DB의 조건부 업데이트, 유니크 제약, 작업 큐 직렬화가 더 단순하게 끝나는 경우가 많다.

### DB 기반 분산 락

테이블에 유니크 키를 걸고 `INSERT`로 락을 잡는 방식은 단순하다.

**구현 방식:**
- 락 테이블에 `lock_key`, `owner`, `expires_at` 컬럼
- `lock_key`에 유니크 인덱스
- `INSERT`로 락을 잡고, `DELETE`로 해제

**장점:**
- 단일 DB가 단일 권위
- 트랜잭션으로 정합성 관리가 쉬움
- Redis보다 단순하다

**단점:**
- DB 부하를 올릴 수 있다
- 핫키 락이 많으면 이 방식도 병목이 된다
- 만료 청소 로직이 필요하다

**만료 청소:**
운영에서 자주 놓치는 부분은 "만료"다. 만료 컬럼만 두고 청소 작업이 없으면 락이 영구히 남는다. 주기적으로 만료된 락을 삭제하는 작업이 필요하다.

### 분산 락 관측 포인트

**주요 메트릭:**

**락 획득 실패율:**
- 락을 잡지 못하는 비율
- 증가하면 경합이 심한 것이다

**락 대기 시간:**
- 락을 기다리는 시간
- 증가하면 경합이 심한 것이다

**TTL 만료로 인한 재진입:**
- TTL이 만료되어 다른 프로세스가 락을 잡는 빈도
- 증가하면 TTL이 짧거나 작업 시간이 길다

**락 키별 상위 N:**
- 어떤 키에 경합이 몰리는지 확인
- 특정 상품, 특정 주문, 특정 객실에 경합이 몰리는 케이스가 많다

**주의사항:**
락 키별 통계를 안 남기면 "왜 느린지"가 안 보인다. 핫키를 찾아 분산하거나 순서를 보장해야 한다.

## 메시지 큐와 락의 통합 사용

### 메시지 큐에서 락이 필요한 경우

메시지 큐를 사용하면 여러 소비자가 동시에 메시지를 처리한다. 같은 데이터를 수정하면 동시성 충돌이 발생한다.

**문제 시나리오:**
- 주문 처리 메시지가 여러 소비자에 분산된다
- 같은 주문을 두 소비자가 동시에 처리한다
- 재고 차감이 중복된다

**해결 방법:**
- 메시지 큐에서 순서 보장 (FIFO 큐, 파티션 키)
- DB 락으로 동시 수정 방지
- 분산 락으로 리소스 접근 제어

### 메시지 큐 순서 보장과 락

메시지 큐에서 순서를 보장하면 락 경합을 줄일 수 있다.

**파티션 키 활용:**
- 같은 파티션 키를 가진 메시지는 순서대로 처리된다
- 주문 ID를 파티션 키로 사용하면 같은 주문은 항상 같은 소비자가 처리한다
- 락 경합이 줄어든다

**주의사항:**
- 파티션 키가 잘못되면 한 파티션에 트래픽이 몰린다
- 핫키가 생기면 해당 파티션만 병목이 된다

### DB 락과 메시지 큐 소비자

메시지 큐 소비자가 DB를 수정할 때 락이 필요하다.

**패턴:**
- 소비자가 메시지를 받는다
- DB에서 데이터를 조회한다 (`SELECT ... FOR UPDATE`)
- 데이터를 수정한다
- 트랜잭션을 커밋한다

**주의사항:**
- 락 유지 시간이 길어지면 다른 소비자가 대기한다
- 트랜잭션을 짧게 유지해야 한다
- 외부 호출은 트랜잭션 밖에서 한다

### 분산 락과 메시지 큐

메시지 큐 소비자가 외부 리소스에 접근할 때 분산 락이 필요하다.

**사용 예시:**
- 외부 API 호출이 중복되면 안 되는 경우
- 파일 시스템에 접근하는 경우
- 캐시를 업데이트하는 경우

**패턴:**
- 소비자가 메시지를 받는다
- 분산 락을 잡는다
- 작업을 수행한다
- 락을 해제한다

**주의사항:**
- 락을 잡지 못하면 메시지를 다시 큐에 넣는다
- 락 TTL이 작업 시간보다 길어야 한다
- 락 해제 실패를 대비한 만료 청소가 필요하다

## 운영에서 자주 터지는 케이스

### 큐 적체가 시작되었는데 소비자는 정상처럼 보이는 경우

원인은 대체로 2가지로 좁혀진다.

**외부 의존성 지연:**
- 결제/메일/푸시 서비스가 느려진다
- 소비자가 외부 호출을 기다리고 있다
- 애플리케이션 로그는 조용하지만 큐는 쌓인다

**DB 락 대기:**
- 소비자가 DB에서 멈춰 있다
- 락 대기, 커넥션 대기 상태다
- 애플리케이션 코드가 실행되지 않는다

**진단 방법:**
"소비자 로그가 없다"가 정상은 아니다. 락 대기, 커넥션 대기 상태면 애플리케이션 코드가 실행되지 않는다. DB 상태를 확인해야 한다.

### 중복 메시지로 재고/포인트가 깨지는 경우

중복 처리가 되지 않는 작업은 메시지 큐에서 사고가 난다. 소비자 장애, 재시도는 언젠가 발생한다.

**원인:**
- 소비자 장애로 ack를 못 보냄
- 타임아웃 설정 문제로 재전달
- 네트워크 문제로 ack 유실

**해결:**
해결은 결국 멱등성이다. 멱등성 키를 DB 유니크로 막는 패턴이 가장 단순하게 유지되는 편이다.

### 데드락이 특정 시간대에만 터지는 경우

트래픽이 늘어나면서 "락 획득 순서가 섞이는 요청"이 늘어난 경우가 많다.

**원인:**
- 배치 + 실시간 요청이 같은 테이블을 갱신한다
- 서로 다른 API가 같은 테이블을 다른 순서로 갱신한다
- 트래픽이 적을 때는 순서가 섞이지 않지만, 많을 때는 섞인다

**해결:**
데드락은 로그만 보고 원인을 단정하기 어렵다. InnoDB deadlock 로그로 "어떤 인덱스/어떤 레코드"에서 막혔는지 확인해야 한다. 락 순서를 통일한다.

## 테스트

### 메시지 큐 테스트

**중복 처리 테스트:**
- 소비자 프로세스를 강제로 죽이고 재전달이 발생하는지 확인한다
- visibility timeout(또는 ack timeout)을 일부러 짧게 두고 중복이 생기는지 확인한다
- 멱등성 보장이 제대로 동작하는지 확인한다

**DLQ 테스트:**
- DLQ로 보내는 경로가 실제로 동작하는지 확인한다
- 실패한 메시지가 DLQ로 이동하는지 확인한다

**스키마 변경 테스트:**
- 스키마 버전이 바뀐 메시지를 흘려서 소비자가 어떻게 반응하는지 확인한다
- 이전 버전 메시지 처리가 실패하는지 확인한다

### DB 락 테스트

**락 경합 테스트:**
- 동일 자원에 동시 요청을 걸어 락 대기와 처리 지연을 재현한다
- 락 대기 시간이 예상대로 동작하는지 확인한다

**데드락 테스트:**
- 데드락을 의도적으로 만들어 "재시도 로직이 안전한지" 확인한다
- 데드락 발생 시 데이터 정합성이 유지되는지 확인한다

**락 범위 테스트:**
- 인덱스가 빠진 `FOR UPDATE`가 실제로 어떤 범위를 잠그는지 확인한다
- 락 범위가 예상보다 넓은지 확인한다

### 분산 락 테스트

**TTL 만료 테스트:**
- 작업 시간이 TTL을 넘는 케이스를 일부러 만들고 데이터가 깨지는지 확인한다
- 펜싱 토큰이 제대로 동작하는지 확인한다

**락 해제 실패 테스트:**
- 락 획득 실패 시 애플리케이션이 어떤 상태로 종료되는지 확인한다
- 락 해제가 누락되었을 때 만료 청소가 복구되는지 확인한다

**경합 테스트:**
- 여러 프로세스가 동시에 락을 잡으려고 할 때 경합이 제대로 동작하는지 확인한다
- 락 획득 실패율이 예상 범위 내인지 확인한다

