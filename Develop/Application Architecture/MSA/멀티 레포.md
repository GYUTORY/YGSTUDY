---
title: 멀티레포(Multi-Repository)란?
tags: [msa, repository, microservices, architecture, devops]
updated: 2024-12-19
---

# 멀티레포(Multi-Repository)란?

멀티레포(Multi-Repository)는 소프트웨어 개발에서 여러 개의 독립된 코드 저장소를 사용하는 구조를 의미합니다.
이는 프로젝트를 구성하는 각 컴포넌트나 서비스가 별도의 저장소로 관리되는 형태를 가리킵니다.

## 배경

### 대분류와 중분류
멀티레포는 소프트웨어 개발 및 배포 전략에 속하며, 대분류와 중분류로 다음과 같이 나뉩니다.

### 대분류: 코드 저장소 관리 방식
- **단일 저장소(Monorepo):** 
    - 하나의 저장소에서 모든 프로젝트 코드를 관리
    - 모든 팀이 동일한 저장소에서 작업
    - Google, Facebook과 같은 대기업에서 주로 사용
    - 장점: 코드 공유가 용이, 일관된 개발 환경
    - 단점: 저장소 크기 증가, 권한 관리 복잡성

- **다중 저장소(Multi-Repository):** 
    - 각 프로젝트 또는 컴포넌트를 별도의 저장소로 관리
    - 마이크로서비스 아키텍처에 적합
    - Netflix, Amazon과 같은 서비스 기업에서 주로 사용
    - 장점: 독립적인 개발과 배포, 명확한 책임 분리
    - 단점: 저장소 관리 복잡성, 코드 중복 가능성

### 중분류: 멀티레포의 구현 및 관리 방법
1. **서비스 기반(Service-based):**
    - 마이크로서비스 아키텍처에서 서비스별로 독립적인 저장소를 운영
    - 각 서비스는 자체 데이터베이스와 API를 가짐
    - 서비스 간 통신은 API Gateway나 메시지 큐를 통해 이루어짐
    - 예시: 사용자 서비스, 결제 서비스, 상품 서비스 등

2. **컴포넌트 기반(Component-based):**
    - 소프트웨어의 주요 모듈이나 라이브러리 단위로 저장소를 분리
    - 재사용 가능한 컴포넌트를 독립적으로 관리
    - 버전 관리가 용이하고 의존성 관리가 명확
    - 예시: 공통 UI 컴포넌트, 유틸리티 라이브러리, 공통 비즈니스 로직

3. **팀 기반(Team-based):**
    - 팀별로 독립된 저장소를 운영하며 각 팀이 저장소를 책임지고 관리
    - 팀의 자율성과 독립성을 보장
    - 팀별로 다른 개발 프로세스와 도구 사용 가능
    - 예시: 프론트엔드 팀, 백엔드 팀, 인프라 팀 등

## 핵심

### 멀티레포의 특징
- **장점:**
    - 독립성: 
        - 각 저장소가 분리되어 있어 팀 간 간섭을 최소화
        - 팀별로 독립적인 개발 주기와 배포 가능
        - 기술 스택과 프레임워크를 자유롭게 선택 가능
    - 유연성: 
        - 특정 서비스나 컴포넌트만 업데이트하거나 배포 가능
        - 서비스별로 다른 배포 전략 적용 가능
        - 장애 발생 시 영향 범위 최소화
    - 스케일링: 
        - 각 저장소를 개별적으로 확장 및 최적화
        - 서비스별로 다른 인프라 구성 가능
        - 리소스 사용의 효율성 향상

- **단점:**
    - 복잡성 증가: 
        - 저장소가 많아질수록 관리와 연동이 어려워짐
        - 서비스 간 통신 관리의 복잡성
        - 분산 시스템의 운영 복잡성
    - 중복 코드: 
        - 공통 모듈이나 코드가 여러 저장소에 중복될 가능성
        - 코드 재사용의 어려움
        - 일관성 유지의 어려움
    - 설정 작업: 
        - CI/CD 및 의존성 관리를 개별적으로 설정해야 함
        - 각 저장소별 빌드/배포 파이프라인 구성 필요
        - 모니터링과 로깅 시스템의 분산

### 멀티레포 vs 모노레포 상세 비교

#### 아키텍처 및 구조 비교
| 측면 | 멀티레포 | 모노레포 |
|------|----------|----------|
| **저장소 구조** | 다중 저장소 | 단일 저장소 |
| **코드 공유** | 어려움 (패키지 매니저 필요) | 쉬움 (직접 공유) |
| **의존성 관리** | 분산화 | 중앙화 |
| **버전 관리** | 독립적 | 통합/독립 선택 가능 |
| **빌드 시스템** | 분산 | 통합 |
| **팀 협업** | 제한적 (저장소별) | 높음 (전체 접근) |
| **복잡성** | 낮음 (개별 관리) | 높음 (통합 관리) |
| **확장성** | 우수 (서비스별 독립) | 제한적 (전체 통합) |

#### 개발 및 운영 측면
| 항목 | 멀티레포 | 모노레포 |
|------|----------|----------|
| **코드 구조** | 독립된 저장소로 분리 | 하나의 저장소에서 모든 코드 관리 |
| **관리 난이도** | 저장소가 많아질수록 복잡 | 단일 저장소로 관리가 용이 |
| **협업 방식** | 팀/서비스별 독립적 협업 가능 | 모든 팀이 같은 저장소에서 협업 |
| **빌드/배포** | 개별 저장소에 맞춘 빌드/배포 | 통합된 빌드/배포 프로세스 |
| **코드 공유** | 패키지 매니저나 공통 라이브러리 사용 | 직접적인 코드 공유 가능 |
| **버전 관리** | 각 저장소별 독립적인 버전 관리 | 통합된 버전 관리 |
| **테스트** | 서비스별 독립적인 테스트 | 통합 테스트 용이 |
| **배포** | 서비스별 독립적인 배포 가능 | 전체 시스템 통합 배포 |
| **확장성** | 서비스별 독립적인 확장 가능 | 전체 시스템 통합 확장 |

#### 모노레포 구조 예시
```
monorepo/
├── packages/
│   ├── shared/
│   │   ├── utils/
│   │   ├── components/
│   │   └── types/
│   ├── frontend/
│   │   ├── web-app/
│   │   └── mobile-app/
│   ├── backend/
│   │   ├── api-service/
│   │   ├── auth-service/
│   │   └── payment-service/
│   └── tools/
│       ├── eslint-config/
│       └── typescript-config/
├── apps/
│   ├── admin-dashboard/
│   └── user-portal/
├── package.json
├── lerna.json
├── nx.json
└── tsconfig.json
```

#### 모노레포 도구 비교
| 도구 | 언어 지원 | 특징 | 장점 | 단점 |
|------|-----------|------|------|------|
| **Lerna** | JavaScript/TypeScript | 패키지 관리 중심 | 간단한 설정, npm 생태계 | 성능 제한 |
| **Nx** | 다중 언어 | 빌드 시스템 중심 | 고성능, 캐싱, 의존성 그래프 | 복잡한 설정 |
| **Yarn Workspaces** | JavaScript/TypeScript | 패키지 매니저 내장 | 별도 도구 불필요 | 제한적 기능 |
| **Rush** | 다중 언어 | 엔터프라이즈 중심 | 대규모 프로젝트 최적화 | 높은 학습 곡선 |

#### 선택 기준
**멀티레포를 선택해야 하는 경우:**
- 팀이 완전히 독립적으로 작업
- 서비스별로 다른 기술 스택 사용
- 서비스별 독립적인 배포 주기
- 보안상 코드 분리가 필요
- 대규모 조직에서 팀별 자율성 중요

**모노레포를 선택해야 하는 경우:**
- 코드 공유가 빈번
- 통합된 개발 환경 필요
- 의존성 관리의 복잡성 최소화
- 전체 시스템의 일관성 중요
- 중소규모 팀에서 협업 효율성 중요

## 예시

### 마이크로서비스 아키텍처 예시
```javascript
// 사용자 서비스 저장소 (user-service)
const express = require('express');
const app = express();

app.get('/api/users/:id', async (req, res) => {
  const userId = req.params.id;
  const user = await UserService.getUser(userId);
  res.json(user);
});

// 결제 서비스 저장소 (payment-service)
const paymentApp = express();

paymentApp.post('/api/payments', async (req, res) => {
  const payment = await PaymentService.processPayment(req.body);
  res.json(payment);
});

// 상품 서비스 저장소 (product-service)
const productApp = express();

productApp.get('/api/products', async (req, res) => {
  const products = await ProductService.getProducts();
  res.json(products);
});
```

### 공통 라이브러리 관리 예시
```javascript
// 공통 유틸리티 라이브러리 (shared-utils)
class Logger {
  static info(message) {
    console.log(`[INFO] ${new Date().toISOString()}: ${message}`);
  }
  
  static error(message, error) {
    console.error(`[ERROR] ${new Date().toISOString()}: ${message}`, error);
  }
}

module.exports = { Logger };

// 각 서비스에서 사용
const { Logger } = require('@company/shared-utils');

Logger.info('서비스 시작됨');
```

### CI/CD 파이프라인 예시
```yaml
# .github/workflows/deploy.yml (각 서비스별로 별도 설정)
name: Deploy Service

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Setup Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '18'
      - name: Install dependencies
        run: npm install
      - name: Run tests
        run: npm test
      - name: Build
        run: npm run build
      - name: Deploy to staging
        run: npm run deploy:staging
```

## 운영 팁

### 멀티레포 도입 시 고려사항
1. **조직 구조:**
    - 팀 구조와 책임 분리가 명확한지
    - 팀 간 협업 방식이 잘 정의되어 있는지
    - 의사소통 채널이 잘 구축되어 있는지

2. **기술적 요구사항:**
    - 서비스 간 통신 방식
    - 데이터 일관성 보장 방법
    - 모니터링과 로깅 전략
    - 장애 대응 방안

3. **운영 관리:**
    - CI/CD 파이프라인 구성
    - 배포 전략
    - 인프라 관리
    - 보안 정책

4. **개발 프로세스:**
    - 코드 리뷰 방식
    - 테스트 전략
    - 문서화 정책
    - 품질 관리 방법

### 실무 적용 가이드
- **저장소 분리 기준:** 비즈니스 도메인이나 팀 책임에 따라 분리
- **공통 코드 관리:** npm 패키지나 공통 라이브러리로 관리
- **버전 관리:** 각 저장소별로 독립적인 버전 관리
- **배포 전략:** 서비스별 독립 배포와 롤백 전략 수립
- **모니터링:** 분산 시스템 모니터링 도구 활용

## 참고

### 실제 사례
1. **마이크로서비스 아키텍처:**
    - Netflix: 각 마이크로서비스를 독립적인 저장소로 관리
    - Amazon: 서비스별로 분리된 저장소 운영
    - Uber: 지역별, 기능별로 분리된 서비스 저장소

2. **오픈소스 프로젝트:**
    - Kubernetes: 코어 모듈과 플러그인 모듈을 각각 다른 저장소로 관리
    - React: 코어 라이브러리와 각종 플러그인을 별도 저장소로 관리
    - Angular: 프레임워크와 관련 도구들을 분리된 저장소로 관리

3. **팀 기반 협업:**
    - 팀별로 담당 서비스 저장소를 별도로 두고 협업
    - 예시:
        - 프론트엔드 팀: 웹 클라이언트 저장소
        - 백엔드 팀: API 서버 저장소
        - 인프라 팀: 인프라 관리 저장소

### 결론
멀티레포는 소프트웨어 개발 환경에서 독립성과 유연성을 제공하지만, 복잡성과 관리 비용이 동반될 수 있습니다.
따라서 프로젝트의 규모, 팀 구조, 요구 사항 등을 고려하여 적절한 저장소 관리 방식을 선택하는 것이 중요합니다.
특히 마이크로서비스 아키텍처를 도입하는 경우, 멀티레포는 필수적인 선택이 될 수 있으며,
이를 효과적으로 운영하기 위해서는 체계적인 관리 전략과 도구의 도입이 필요합니다.
