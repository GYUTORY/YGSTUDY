---
title: 멀티레포(Multi-Repository)
tags: [msa, repository, microservices, architecture, devops]
updated: 2025-12-25
---

# 멀티레포(Multi-Repository)

## 개요

멀티레포는 소프트웨어 개발에서 여러 개의 독립된 코드 저장소를 사용하는 구조다. 각 컴포넌트나 서비스가 별도의 저장소로 관리된다.

## 코드 저장소 관리 방식

### 단일 저장소(Monorepo)

하나의 저장소에서 모든 프로젝트 코드를 관리한다.

**특징:**
- 모든 팀이 동일한 저장소에서 작업
- Google, Facebook과 같은 대기업에서 주로 사용
- 장점: 코드 공유가 용이, 일관된 개발 환경
- 단점: 저장소 크기 증가, 권한 관리 복잡성

### 다중 저장소(Multi-Repository)

각 프로젝트 또는 컴포넌트를 별도의 저장소로 관리한다.

**특징:**
- 마이크로서비스 아키텍처에 적합
- Netflix, Amazon과 같은 서비스 기업에서 주로 사용
- 장점: 독립적인 개발과 배포, 명확한 책임 분리
- 단점: 저장소 관리 복잡성, 코드 중복 가능성

**실무 팁:**
마이크로서비스 아키텍처에서는 멀티레포가 더 적합하다. 각 서비스가 독립적으로 배포되어야 하기 때문이다.

## 멀티레포 구현 방법

### 서비스 기반(Service-based)

마이크로서비스 아키텍처에서 서비스별로 독립적인 저장소를 운영한다.

**특징:**
- 각 서비스는 자체 데이터베이스와 API를 가짐
- 서비스 간 통신은 API Gateway나 메시지 큐를 통해 이루어짐
- 예시: 사용자 서비스, 결제 서비스, 상품 서비스 등

### 컴포넌트 기반(Component-based)

소프트웨어의 주요 모듈이나 라이브러리 단위로 저장소를 분리한다.

**특징:**
- 재사용 가능한 컴포넌트를 독립적으로 관리
- 버전 관리가 용이하고 의존성 관리가 명확
- 예시: 공통 UI 컴포넌트, 유틸리티 라이브러리, 공통 비즈니스 로직

### 팀 기반(Team-based)

팀별로 독립된 저장소를 운영하며 각 팀이 저장소를 책임지고 관리한다.

**특징:**
- 팀의 자율성과 독립성을 보장
- 팀별로 다른 개발 프로세스와 도구 사용 가능
- 예시: 프론트엔드 팀, 백엔드 팀, 인프라 팀 등

## 멀티레포의 특징

### 장점

**독립성:**
- 각 저장소가 분리되어 있어 팀 간 간섭을 최소화
- 팀별로 독립적인 개발 주기와 배포 가능
- 기술 스택과 프레임워크를 자유롭게 선택 가능

**유연성:**
- 특정 서비스나 컴포넌트만 업데이트하거나 배포 가능
- 서비스별로 다른 배포 전략 적용 가능
- 장애 발생 시 영향 범위 최소화

**스케일링:**
- 각 저장소를 개별적으로 확장 및 최적화
- 서비스별로 다른 인프라 구성 가능
- 리소스 사용의 효율성 향상

### 단점

**복잡성 증가:**
- 저장소가 많아질수록 관리와 연동이 어려워짐
- 서비스 간 통신 관리의 복잡성
- 분산 시스템의 운영 복잡성

**중복 코드:**
- 공통 모듈이나 코드가 여러 저장소에 중복될 가능성
- 코드 재사용의 어려움
- 일관성 유지의 어려움

**설정 작업:**
- CI/CD 및 의존성 관리를 개별적으로 설정해야 함
- 각 저장소별 빌드/배포 파이프라인 구성 필요
- 모니터링과 로깅 시스템의 분산

**실무 팁:**
공통 코드는 npm 패키지나 공통 라이브러리로 관리하면 중복을 줄일 수 있다.

### 멀티레포 vs 모노레포 비교

#### 아키텍처 및 구조 비교

| 측면 | 멀티레포 | 모노레포 |
|------|----------|----------|
| 저장소 구조 | 다중 저장소 | 단일 저장소 |
| 코드 공유 | 어려움 (패키지 매니저 필요) | 쉬움 (직접 공유) |
| 의존성 관리 | 분산화 | 중앙화 |
| 버전 관리 | 독립적 | 통합/독립 선택 가능 |
| 빌드 시스템 | 분산 | 통합 |
| 팀 협업 | 제한적 (저장소별) | 높음 (전체 접근) |
| 복잡성 | 낮음 (개별 관리) | 높음 (통합 관리) |
| 확장성 | 우수 (서비스별 독립) | 제한적 (전체 통합) |

#### 개발 및 운영 측면

| 항목 | 멀티레포 | 모노레포 |
|------|----------|----------|
| 코드 구조 | 독립된 저장소로 분리 | 하나의 저장소에서 모든 코드 관리 |
| 관리 난이도 | 저장소가 많아질수록 복잡 | 단일 저장소로 관리가 용이 |
| 협업 방식 | 팀/서비스별 독립적 협업 가능 | 모든 팀이 같은 저장소에서 협업 |
| 빌드/배포 | 개별 저장소에 맞춘 빌드/배포 | 통합된 빌드/배포 프로세스 |
| 코드 공유 | 패키지 매니저나 공통 라이브러리 사용 | 직접적인 코드 공유 가능 |
| 버전 관리 | 각 저장소별 독립적인 버전 관리 | 통합된 버전 관리 |
| 테스트 | 서비스별 독립적인 테스트 | 통합 테스트 용이 |
| 배포 | 서비스별 독립적인 배포 가능 | 전체 시스템 통합 배포 |
| 확장성 | 서비스별 독립적인 확장 가능 | 전체 시스템 통합 확장 |

**실무 팁:**
마이크로서비스 아키텍처에서는 멀티레포가 더 적합하다. 각 서비스가 독립적으로 배포되어야 하기 때문이다.

#### 모노레포 구조 예시
```
monorepo/
├── packages/
│   ├── shared/
│   │   ├── utils/
│   │   ├── components/
│   │   └── types/
│   ├── frontend/
│   │   ├── web-app/
│   │   └── mobile-app/
│   ├── backend/
│   │   ├── api-service/
│   │   ├── auth-service/
│   │   └── payment-service/
│   └── tools/
│       ├── eslint-config/
│       └── typescript-config/
├── apps/
│   ├── admin-dashboard/
│   └── user-portal/
├── package.json
├── lerna.json
├── nx.json
└── tsconfig.json
```

#### 모노레포 도구 비교
| 도구 | 언어 지원 | 특징 | 장점 | 단점 |
|------|-----------|------|------|------|
| **Lerna** | JavaScript/TypeScript | 패키지 관리 중심 | 간단한 설정, npm 생태계 | 성능 제한 |
| **Nx** | 다중 언어 | 빌드 시스템 중심 | 고성능, 캐싱, 의존성 그래프 | 복잡한 설정 |
| **Yarn Workspaces** | JavaScript/TypeScript | 패키지 매니저 내장 | 별도 도구 불필요 | 제한적 기능 |
| **Rush** | 다중 언어 | 엔터프라이즈 중심 | 대규모 프로젝트 최적화 | 높은 학습 곡선 |

### 선택 기준

**멀티레포를 선택해야 하는 경우:**
- 팀이 완전히 독립적으로 작업
- 서비스별로 다른 기술 스택 사용
- 서비스별 독립적인 배포 주기
- 보안상 코드 분리가 필요
- 대규모 조직에서 팀별 자율성 중요

**모노레포를 선택해야 하는 경우:**
- 코드 공유가 빈번
- 통합된 개발 환경 필요
- 의존성 관리의 복잡성 최소화
- 전체 시스템의 일관성 중요
- 중소규모 팀에서 협업 효율성 중요

**실무 팁:**
팀 규모가 작고 코드 공유가 많으면 모노레포가 더 적합하다. 팀이 크고 서비스가 독립적이면 멀티레포가 더 적합하다.

## 예시

### 마이크로서비스 아키텍처 예시
```javascript
// 사용자 서비스 저장소 (user-service)
const express = require('express');
const app = express();

app.get('/api/users/:id', async (req, res) => {
  const userId = req.params.id;
  const user = await UserService.getUser(userId);
  res.json(user);
});

// 결제 서비스 저장소 (payment-service)
const paymentApp = express();

paymentApp.post('/api/payments', async (req, res) => {
  const payment = await PaymentService.processPayment(req.body);
  res.json(payment);
});

// 상품 서비스 저장소 (product-service)
const productApp = express();

productApp.get('/api/products', async (req, res) => {
  const products = await ProductService.getProducts();
  res.json(products);
});
```

### 공통 라이브러리 관리 예시
```javascript
// 공통 유틸리티 라이브러리 (shared-utils)
class Logger {
  static info(message) {
    console.log(`[INFO] ${new Date().toISOString()}: ${message}`);
  }
  
  static error(message, error) {
    console.error(`[ERROR] ${new Date().toISOString()}: ${message}`, error);
  }
}

module.exports = { Logger };

// 각 서비스에서 사용
const { Logger } = require('@company/shared-utils');

Logger.info('서비스 시작됨');
```

### CI/CD 파이프라인 예시
```yaml
# .github/workflows/deploy.yml (각 서비스별로 별도 설정)
name: Deploy Service

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Setup Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '18'
      - name: Install dependencies
        run: npm install
      - name: Run tests
        run: npm test
      - name: Build
        run: npm run build
      - name: Deploy to staging
        run: npm run deploy:staging
```

## 운영 고려사항

### 멀티레포 도입 시 고려사항

**조직 구조:**
- 팀 구조와 책임 분리가 명확한지
- 팀 간 협업 방식이 잘 정의되어 있는지
- 의사소통 채널이 잘 구축되어 있는지

**기술적 요구사항:**
- 서비스 간 통신 방식
- 데이터 일관성 보장 방법
- 모니터링과 로깅 전략
- 장애 대응 방안

**운영 관리:**
- CI/CD 파이프라인 구성
- 배포 전략
- 인프라 관리
- 보안 정책

**개발 프로세스:**
- 코드 리뷰 방식
- 테스트 전략
- 문서화 정책
- 품질 관리 방법

### 실무 적용 가이드

- 저장소 분리 기준: 비즈니스 도메인이나 팀 책임에 따라 분리
- 공통 코드 관리: npm 패키지나 공통 라이브러리로 관리
- 버전 관리: 각 저장소별로 독립적인 버전 관리
- 배포 전략: 서비스별 독립 배포와 롤백 전략 수립
- 모니터링: 분산 시스템 모니터링 도구 활용

**실무 팁:**
공통 코드는 npm 패키지로 관리하면 버전 관리가 쉬워진다. 각 서비스에서 필요한 버전을 선택해 사용할 수 있다.

## 참고

### 실제 사례

**마이크로서비스 아키텍처:**
- Netflix: 각 마이크로서비스를 독립적인 저장소로 관리
- Amazon: 서비스별로 분리된 저장소 운영
- Uber: 지역별, 기능별로 분리된 서비스 저장소

**오픈소스 프로젝트:**
- Kubernetes: 코어 모듈과 플러그인 모듈을 각각 다른 저장소로 관리
- React: 코어 라이브러리와 각종 플러그인을 별도 저장소로 관리
- Angular: 프레임워크와 관련 도구들을 분리된 저장소로 관리

**팀 기반 협업:**
- 팀별로 담당 서비스 저장소를 별도로 두고 협업
- 예시:
  - 프론트엔드 팀: 웹 클라이언트 저장소
  - 백엔드 팀: API 서버 저장소
  - 인프라 팀: 인프라 관리 저장소

**실무 팁:**
마이크로서비스 아키텍처를 도입하는 경우 멀티레포는 필수적이다. 각 서비스가 독립적으로 배포되어야 하기 때문이다.
