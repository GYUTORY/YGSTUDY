최종 업데이트 2025-08-08, 버전 v1.0
---
title: 벌크헤드(Bulkhead) 실전 설정 가이드
tags: [msa, bulkhead, resilience, architecture, performance, isolation]
updated: 2024-12-19
---

# 벌크헤드(Bulkhead) 실전 설정 가이드

## 배경

### 벌크헤드 패턴이란?
하나의 서비스 안에서도 리소스를 칸막이치듯 나눠서(스레드풀/커넥션풀/큐) 특정 기능 장애가 전체를 끌어내리지 않도록 하는 방법입니다. 외부 의존성 부하나 느린 호출이 있어도 다른 기능은 최대한 정상 동작하게 만듭니다.

### 벌크헤드의 필요성
1. **장애 격리**: 한 기능의 장애가 전체 시스템에 영향을 주지 않도록 함
2. **리소스 보호**: 중요한 기능의 리소스를 보호하여 가용성 확보
3. **성능 안정성**: 느린 외부 의존성으로 인한 성능 저하 방지
4. **확장성**: 기능별로 독립적인 스케일링 가능

### 벌크헤드 패턴의 원칙
- 기능별로 풀(스레드/커넥션/큐) 상한을 분리
- 타임아웃과 큐 길이 제한
- 풀 고갈 시 빠르게 실패하거나 폴백
- 대기시간, 풀 사용률, 거부 건수 모니터링

## 핵심

### 벌크헤드 패턴의 구성 요소
1. **리소스 격리**: 스레드풀, 커넥션풀, 큐 등을 기능별로 분리
2. **상한 설정**: 각 풀의 최대 크기와 타임아웃 설정
3. **장애 처리**: 풀 고갈 시의 폴백 전략
4. **모니터링**: 리소스 사용률과 성능 지표 추적

### 벌크헤드 패턴의 장점
- **고가용성**: 부분 장애 시에도 전체 시스템 동작
- **예측 가능한 성능**: 리소스 상한으로 인한 성능 보장
- **확장성**: 기능별 독립적인 스케일링
- **운영 편의성**: 명확한 장애 경계와 모니터링

### 벌크헤드 패턴의 단점
- **복잡성 증가**: 리소스 관리의 복잡성
- **리소스 낭비**: 각 풀의 최소 크기로 인한 리소스 사용
- **설정 복잡성**: 적절한 풀 크기 설정의 어려움

## 예시

### DB 커넥션풀 벌크헤드

#### TypeORM 예시
```typescript
// data-source.ts
import { DataSource } from 'typeorm';

// 읽기 전용 커넥션풀
export const ReadDataSource = new DataSource({
  type: 'postgres',
  host: process.env.DB_HOST,
  port: 5432,
  username: 'app',
  password: 'secret',
  database: 'app',
  synchronize: false,
  extra: {
    max: 20,      // 읽기 작업용 풀 크기
    min: 4,
    idleTimeoutMillis: 30000,
  },
});

// 쓰기 전용 커넥션풀
export const WriteDataSource = new DataSource({
  type: 'postgres',
  host: process.env.DB_HOST,
  port: 5432,
  username: 'app',
  password: 'secret',
  database: 'app',
  synchronize: false,
  extra: {
    max: 10,      // 쓰기 작업용 풀 크기 (더 작게)
    min: 2,
    idleTimeoutMillis: 30000,
  },
});

// 중요 트랜잭션용 커넥션풀
export const CriticalDataSource = new DataSource({
  type: 'postgres',
  host: process.env.DB_HOST,
  port: 5432,
  username: 'app',
  password: 'secret',
  database: 'app',
  synchronize: false,
  extra: {
    max: 5,       // 중요 트랜잭션용 작은 풀
    min: 1,
    idleTimeoutMillis: 30000,
  },
});
```

#### 커넥션풀 모니터링
```javascript
// pool-monitor.js
class ConnectionPoolMonitor {
  constructor(dataSource, poolName) {
    this.dataSource = dataSource;
    this.poolName = poolName;
    this.metrics = {
      totalConnections: 0,
      activeConnections: 0,
      idleConnections: 0,
      waitingClients: 0
    };
  }
  
  startMonitoring() {
    setInterval(() => {
      const pool = this.dataSource.driver.pool;
      this.metrics = {
        totalConnections: pool.totalCount,
        activeConnections: pool.used,
        idleConnections: pool.free,
        waitingClients: pool.pending
      };
      
      console.log(`${this.poolName} Pool Status:`, this.metrics);
      
      // 경고 조건 체크
      if (this.metrics.waitingClients > 0) {
        console.warn(`${this.poolName}: 클라이언트 대기 중`);
      }
      
      if (this.metrics.activeConnections / this.metrics.totalConnections > 0.8) {
        console.warn(`${this.poolName}: 풀 사용률 높음`);
      }
    }, 5000);
  }
}

// 모니터링 시작
const readPoolMonitor = new ConnectionPoolMonitor(ReadDataSource, 'Read');
const writePoolMonitor = new ConnectionPoolMonitor(WriteDataSource, 'Write');
const criticalPoolMonitor = new ConnectionPoolMonitor(CriticalDataSource, 'Critical');

readPoolMonitor.startMonitoring();
writePoolMonitor.startMonitoring();
criticalPoolMonitor.startMonitoring();
```

### HTTP 클라이언트 벌크헤드

#### Axios Keep-Alive 에이전트 풀
```javascript
// http-clients.js
import axios from 'axios';
import http from 'http';
import https from 'https';

// 일반 API용 클라이언트
export const generalHttpClient = axios.create({
  httpAgent: new http.Agent({ 
    keepAlive: true, 
    maxSockets: 50,
    timeout: 30000
  }),
  httpsAgent: new https.Agent({ 
    keepAlive: true, 
    maxSockets: 50,
    timeout: 30000
  }),
  timeout: 5000,
});

// 결제 API용 클라이언트 (더 엄격한 설정)
export const paymentHttpClient = axios.create({
  httpAgent: new http.Agent({ 
    keepAlive: true, 
    maxSockets: 10,  // 결제는 더 작은 풀
    timeout: 30000
  }),
  httpsAgent: new https.Agent({ 
    keepAlive: true, 
    maxSockets: 10,
    timeout: 30000
  }),
  timeout: 3000,  // 더 짧은 타임아웃
});

// 외부 서비스용 클라이언트 (느린 서비스 대응)
export const externalHttpClient = axios.create({
  httpAgent: new http.Agent({ 
    keepAlive: true, 
    maxSockets: 20,
    timeout: 60000
  }),
  httpsAgent: new https.Agent({ 
    keepAlive: true, 
    maxSockets: 20,
    timeout: 60000
  }),
  timeout: 10000,  // 더 긴 타임아웃
});
```

#### API별 클라이언트 분리
```javascript
// api-clients.js
class ApiClientManager {
  constructor() {
    this.clients = new Map();
    this.setupClients();
  }
  
  setupClients() {
    // 사용자 서비스 API
    this.clients.set('user-service', axios.create({
      baseURL: 'http://user-service:3001',
      timeout: 3000,
      httpAgent: new http.Agent({ maxSockets: 20 }),
      httpsAgent: new https.Agent({ maxSockets: 20 })
    }));
    
    // 주문 서비스 API
    this.clients.set('order-service', axios.create({
      baseURL: 'http://order-service:3002',
      timeout: 5000,
      httpAgent: new http.Agent({ maxSockets: 30 }),
      httpsAgent: new https.Agent({ maxSockets: 30 })
    }));
    
    // 결제 서비스 API (중요한 서비스)
    this.clients.set('payment-service', axios.create({
      baseURL: 'http://payment-service:3003',
      timeout: 2000,
      httpAgent: new http.Agent({ maxSockets: 10 }),
      httpsAgent: new https.Agent({ maxSockets: 10 })
    }));
  }
  
  getClient(serviceName) {
    const client = this.clients.get(serviceName);
    if (!client) {
      throw new Error(`Unknown service: ${serviceName}`);
    }
    return client;
  }
  
  async callService(serviceName, method, url, data = null) {
    const client = this.getClient(serviceName);
    
    try {
      const response = await client.request({
        method,
        url,
        data
      });
      return response.data;
    } catch (error) {
      console.error(`${serviceName} 호출 실패:`, error.message);
      throw error;
    }
  }
}

export const apiManager = new ApiClientManager();
```

### 스레드풀 벌크헤드 (Node.js)

#### CPU 작업: worker_threads 풀(Piscina)
```javascript
// cpu-pool.js
import Piscina from 'piscina';
import { resolve } from 'path';

// 일반 CPU 작업용 풀
export const generalCpuPool = new Piscina({
  filename: resolve(__dirname, 'general-worker.js'),
  minThreads: 2,
  maxThreads: 8,
  idleTimeout: 10000,
});

// 중요 CPU 작업용 풀 (더 작은 풀)
export const criticalCpuPool = new Piscina({
  filename: resolve(__dirname, 'critical-worker.js'),
  minThreads: 1,
  maxThreads: 3,
  idleTimeout: 10000,
});

// 배치 처리용 풀
export const batchCpuPool = new Piscina({
  filename: resolve(__dirname, 'batch-worker.js'),
  minThreads: 4,
  maxThreads: 12,
  idleTimeout: 30000,
});
```

```javascript
// general-worker.js
module.exports = ({ task, data }) => {
  switch (task) {
    case 'calculate':
      return calculateSum(data.n);
    case 'process':
      return processData(data);
    default:
      throw new Error('Unknown task');
  }
};

function calculateSum(n) {
  let sum = 0;
  for (let i = 0; i < n; i++) {
    sum += i;
  }
  return sum;
}

function processData(data) {
  // 데이터 처리 로직
  return data.map(item => item * 2);
}
```

```javascript
// critical-worker.js
module.exports = ({ task, data }) => {
  // 중요 작업만 처리
  if (task === 'critical-calculation') {
    return criticalCalculation(data);
  }
  throw new Error('Critical worker only handles critical tasks');
};

function criticalCalculation(data) {
  // 중요 계산 로직
  return data.reduce((acc, val) => acc + val, 0);
}
```

#### I/O 작업: 동시성 상한(p-limit)
```javascript
// io-bulkhead.js
import pLimit from 'p-limit';

class IoBulkhead {
  constructor() {
    this.limits = new Map();
    this.setupLimits();
  }
  
  setupLimits() {
    // 일반 API 호출 제한
    this.limits.set('general-api', pLimit(20));
    
    // 파일 처리 제한
    this.limits.set('file-processing', pLimit(5));
    
    // 외부 서비스 호출 제한 (느린 서비스)
    this.limits.set('external-service', pLimit(10));
    
    // 결제 API 호출 제한 (중요한 서비스)
    this.limits.set('payment-api', pLimit(5));
  }
  
  async executeWithLimit(limitName, task) {
    const limit = this.limits.get(limitName);
    if (!limit) {
      throw new Error(`Unknown limit: ${limitName}`);
    }
    
    return limit(task);
  }
  
  async fetchSafely(urls, limitName = 'general-api') {
    const limit = this.limits.get(limitName);
    
    return Promise.all(
      urls.map(url => 
        limit(() => 
          axios.get(url, { timeout: 5000 })
        )
      )
    );
  }
  
  async processFiles(files, limitName = 'file-processing') {
    const limit = this.limits.get(limitName);
    
    return Promise.all(
      files.map(file => 
        limit(() => 
          this.processFile(file)
        )
      )
    );
  }
  
  async processFile(file) {
    // 파일 처리 로직
    console.log(`Processing file: ${file}`);
    await new Promise(resolve => setTimeout(resolve, 1000));
    return `Processed: ${file}`;
  }
}

export const ioBulkhead = new IoBulkhead();
```

### 큐 기반 벌크헤드

#### 작업 큐 분리
```javascript
// queue-bulkhead.js
import Queue from 'bull';

class QueueBulkhead {
  constructor() {
    this.queues = new Map();
    this.setupQueues();
  }
  
  setupQueues() {
    // 일반 작업 큐
    this.queues.set('general', new Queue('general-tasks', {
      redis: { port: 6379, host: 'localhost' },
      limiter: {
        max: 100,
        duration: 1000
      }
    }));
    
    // 중요 작업 큐 (더 작은 제한)
    this.queues.set('critical', new Queue('critical-tasks', {
      redis: { port: 6379, host: 'localhost' },
      limiter: {
        max: 20,
        duration: 1000
      }
    }));
    
    // 배치 작업 큐
    this.queues.set('batch', new Queue('batch-tasks', {
      redis: { port: 6379, host: 'localhost' },
      limiter: {
        max: 50,
        duration: 1000
      }
    }));
  }
  
  async addTask(queueName, task, priority = 'normal') {
    const queue = this.queues.get(queueName);
    if (!queue) {
      throw new Error(`Unknown queue: ${queueName}`);
    }
    
    const job = await queue.add(task, { priority });
    return job;
  }
  
  async processTasks(queueName, processor) {
    const queue = this.queues.get(queueName);
    if (!queue) {
      throw new Error(`Unknown queue: ${queueName}`);
    }
    
    queue.process(processor);
  }
}

export const queueBulkhead = new QueueBulkhead();
```

## 운영 팁

### 실전 팁
- **쓰기/읽기 풀 분리**: 기능 모듈별 다른 풀 크기로 중요 트랜잭션 보호
- **커넥션 누수 감지**: 최대 사용 시간, slow query 로깅
- **외부 API별 별도 클라이언트/풀**: 느린 의존성의 영향 차단
- **maxSockets 상한**: 다운스트림 보호

### 모니터링 지표
```javascript
// bulkhead-monitor.js
class BulkheadMonitor {
  constructor() {
    this.metrics = {
      poolUsage: {},
      rejectionCount: {},
      responseTime: {},
      errorRate: {}
    };
  }
  
  recordPoolUsage(poolName, usage) {
    this.metrics.poolUsage[poolName] = usage;
  }
  
  recordRejection(poolName) {
    this.metrics.rejectionCount[poolName] = 
      (this.metrics.rejectionCount[poolName] || 0) + 1;
  }
  
  recordResponseTime(poolName, time) {
    if (!this.metrics.responseTime[poolName]) {
      this.metrics.responseTime[poolName] = [];
    }
    this.metrics.responseTime[poolName].push(time);
    
    // 최근 100개만 유지
    if (this.metrics.responseTime[poolName].length > 100) {
      this.metrics.responseTime[poolName].shift();
    }
  }
  
  getMetrics() {
    return {
      ...this.metrics,
      averageResponseTime: this.calculateAverageResponseTime()
    };
  }
  
  calculateAverageResponseTime() {
    const averages = {};
    for (const [poolName, times] of Object.entries(this.metrics.responseTime)) {
      averages[poolName] = times.reduce((a, b) => a + b, 0) / times.length;
    }
    return averages;
  }
}

export const bulkheadMonitor = new BulkheadMonitor();
```

### 설정 최적화
- **풀 크기 설정**: 트래픽 패턴과 리소스 사용량 분석
- **타임아웃 설정**: 서비스 특성에 맞는 적절한 타임아웃
- **폴백 전략**: 풀 고갈 시의 대응 방안
- **알림 설정**: 임계값 초과 시 알림

## 참고

### 관련 문서
- [MSA 가이드](./MSA.md) — 회복탄력성 섹션 배경
- [Nginx](../../WebServer/Nginx/Definition.md) — 프록시단 최적화와 병행
- [NestJS Basic](../../Framework/Node/NestJS/Basic.md) — 모듈 단위 자원 격리 구현

### 추천 도서 및 자료
- Release It! (Michael T. Nygard)
- Node.js worker_threads, Piscina — `https://github.com/piscinajs/piscina`
- Axios Keep-Alive — `https://github.com/axios/axios`

### 결론
벌크헤드 패턴은 MSA 환경에서 시스템의 안정성과 가용성을 높이는 중요한 패턴입니다.
기능별로 리소스를 격리하고 적절한 상한을 설정하여 부분 장애가 전체 시스템에 영향을 주지 않도록 설계해야 합니다.
모니터링과 알림을 통해 지속적으로 시스템 상태를 파악하고, 필요에 따라 설정을 조정하는 것이 중요합니다.










## 스레드풀 벌크헤드 (Node.js)

### 1) CPU 작업: worker_threads 풀(Piscina) 예시
```ts
// cpu-pool.ts
import Piscina from 'piscina';
import { resolve } from 'path';

export const cpuPool = new Piscina({
  filename: resolve(__dirname, 'worker.js'),
  minThreads: 2,
  maxThreads: 4,        // 서비스 중요도에 따라 상한을 다르게
  idleTimeout: 10_000,
});

// 사용
// const result = await cpuPool.run({ n: 1e8 });
```

```js
// worker.js
module.exports = ({ n }) => {
  let s = 0;
  for (let i = 0; i < n; i++) s += i;
  return s;
};
```

핵심 포인트
- CPU 집약 작업은 별도 스레드풀로 격리해 메인 이벤트루프를 보호
- 최대 스레드 수를 기능 단위로 다르게 잡아 파급 최소화

### 2) I/O 작업: 동시성 상한(p-limit)로 격리
```ts
// io-bulkhead.ts
import pLimit from 'p-limit';
import axios from 'axios';

const limit = pLimit(10); // 엔드포인트별 동시 호출 상한

export async function fetchSafely(urls: string[]) {
  return Promise.all(
    urls.map((u) => limit(() => axios.get(u, { timeout: 800 })))
  );
}
```

---

