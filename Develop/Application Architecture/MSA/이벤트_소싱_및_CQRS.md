---
title: 이벤트 소싱과 CQRS 개념 정리
tags: [backend, event-sourcing, cqrs, distributed-system]
updated: 2025-12-24
---

# 이벤트 소싱과 CQRS 개념 정리

## 범위

이 문서는 이벤트 소싱과 CQRS를 **왜 쓰는지**, **언제 쓰지 말아야 하는지**를 정리한다.  
구현 예제나 코드 구조 설명은 최소화하고, 개념과 판단 기준 위주로 정리한다.

실무에서 이 패턴들을 도입할지 말지 결정할 때 참고하는 용도다.

---

## 분산 시스템에서 상태 관리가 어려운 이유

서비스가 분리되면 상태 변경이 여러 저장소에 흩어진다.

- 하나의 요청이 여러 서비스 상태를 바꾼다
- 일부 단계만 성공할 수 있다
- 같은 요청이 중복으로 들어올 수 있다
- 순서가 바뀐 이벤트가 도착할 수 있다

이 상태에서 “현재 상태가 무엇인지”를 단일 테이블로 표현하기가 어려워진다.  
이벤트 소싱과 CQRS는 이 문제를 다른 방향에서 해결한다.

---

## 이벤트 소싱(Event Sourcing)

### 핵심 개념

이벤트 소싱은 **상태를 저장하지 않고, 상태 변경 내역만 저장**한다.

- 현재 상태 = 과거 이벤트들을 순서대로 재생한 결과
- 데이터의 원본은 항상 이벤트다
- 테이블에 있는 상태 값은 파생 데이터다

### 기존 방식과의 차이

기존 CRUD 모델은 “현재 값”만 남긴다.

- 주문 상태: PAID
- 결제 금액: 50,000

이벤트 소싱에서는 이렇게 남는다.

- 주문 생성됨
- 결제 요청됨
- 결제 완료됨

상태는 결과이고, 원인은 이벤트다.

---

## 이벤트 소싱을 쓰는 이유

### 상태 변경 이력을 정확히 남겨야 할 때

- 금액, 포인트, 정산, 회계
- 주문 흐름, 상태 변경이 중요한 도메인
- 장애 발생 시 과거 상태를 재현해야 하는 경우

이벤트 소싱은 “왜 이 상태가 되었는지”를 항상 설명할 수 있다.

### 비즈니스 규칙이 자주 바뀌는 경우

과거 이벤트를 다시 해석해 다른 뷰를 만들 수 있다.

- 새로운 통계 기준
- 새로운 상태 분류
- 과거 데이터 재처리

이벤트 자체는 바뀌지 않는다.

---

## 이벤트 소싱을 쓰면 생기는 부담

### 읽기 성능

이벤트가 많아질수록 상태 복원이 느려진다.  
그래서 스냅샷이나 별도 읽기 모델이 필요해진다.

### 설계 난이도

- 이벤트 스키마 변경
- 이벤트 버전 관리
- 재처리 시 멱등성

초기에 단순 CRUD보다 설계 부담이 크다.

### 운영 복잡도

- 이벤트 중복
- 순서 뒤집힘
- 일부 이벤트만 처리된 상태

이걸 감당할 준비가 되어 있어야 한다.

---

## CQRS(Command Query Responsibility Segregation)

### 핵심 개념

CQRS는 **쓰기(Command)** 와 **읽기(Query)** 를 분리한다.

- 쓰기 모델: 도메인 규칙 중심
- 읽기 모델: 조회 성능 중심

하나의 데이터 모델로 둘 다 해결하지 않는다.

---

## CQRS를 쓰는 이유

### 읽기와 쓰기의 성격이 다를 때

- 쓰기는 복잡한 검증과 규칙이 많다
- 읽기는 단순 조회, 리스트, 통계가 많다

같은 테이블로 처리하면 어느 쪽도 만족시키기 어렵다.

### 읽기 트래픽이 압도적으로 많을 때

- 읽기 전용 DB
- 캐시 친화적 구조
- 조인 최소화

쓰기 모델과 분리하면 조회 구조를 자유롭게 바꿀 수 있다.

---

## CQRS에서 흔히 생기는 오해

### “무조건 이벤트 소싱이 필요하다”

아니다. CQRS는 이벤트 소싱 없이도 가능하다.

- 쓰기는 RDB 트랜잭션
- 읽기는 조회 전용 테이블

이벤트 소싱은 선택 사항이다.

### “CQRS = 마이크로서비스”

아니다. 모놀리식에서도 CQRS는 쓸 수 있다.  
서비스 분리 여부와 직접적인 연관은 없다.

---

## 이벤트 소싱 + CQRS 조합

이 조합은 이런 형태가 된다.

- 이벤트 소싱: 쓰기 모델의 진실
- 프로젝션: 이벤트를 읽기 모델로 변환
- CQRS: 읽기/쓰기 경로 분리

이 구조는 다음을 전제로 한다.

- 읽기 지연을 허용한다
- 최종 일관성을 받아들인다
- 상태 불일치가 잠시 존재할 수 있다

---

## 도입 판단 기준

### 쓰는 게 맞는 경우

- 상태 변경 이력이 중요하다
- 장애 재현이 잦다
- 비즈니스 규칙이 자주 바뀐다
- 단순 CRUD로 설명이 안 된다

### 쓰지 말아야 하는 경우

- 단순 게시판, 설정 관리
- 트랜잭션 범위가 작다
- 팀에 운영 여력이 없다
- 빠른 개발이 최우선이다

패턴은 문제를 해결할 때 쓰는 도구다.  
도입 자체가 목표가 되면 실패한다.

---

## 정리

- 이벤트 소싱은 상태가 아니라 **변화**를 저장한다
- CQRS는 읽기와 쓰기를 **역할 기준으로 분리**한다
- 둘은 독립적이지만 같이 쓰이는 경우가 많다
- 운영 복잡도를 감당할 수 있을 때만 선택해야 한다

이 패턴들은 시스템을 “단순하게” 만들지 않는다.  
대신 **설명 가능한 시스템**을 만든다.
