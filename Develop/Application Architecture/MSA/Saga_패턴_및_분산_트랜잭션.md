---
title: Saga 패턴 및 분산 트랜잭션
tags: [backend, saga, distributed-transaction, choreography, orchestration, outbox, idempotency, compensation]
updated: 2025-12-24
---

# Saga 패턴 및 분산 트랜잭션

## 목차

1. 범위
2. 분산 트랜잭션에서 실제로 필요한 것
3. Saga 패턴
4. Choreography Saga
5. Orchestration Saga
6. 보상 트랜잭션
7. 상태 저장과 재처리
8. 2PC/3PC를 운영에서 피하는 이유
9. 메시지 설계 포인트
10. 관측과 장애 대응
11. 테스트

---

## 범위

서비스가 분리되면 하나의 DB 트랜잭션으로는 끝나지 않습니다.  
주문, 결제, 재고, 배송이 각각 다른 저장소를 가진 순간부터 “부분 성공”이 기본 상태입니다.

이 문서는 아래를 다룹니다.

- Saga로 분산 트랜잭션을 운영 가능한 형태로 만든다
- 실패했을 때 어떤 상태가 남고, 누가 어디서 복구하는지 정한다
- 재시도, 중복, 순서, 지연 때문에 생기는 사고를 줄인다

코드는 최소로 두고 운영 관점으로 정리합니다.

---

## 분산 트랜잭션에서 실제로 필요한 것

분산 트랜잭션 문제는 결국 4가지로 축약됩니다.

- 단계가 일부만 성공한다
- 같은 단계가 중복 실행된다
- 단계 실행 순서가 바뀐다
- 외부 의존성 때문에 오래 걸리거나 실패한다

“원자성”을 시스템 전체에서 만들려는 시도는 대부분 비용이 큽니다.  
운영에서는 “일관성은 늦게 맞춘다”를 전제로, 실패와 지연을 관리합니다.

---

## Saga 패턴

Saga는 긴 트랜잭션을 단계로 쪼개고, 각 단계의 실패를 보상 단계로 되돌립니다.

- 각 단계는 로컬 트랜잭션으로 끝납니다.
- 단계 사이 연결은 메시지(이벤트)로 이어집니다.
- 실패는 보상 트랜잭션으로 수습합니다.

Saga를 넣는다고 자동으로 안정해지지 않습니다.  
운영에서 문제 되는 지점은 “상태가 어디에 남는가”, “재시도 시 어디서 재개하는가”입니다.

---

## Choreography Saga

### 형태

중앙 오케스트레이터 없이 각 서비스가 이벤트를 구독하고 다음 이벤트를 발행합니다.

- 주문 서비스: `OrderCreated` 발행
- 결제 서비스: `OrderCreated` 수신 → 결제 처리 → `PaymentCompleted` 또는 `PaymentFailed` 발행
- 재고 서비스: `PaymentCompleted` 수신 → 재고 예약 → `InventoryReserved` 또는 `InventoryFailed` 발행
- 배송 서비스: `InventoryReserved` 수신 → 배송 생성 → `ShippingCreated` 또는 `ShippingFailed` 발행

### 장점

- 서비스가 느슨하게 연결됩니다.
- 중앙 장애 지점이 없습니다.
- 특정 단계가 늘어도 구조가 단순하게 보일 때가 있습니다.

### 운영에서 자주 터지는 문제

1) 이벤트 흐름이 커지면 “누가 전체 진행을 책임지는지”가 사라집니다.  
   장애 대응 때 가장 먼저 나오는 질문이 “이 주문 지금 어디까지 갔냐”입니다. 이 답을 낼 수 있는 곳이 없습니다.

2) 스키마 변경 시 배포 순서가 꼬이면 소비자가 죽습니다.  
   이벤트를 “서버 간 API”처럼 쓰는 순간부터 배포 순서 사고가 납니다.

3) 보상이 여러 서비스에 흩어져서 실패 복구가 어렵습니다.  
   결제 취소는 됐는데 재고 복구가 안 됐다 같은 상태가 남습니다.

### Choreography를 유지하려면

- 이벤트 기준으로 “단계 상태”를 조회할 수 있어야 합니다.
- 이벤트 버전과 하위 호환 처리가 들어가야 합니다.
- 보상 이벤트도 정상 이벤트처럼 관측되어야 합니다.

운영 현실에서는 결국 “진행 상태 조회를 위한 별도 저장소”가 필요해지는 경우가 많습니다.

---

## Orchestration Saga

### 형태

오케스트레이터가 단계를 호출(메시지로 명령을 내리거나 동기 호출)하고, 결과를 보고 다음 단계로 진행합니다.

오케스트레이터가 하는 일은 단순합니다.

- 현재 단계가 무엇인지 저장
- 다음 단계 실행 요청
- 실패 시 보상 단계 실행
- 재시도/타임아웃/중단 상태 관리

### 장점

- “현재 어디까지 진행됐는지”를 한 곳에서 볼 수 있습니다.
- 실패 시 보상 호출 순서가 고정됩니다.
- 운영 대응이 빠릅니다. 재처리도 통제 가능합니다.

### 운영에서 자주 터지는 문제

1) 오케스트레이터가 병목이 됩니다.  
   트래픽이 커지면 오케스트레이터 DB가 먼저 터집니다. 상태 저장이 잦기 때문입니다.

2) 오케스트레이터 장애 시 “멈춘 사가”가 생깁니다.  
   사가 상태가 저장돼 있어도 워커가 다시 돌릴 수 있어야 합니다.

3) 오케스트레이터가 동기 호출을 섞기 시작하면 장애 전파가 되살아납니다.  
   결제/재고/배송을 HTTP로 직렬 호출하면 다시 모놀리식처럼 터집니다.

### 운영에서 많이 쓰는 타협

- 오케스트레이터는 상태 저장과 명령 발행만 합니다.
- 실제 실행은 큐 소비자가 합니다.
- 결과는 이벤트로 돌아옵니다.
- 오케스트레이터는 결과 이벤트를 보고 상태를 전진시킵니다.

---

## 보상 트랜잭션

보상은 “되돌리기”가 아니라 “상태를 수습하기”입니다.  
완벽하게 롤백이 안 되는 단계가 많습니다.

예시가 이렇습니다.

- 결제 승인: 취소/환불로 수습 가능
- 재고 예약: 해제로 수습 가능
- 배송 생성: 취소 가능하지만 이미 출고되면 취소가 의미 없습니다
- 포인트 적립: 회수로 수습 가능하지만 일부는 불가능할 수 있습니다

보상 설계에서 실제로 중요한 포인트는 3가지입니다.

### 1) 보상 가능 기간

결제 취소는 “승인 후 N분” 제약이 있는 경우가 많습니다.  
배송 취소는 출고 상태에 따라 갈립니다.

보상 가능 기간이 지나면 “인간 개입 프로세스”가 필요합니다.  
이걸 정의하지 않으면 장애 대응이 끝나지 않습니다.

### 2) 보상 순서

보상은 성공한 단계의 역순이 기본입니다.  
실무에서는 역순이 깨지는 케이스가 있습니다.

- 재고 해제보다 결제 취소를 먼저 해야 하는 정책
- 배송 취소가 안 되면 결제 환불을 막아야 하는 정책

보상 순서는 비즈니스 정책으로 고정돼야 합니다.  
운영 중에 바꾸면 기존 사가와 충돌합니다.

### 3) 보상도 멱등해야 함

보상 이벤트도 중복이 생깁니다.  
보상 로직도 멱등하지 않으면 “보상 때문에” 사고가 납니다.

---

## 상태 저장과 재처리

사가가 운영 가능한지 여부는 “상태 저장”에서 결정됩니다.

### 상태가 없는 사가가 만드는 사고

- 이벤트는 흘렀는데 소비자가 죽었습니다.
- 중간 단계가 실패했습니다.
- 누군가 수동 재처리하려고 합니다.

이때 상태 저장이 없으면 결국 로그를 보고 추측합니다.  
운영에서 가장 위험한 형태입니다.

### 상태 저장을 할 때 필요한 필드

- saga_id
- business_key(order_id 같은 값)
- current_step
- status(RUNNING/COMPLETED/FAILED/COMPENSATING/STOPPED)
- started_at, updated_at
- last_error
- retry_count
- step_history(최소한 단계별 결과)

상태 저장소는 RDB가 제일 단순합니다.  
중요한 것은 “조회가 빨라야 한다” 입니다. 운영 대응 화면이 필요해집니다.

### 재처리 방식

사가 재처리는 2가지로 나뉩니다.

- 같은 단계 재시도
- 보상 단계 재시도

두 경우를 구분해야 합니다.  
“실패한 메시지 재발행”으로 퉁치면 중복이 커집니다.

---

## 2PC/3PC를 운영에서 피하는 이유

2PC는 준비(prepare)와 커밋(commit) 단계를 분리합니다.  
운영에서는 아래 이유로 부담이 큽니다.

- 코디네이터 장애 시 참여자가 “준비 상태”로 묶입니다.
- 네트워크 분할에서 처리가 멈출 수 있습니다.
- 참여 서비스가 늘어날수록 실패 지점이 늘어납니다.

3PC는 2PC의 블로킹 문제를 줄이려는 시도지만, 구현과 운영 복잡도가 더 커집니다.  
현장에서는 Saga로 “부분 성공을 관리”하는 쪽이 더 현실적인 경우가 많습니다.

---

## 메시지 설계 포인트

Saga는 메시지 설계가 허술하면 바로 깨집니다.

### 이벤트/명령 구분

- 명령(Command): “해라”에 가깝습니다. 실패하면 재시도를 강하게 합니다.
- 이벤트(Event): “됐다/안됐다”에 가깝습니다. 소비자가 여러 명일 수 있습니다.

오케스트레이션은 명령이 많고, 코레오그래피는 이벤트가 많습니다.

### 상관관계 키

사가 디버깅은 결국 “같은 트랜잭션 묶음”을 찾는 작업입니다.

- saga_id
- correlation_id
- business_key(order_id)

이 3개가 메시지에 들어가야 합니다.

### 스키마 버전

이벤트 버전이 없으면 배포 순서 사고가 납니다.  
버전은 메시지 헤더든 바디든 한 곳에 고정해야 합니다.

---

## 관측과 장애 대응

### 사가 관측에서 봐야 하는 것

- 진행 중 사가 수
- 실패 사가 수
- 단계별 평균 소요 시간
- 단계별 실패율
- 보상 진행 중 사가 수
- 보상 실패 사가 수
- 특정 단계에서 오래 멈춘 사가 수

“큐 적체”만 보면 늦습니다.  
사가 상태 기준으로 봐야 실제 사용자 영향 구간을 찾습니다.

### 멈춘 사가

멈춘 사가는 대부분 이 패턴입니다.

- 오케스트레이터는 단계 요청을 보냈다
- 워커가 받았는데 처리 중 죽었다
- 결과 이벤트가 오지 않는다

이 경우는 “타임아웃 후 재발행”이 필요합니다.  
타임아웃 값을 정할 때 외부 의존성 최대 지연을 반영해야 합니다.

### 운영 대응 루틴

- 해당 order_id/saga_id 기준 현재 단계 확인
- 해당 단계 워커 로그 확인
- 외부 의존성 상태 확인
- 재시도 가능한 실패인지 판단
- 보상으로 전환할지 판단
- 수동 개입이 필요한지 분기

사가 운영은 결국 “분기”입니다. 자동화가 안 되는 구간이 남습니다.

---

## 테스트

### 실패 주입

사가 테스트는 성공 시나리오보다 실패 시나리오가 더 중요합니다.

- 결제 승인 성공 후 재고 실패
- 재고 성공 후 배송 실패
- 배송 요청 직후 워커 다운
- 동일 order_id 중복 요청
- 메시지 중복 전달
- 이벤트 순서 뒤집힘

### 멱등성 검증

- 동일 이벤트를 2회 이상 흘렸을 때 결과가 1회와 같아야 합니다.
- 보상 이벤트도 동일하게 검증해야 합니다.

### 타임아웃 검증

- 처리 시간을 일부러 늘려 타임아웃 동작을 확인합니다.
- 타임아웃 후 재발행이 중복 처리로 이어지지 않는지 확인합니다.

---
