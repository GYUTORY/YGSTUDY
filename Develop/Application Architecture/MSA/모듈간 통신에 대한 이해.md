---
title: MSA에서 모듈 간 통신에 대한 이해
tags: [msa, microservices, communication, api, messaging, architecture]
updated: 2024-12-19
---

# MSA에서 모듈 간 통신에 대한 이해

## 배경

### MSA에서 모듈 간 통신의 필요성
MSA에서는 각 서비스가 독립적으로 배포되며 서로 다른 프로세스에서 실행됩니다. 따라서, 서비스를 통합하고 협력시키기 위해 통신 메커니즘이 필요합니다.

### 통신 방식의 분류
1. **동기식 통신**
    - **HTTP/REST API**: 가장 일반적인 방식으로, 클라이언트가 요청을 보내고 응답을 받음.
    - **gRPC**: 고성능 원격 프로시저 호출(RPC) 프레임워크.

2. **비동기식 통신**
    - **메시지 큐(Message Queue)**: RabbitMQ, Kafka와 같은 메시지 브로커를 통해 서비스 간 메시지 전달.
    - **이벤트 기반(Event-Driven)**: 서비스가 이벤트를 발행하고 구독하여 비동기적으로 처리.

### 모듈 간 통신이 중요한 이유
1. **독립성 유지**
    - 각 서비스는 독립적으로 배포 및 스케일링이 가능해야 하므로 직접 호출보다 명확한 인터페이스가 필요합니다.

2. **확장성**
    - 동기/비동기 통신 방식을 통해 서비스 간 부하 분산 및 확장이 용이합니다.

3. **고가용성**
    - 한 서비스의 장애가 다른 서비스로 전파되지 않도록 설계 가능합니다.

4. **유연한 개발**
    - 다양한 프로그래밍 언어와 프레임워크를 활용한 개발이 가능하며, 통신 규격만 맞추면 됩니다.

## 핵심

### 통신 방식의 선택 기준
1. **실시간성**
    - 실시간성이 중요할 경우: REST API, gRPC 사용.
    - 지연 허용 가능: 메시지 큐 사용.

2. **데이터 일관성**
    - 강한 일관성 필요: 동기식 통신.
    - 최종 일관성 허용: 비동기식 통신.

3. **성능**
    - 낮은 지연 시간: gRPC.
    - 높은 처리량: Kafka.

### 서비스 구성 예시

#### 전자상거래 플랫폼
1. **사용자 서비스**
   - 사용자 계정 관리
   - 인증/인가 처리
   - 프로필 정보 관리
   - 포인트/쿠폰 관리

2. **상품 서비스**
   - 상품 정보 관리
   - 재고 관리
   - 카테고리 관리
   - 가격 관리

3. **주문 서비스**
   - 주문 생성 및 관리
   - 주문 상태 추적
   - 배송 정보 관리
   - 주문 이력 조회

4. **결제 서비스**
   - 결제 처리
   - 결제 수단 관리
   - 환불 처리
   - 결제 이력 관리

5. **알림 서비스**
   - 이메일 발송
   - SMS 발송
   - 푸시 알림
   - 알림 템플릿 관리

#### 스트리밍 서비스
1. **계정 서비스**
   - 사용자 인증/인가
   - 구독 관리
   - 프로필 관리
   - 결제 정보 관리

2. **콘텐츠 서비스**
   - 비디오 메타데이터 관리
   - 콘텐츠 인코딩/트랜스코딩
   - 콘텐츠 배포 관리
   - 콘텐츠 권한 관리

3. **추천 서비스**
   - 사용자 선호도 분석
   - 콘텐츠 추천 알고리즘
   - 실시간 추천 처리
   - A/B 테스트 관리

4. **재생 서비스**
   - 스트리밍 세션 관리
   - CDN 라우팅
   - 화질 자동 조절
   - 재생 이력 관리

5. **분석 서비스**
   - 사용자 행동 분석
   - 콘텐츠 인기도 분석
   - 실시간 시청자 통계
   - 성능 모니터링

## 예시

### 동기식 통신 예제 (REST API)

#### 주문 서비스 (Node.js)
```javascript
const express = require('express');
const axios = require('axios');
const app = express();

app.use(express.json());

class OrderService {
  constructor() {
    this.orders = new Map();
  }
  
  async createOrder(orderData) {
    try {
      // 재고 서비스 호출
      const stockResponse = await axios.get(`http://localhost:4000/stock/${orderData.productId}`);
      
      if (!stockResponse.data.available) {
        throw new Error('상품이 품절입니다');
      }
      
      // 결제 서비스 호출
      const paymentResponse = await axios.post('http://localhost:5000/payment', {
        amount: orderData.amount,
        userId: orderData.userId
      });
      
      if (!paymentResponse.data.success) {
        throw new Error('결제에 실패했습니다');
      }
      
      // 주문 생성
      const orderId = Date.now().toString();
      const order = {
        id: orderId,
        ...orderData,
        status: 'confirmed',
        createdAt: new Date()
      };
      
      this.orders.set(orderId, order);
      
      // 알림 서비스 호출 (비동기)
      axios.post('http://localhost:6000/notify', {
        type: 'order_confirmed',
        userId: orderData.userId,
        orderId: orderId
      }).catch(err => console.error('알림 전송 실패:', err));
      
      return order;
    } catch (error) {
      throw new Error(`주문 생성 실패: ${error.message}`);
    }
  }
  
  async getOrder(orderId) {
    return this.orders.get(orderId);
  }
}

const orderService = new OrderService();

app.post('/order', async (req, res) => {
  try {
    const order = await orderService.createOrder(req.body);
    res.json(order);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

app.get('/order/:id', async (req, res) => {
  const order = await orderService.getOrder(req.params.id);
  if (!order) {
    return res.status(404).json({ error: '주문을 찾을 수 없습니다' });
  }
  res.json(order);
});

app.listen(3000, () => console.log('주문 서비스가 포트 3000에서 실행 중'));
```

#### 재고 서비스 (Node.js)
```javascript
const express = require('express');
const app = express();

class StockService {
  constructor() {
    this.stock = new Map();
    this.stock.set('1', 10);
    this.stock.set('2', 0);
    this.stock.set('3', 5);
  }
  
  checkStock(productId) {
    const quantity = this.stock.get(productId) || 0;
    return { available: quantity > 0, quantity };
  }
  
  decreaseStock(productId, amount = 1) {
    const currentStock = this.stock.get(productId) || 0;
    if (currentStock < amount) {
      throw new Error('재고가 부족합니다');
    }
    this.stock.set(productId, currentStock - amount);
    return { available: true, quantity: currentStock - amount };
  }
}

const stockService = new StockService();

app.get('/stock/:productId', (req, res) => {
  const productId = req.params.productId;
  const stockInfo = stockService.checkStock(productId);
  res.json(stockInfo);
});

app.post('/stock/:productId/decrease', (req, res) => {
  try {
    const productId = req.params.productId;
    const amount = req.body.amount || 1;
    const result = stockService.decreaseStock(productId, amount);
    res.json(result);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

app.listen(4000, () => console.log('재고 서비스가 포트 4000에서 실행 중'));
```

### 비동기식 통신 예제 (메시지 큐)

#### 메시지 브로커 설정 (Redis)
```javascript
const Redis = require('ioredis');
const redis = new Redis();

class MessageBroker {
  async publish(channel, message) {
    await redis.publish(channel, JSON.stringify(message));
  }
  
  async subscribe(channel, callback) {
    const subscriber = new Redis();
    await subscriber.subscribe(channel);
    
    subscriber.on('message', (ch, message) => {
      callback(JSON.parse(message));
    });
  }
}

module.exports = { MessageBroker };
```

#### 주문 서비스에서 이벤트 발행
```javascript
const { MessageBroker } = require('./messageBroker');
const messageBroker = new MessageBroker();

app.post('/order', async (req, res) => {
  try {
    const order = await orderService.createOrder(req.body);
    
    // 주문 생성 이벤트 발행
    await messageBroker.publish('order.created', {
      orderId: order.id,
      userId: order.userId,
      productId: order.productId,
      amount: order.amount,
      timestamp: new Date()
    });
    
    res.json(order);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});
```

#### 알림 서비스에서 이벤트 구독
```javascript
const { MessageBroker } = require('./messageBroker');
const messageBroker = new MessageBroker();

class NotificationService {
  constructor() {
    this.setupEventHandlers();
  }
  
  setupEventHandlers() {
    // 주문 생성 이벤트 구독
    messageBroker.subscribe('order.created', async (event) => {
      await this.sendOrderConfirmation(event);
    });
    
    // 결제 완료 이벤트 구독
    messageBroker.subscribe('payment.completed', async (event) => {
      await this.sendPaymentConfirmation(event);
    });
  }
  
  async sendOrderConfirmation(event) {
    console.log('주문 확인 알림 발송:', event);
    // 이메일 발송 로직
    await this.sendEmail(event.userId, '주문이 확인되었습니다', {
      orderId: event.orderId,
      amount: event.amount
    });
  }
  
  async sendPaymentConfirmation(event) {
    console.log('결제 완료 알림 발송:', event);
    // SMS 발송 로직
    await this.sendSMS(event.userId, '결제가 완료되었습니다');
  }
  
  async sendEmail(userId, subject, data) {
    // 이메일 발송 구현
    console.log(`이메일 발송: ${userId}에게 ${subject}`);
  }
  
  async sendSMS(userId, message) {
    // SMS 발송 구현
    console.log(`SMS 발송: ${userId}에게 ${message}`);
  }
}

const notificationService = new NotificationService();
```

### API 게이트웨이 예제
```javascript
const express = require('express');
const { createProxyMiddleware } = require('http-proxy-middleware');
const app = express();

// 서비스 라우팅 설정
const services = {
  'user-service': 'http://localhost:3001',
  'order-service': 'http://localhost:3000',
  'stock-service': 'http://localhost:4000',
  'payment-service': 'http://localhost:5000',
  'notification-service': 'http://localhost:6000'
};

// 동적 프록시 미들웨어
app.use('/api/:service/*', (req, res, next) => {
  const serviceName = req.params.service;
  const serviceUrl = services[serviceName];
  
  if (!serviceUrl) {
    return res.status(404).json({ error: '서비스를 찾을 수 없습니다' });
  }
  
  // 프록시 설정
  const proxy = createProxyMiddleware({
    target: serviceUrl,
    changeOrigin: true,
    pathRewrite: {
      [`^/api/${serviceName}`]: ''
    },
    onError: (err, req, res) => {
      console.error(`프록시 오류 (${serviceName}):`, err);
      res.status(503).json({ error: '서비스가 일시적으로 사용할 수 없습니다' });
    }
  });
  
  proxy(req, res, next);
});

// 헬스 체크 엔드포인트
app.get('/health', async (req, res) => {
  const healthStatus = {};
  
  for (const [serviceName, serviceUrl] of Object.entries(services)) {
    try {
      const response = await axios.get(`${serviceUrl}/health`);
      healthStatus[serviceName] = response.status === 200 ? 'healthy' : 'unhealthy';
    } catch (error) {
      healthStatus[serviceName] = 'unhealthy';
    }
  }
  
  res.json(healthStatus);
});

app.listen(8080, () => {
  console.log('API 게이트웨이가 포트 8080에서 실행 중');
});
```

## 운영 팁

### 서비스 간 통신 패턴
1. **주문 프로세스**
   ```
   사용자 → 주문 서비스
   ↓
   주문 서비스 → 상품 서비스 (재고 확인)
   ↓
   주문 서비스 → 결제 서비스 (결제 처리)
   ↓
   결제 서비스 → 알림 서비스 (결제 완료 알림)
   ↓
   주문 서비스 → 상품 서비스 (재고 차감)
   ↓
   주문 서비스 → 알림 서비스 (주문 완료 알림)
   ```

2. **장애 상황 처리**
   - 결제 실패 시: 주문 취소 및 재고 복구
   - 재고 부족 시: 결제 취소 및 알림 발송
   - 서비스 장애 시: Circuit Breaker 패턴으로 장애 격리

### Circuit Breaker 패턴 구현
```javascript
class CircuitBreaker {
  constructor(failureThreshold = 5, timeout = 60000) {
    this.failureThreshold = failureThreshold;
    this.timeout = timeout;
    this.failures = 0;
    this.lastFailureTime = null;
    this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN
  }
  
  async call(serviceCall) {
    if (this.state === 'OPEN') {
      if (Date.now() - this.lastFailureTime > this.timeout) {
        this.state = 'HALF_OPEN';
      } else {
        throw new Error('Circuit breaker is OPEN');
      }
    }
    
    try {
      const result = await serviceCall();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }
  
  onSuccess() {
    this.failures = 0;
    this.state = 'CLOSED';
  }
  
  onFailure() {
    this.failures++;
    this.lastFailureTime = Date.now();
    
    if (this.failures >= this.failureThreshold) {
      this.state = 'OPEN';
    }
  }
}

// 사용 예시
const circuitBreaker = new CircuitBreaker();

app.post('/order', async (req, res) => {
  try {
    const order = await circuitBreaker.call(async () => {
      return await orderService.createOrder(req.body);
    });
    res.json(order);
  } catch (error) {
    res.status(503).json({ error: '서비스가 일시적으로 사용할 수 없습니다' });
  }
});
```

### 실시간 처리 예시
```javascript
// 콘텐츠 재생 프로세스
/*
사용자 → 계정 서비스 (인증)
↓
계정 서비스 → 콘텐츠 서비스 (접근 권한 확인)
↓
콘텐츠 서비스 → 재생 서비스 (스트리밍 세션 생성)
↓
재생 서비스 → 분석 서비스 (시청 시작 로깅)
↓
재생 서비스 → 추천 서비스 (관련 콘텐츠 추천)
*/

// 실시간 처리
- 시청자 수 실시간 집계
- 인기 콘텐츠 실시간 업데이트
- 서버 부하 실시간 모니터링
- 장애 상황 실시간 감지
```

## 참고

### 실제 사례
1. **전자상거래 플랫폼**: 주문, 결제, 재고, 알림 서비스 간 복잡한 통신
2. **스트리밍 서비스**: 실시간 콘텐츠 전송과 사용자 행동 분석
3. **금융 서비스**: 보안이 중요한 거래 처리와 실시간 모니터링

### 결론
MSA에서 모듈 간 통신은 서비스 간 협력을 가능하게 하며, 독립성, 확장성, 고가용성을 보장합니다.
REST API, 메시지 큐, gRPC 등 다양한 통신 방식이 존재하며, 서비스의 요구 사항에 따라 적절한 방식을 선택해야 합니다.
실제 사례를 통해 MSA의 필요성과 장점을 이해할 수 있으며, 적절한 통신 패턴과 장애 처리 방안을 구현하는 것이 중요합니다.

