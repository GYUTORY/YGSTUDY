---
title: 클라우드 네이티브 개발 (Cloud Native Development)
tags: [Cloud]
updated: 2025-12-18
---

# 클라우드 네이티브 개발 (Cloud Native Development)

> **운영·아키텍처 관점 중심 문서**  
> 이 문서는 코드 구현 예제가 아닌 **개념 · 설계 원칙 · 운영 관점**에서 클라우드 네이티브 개발을 체계적으로 정리합니다.  
> 실무에서 “왜 이렇게 설계해야 하는가”에 대한 판단 기준을 제공하는 것을 목표로 합니다.

---

## 목차
1. 클라우드 네이티브란 무엇인가
2. 12-Factor App을 왜 지금도 지켜야 하는가
3. 컨테이너는 패키징 도구가 아니다
4. Kubernetes의 본질적 역할
5. 서비스 메시(Istio)는 언제 필요한가
6. GitOps는 배포 자동화가 아니라 운영 모델이다
7. 클라우드 비용은 기술 문제가 아니라 구조 문제다
8. 실무 체크리스트 요약

---

## 1. 클라우드 네이티브란 무엇인가

클라우드 네이티브는 단순히 **클라우드 위에서 돌아가는 애플리케이션**을 의미하지 않습니다.  
다음 전제를 **처음부터 받아들이는 개발 방식**입니다.

- 서버는 언제든 사라질 수 있다
- 네트워크는 항상 불안정하다
- 장애는 예외가 아니라 일상이다
- 확장은 “사전 계획”이 아니라 “자동 반응”이어야 한다

### 핵심 철학 요약

| 항목 | 전통적 시스템 | 클라우드 네이티브 |
|---|---|---|
| 서버 | 영구 자산 | 소모품 |
| 장애 | 예외 | 전제 |
| 확장 | 수동 | 자동 |
| 배포 | 이벤트 | 일상 |
| 설정 | 코드 내부 | 외부 주입 |

---

## 2. 12-Factor App을 왜 지금도 지켜야 하는가

12-Factor App은 오래된 문서처럼 보이지만,  
**컨테이너·Kubernetes·GitOps의 전제 조건**을 가장 정확하게 정의합니다.

### 핵심은 세 가지입니다

1. **코드는 환경을 몰라야 한다**
2. **상태는 외부에 있어야 한다**
3. **프로세스는 언제든 죽어도 된다**

#### 설정(Config)을 코드에서 분리해야 하는 이유

- 컨테이너 이미지는 반드시 **환경 불변(immutable)** 이어야 합니다
- 동일한 이미지를 dev/staging/prod에 배포해야 합니다
- 환경별 분기는 코드가 아니라 **환경 변수 / Secret / ConfigMap**이 담당해야 합니다

> 설정을 코드로 분기하는 순간,  
> 그 애플리케이션은 클라우드 네이티브가 아닙니다.

---

## 3. 컨테이너는 패키징 도구가 아니다

Docker는 가상머신 대체제가 아닙니다.  
컨테이너의 본질은 **“실행 단위 표준화”** 입니다.

### 컨테이너 설계의 핵심 기준

| 기준 | 설명 |
|---|---|
| 단일 책임 | 컨테이너 하나 = 프로세스 하나 |
| 무상태 | 로컬 디스크에 상태 저장 금지 |
| 빠른 기동 | 수 초 내 기동 가능해야 함 |
| 예측 가능성 | 어디서 실행해도 동일 |

### Multi-stage Build의 진짜 목적

- 이미지 용량 감소 ❌
- **공격 표면 감소 + 재현성 확보** ✅

빌드 도구, 테스트 도구, 패키지 매니저는  
**런타임 컨테이너에 존재하면 안 됩니다.**

---

## 4. Kubernetes의 본질적 역할

Kubernetes는 컨테이너 실행기가 아닙니다.  
**“의도한 상태(desired state)를 유지하는 제어 시스템”** 입니다.

### Kubernetes가 대신 해주는 것

- 프로세스 헬스 감시
- 장애 발생 시 자동 재기동
- 트래픽 분산
- 선언된 스케일 유지
- 롤링 업데이트 보장

### Deployment를 사용하는 이유

> “이 파드는 항상 3개여야 한다”

이 문장을 사람이 지키는 것이 아니라  
**컨트롤러가 지속적으로 강제**하도록 만드는 것이 핵심입니다.

---

## 5. 서비스 메시(Istio)는 언제 필요한가

Istio는 **복잡한 마이크로서비스 환경에서만** 의미가 있습니다.

### Istio가 필요한 조건

- 서비스 간 호출이 많다
- 장애 전파를 제어해야 한다
- 트래픽 비율 배포(Canary, Blue/Green)가 필요하다
- 인증·인가를 네트워크 레벨에서 통제해야 한다

### Istio의 역할 요약

| 영역 | 설명 |
|---|---|
| 트래픽 | 라우팅, 재시도, 타임아웃 |
| 안정성 | 서킷 브레이커 |
| 보안 | mTLS, 서비스 간 인증 |
| 관찰성 | 메트릭·트레이싱 자동 수집 |

> 단일 서비스나 소규모 시스템에서는  
> **운영 복잡도만 증가**할 수 있습니다.

---

## 6. GitOps는 배포 자동화가 아니라 운영 모델이다

GitOps의 핵심은 “자동 배포”가 아닙니다.  
**운영의 단일 진실 공급원(Single Source of Truth)** 입니다.

### GitOps의 본질

- Git에 있는 상태 = 실제 클러스터 상태
- 수동 kubectl 수정 금지
- 모든 변경은 PR로 기록
- 롤백은 git revert

### GitOps 도입 효과

| 항목 | 효과 |
|---|---|
| 감사 | 누가 언제 무엇을 변경했는지 명확 |
| 복구 | 클러스터 장애 시 즉시 재현 |
| 표준화 | 환경 간 편차 제거 |
| 안정성 | Drift 자동 감지 |

---

## 7. 클라우드 비용은 기술 문제가 아니라 구조 문제다

비용 최적화는 **나중에 하는 작업이 아닙니다.**  
아키텍처 선택의 결과입니다.

### 비용이 폭증하는 대표적 원인

- 요청 대비 과도한 리소스 요청
- 상태ful 서비스의 무분별한 확장
- 스케일링 기준 부재
- 로그/메트릭 무제한 수집

### 반드시 지켜야 할 원칙

- requests는 “최소 생존값”
- limits는 “최대 허용값”
- HPA는 CPU가 아니라 **실제 병목 지표** 기준
- 스팟 인스턴스는 Stateless 워크로드에만 사용


---

## 결론

클라우드 네이티브는  
**도구의 집합이 아니라 사고방식의 전환**입니다.

- Docker는 시작일 뿐이고
- Kubernetes는 기본값이며
- GitOps는 선택이 아니라 필수에 가깝고
- 비용은 구조의 결과입니다

이 관점을 기준으로 설계하지 않으면  
클라우드는 결국 **비싸고 불안정한 서버 호스팅**이 됩니다.

---

문서 작성일: 2025-12-16
