---
title: 서버 간 통신 방식 정리
tags: [backend, server-communication, http, rpc, messaging, websocket, grpc]
updated: 2025-12-17
---

# 서버 간 통신 방식 실전 정리

## 목차

1. 개요
2. HTTP 기반 통신
3. RPC 기반 통신
4. 메시지 기반 비동기 통신
5. 실시간 양방향 통신
6. 내부 서비스 통신 설계에서 실제로 겪는 문제
7. 트러블슈팅 사례
8. 테스트 방법
9. 참고 자료

---

## 개요

서버 간 통신 방식은 시스템 구조를 사실상 결정한다.  
초기에는 단순해 보이지만, 트래픽 증가나 장애가 발생하면 선택의 결과가 그대로 드러난다.

실무에서는 단일 방식으로 끝나는 경우가 거의 없다.  
HTTP로 시작하고, 병목이 생긴 구간만 메시지나 RPC로 분리하는 흐름이 일반적이다.

---

## HTTP 기반 통신

### REST API

가장 많이 쓰이는 방식이다. 내부 통신이든 외부 연동이든 기본값에 가깝다.

#### 사용되는 상황

- 인증 서버 호출
- 주문, 결제, 회원 API
- 외부 파트너 연동

#### 예제

```http
POST /internal/orders HTTP/1.1
Content-Type: application/json

{
  "userId": "user-123",
  "items": [
    { "productId": "p1", "quantity": 2 }
  ]
}
```

#### 실무에서 자주 발생하는 문제

- 호출 체인이 길어질수록 지연이 누적된다
- 한 서비스 장애가 다른 서비스 장애로 번진다
- 타임아웃 기준이 제각각이면 장애 원인 추적이 어렵다

#### 운영 시 주의사항

- 내부 통신이라도 타임아웃은 짧게 둔다
- 재시도는 한 곳에서만 한다
- 상태 변경 API는 반드시 로그를 남긴다

---

## RPC 기반 통신

### gRPC

내부 서비스 간 호출 빈도가 높은 경우 선택된다.

#### 사용하는 이유

- 요청/응답 구조가 코드로 고정된다
- JSON 직렬화 비용이 없다
- 대량 호출 시 HTTP 대비 차이가 체감된다

#### proto 예제

```proto
syntax = "proto3";

service OrderService {
  rpc CreateOrder (CreateOrderRequest) returns (CreateOrderResponse);
}

message CreateOrderRequest {
  string userId = 1;
}

message CreateOrderResponse {
  string orderId = 1;
}
```

#### 실제로 겪는 문제

- proto 변경 시 배포 순서가 꼬이면 바로 장애다
- 외부 연동에는 거의 쓸 수 없다
- 로그가 사람이 읽기 어렵다

#### 주의사항

- 외부 API에는 사용하지 않는다
- 필드 삭제보다 deprecated 처리로 간다
- 장애 분석용 로그는 별도로 남긴다

---

## 메시지 기반 비동기 통신

### Queue / Pub-Sub

동기 호출 부담을 줄이기 위해 가장 많이 도입된다.

#### 사용하는 상황

- 주문 후 후처리
- 알림 발송
- 데이터 적재, 로그 수집

#### 흐름 예시

```text
주문 서비스 → 이벤트 발행
재고 서비스 → 이벤트 소비
알림 서비스 → 이벤트 소비
```

#### 운영 중 자주 발생하는 문제

- 메시지 중복 처리
- 순서가 섞인다
- DLQ가 쌓여도 아무도 모른다

#### 필수로 넣어야 하는 것

- 멱등성 키
- 이벤트 버전
- DLQ 모니터링

---

## 실시간 양방향 통신

### WebSocket / SSE

요청-응답 구조로 해결이 안 되는 경우에만 사용한다.

#### 사용하는 상황

- 실시간 알림
- 채팅
- 상태 스트림

#### 문제 포인트

- 서버 재시작 시 연결이 끊긴다
- 스케일 아웃 시 세션 관리가 복잡해진다
- 로드밸런서 설정에 따라 장애가 난다

#### 주의사항

- 서버 메모리에 상태를 두지 않는다
- 클라이언트 재연결 로직은 필수다
- 트래픽이 늘면 메시지 구조로 바뀌는 경우가 많다

---

## 내부 서비스 통신 설계에서 실제로 겪는 문제

### 문제 1. 구조가 과도하게 복잡해짐

초기부터 HTTP, gRPC, 메시지를 동시에 쓰는 경우가 있다.  
결과적으로 신규 인력이 구조를 이해하는 데 시간이 많이 든다.

### 문제 2. 동기 호출 장애 전파

A → B → C 구조에서 C가 느려지면 A까지 영향을 받는다.  
B → C만 메시지로 바꿔도 장애 범위가 줄어든다.

### 문제 3. 이벤트의 주인이 사라짐

누가 발행했고 누가 소비하는지 시간이 지나면 모르게 된다.  
이벤트 스키마와 소비 서비스는 문서로 남겨야 한다.

---

## 트러블슈팅 사례

### HTTP 타임아웃으로 주문 장애 발생

- 주문 서비스가 결제 서비스 호출
- 결제 서비스 지연
- 주문 API 전체 장애

처리 방식
- 결제 요청을 비동기로 전환
- 주문 상태를 `PENDING`으로 분리

---

### 메시지 중복 처리로 데이터 깨짐

- 메시지 재시도 발생
- 멱등성 처리 없음

처리 방식
- 처리 이력 저장
- 이미 처리된 이벤트 무시

---

## 테스트 방법

- HTTP: 계약 테스트
- gRPC: proto 기준 테스트
- 메시지: 소비 로직 단독 테스트

통합 테스트에서는 실제 장애 시나리오를 반드시 재현한다.

---

## 참고 자료

- AWS Architecture Center
- Google gRPC Documentation
- Martin Fowler – Event-Driven Architecture
- Kafka Documentation

---

문서 작성일: 2025-12-16  
최종 업데이트: 2025-12-16
