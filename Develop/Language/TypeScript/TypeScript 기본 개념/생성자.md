---
title: TypeScript 생성자 완벽 가이드
tags: [language, typescript, typescript-기본-개념, constructor, class]
updated: 2025-08-10
---

# TypeScript 생성자 완벽 가이드

## 배경

TypeScript에서 생성자는 클래스의 인스턴스를 초기화하는 특별한 메서드입니다.

### 생성자의 특징
- `constructor` 키워드를 사용하여 정의
- 클래스 내에서 단 하나만 정의 가능
- 클래스의 인스턴스를 생성할 때 자동으로 호출
- 객체의 초기 상태를 설정하는 역할

### 생성자의 필요성
- 객체 생성 시 필요한 데이터를 받아서 초기화
- 인스턴스 속성들의 기본값 설정
- 의존성 주입을 통한 객체 간 관계 설정

## 핵심

### 1. 기본 생성자

#### 단순한 생성자
```typescript
class Person {
    name: string;
    age: number;

    constructor(name: string, age: number) {
        this.name = name;
        this.age = age;
    }

    greet(): void {
        console.log(`안녕하세요, 저는 ${this.name}이고 ${this.age}세입니다.`);
    }
}

const person = new Person('홍길동', 25);
person.greet(); // 안녕하세요, 저는 홍길동이고 25세입니다.
```

#### 매개변수 기본값
```typescript
class User {
    name: string;
    email: string;
    isActive: boolean;

    constructor(name: string, email: string, isActive: boolean = true) {
        this.name = name;
        this.email = email;
        this.isActive = isActive;
    }

    getInfo(): string {
        return `${this.name} (${this.email}) - ${this.isActive ? '활성' : '비활성'}`;
    }
}

const user1 = new User('김철수', 'kim@example.com');
const user2 = new User('이영희', 'lee@example.com', false);

console.log(user1.getInfo()); // 김철수 (kim@example.com) - 활성
console.log(user2.getInfo()); // 이영희 (lee@example.com) - 비활성
```

### 2. 생성자 오버로드

TypeScript는 생성자 오버로드를 지원합니다. 다양한 매개변수 조합으로 객체를 생성할 수 있습니다.

#### 오버로드 시그니처
```typescript
class Person {
    name: string;
    age: number;
    email?: string;

    // 오버로드 시그니처들
    constructor(name: string);
    constructor(name: string, age: number);
    constructor(name: string, age: number, email: string);
    
    // 실제 구현체
    constructor(name: string, age?: number, email?: string) {
        this.name = name;
        this.age = age ?? 0;
        this.email = email;
    }

    describe(): void {
        let description = `${this.name}은(는) ${this.age}세입니다.`;
        if (this.email) {
            description += ` 이메일: ${this.email}`;
        }
        console.log(description);
    }
}

const person1 = new Person('홍길동');
const person2 = new Person('김철수', 30);
const person3 = new Person('이영희', 25, 'lee@example.com');

person1.describe(); // 홍길동은(는) 0세입니다.
person2.describe(); // 김철수은(는) 30세입니다.
person3.describe(); // 이영희은(는) 25세입니다. 이메일: lee@example.com
```

#### 복잡한 오버로드 예제
```typescript
class Product {
    id: string;
    name: string;
    price: number;
    category?: string;

    // 다양한 생성자 시그니처
    constructor(id: string, name: string, price: number);
    constructor(id: string, name: string, price: number, category: string);
    constructor(productData: { id: string; name: string; price: number; category?: string });
    
    // 실제 구현체
    constructor(
        idOrData: string | { id: string; name: string; price: number; category?: string },
        name?: string,
        price?: number,
        category?: string
    ) {
        if (typeof idOrData === 'string') {
            this.id = idOrData;
            this.name = name!;
            this.price = price!;
            this.category = category;
        } else {
            this.id = idOrData.id;
            this.name = idOrData.name;
            this.price = idOrData.price;
            this.category = idOrData.category;
        }
    }

    getInfo(): string {
        let info = `${this.name} (${this.id}) - ${this.price}원`;
        if (this.category) {
            info += ` [${this.category}]`;
        }
        return info;
    }
}

// 다양한 방식으로 객체 생성
const product1 = new Product('P001', '노트북', 1500000);
const product2 = new Product('P002', '마우스', 50000, '액세서리');
const product3 = new Product({
    id: 'P003',
    name: '키보드',
    price: 100000,
    category: '액세서리'
});

console.log(product1.getInfo()); // 노트북 (P001) - 1500000원
console.log(product2.getInfo()); // 마우스 (P002) - 50000원 [액세서리]
console.log(product3.getInfo()); // 키보드 (P003) - 100000원 [액세서리]
```

### 3. 접근 제한자와 생성자

#### 매개변수 속성
```typescript
class User {
    constructor(
        public name: string,
        public email: string,
        private password: string,
        protected role: string = 'user'
    ) {
        // 매개변수 속성을 사용하면 자동으로 인스턴스 속성이 생성됩니다
    }

    getInfo(): string {
        return `${this.name} (${this.email}) - ${this.role}`;
    }

    changePassword(newPassword: string): void {
        this.password = newPassword;
        console.log('비밀번호가 변경되었습니다.');
    }
}

const user = new User('홍길동', 'hong@example.com', 'secret123', 'admin');
console.log(user.getInfo()); // 홍길동 (hong@example.com) - admin
user.changePassword('newSecret456');
```

#### 읽기 전용 속성
```typescript
class Configuration {
    constructor(
        public readonly apiUrl: string,
        public readonly timeout: number,
        public readonly retries: number = 3
    ) {
        // readonly 속성은 생성자에서만 설정 가능
    }

    getConfig(): object {
        return {
            apiUrl: this.apiUrl,
            timeout: this.timeout,
            retries: this.retries
        };
    }
}

const config = new Configuration('https://api.example.com', 5000);
console.log(config.getConfig());

// config.apiUrl = 'https://new-api.example.com'; // 컴파일 에러!
```

## 예시

### 1. 실제 사용 사례

#### 데이터베이스 연결 클래스
```typescript
class DatabaseConnection {
    private connection: any;
    private isConnected: boolean = false;

    constructor(
        private host: string,
        private port: number,
        private username: string,
        private password: string,
        private database: string
    ) {
        this.validateConnectionParams();
    }

    private validateConnectionParams(): void {
        if (!this.host || !this.username || !this.password) {
            throw new Error('필수 연결 매개변수가 누락되었습니다.');
        }
        if (this.port < 1 || this.port > 65535) {
            throw new Error('포트 번호가 유효하지 않습니다.');
        }
    }

    async connect(): Promise<void> {
        try {
            // 실제 데이터베이스 연결 로직 (시뮬레이션)
            this.connection = { host: this.host, port: this.port };
            this.isConnected = true;
            console.log(`데이터베이스에 연결되었습니다: ${this.host}:${this.port}`);
        } catch (error) {
            throw new Error(`데이터베이스 연결 실패: ${error}`);
        }
    }

    disconnect(): void {
        this.connection = null;
        this.isConnected = false;
        console.log('데이터베이스 연결이 종료되었습니다.');
    }

    isConnectionActive(): boolean {
        return this.isConnected;
    }
}

// 사용 예시
const db = new DatabaseConnection('localhost', 5432, 'admin', 'password', 'mydb');
db.connect().then(() => {
    console.log('연결 상태:', db.isConnectionActive());
    db.disconnect();
});
```

#### API 클라이언트 클래스
```typescript
class ApiClient {
    private baseUrl: string;
    private headers: Record<string, string>;
    private timeout: number;

    constructor(
        baseUrl: string,
        apiKey?: string,
        timeout: number = 5000
    ) {
        this.baseUrl = baseUrl.endsWith('/') ? baseUrl.slice(0, -1) : baseUrl;
        this.timeout = timeout;
        this.headers = {
            'Content-Type': 'application/json'
        };

        if (apiKey) {
            this.headers['Authorization'] = `Bearer ${apiKey}`;
        }
    }

    async request<T>(endpoint: string, options: RequestInit = {}): Promise<T> {
        const url = `${this.baseUrl}${endpoint.startsWith('/') ? endpoint : `/${endpoint}`}`;
        
        const response = await fetch(url, {
            ...options,
            headers: { ...this.headers, ...options.headers },
            signal: AbortSignal.timeout(this.timeout)
        });

        if (!response.ok) {
            throw new Error(`API 요청 실패: ${response.status} ${response.statusText}`);
        }

        return response.json();
    }

    get<T>(endpoint: string): Promise<T> {
        return this.request<T>(endpoint, { method: 'GET' });
    }

    post<T>(endpoint: string, data: any): Promise<T> {
        return this.request<T>(endpoint, {
            method: 'POST',
            body: JSON.stringify(data)
        });
    }
}

// 사용 예시
const apiClient = new ApiClient('https://api.example.com', 'your-api-key', 10000);

// GET 요청
apiClient.get<User[]>('/users').then(users => {
    console.log('사용자 목록:', users);
});

// POST 요청
apiClient.post<User>('/users', { name: '홍길동', email: 'hong@example.com' }).then(user => {
    console.log('생성된 사용자:', user);
});
```

### 2. 고급 패턴

#### 팩토리 패턴과 생성자
```typescript
abstract class Vehicle {
    constructor(
        protected brand: string,
        protected model: string,
        protected year: number
    ) {}

    abstract getInfo(): string;
    abstract startEngine(): void;
}

class Car extends Vehicle {
    constructor(
        brand: string,
        model: string,
        year: number,
        private fuelType: string
    ) {
        super(brand, model, year);
    }

    getInfo(): string {
        return `${this.brand} ${this.model} (${this.year}) - ${this.fuelType}`;
    }

    startEngine(): void {
        console.log(`${this.brand} ${this.model}의 엔진이 시동되었습니다.`);
    }
}

class Motorcycle extends Vehicle {
    constructor(
        brand: string,
        model: string,
        year: number,
        private engineSize: number
    ) {
        super(brand, model, year);
    }

    getInfo(): string {
        return `${this.brand} ${this.model} (${this.year}) - ${this.engineSize}cc`;
    }

    startEngine(): void {
        console.log(`${this.brand} ${this.model}의 엔진이 시동되었습니다.`);
    }
}

// 팩토리 클래스
class VehicleFactory {
    static createVehicle(
        type: 'car' | 'motorcycle',
        brand: string,
        model: string,
        year: number,
        additionalInfo: any
    ): Vehicle {
        switch (type) {
            case 'car':
                return new Car(brand, model, year, additionalInfo.fuelType);
            case 'motorcycle':
                return new Motorcycle(brand, model, year, additionalInfo.engineSize);
            default:
                throw new Error('지원하지 않는 차량 타입입니다.');
        }
    }
}

// 사용 예시
const car = VehicleFactory.createVehicle('car', '현대', '아반떼', 2023, { fuelType: '가솔린' });
const motorcycle = VehicleFactory.createVehicle('motorcycle', '혼다', 'CBR600RR', 2023, { engineSize: 600 });

console.log(car.getInfo()); // 현대 아반떼 (2023) - 가솔린
console.log(motorcycle.getInfo()); // 혼다 CBR600RR (2023) - 600cc
```

#### 싱글톤 패턴과 생성자
```typescript
class Logger {
    private static instance: Logger;
    private logs: string[] = [];

    private constructor() {
        // private 생성자로 외부에서 직접 인스턴스 생성 방지
    }

    static getInstance(): Logger {
        if (!Logger.instance) {
            Logger.instance = new Logger();
        }
        return Logger.instance;
    }

    log(message: string): void {
        const timestamp = new Date().toISOString();
        const logEntry = `[${timestamp}] ${message}`;
        this.logs.push(logEntry);
        console.log(logEntry);
    }

    getLogs(): string[] {
        return [...this.logs];
    }

    clearLogs(): void {
        this.logs = [];
    }
}

// 사용 예시
const logger1 = Logger.getInstance();
const logger2 = Logger.getInstance();

console.log(logger1 === logger2); // true (같은 인스턴스)

logger1.log('애플리케이션이 시작되었습니다.');
logger2.log('사용자 로그인 성공');

console.log(logger1.getLogs()); // 두 로그 모두 포함
```

## 운영 팁

### 성능 최적화

#### 생성자 최적화
```typescript
class OptimizedClass {
    private computedValue: string;

    constructor(
        public name: string,
        public age: number
    ) {
        // 생성자에서 무거운 계산을 피하고 필요할 때 계산
        this.computedValue = this.computeExpensiveValue();
    }

    private computeExpensiveValue(): string {
        // 무거운 계산을 시뮬레이션
        let result = '';
        for (let i = 0; i < 1000000; i++) {
            result += i.toString();
        }
        return result;
    }

    // 더 나은 방법: 지연 초기화
    private _lazyComputedValue?: string;
    get lazyComputedValue(): string {
        if (!this._lazyComputedValue) {
            this._lazyComputedValue = this.computeExpensiveValue();
        }
        return this._lazyComputedValue;
    }
}
```

### 에러 처리

#### 생성자에서의 유효성 검사
```typescript
class ValidatedUser {
    public readonly name: string;
    public readonly email: string;
    public readonly age: number;

    constructor(name: string, email: string, age: number) {
        // 유효성 검사
        if (!name || name.trim().length === 0) {
            throw new Error('이름은 필수입니다.');
        }

        if (!email || !this.isValidEmail(email)) {
            throw new Error('유효한 이메일 주소를 입력해주세요.');
        }

        if (age < 0 || age > 150) {
            throw new Error('유효한 나이를 입력해주세요.');
        }

        // 유효성 검사를 통과한 경우에만 속성 할당
        this.name = name.trim();
        this.email = email.toLowerCase();
        this.age = age;
    }

    private isValidEmail(email: string): boolean {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
    }

    getInfo(): string {
        return `${this.name} (${this.email}) - ${this.age}세`;
    }
}

// 사용 예시
try {
    const user = new ValidatedUser('홍길동', 'hong@example.com', 25);
    console.log(user.getInfo());
} catch (error) {
    console.error('사용자 생성 실패:', error.message);
}
```

## 참고

### 생성자 패턴 비교

#### 다양한 생성자 패턴
```typescript
// 1. 기본 생성자
class BasicClass {
    constructor(public name: string) {}
}

// 2. 빌더 패턴
class UserBuilder {
    private name: string = '';
    private email: string = '';
    private age: number = 0;

    setName(name: string): UserBuilder {
        this.name = name;
        return this;
    }

    setEmail(email: string): UserBuilder {
        this.email = email;
        return this;
    }

    setAge(age: number): UserBuilder {
        this.age = age;
        return this;
    }

    build(): User {
        return new User(this.name, this.email, this.age);
    }
}

// 3. 정적 팩토리 메서드
class Connection {
    private constructor(private url: string) {}

    static create(url: string): Connection {
        return new Connection(url);
    }

    static createSecure(url: string): Connection {
        return new Connection(`https://${url}`);
    }
}

// 사용 예시
const basic = new BasicClass('홍길동');

const user = new UserBuilder()
    .setName('김철수')
    .setEmail('kim@example.com')
    .setAge(30)
    .build();

const connection = Connection.create('api.example.com');
const secureConnection = Connection.createSecure('api.example.com');
```

### 결론
TypeScript의 생성자는 클래스의 인스턴스를 초기화하는 강력한 도구입니다.
생성자 오버로드를 통해 다양한 매개변수 조합을 지원할 수 있습니다.
매개변수 속성을 사용하면 코드를 더 간결하게 작성할 수 있습니다.
적절한 유효성 검사와 에러 처리가 견고한 생성자의 핵심입니다.
생성자를 활용한 다양한 디자인 패턴으로 유연하고 확장 가능한 코드를 작성할 수 있습니다.





