---
title: TypeScript 생성자 완벽 가이드
tags: [language, typescript, typescript-기본-개념, constructor, class, oop]
updated: 2025-09-22
---

# TypeScript 생성자 완벽 가이드

## 개요

TypeScript의 생성자(Constructor)는 객체지향 프로그래밍의 핵심 개념으로, 클래스의 인스턴스를 초기화하는 특별한 메서드입니다. 이 문서는 TypeScript에서 생성자를 효과적으로 활용하는 방법을 상세히 다룹니다.

### 생성자의 본질적 특성

생성자는 다음과 같은 고유한 특성을 가집니다:

- **단일성**: 클래스당 정확히 하나의 생성자만 정의 가능
- **자동 호출**: `new` 연산자로 인스턴스 생성 시 자동으로 실행
- **초기화 전담**: 객체의 초기 상태를 안전하게 설정
- **타입 안전성**: TypeScript의 강력한 타입 시스템과 완벽 통합

### 생성자가 중요한 이유

1. **객체 생명주기 관리**: 객체의 생성부터 초기화까지의 과정을 제어
2. **의존성 주입**: 외부 의존성을 안전하게 주입받아 사용
3. **불변성 보장**: 생성 시점에 객체의 불변 속성들을 설정
4. **유효성 검증**: 객체 생성 전 데이터의 유효성을 검증
5. **메모리 효율성**: 필요한 리소스만 할당하여 메모리 사용량 최적화

## 핵심 개념

### 1. 기본 생성자 패턴

#### 표준 생성자 구현
```typescript
class Person {
    private readonly id: string;
    public name: string;
    public age: number;
    private createdAt: Date;

    constructor(name: string, age: number) {
        // 유효성 검사
        if (!name || name.trim().length === 0) {
            throw new Error('이름은 필수입니다.');
        }
        if (age < 0 || age > 150) {
            throw new Error('유효한 나이를 입력해주세요.');
        }

        // 속성 초기화
        this.id = this.generateId();
        this.name = name.trim();
        this.age = age;
        this.createdAt = new Date();
    }

    private generateId(): string {
        return `person_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }

    public greet(): string {
        return `안녕하세요, 저는 ${this.name}이고 ${this.age}세입니다.`;
    }

    public getInfo(): object {
        return {
            id: this.id,
            name: this.name,
            age: this.age,
            createdAt: this.createdAt
        };
    }
}

// 사용 예시
const person = new Person('홍길동', 25);
console.log(person.greet()); // 안녕하세요, 저는 홍길동이고 25세입니다.
console.log(person.getInfo());
```

#### 매개변수 기본값과 선택적 매개변수
```typescript
class User {
    private readonly id: string;
    public name: string;
    public email: string;
    public isActive: boolean;
    public role: string;
    private lastLoginAt?: Date;

    constructor(
        name: string, 
        email: string, 
        isActive: boolean = true,
        role: string = 'user'
    ) {
        // 이메일 유효성 검사
        if (!this.isValidEmail(email)) {
            throw new Error('유효한 이메일 주소를 입력해주세요.');
        }

        this.id = this.generateUserId();
        this.name = name.trim();
        this.email = email.toLowerCase();
        this.isActive = isActive;
        this.role = role;
    }

    private generateUserId(): string {
        return `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }

    private isValidEmail(email: string): boolean {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
    }

    public login(): void {
        this.lastLoginAt = new Date();
        console.log(`${this.name}님이 로그인했습니다.`);
    }

    public getProfile(): object {
        return {
            id: this.id,
            name: this.name,
            email: this.email,
            isActive: this.isActive,
            role: this.role,
            lastLoginAt: this.lastLoginAt
        };
    }
}

// 다양한 방식으로 사용자 생성
const user1 = new User('김철수', 'kim@example.com');
const user2 = new User('이영희', 'lee@example.com', false);
const user3 = new User('박민수', 'park@example.com', true, 'admin');

console.log(user1.getProfile());
console.log(user2.getProfile());
console.log(user3.getProfile());
```

### 2. 생성자 오버로드 (Constructor Overloading)

TypeScript의 생성자 오버로드는 동일한 클래스에 대해 다양한 매개변수 조합으로 객체를 생성할 수 있게 해주는 강력한 기능입니다. 이를 통해 API의 유연성과 사용성을 크게 향상시킬 수 있습니다.

#### 기본 오버로드 패턴
```typescript
class Employee {
    private readonly id: string;
    public name: string;
    public age: number;
    public email?: string;
    public department: string;
    public salary: number;

    // 오버로드 시그니처들 - 타입 정의만 제공
    constructor(name: string, age: number);
    constructor(name: string, age: number, email: string);
    constructor(name: string, age: number, email: string, department: string);
    constructor(name: string, age: number, email: string, department: string, salary: number);
    
    // 실제 구현체 - 모든 오버로드를 처리
    constructor(
        name: string, 
        age: number, 
        email?: string, 
        department: string = 'General', 
        salary: number = 0
    ) {
        // 유효성 검사
        if (!name || name.trim().length === 0) {
            throw new Error('이름은 필수입니다.');
        }
        if (age < 18 || age > 65) {
            throw new Error('유효한 나이를 입력해주세요.');
        }
        if (email && !this.isValidEmail(email)) {
            throw new Error('유효한 이메일 주소를 입력해주세요.');
        }

        // 속성 초기화
        this.id = this.generateEmployeeId();
        this.name = name.trim();
        this.age = age;
        this.email = email?.toLowerCase();
        this.department = department;
        this.salary = salary;
    }

    private generateEmployeeId(): string {
        return `emp_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`;
    }

    private isValidEmail(email: string): boolean {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
    }

    public getEmployeeInfo(): object {
        return {
            id: this.id,
            name: this.name,
            age: this.age,
            email: this.email,
            department: this.department,
            salary: this.salary
        };
    }

    public promote(newDepartment: string, newSalary: number): void {
        this.department = newDepartment;
        this.salary = newSalary;
        console.log(`${this.name}님이 ${newDepartment} 부서로 승진했습니다.`);
    }
}

// 다양한 방식으로 직원 생성
const emp1 = new Employee('홍길동', 25);
const emp2 = new Employee('김철수', 30, 'kim@company.com');
const emp3 = new Employee('이영희', 28, 'lee@company.com', 'IT');
const emp4 = new Employee('박민수', 35, 'park@company.com', 'Marketing', 5000000);

console.log(emp1.getEmployeeInfo());
console.log(emp2.getEmployeeInfo());
console.log(emp3.getEmployeeInfo());
console.log(emp4.getEmployeeInfo());
```

#### 고급 오버로드 패턴 - 객체와 개별 매개변수 혼합
```typescript
class Product {
    private readonly id: string;
    public name: string;
    public price: number;
    public category: string;
    public inStock: boolean;
    public tags: string[];

    // 오버로드 시그니처들
    constructor(id: string, name: string, price: number);
    constructor(id: string, name: string, price: number, category: string);
    constructor(productData: ProductData);
    constructor(productData: ProductData, inStock: boolean);
    
    // 실제 구현체
    constructor(
        idOrData: string | ProductData,
        name?: string,
        price?: number,
        categoryOrInStock?: string | boolean,
        inStock?: boolean
    ) {
        if (typeof idOrData === 'string') {
            // 개별 매개변수로 생성
            this.id = idOrData;
            this.name = name!;
            this.price = price!;
            this.category = typeof categoryOrInStock === 'string' ? categoryOrInStock : 'General';
            this.inStock = typeof inStock === 'boolean' ? inStock : true;
            this.tags = [];
        } else {
            // 객체로 생성
            this.id = idOrData.id;
            this.name = idOrData.name;
            this.price = idOrData.price;
            this.category = idOrData.category || 'General';
            this.inStock = typeof categoryOrInStock === 'boolean' ? categoryOrInStock : true;
            this.tags = idOrData.tags || [];
        }

        // 유효성 검사
        this.validateProduct();
    }

    private validateProduct(): void {
        if (!this.name || this.name.trim().length === 0) {
            throw new Error('상품명은 필수입니다.');
        }
        if (this.price < 0) {
            throw new Error('가격은 0 이상이어야 합니다.');
        }
    }

    public addTag(tag: string): void {
        if (!this.tags.includes(tag)) {
            this.tags.push(tag);
        }
    }

    public getProductInfo(): object {
        return {
            id: this.id,
            name: this.name,
            price: this.price,
            category: this.category,
            inStock: this.inStock,
            tags: this.tags
        };
    }
}

interface ProductData {
    id: string;
    name: string;
    price: number;
    category?: string;
    tags?: string[];
}

// 다양한 방식으로 상품 생성
const product1 = new Product('P001', '노트북', 1500000);
const product2 = new Product('P002', '마우스', 50000, '액세서리');
const product3 = new Product({
    id: 'P003',
    name: '키보드',
    price: 100000,
    category: '액세서리',
    tags: ['무선', '기계식']
});
const product4 = new Product({
    id: 'P004',
    name: '모니터',
    price: 300000,
    category: '디스플레이'
}, false);

console.log(product1.getProductInfo());
console.log(product2.getProductInfo());
console.log(product3.getProductInfo());
console.log(product4.getProductInfo());
```

### 3. 매개변수 속성 (Parameter Properties)

매개변수 속성은 TypeScript의 강력한 기능으로, 생성자 매개변수에 접근 제한자를 추가하여 자동으로 클래스 속성을 생성하고 초기화할 수 있게 해줍니다.

#### 기본 매개변수 속성 패턴
```typescript
class SecureUser {
    // 매개변수 속성을 사용하면 자동으로 인스턴스 속성이 생성됩니다
    constructor(
        public readonly id: string,           // public readonly 속성
        public name: string,                  // public 속성
        public email: string,                 // public 속성
        private password: string,             // private 속성
        protected role: string = 'user',      // protected 속성 (기본값)
        private readonly createdAt: Date = new Date()  // private readonly 속성
    ) {
        // 유효성 검사
        this.validateUser();
    }

    private validateUser(): void {
        if (!this.name || this.name.trim().length === 0) {
            throw new Error('이름은 필수입니다.');
        }
        if (!this.isValidEmail(this.email)) {
            throw new Error('유효한 이메일 주소를 입력해주세요.');
        }
        if (!this.password || this.password.length < 8) {
            throw new Error('비밀번호는 최소 8자 이상이어야 합니다.');
        }
    }

    private isValidEmail(email: string): boolean {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
    }

    public getPublicInfo(): object {
        return {
            id: this.id,
            name: this.name,
            email: this.email,
            role: this.role,
            createdAt: this.createdAt
        };
    }

    public changePassword(oldPassword: string, newPassword: string): boolean {
        if (this.password !== oldPassword) {
            throw new Error('기존 비밀번호가 일치하지 않습니다.');
        }
        if (newPassword.length < 8) {
            throw new Error('새 비밀번호는 최소 8자 이상이어야 합니다.');
        }
        this.password = newPassword;
        return true;
    }

    public isAdmin(): boolean {
        return this.role === 'admin';
    }
}

// 사용 예시
const user = new SecureUser(
    'user_123',
    '홍길동',
    'hong@example.com',
    'securePassword123',
    'admin'
);

console.log(user.getPublicInfo());
console.log('관리자 여부:', user.isAdmin());
user.changePassword('securePassword123', 'newSecurePassword456');
```

#### 읽기 전용 속성과 불변성 보장
```typescript
class AppConfiguration {
    constructor(
        public readonly apiUrl: string,
        public readonly timeout: number,
        public readonly retries: number = 3,
        public readonly environment: 'development' | 'staging' | 'production' = 'development',
        private readonly secretKey: string = ''
    ) {
        // 설정 유효성 검사
        this.validateConfiguration();
    }

    private validateConfiguration(): void {
        if (!this.apiUrl || !this.isValidUrl(this.apiUrl)) {
            throw new Error('유효한 API URL을 입력해주세요.');
        }
        if (this.timeout < 1000 || this.timeout > 30000) {
            throw new Error('타임아웃은 1초에서 30초 사이여야 합니다.');
        }
        if (this.retries < 0 || this.retries > 10) {
            throw new Error('재시도 횟수는 0에서 10 사이여야 합니다.');
        }
    }

    private isValidUrl(url: string): boolean {
        try {
            new URL(url);
            return true;
        } catch {
            return false;
        }
    }

    public getConfig(): object {
        return {
            apiUrl: this.apiUrl,
            timeout: this.timeout,
            retries: this.retries,
            environment: this.environment,
            hasSecretKey: this.secretKey.length > 0
        };
    }

    public isProduction(): boolean {
        return this.environment === 'production';
    }

    public getTimeoutInSeconds(): number {
        return this.timeout / 1000;
    }
}

// 사용 예시
const config = new AppConfiguration(
    'https://api.example.com',
    5000,
    3,
    'production',
    'secret-key-123'
);

console.log(config.getConfig());
console.log('프로덕션 환경:', config.isProduction());
console.log('타임아웃(초):', config.getTimeoutInSeconds());

// config.apiUrl = 'https://new-api.example.com'; // 컴파일 에러! readonly 속성
```

## 실전 활용 사례

### 1. 엔터프라이즈급 애플리케이션 예시

#### 고급 데이터베이스 연결 관리자
```typescript
interface DatabaseConfig {
    host: string;
    port: number;
    username: string;
    password: string;
    database: string;
    ssl?: boolean;
    poolSize?: number;
    timeout?: number;
}

class DatabaseConnectionManager {
    private connection: any = null;
    private isConnected: boolean = false;
    private connectionAttempts: number = 0;
    private readonly maxRetries: number;
    private readonly retryDelay: number;

    constructor(
        private config: DatabaseConfig,
        maxRetries: number = 3,
        retryDelay: number = 1000
    ) {
        this.maxRetries = maxRetries;
        this.retryDelay = retryDelay;
        this.validateConfiguration();
    }

    private validateConfiguration(): void {
        const { host, port, username, password, database } = this.config;
        
        if (!host || !username || !password || !database) {
            throw new Error('필수 데이터베이스 연결 매개변수가 누락되었습니다.');
        }
        
        if (port < 1 || port > 65535) {
            throw new Error('포트 번호는 1-65535 범위여야 합니다.');
        }
        
        if (this.config.poolSize && (this.config.poolSize < 1 || this.config.poolSize > 100)) {
            throw new Error('연결 풀 크기는 1-100 범위여야 합니다.');
        }
    }

    public async connect(): Promise<void> {
        if (this.isConnected) {
            console.log('이미 데이터베이스에 연결되어 있습니다.');
            return;
        }

        for (let attempt = 1; attempt <= this.maxRetries; attempt++) {
            try {
                this.connectionAttempts = attempt;
                console.log(`데이터베이스 연결 시도 ${attempt}/${this.maxRetries}`);
                
            // 실제 데이터베이스 연결 로직 (시뮬레이션)
                await this.establishConnection();
                
            this.isConnected = true;
                console.log(`데이터베이스 연결 성공: ${this.config.host}:${this.config.port}`);
                return;
                
        } catch (error) {
                console.error(`연결 시도 ${attempt} 실패:`, error);
                
                if (attempt === this.maxRetries) {
                    throw new Error(`데이터베이스 연결 실패 (${this.maxRetries}회 시도): ${error}`);
                }
                
                // 재시도 전 대기
                await this.delay(this.retryDelay * attempt);
            }
        }
    }

    private async establishConnection(): Promise<void> {
        // 실제 데이터베이스 연결 로직 시뮬레이션
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                // 90% 확률로 성공
                if (Math.random() > 0.1) {
                    this.connection = {
                        host: this.config.host,
                        port: this.config.port,
                        database: this.config.database,
                        connectedAt: new Date()
                    };
                    resolve();
                } else {
                    reject(new Error('연결 시간 초과'));
                }
            }, 100);
        });
    }

    public async disconnect(): Promise<void> {
        if (!this.isConnected) {
            console.log('연결된 데이터베이스가 없습니다.');
            return;
        }

        try {
            // 실제 연결 해제 로직
        this.connection = null;
        this.isConnected = false;
            console.log('데이터베이스 연결이 안전하게 종료되었습니다.');
        } catch (error) {
            throw new Error(`데이터베이스 연결 해제 실패: ${error}`);
        }
    }

    public isConnectionActive(): boolean {
        return this.isConnected && this.connection !== null;
    }

    public getConnectionInfo(): object {
        return {
            isConnected: this.isConnected,
            connectionAttempts: this.connectionAttempts,
            config: {
                host: this.config.host,
                port: this.config.port,
                database: this.config.database,
                ssl: this.config.ssl || false,
                poolSize: this.config.poolSize || 10
            },
            connection: this.connection
        };
    }

    private delay(ms: number): Promise<void> {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}

// 사용 예시
const dbConfig: DatabaseConfig = {
    host: 'localhost',
    port: 5432,
    username: 'admin',
    password: 'securePassword123',
    database: 'production_db',
    ssl: true,
    poolSize: 20,
    timeout: 30000
};

const dbManager = new DatabaseConnectionManager(dbConfig, 5, 2000);

dbManager.connect()
    .then(() => {
        console.log('연결 정보:', dbManager.getConnectionInfo());
        return dbManager.disconnect();
    })
    .catch(error => {
        console.error('데이터베이스 연결 실패:', error.message);
});
```

#### 엔터프라이즈 API 클라이언트
```typescript
interface ApiClientConfig {
    baseUrl: string;
    apiKey?: string;
    timeout?: number;
    retries?: number;
    retryDelay?: number;
    defaultHeaders?: Record<string, string>;
}

interface RequestOptions extends RequestInit {
    timeout?: number;
    retries?: number;
}

class EnterpriseApiClient {
    private readonly baseUrl: string;
    private readonly headers: Record<string, string>;
    private readonly defaultTimeout: number;
    private readonly maxRetries: number;
    private readonly retryDelay: number;
    private requestCount: number = 0;

    constructor(config: ApiClientConfig) {
        this.validateConfig(config);
        
        this.baseUrl = this.normalizeUrl(config.baseUrl);
        this.defaultTimeout = config.timeout || 10000;
        this.maxRetries = config.retries || 3;
        this.retryDelay = config.retryDelay || 1000;
        
        this.headers = {
            'Content-Type': 'application/json',
            'User-Agent': 'EnterpriseApiClient/1.0',
            ...config.defaultHeaders
        };

        if (config.apiKey) {
            this.headers['Authorization'] = `Bearer ${config.apiKey}`;
        }
    }

    private validateConfig(config: ApiClientConfig): void {
        if (!config.baseUrl || !this.isValidUrl(config.baseUrl)) {
            throw new Error('유효한 baseUrl을 제공해야 합니다.');
        }
        
        if (config.timeout && (config.timeout < 1000 || config.timeout > 60000)) {
            throw new Error('타임아웃은 1초에서 60초 사이여야 합니다.');
        }
        
        if (config.retries && (config.retries < 0 || config.retries > 10)) {
            throw new Error('재시도 횟수는 0에서 10 사이여야 합니다.');
        }
    }

    private normalizeUrl(url: string): string {
        return url.endsWith('/') ? url.slice(0, -1) : url;
    }

    private isValidUrl(url: string): boolean {
        try {
            new URL(url);
            return true;
        } catch {
            return false;
        }
    }

    public async request<T>(endpoint: string, options: RequestOptions = {}): Promise<T> {
        const url = this.buildUrl(endpoint);
        const timeout = options.timeout || this.defaultTimeout;
        const retries = options.retries ?? this.maxRetries;
        
        this.requestCount++;

        for (let attempt = 1; attempt <= retries + 1; attempt++) {
            try {
                const response = await this.executeRequest(url, options, timeout);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                return await response.json();
                
            } catch (error) {
                if (attempt === retries + 1) {
                    throw new Error(`API 요청 실패 (${retries + 1}회 시도): ${error}`);
                }
                
                console.warn(`요청 실패 (시도 ${attempt}/${retries + 1}):`, error);
                await this.delay(this.retryDelay * attempt);
            }
        }
        
        throw new Error('예상치 못한 오류가 발생했습니다.');
    }

    private async executeRequest(url: string, options: RequestOptions, timeout: number): Promise<Response> {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeout);

        try {
        const response = await fetch(url, {
            ...options,
            headers: { ...this.headers, ...options.headers },
                signal: controller.signal
            });

            clearTimeout(timeoutId);
            return response;
        } catch (error) {
            clearTimeout(timeoutId);
            throw error;
        }
    }

    private buildUrl(endpoint: string): string {
        const normalizedEndpoint = endpoint.startsWith('/') ? endpoint : `/${endpoint}`;
        return `${this.baseUrl}${normalizedEndpoint}`;
    }

    public get<T>(endpoint: string, options: RequestOptions = {}): Promise<T> {
        return this.request<T>(endpoint, { ...options, method: 'GET' });
    }

    public post<T>(endpoint: string, data: any, options: RequestOptions = {}): Promise<T> {
        return this.request<T>(endpoint, {
            ...options,
            method: 'POST',
            body: JSON.stringify(data)
        });
    }

    public put<T>(endpoint: string, data: any, options: RequestOptions = {}): Promise<T> {
        return this.request<T>(endpoint, {
            ...options,
            method: 'PUT',
            body: JSON.stringify(data)
        });
    }

    public delete<T>(endpoint: string, options: RequestOptions = {}): Promise<T> {
        return this.request<T>(endpoint, { ...options, method: 'DELETE' });
    }

    public getRequestCount(): number {
        return this.requestCount;
    }

    public resetRequestCount(): void {
        this.requestCount = 0;
    }

    private delay(ms: number): Promise<void> {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}

// 사용 예시
const apiConfig: ApiClientConfig = {
    baseUrl: 'https://api.example.com',
    apiKey: 'your-secure-api-key',
    timeout: 15000,
    retries: 3,
    retryDelay: 2000,
    defaultHeaders: {
        'X-Client-Version': '1.0.0',
        'X-Request-ID': () => Math.random().toString(36).substr(2, 9)
    }
};

const apiClient = new EnterpriseApiClient(apiConfig);

// 사용 예시
apiClient.get<User[]>('/users')
    .then(users => {
    console.log('사용자 목록:', users);
        console.log('총 요청 수:', apiClient.getRequestCount());
    })
    .catch(error => {
        console.error('API 요청 실패:', error.message);
    });

apiClient.post<User>('/users', { 
    name: '홍길동', 
    email: 'hong@example.com' 
})
    .then(user => {
    console.log('생성된 사용자:', user);
    })
    .catch(error => {
        console.error('사용자 생성 실패:', error.message);
});
```

### 2. 고급 디자인 패턴과 생성자

#### 팩토리 패턴과 생성자
```typescript
// 추상 기본 클래스
abstract class Vehicle {
    protected readonly id: string;
    protected readonly createdAt: Date;

    constructor(
        protected brand: string,
        protected model: string,
        protected year: number,
        protected price: number
    ) {
        this.id = this.generateVehicleId();
        this.createdAt = new Date();
        this.validateVehicle();
    }

    private generateVehicleId(): string {
        return `vehicle_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`;
    }

    private validateVehicle(): void {
        if (!this.brand || !this.model) {
            throw new Error('브랜드와 모델명은 필수입니다.');
        }
        if (this.year < 1900 || this.year > new Date().getFullYear() + 1) {
            throw new Error('유효한 연도를 입력해주세요.');
        }
        if (this.price < 0) {
            throw new Error('가격은 0 이상이어야 합니다.');
        }
    }

    abstract getInfo(): string;
    abstract startEngine(): void;
    abstract calculateMaintenanceCost(): number;

    public getBasicInfo(): object {
        return {
            id: this.id,
            brand: this.brand,
            model: this.model,
            year: this.year,
            price: this.price,
            createdAt: this.createdAt
        };
    }
}

// 구체적인 구현 클래스들
class Car extends Vehicle {
    constructor(
        brand: string,
        model: string,
        year: number,
        price: number,
        private fuelType: 'gasoline' | 'diesel' | 'electric' | 'hybrid',
        private doors: number,
        private transmission: 'manual' | 'automatic'
    ) {
        super(brand, model, year, price);
        this.validateCar();
    }

    private validateCar(): void {
        if (this.doors < 2 || this.doors > 5) {
            throw new Error('문의 개수는 2-5개 사이여야 합니다.');
        }
    }

    getInfo(): string {
        return `${this.brand} ${this.model} (${this.year}) - ${this.fuelType}, ${this.doors}도어, ${this.transmission}`;
    }

    startEngine(): void {
        console.log(`${this.brand} ${this.model}의 ${this.fuelType} 엔진이 시동되었습니다.`);
    }

    calculateMaintenanceCost(): number {
        const baseCost = 100000;
        const fuelMultiplier = this.fuelType === 'electric' ? 0.5 : 1.0;
        const ageMultiplier = (new Date().getFullYear() - this.year) * 0.1 + 1;
        return Math.round(baseCost * fuelMultiplier * ageMultiplier);
    }
}

class Motorcycle extends Vehicle {
    constructor(
        brand: string,
        model: string,
        year: number,
        price: number,
        private engineSize: number,
        private type: 'sport' | 'cruiser' | 'touring' | 'dirt'
    ) {
        super(brand, model, year, price);
        this.validateMotorcycle();
    }

    private validateMotorcycle(): void {
        if (this.engineSize < 50 || this.engineSize > 2000) {
            throw new Error('엔진 크기는 50cc에서 2000cc 사이여야 합니다.');
        }
    }

    getInfo(): string {
        return `${this.brand} ${this.model} (${this.year}) - ${this.engineSize}cc, ${this.type}`;
    }

    startEngine(): void {
        console.log(`${this.brand} ${this.model}의 ${this.engineSize}cc 엔진이 시동되었습니다.`);
    }

    calculateMaintenanceCost(): number {
        const baseCost = 50000;
        const engineMultiplier = this.engineSize / 1000;
        const typeMultiplier = this.type === 'sport' ? 1.5 : 1.0;
        return Math.round(baseCost * engineMultiplier * typeMultiplier);
    }
}

// 고급 팩토리 클래스
class VehicleFactory {
    private static vehicleCount: number = 0;

    static createVehicle(
        type: 'car' | 'motorcycle',
        config: VehicleConfig
    ): Vehicle {
        this.vehicleCount++;
        
        try {
        switch (type) {
            case 'car':
                    return new Car(
                        config.brand,
                        config.model,
                        config.year,
                        config.price,
                        config.fuelType!,
                        config.doors!,
                        config.transmission!
                    );
            case 'motorcycle':
                    return new Motorcycle(
                        config.brand,
                        config.model,
                        config.year,
                        config.price,
                        config.engineSize!,
                        config.type!
                    );
            default:
                    throw new Error(`지원하지 않는 차량 타입: ${type}`);
            }
        } catch (error) {
            throw new Error(`차량 생성 실패: ${error.message}`);
        }
    }

    static getVehicleCount(): number {
        return this.vehicleCount;
    }

    static createCar(config: CarConfig): Car {
        return this.createVehicle('car', config) as Car;
    }

    static createMotorcycle(config: MotorcycleConfig): Motorcycle {
        return this.createVehicle('motorcycle', config) as Motorcycle;
    }
}

// 타입 정의
interface VehicleConfig {
    brand: string;
    model: string;
    year: number;
    price: number;
    fuelType?: 'gasoline' | 'diesel' | 'electric' | 'hybrid';
    doors?: number;
    transmission?: 'manual' | 'automatic';
    engineSize?: number;
    type?: 'sport' | 'cruiser' | 'touring' | 'dirt';
}

interface CarConfig extends VehicleConfig {
    fuelType: 'gasoline' | 'diesel' | 'electric' | 'hybrid';
    doors: number;
    transmission: 'manual' | 'automatic';
}

interface MotorcycleConfig extends VehicleConfig {
    engineSize: number;
    type: 'sport' | 'cruiser' | 'touring' | 'dirt';
}

// 사용 예시
const carConfig: CarConfig = {
    brand: '현대',
    model: '아반떼',
    year: 2023,
    price: 25000000,
    fuelType: 'gasoline',
    doors: 4,
    transmission: 'automatic'
};

const motorcycleConfig: MotorcycleConfig = {
    brand: '혼다',
    model: 'CBR600RR',
    year: 2023,
    price: 15000000,
    engineSize: 600,
    type: 'sport'
};

const car = VehicleFactory.createCar(carConfig);
const motorcycle = VehicleFactory.createMotorcycle(motorcycleConfig);

console.log(car.getInfo());
console.log('자동차 정비비:', car.calculateMaintenanceCost());
console.log(motorcycle.getInfo());
console.log('오토바이 정비비:', motorcycle.calculateMaintenanceCost());
console.log('생성된 차량 수:', VehicleFactory.getVehicleCount());
```

#### 싱글톤 패턴과 생성자
```typescript
class ApplicationLogger {
    private static instance: ApplicationLogger;
    private logs: LogEntry[] = [];
    private readonly maxLogs: number;
    private readonly logLevel: LogLevel;

    private constructor(
        maxLogs: number = 1000,
        logLevel: LogLevel = 'INFO'
    ) {
        this.maxLogs = maxLogs;
        this.logLevel = logLevel;
        this.initializeLogger();
    }

    private initializeLogger(): void {
        console.log('로거가 초기화되었습니다.');
        this.log('INFO', 'ApplicationLogger', '로거 인스턴스가 생성되었습니다.');
    }

    public static getInstance(
        maxLogs?: number,
        logLevel?: LogLevel
    ): ApplicationLogger {
        if (!ApplicationLogger.instance) {
            ApplicationLogger.instance = new ApplicationLogger(maxLogs, logLevel);
        }
        return ApplicationLogger.instance;
    }

    public log(level: LogLevel, source: string, message: string, data?: any): void {
        if (!this.shouldLog(level)) {
            return;
        }

        const logEntry: LogEntry = {
            timestamp: new Date(),
            level,
            source,
            message,
            data
        };

        this.addLog(logEntry);
        this.outputLog(logEntry);
    }

    private shouldLog(level: LogLevel): boolean {
        const levels: LogLevel[] = ['DEBUG', 'INFO', 'WARN', 'ERROR'];
        const currentLevelIndex = levels.indexOf(this.logLevel);
        const messageLevelIndex = levels.indexOf(level);
        return messageLevelIndex >= currentLevelIndex;
    }

    private addLog(logEntry: LogEntry): void {
        this.logs.push(logEntry);
        
        // 최대 로그 수 제한
        if (this.logs.length > this.maxLogs) {
            this.logs = this.logs.slice(-this.maxLogs);
        }
    }

    private outputLog(logEntry: LogEntry): void {
        const timestamp = logEntry.timestamp.toISOString();
        const logMessage = `[${timestamp}] [${logEntry.level}] [${logEntry.source}] ${logEntry.message}`;
        
        switch (logEntry.level) {
            case 'ERROR':
                console.error(logMessage, logEntry.data || '');
                break;
            case 'WARN':
                console.warn(logMessage, logEntry.data || '');
                break;
            case 'DEBUG':
                console.debug(logMessage, logEntry.data || '');
                break;
            default:
                console.log(logMessage, logEntry.data || '');
        }
    }

    public getLogs(filter?: LogFilter): LogEntry[] {
        if (!filter) {
            return [...this.logs];
        }

        return this.logs.filter(log => {
            if (filter.level && log.level !== filter.level) return false;
            if (filter.source && !log.source.includes(filter.source)) return false;
            if (filter.since && log.timestamp < filter.since) return false;
            if (filter.until && log.timestamp > filter.until) return false;
            return true;
        });
    }

    public clearLogs(): void {
        this.logs = [];
        this.log('INFO', 'ApplicationLogger', '로그가 초기화되었습니다.');
    }

    public getLogStats(): LogStats {
        const stats: LogStats = {
            total: this.logs.length,
            byLevel: {},
            bySource: {},
            oldest: null,
            newest: null
        };

        this.logs.forEach(log => {
            // 레벨별 통계
            stats.byLevel[log.level] = (stats.byLevel[log.level] || 0) + 1;
            
            // 소스별 통계
            stats.bySource[log.source] = (stats.bySource[log.source] || 0) + 1;
            
            // 시간 범위
            if (!stats.oldest || log.timestamp < stats.oldest) {
                stats.oldest = log.timestamp;
            }
            if (!stats.newest || log.timestamp > stats.newest) {
                stats.newest = log.timestamp;
            }
        });

        return stats;
    }
}

// 타입 정의
type LogLevel = 'DEBUG' | 'INFO' | 'WARN' | 'ERROR';

interface LogEntry {
    timestamp: Date;
    level: LogLevel;
    source: string;
    message: string;
    data?: any;
}

interface LogFilter {
    level?: LogLevel;
    source?: string;
    since?: Date;
    until?: Date;
}

interface LogStats {
    total: number;
    byLevel: Record<LogLevel, number>;
    bySource: Record<string, number>;
    oldest: Date | null;
    newest: Date | null;
}

// 사용 예시
const logger1 = ApplicationLogger.getInstance(500, 'DEBUG');
const logger2 = ApplicationLogger.getInstance(); // 같은 인스턴스 반환

console.log('같은 인스턴스:', logger1 === logger2); // true

logger1.log('INFO', 'UserService', '사용자 로그인 성공', { userId: 123 });
logger2.log('ERROR', 'DatabaseService', '데이터베이스 연결 실패', { error: 'Connection timeout' });
logger1.log('DEBUG', 'CacheService', '캐시 히트', { key: 'user:123' });

console.log('로그 통계:', logger1.getLogStats());
console.log('에러 로그만:', logger1.getLogs({ level: 'ERROR' }));
```

## 성능 최적화 및 모범 사례

### 1. 생성자 성능 최적화

#### 지연 초기화 패턴
```typescript
class OptimizedDataProcessor {
    private _expensiveCache: Map<string, any> | null = null;
    private _computedMetrics: object | null = null;

    constructor(
        public readonly dataSource: string,
        public readonly config: ProcessingConfig
    ) {
        // 생성자에서는 가벼운 초기화만 수행
        this.validateConfig();
    }

    private validateConfig(): void {
        if (!this.dataSource) {
            throw new Error('데이터 소스는 필수입니다.');
        }
        if (!this.config.batchSize || this.config.batchSize < 1) {
            throw new Error('배치 크기는 1 이상이어야 합니다.');
        }
    }

    // 지연 초기화: 필요할 때만 생성
    private get expensiveCache(): Map<string, any> {
        if (!this._expensiveCache) {
            console.log('비용이 큰 캐시를 초기화합니다...');
            this._expensiveCache = new Map();
            // 무거운 초기화 작업 시뮬레이션
            for (let i = 0; i < 100000; i++) {
                this._expensiveCache.set(`key_${i}`, `value_${i}`);
            }
        }
        return this._expensiveCache;
    }

    private get computedMetrics(): object {
        if (!this._computedMetrics) {
            console.log('메트릭을 계산합니다...');
            this._computedMetrics = {
                totalItems: this.expensiveCache.size,
                memoryUsage: process.memoryUsage(),
                timestamp: new Date()
            };
        }
        return this._computedMetrics;
    }

    public processData(): void {
        console.log('데이터 처리 중...');
        console.log('캐시 크기:', this.expensiveCache.size);
        console.log('메트릭:', this.computedMetrics);
    }

    public clearCache(): void {
        this._expensiveCache = null;
        this._computedMetrics = null;
        console.log('캐시가 초기화되었습니다.');
    }
}

interface ProcessingConfig {
    batchSize: number;
    timeout?: number;
    retries?: number;
}
```

### 2. 에러 처리 및 복구

#### 견고한 생성자 패턴
```typescript
class RobustServiceManager {
    private readonly services: Map<string, any> = new Map();
    private readonly fallbackConfig: ServiceConfig;
    private initializationAttempts: number = 0;
    private readonly maxInitAttempts: number = 3;

    constructor(
        private primaryConfig: ServiceConfig,
        fallbackConfig?: ServiceConfig
    ) {
        this.fallbackConfig = fallbackConfig || this.createDefaultConfig();
        this.initializeServices();
    }

    private createDefaultConfig(): ServiceConfig {
        return {
            database: { host: 'localhost', port: 5432 },
            cache: { host: 'localhost', port: 6379 },
            api: { baseUrl: 'http://localhost:3000' }
        };
    }

    private async initializeServices(): Promise<void> {
        for (let attempt = 1; attempt <= this.maxInitAttempts; attempt++) {
            try {
                this.initializationAttempts = attempt;
                console.log(`서비스 초기화 시도 ${attempt}/${this.maxInitAttempts}`);
                
                await this.initializeDatabase();
                await this.initializeCache();
                await this.initializeApi();
                
                console.log('모든 서비스가 성공적으로 초기화되었습니다.');
                return;
                
            } catch (error) {
                console.error(`초기화 시도 ${attempt} 실패:`, error);
                
                if (attempt === this.maxInitAttempts) {
                    console.warn('모든 초기화 시도가 실패했습니다. 폴백 모드로 전환합니다.');
                    await this.initializeFallbackServices();
                } else {
                    await this.delay(1000 * attempt);
                }
            }
        }
    }

    private async initializeDatabase(): Promise<void> {
        // 데이터베이스 초기화 시뮬레이션
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                if (Math.random() > 0.3) {
                    this.services.set('database', { connected: true, config: this.primaryConfig.database });
                    resolve();
                } else {
                    reject(new Error('데이터베이스 연결 실패'));
                }
            }, 100);
        });
    }

    private async initializeCache(): Promise<void> {
        // 캐시 초기화 시뮬레이션
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                if (Math.random() > 0.2) {
                    this.services.set('cache', { connected: true, config: this.primaryConfig.cache });
                    resolve();
                } else {
                    reject(new Error('캐시 연결 실패'));
                }
            }, 100);
        });
    }

    private async initializeApi(): Promise<void> {
        // API 초기화 시뮬레이션
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                if (Math.random() > 0.1) {
                    this.services.set('api', { connected: true, config: this.primaryConfig.api });
                    resolve();
                } else {
                    reject(new Error('API 연결 실패'));
                }
            }, 100);
        });
    }

    private async initializeFallbackServices(): Promise<void> {
        console.log('폴백 서비스로 초기화합니다...');
        this.services.set('database', { connected: false, config: this.fallbackConfig.database });
        this.services.set('cache', { connected: false, config: this.fallbackConfig.cache });
        this.services.set('api', { connected: false, config: this.fallbackConfig.api });
    }

    public getServiceStatus(): object {
        return {
            initializationAttempts: this.initializationAttempts,
            services: Object.fromEntries(this.services),
            isFullyOperational: Array.from(this.services.values()).every(service => service.connected)
        };
    }

    private delay(ms: number): Promise<void> {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}

interface ServiceConfig {
    database: { host: string; port: number };
    cache: { host: string; port: number };
    api: { baseUrl: string };
}
```

## 결론

TypeScript의 생성자는 단순한 초기화 메서드를 넘어서 객체의 생명주기를 관리하고, 의존성을 주입하며, 유효성을 검증하는 핵심적인 역할을 담당합니다. 

### 핵심 포인트

1. **타입 안전성**: TypeScript의 강력한 타입 시스템과 결합하여 컴파일 타임에 오류를 방지
2. **유연성**: 생성자 오버로드를 통한 다양한 객체 생성 방식 지원
3. **확장성**: 매개변수 속성과 디자인 패턴을 활용한 유지보수 가능한 코드 작성
4. **견고성**: 적절한 유효성 검사와 에러 처리를 통한 안정적인 애플리케이션 구축
5. **성능**: 지연 초기화와 최적화 기법을 통한 효율적인 리소스 관리

### 실무 적용 가이드

- **엔터프라이즈 환경**: 복잡한 의존성과 설정을 가진 대규모 애플리케이션에서 생성자의 역할이 더욱 중요
- **마이크로서비스**: 각 서비스의 독립적인 초기화와 설정 관리
- **테스트**: 생성자를 통한 의존성 주입으로 테스트 가능한 코드 작성
- **성능**: 대용량 데이터 처리 시 지연 초기화와 메모리 최적화

생성자를 올바르게 활용하면 더 안전하고, 유지보수하기 쉬우며, 확장 가능한 TypeScript 애플리케이션을 구축할 수 있습니다.

## 참조

### 공식 문서
- [TypeScript Handbook - Classes](https://www.typescriptlang.org/docs/handbook/2/classes.html)
- [TypeScript Handbook - Constructor Functions](https://www.typescriptlang.org/docs/handbook/2/classes.html#constructors)
- [TypeScript Handbook - Parameter Properties](https://www.typescriptlang.org/docs/handbook/2/classes.html#parameter-properties)

### 추가 학습 자료
- [MDN Web Docs - Classes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes)
- [JavaScript.info - Classes](https://javascript.info/classes)
- [TypeScript Deep Dive - Classes](https://basarat.gitbook.io/typescript/type-system/classes)

### 디자인 패턴 관련
- [Design Patterns: Elements of Reusable Object-Oriented Software](https://en.wikipedia.org/wiki/Design_Patterns)
- [Refactoring.Guru - Design Patterns](https://refactoring.guru/design-patterns)
- [TypeScript Design Patterns](https://github.com/torokmark/design_patterns_in_typescript)

### 성능 최적화
- [V8 Engine Optimization](https://v8.dev/docs)
- [JavaScript Performance Best Practices](https://developer.mozilla.org/en-US/docs/Web/Performance)
- [TypeScript Performance Tips](https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html)

### 실무 가이드
- [Clean Code in TypeScript](https://github.com/labs42io/clean-code-typescript)
- [TypeScript Best Practices](https://typescript-eslint.io/docs/linting/typed-linting/)
- [Enterprise TypeScript Patterns](https://www.oreilly.com/library/view/enterprise-typescript/9781492059021/)





