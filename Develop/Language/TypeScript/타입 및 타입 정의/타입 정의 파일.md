---
title: TypeScript 타입 정의 파일
tags: [language, typescript, 타입-및-타입-정의, type-definitions]
updated: 2025-11-11
---

# TypeScript 타입 정의 파일

## 배경

타입 정의 파일(type definition file)은 타입이 없는 JavaScript 라이브러리에 대한 타입 정보를 TypeScript 컴파일러에 전달하여 컴파일을 돕습니다.

### 타입 정의 파일의 필요성
- **타입 안전성 확보**: JavaScript 라이브러리의 타입 정보 제공
- **개발자 경험 향상**: IDE에서 자동완성과 타입 검사 지원
- **컴파일 에러 방지**: 런타임 오류를 컴파일 타임에 감지
- **코드 가독성**: 명확한 API 문서화

### 기본 개념
- **파일 확장자**: `.d.ts` (d는 definition을 의미)
- **앰비언트 선언**: `declare` 키워드를 사용한 타입만 선언
- **고스트 모듈**: 실제 구현 없이 타입 정보만 제공

## 핵심

### 1. 기본 앰비언트 선언

#### 변수 선언
```typescript
declare var hello: any;
declare const API_BASE_URL: string;
declare let globalConfig: {
    debug: boolean;
    timeout: number;
};
```

#### 함수 선언
```typescript
declare function area(shape: string, width: number, height: number): number;
declare function fetchData(url: string): Promise<any>;
declare function formatDate(date: Date, format: string): string;
```

#### 클래스 선언
```typescript
declare class Calculator {
    constructor(initialValue?: number);
    add(value: number): Calculator;
    subtract(value: number): Calculator;
    getResult(): number;
}
```

### 2. 모듈 선언

#### 기본 모듈 선언
```typescript
declare module 'my-library' {
    export interface User {
        id: number;
        name: string;
        email: string;
    }

    export class UserService {
        getUser(id: number): Promise<User>;
        createUser(user: Omit<User, 'id'>): Promise<User>;
        updateUser(id: number, user: Partial<User>): Promise<User>;
        deleteUser(id: number): Promise<void>;
    }

    export function formatUserName(user: User): string;
}
```

#### 네임스페이스 사용
```typescript
declare namespace MyLibrary {
    interface Config {
        apiUrl: string;
        timeout: number;
    }

    class HttpClient {
        constructor(config: Config);
        get<T>(url: string): Promise<T>;
        post<T>(url: string, data: any): Promise<T>;
    }

    function createClient(config: Config): HttpClient;
}
```

### 3. 전역 선언

#### 전역 변수와 함수
```typescript
declare global {
    var globalConfig: {
        apiUrl: string;
        debug: boolean;
    };

    function showNotification(message: string, type?: 'info' | 'warning' | 'error'): void;
}

export {};
```

#### 전역 인터페이스 확장
```typescript
declare global {
    interface Window {
        myApp: {
            version: string;
            config: any;
        };
    }

    interface Array<T> {
        customFilter(predicate: (value: T) => boolean): T[];
    }
}

export {};
```

## 예시

### 1. 실제 사용 사례

#### 외부 라이브러리 타입 정의
```typescript
// chart-library.d.ts
declare module 'chart-library' {
    export interface ChartOptions {
        width: number;
        height: number;
        data: Array<{ x: number; y: number }>;
        color?: string;
        showLegend?: boolean;
    }

    export interface ChartInstance {
        render(): void;
        update(data: Array<{ x: number; y: number }>): void;
        destroy(): void;
    }

    export function createChart(container: HTMLElement, options: ChartOptions): ChartInstance;
    export function createLineChart(container: HTMLElement, options: ChartOptions): ChartInstance;
    export function createBarChart(container: HTMLElement, options: ChartOptions): ChartInstance;
}
```

#### 사용 예시
```typescript
import { createChart, ChartOptions } from 'chart-library';

const options: ChartOptions = {
    width: 800,
    height: 600,
    data: [
        { x: 1, y: 10 },
        { x: 2, y: 20 },
        { x: 3, y: 15 }
    ],
    color: '#ff0000',
    showLegend: true
};

const chart = createChart(document.getElementById('chart'), options);
chart.render();
```

#### API 클라이언트 타입 정의
```typescript
// api-client.d.ts
declare module 'api-client' {
    export interface ApiResponse<T> {
        data: T;
        status: number;
        message: string;
    }

    export interface ApiError {
        code: string;
        message: string;
        details?: any;
    }

    export interface RequestConfig {
        baseURL?: string;
        timeout?: number;
        headers?: Record<string, string>;
    }

    export class ApiClient {
        constructor(config?: RequestConfig);
        
        get<T>(url: string, config?: RequestConfig): Promise<ApiResponse<T>>;
        post<T>(url: string, data: any, config?: RequestConfig): Promise<ApiResponse<T>>;
        put<T>(url: string, data: any, config?: RequestConfig): Promise<ApiResponse<T>>;
        delete<T>(url: string, config?: RequestConfig): Promise<ApiResponse<T>>;
    }

    export function createApiClient(config?: RequestConfig): ApiClient;
}
```

### 2. 고급 활용 패턴

#### 조건부 타입과 제네릭

조건부 타입을 타입 정의 파일에서 사용하면 API 응답의 여러 상태를 타입 레벨에서 안전하게 표현할 수 있습니다. 특히 성공/실패 같은 유니온 타입을 다룰 때 유용합니다.

```typescript
// advanced-types.d.ts
declare module 'advanced-types' {
    // 성공과 실패를 구분하는 조건부 타입
    // success 필드로 타입 가드를 할 수 있어서 런타임에서도 안전
    export type ApiResult<T> = 
        | { success: true; data: T }
        | { success: false; error: string };

    export type AsyncApiResult<T> = Promise<ApiResult<T>>;

    export interface ApiHandler<T> {
        execute(): AsyncApiResult<T>;
    }

    // 엔드포인트별로 다른 타입을 반환하는 API 클라이언트
    // T는 { '/users': User[], '/posts': Post[] } 같은 맵 타입
    export class TypedApiClient<T> {
        constructor(baseUrl: string);
        
        // K는 T의 키만 허용 (자동완성으로 엔드포인트 목록이 뜸)
        get<K extends keyof T>(endpoint: K): AsyncApiResult<T[K]>;
        post<K extends keyof T>(endpoint: K, data: Partial<T[K]>): AsyncApiResult<T[K]>;
    }
}
```

**실제 사용 예시**
```typescript
import { TypedApiClient, ApiResult } from 'advanced-types';

// API 엔드포인트와 반환 타입을 맵으로 정의
interface ApiEndpoints {
    '/users': User[];
    '/posts': Post[];
    '/profile': UserProfile;
}

const client = new TypedApiClient<ApiEndpoints>('https://api.example.com');

// 엔드포인트를 잘못 입력하면 컴파일 에러
const result = await client.get('/users'); // OK
// const wrong = await client.get('/wrong'); // 에러: '/wrong'은 ApiEndpoints의 키가 아님

// success 필드로 타입 가드
if (result.success) {
    // result.data는 User[] 타입
    console.log(result.data[0].name);
} else {
    // result.error는 string 타입
    console.error(result.error);
}
```

**조건부 타입으로 유연한 반환 타입 만들기**
```typescript
declare module 'flexible-api' {
    // 옵션에 따라 반환 타입이 바뀌는 함수
    export type FetchOptions = {
        raw?: boolean;
        parsed?: boolean;
    };

    // raw가 true면 Response, 아니면 parsed된 데이터
    export type FetchResult<T, O extends FetchOptions> = 
        O['raw'] extends true 
            ? Response 
            : T;

    export function fetchData<T, O extends FetchOptions>(
        url: string, 
        options?: O
    ): Promise<FetchResult<T, O>>;
}
```

**제네릭 제약으로 타입 안전성 높이기**
```typescript
declare module 'type-safe-store' {
    // 특정 구조를 가진 객체만 저장할 수 있는 스토어
    export interface Identifiable {
        id: string | number;
    }

    // T는 반드시 id 필드를 가져야 함
    export class DataStore<T extends Identifiable> {
        constructor();
        
        add(item: T): void;
        get(id: T['id']): T | undefined;
        update(id: T['id'], updates: Partial<T>): void;
        delete(id: T['id']): boolean;
        
        // T의 특정 필드로 필터링
        findBy<K extends keyof T>(key: K, value: T[K]): T[];
    }

    // 배열 타입에서 요소 타입 추출
    export type ExtractArrayType<T> = T extends (infer U)[] ? U : never;
}
```

이런 패턴들은 외부 라이브러리의 복잡한 타입 관계를 표현할 때 매우 유용합니다. 특히 API 클라이언트, 상태 관리 라이브러리, 데이터 변환 유틸리티 같은 곳에서 자주 사용됩니다.

#### 이벤트 시스템 타입 정의
```typescript
// event-system.d.ts
declare module 'event-system' {
    export interface EventMap {
        'user:created': { userId: string; name: string };
        'user:updated': { userId: string; changes: Record<string, any> };
        'user:deleted': { userId: string };
        'order:placed': { orderId: string; amount: number };
    }

    export type EventHandler<T extends keyof EventMap> = (data: EventMap[T]) => void;

    export class EventEmitter {
        on<T extends keyof EventMap>(event: T, handler: EventHandler<T>): void;
        off<T extends keyof EventMap>(event: T, handler: EventHandler<T>): void;
        emit<T extends keyof EventMap>(event: T, data: EventMap[T]): void;
        once<T extends keyof EventMap>(event: T, handler: EventHandler<T>): void;
    }
}
```

## 운영 팁

### 성능 최적화

#### 타입 정의 파일 구조화
```typescript
// types/index.d.ts
export * from './api';
export * from './models';
export * from './utils';

// types/api.d.ts
export interface ApiResponse<T> {
    data: T;
    status: number;
}

// types/models.d.ts
export interface User {
    id: number;
    name: string;
}

// types/utils.d.ts
export type DeepPartial<T> = {
    [K in keyof T]?: T[K] extends object ? DeepPartial<T[K]> : T[K];
};
```

### 에러 처리

#### 타입 정의 파일 검증
```typescript
// validation.d.ts
declare module 'validation' {
    export interface ValidationRule<T> {
        validate(value: T): boolean;
        message: string;
    }

    export interface ValidationResult {
        isValid: boolean;
        errors: string[];
    }

    export class Validator<T> {
        addRule(rule: ValidationRule<T>): Validator<T>;
        validate(value: T): ValidationResult;
    }
}
```

## 참고

### 타입 정의 파일 작성 가이드라인

1. **명확한 인터페이스 정의**: API의 모든 매개변수와 반환값을 명확히 정의
2. **제네릭 활용**: 재사용 가능한 타입 정의를 위해 제네릭 적극 활용
3. **문서화**: JSDoc 주석을 사용하여 API 문서화
4. **테스트**: 실제 사용 사례를 통한 타입 정의 검증

### 자주 사용되는 패턴

```typescript
// 기본 모듈 선언
declare module 'module-name' {
    export interface Config {
        // 설정 인터페이스
    }

    export class MainClass {
        constructor(config: Config);
        // 메서드들
    }

    export function utilityFunction(): void;
}

// 전역 확장
declare global {
    interface Window {
        // 전역 객체 확장
    }
}

// 네임스페이스
declare namespace MyNamespace {
    // 네임스페이스 내 타입들
}
```

### 결론
TypeScript 타입 정의 파일은 JavaScript 라이브러리의 타입 안전성을 확보하는 핵심 도구입니다.
적절한 타입 정의로 개발자 경험을 크게 향상시킬 수 있습니다.
모듈 선언, 전역 확장, 네임스페이스 등을 활용하여 체계적인 타입 정의를 작성하세요.
실제 사용 사례를 기반으로 타입 정의를 검증하고 지속적으로 개선하세요.
타입 정의 파일은 라이브러리의 API 문서 역할도 하므로 명확하고 일관된 네이밍을 사용하세요.
