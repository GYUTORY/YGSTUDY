---
title: TypeScript 타입 정의 파일 완벽 가이드
tags: [language, typescript, 타입-및-타입-정의, type-definitions]
updated: 2025-08-10
---

# TypeScript 타입 정의 파일 완벽 가이드

## 배경

타입 정의 파일(type definition file)은 타입이 없는 JavaScript 라이브러리에 대한 타입 정보를 TypeScript 컴파일러에 전달하여 컴파일을 돕습니다.

### 타입 정의 파일의 필요성
- **타입 안전성 확보**: JavaScript 라이브러리의 타입 정보 제공
- **개발자 경험 향상**: IDE에서 자동완성과 타입 검사 지원
- **컴파일 에러 방지**: 런타임 오류를 컴파일 타임에 감지
- **코드 가독성**: 명확한 API 문서화

### 기본 개념
- **파일 확장자**: `.d.ts` (d는 definition을 의미)
- **앰비언트 선언**: `declare` 키워드를 사용한 타입만 선언
- **고스트 모듈**: 실제 구현 없이 타입 정보만 제공

## 핵심

### 1. 기본 앰비언트 선언

#### 변수 선언
```typescript
declare var hello: any;
declare const API_BASE_URL: string;
declare let globalConfig: {
    debug: boolean;
    timeout: number;
};
```

#### 함수 선언
```typescript
declare function area(shape: string, width: number, height: number): number;
declare function fetchData(url: string): Promise<any>;
declare function formatDate(date: Date, format: string): string;
```

#### 클래스 선언
```typescript
declare class Calculator {
    constructor(initialValue?: number);
    add(value: number): Calculator;
    subtract(value: number): Calculator;
    getResult(): number;
}
```

### 2. 모듈 선언

#### 기본 모듈 선언
```typescript
declare module 'my-library' {
    export interface User {
        id: number;
        name: string;
        email: string;
    }

    export class UserService {
        getUser(id: number): Promise<User>;
        createUser(user: Omit<User, 'id'>): Promise<User>;
        updateUser(id: number, user: Partial<User>): Promise<User>;
        deleteUser(id: number): Promise<void>;
    }

    export function formatUserName(user: User): string;
}
```

#### 네임스페이스 사용
```typescript
declare namespace MyLibrary {
    interface Config {
        apiUrl: string;
        timeout: number;
    }

    class HttpClient {
        constructor(config: Config);
        get<T>(url: string): Promise<T>;
        post<T>(url: string, data: any): Promise<T>;
    }

    function createClient(config: Config): HttpClient;
}
```

### 3. 전역 선언

#### 전역 변수와 함수
```typescript
declare global {
    var globalConfig: {
        apiUrl: string;
        debug: boolean;
    };

    function showNotification(message: string, type?: 'info' | 'warning' | 'error'): void;
}

export {};
```

#### 전역 인터페이스 확장
```typescript
declare global {
    interface Window {
        myApp: {
            version: string;
            config: any;
        };
    }

    interface Array<T> {
        customFilter(predicate: (value: T) => boolean): T[];
    }
}

export {};
```

## 예시

### 1. 실제 사용 사례

#### 외부 라이브러리 타입 정의
```typescript
// chart-library.d.ts
declare module 'chart-library' {
    export interface ChartOptions {
        width: number;
        height: number;
        data: Array<{ x: number; y: number }>;
        color?: string;
        showLegend?: boolean;
    }

    export interface ChartInstance {
        render(): void;
        update(data: Array<{ x: number; y: number }>): void;
        destroy(): void;
    }

    export function createChart(container: HTMLElement, options: ChartOptions): ChartInstance;
    export function createLineChart(container: HTMLElement, options: ChartOptions): ChartInstance;
    export function createBarChart(container: HTMLElement, options: ChartOptions): ChartInstance;
}
```

#### 사용 예시
```typescript
import { createChart, ChartOptions } from 'chart-library';

const options: ChartOptions = {
    width: 800,
    height: 600,
    data: [
        { x: 1, y: 10 },
        { x: 2, y: 20 },
        { x: 3, y: 15 }
    ],
    color: '#ff0000',
    showLegend: true
};

const chart = createChart(document.getElementById('chart'), options);
chart.render();
```

#### API 클라이언트 타입 정의
```typescript
// api-client.d.ts
declare module 'api-client' {
    export interface ApiResponse<T> {
        data: T;
        status: number;
        message: string;
    }

    export interface ApiError {
        code: string;
        message: string;
        details?: any;
    }

    export interface RequestConfig {
        baseURL?: string;
        timeout?: number;
        headers?: Record<string, string>;
    }

    export class ApiClient {
        constructor(config?: RequestConfig);
        
        get<T>(url: string, config?: RequestConfig): Promise<ApiResponse<T>>;
        post<T>(url: string, data: any, config?: RequestConfig): Promise<ApiResponse<T>>;
        put<T>(url: string, data: any, config?: RequestConfig): Promise<ApiResponse<T>>;
        delete<T>(url: string, config?: RequestConfig): Promise<ApiResponse<T>>;
    }

    export function createApiClient(config?: RequestConfig): ApiClient;
}
```

### 2. 고급 활용 패턴

#### 조건부 타입과 제네릭
```typescript
// advanced-types.d.ts
declare module 'advanced-types' {
    export type ApiResult<T> = 
        | { success: true; data: T }
        | { success: false; error: string };

    export type AsyncApiResult<T> = Promise<ApiResult<T>>;

    export interface ApiHandler<T> {
        execute(): AsyncApiResult<T>;
    }

    export class TypedApiClient<T> {
        constructor(baseUrl: string);
        
        get<K extends keyof T>(endpoint: K): AsyncApiResult<T[K]>;
        post<K extends keyof T>(endpoint: K, data: Partial<T[K]>): AsyncApiResult<T[K]>;
    }
}
```

#### 이벤트 시스템 타입 정의
```typescript
// event-system.d.ts
declare module 'event-system' {
    export interface EventMap {
        'user:created': { userId: string; name: string };
        'user:updated': { userId: string; changes: Record<string, any> };
        'user:deleted': { userId: string };
        'order:placed': { orderId: string; amount: number };
    }

    export type EventHandler<T extends keyof EventMap> = (data: EventMap[T]) => void;

    export class EventEmitter {
        on<T extends keyof EventMap>(event: T, handler: EventHandler<T>): void;
        off<T extends keyof EventMap>(event: T, handler: EventHandler<T>): void;
        emit<T extends keyof EventMap>(event: T, data: EventMap[T]): void;
        once<T extends keyof EventMap>(event: T, handler: EventHandler<T>): void;
    }
}
```

## 운영 팁

### 성능 최적화

#### 타입 정의 파일 구조화
```typescript
// types/index.d.ts
export * from './api';
export * from './models';
export * from './utils';

// types/api.d.ts
export interface ApiResponse<T> {
    data: T;
    status: number;
}

// types/models.d.ts
export interface User {
    id: number;
    name: string;
}

// types/utils.d.ts
export type DeepPartial<T> = {
    [K in keyof T]?: T[K] extends object ? DeepPartial<T[K]> : T[K];
};
```

### 에러 처리

#### 타입 정의 파일 검증
```typescript
// validation.d.ts
declare module 'validation' {
    export interface ValidationRule<T> {
        validate(value: T): boolean;
        message: string;
    }

    export interface ValidationResult {
        isValid: boolean;
        errors: string[];
    }

    export class Validator<T> {
        addRule(rule: ValidationRule<T>): Validator<T>;
        validate(value: T): ValidationResult;
    }
}
```

## 참고

### 타입 정의 파일 작성 가이드라인

1. **명확한 인터페이스 정의**: API의 모든 매개변수와 반환값을 명확히 정의
2. **제네릭 활용**: 재사용 가능한 타입 정의를 위해 제네릭 적극 활용
3. **문서화**: JSDoc 주석을 사용하여 API 문서화
4. **테스트**: 실제 사용 사례를 통한 타입 정의 검증

### 자주 사용되는 패턴

```typescript
// 기본 모듈 선언
declare module 'module-name' {
    export interface Config {
        // 설정 인터페이스
    }

    export class MainClass {
        constructor(config: Config);
        // 메서드들
    }

    export function utilityFunction(): void;
}

// 전역 확장
declare global {
    interface Window {
        // 전역 객체 확장
    }
}

// 네임스페이스
declare namespace MyNamespace {
    // 네임스페이스 내 타입들
}
```

### 결론
TypeScript 타입 정의 파일은 JavaScript 라이브러리의 타입 안전성을 확보하는 핵심 도구입니다.
적절한 타입 정의로 개발자 경험을 크게 향상시킬 수 있습니다.
모듈 선언, 전역 확장, 네임스페이스 등을 활용하여 체계적인 타입 정의를 작성하세요.
실제 사용 사례를 기반으로 타입 정의를 검증하고 지속적으로 개선하세요.
타입 정의 파일은 라이브러리의 API 문서 역할도 하므로 명확하고 일관된 네이밍을 사용하세요.
