---
title: TypeScript 고급 타입 기법 완벽 가이드
tags: [language, typescript, 타입-및-타입-정의, advanced-types]
updated: 2025-08-10
---

# TypeScript 고급 타입 기법 완벽 가이드

## 배경

TypeScript의 고급 타입 기법은 복잡한 타입 시스템을 구축하고 타입 안전성을 극대화하는 데 사용됩니다.

### 고급 타입 기법의 필요성
- **타입 안전성 강화**: 컴파일 타임에 더 정확한 타입 검사
- **코드 재사용성**: 복잡한 타입 로직의 재사용
- **개발자 경험**: 더 나은 IDE 지원과 자동완성
- **런타임 오류 방지**: 타입 시스템을 통한 오류 사전 방지

### 핵심 개념
고급 타입 기법은 조건부 타입, 매핑 타입, 템플릿 리터럴 타입, infer 패턴 등을 조합하여 강력한 타입 시스템을 구축합니다.

## 핵심

### 1. 조건부 타입 (Conditional Types)

#### 기본 조건부 타입
```typescript
type IsString<T> = T extends string ? true : false;

type A = IsString<'a'>; // true
type B = IsString<123>;  // false
```

**설명**: `T extends U ? X : Y` 형태로 T가 U의 부분집합(할당 가능)이면 X, 아니면 Y를 반환합니다.

#### 제네릭 함수에서의 활용
```typescript
function toArray<T>(value: T): T extends any[] ? T : T[] {
    // 구현은 as로 우회할 때가 많음 (런타임 분기와는 별개)
    return (Array.isArray(value) ? value : [value]) as any;
}

const result1 = toArray([1, 2, 3]); // number[]
const result2 = toArray('hello');   // string[]
```

### 2. 분배 조건부 타입 (Distributive Conditional Types)

#### 기본 분배 동작
```typescript
type ToPromise<T> = T extends any ? Promise<T> : never;

type P = ToPromise<string | number>; // Promise<string> | Promise<number>
```

**설명**: 유니온에 조건부 타입을 적용하면 각 원소에 분배되어 평가됩니다.

#### 분배 방지
```typescript
type NoDistribute<T> = [T] extends [any] ? Promise<T> : never;
type Q = NoDistribute<string | number>; // Promise<string | number>
```

#### 유틸리티 타입에서의 활용
```typescript
type OnlyString = Extract<string | number | boolean, string | boolean>; // string | boolean
type NotNull = Exclude<string | null | undefined, null | undefined>;   // string
```

### 3. 매핑 타입 (Mapped Types)

#### 기본 매핑 타입
```typescript
type ReadonlyDeep<T> = {
    readonly [K in keyof T]: T[K] extends object ? ReadonlyDeep<T[K]> : T[K];
};

type PartialBy<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;

type User = { id: string; name: string; age?: number };
type UserReadonly = ReadonlyDeep<User>;
type UserEditableName = PartialBy<User, 'name'>;
```

#### 수식어 활용
```typescript
// readonly 추가
type ReadonlyKeys<T> = { readonly [K in keyof T]: T[K] };

// optional 제거
type RequiredKeys<T> = { [K in keyof T]-?: T[K] };

// readonly 제거
type MutableKeys<T> = { -readonly [K in keyof T]: T[K] };
```

### 4. 템플릿 리터럴 타입 (Template Literal Types)

#### 기본 템플릿 리터럴 타입
```typescript
type HttpMethod = 'get' | 'post' | 'put' | 'delete';
type Route<M extends HttpMethod> = `${M}:/api/${string}`;

type A = Route<'get'>;      // "get:/api/${string}"
type B = Route<'post'>;     // "post:/api/${string}"
```

#### 문자열 조작
```typescript
// camelCase 변환
type CamelCase<S extends string> = S extends `${infer H}_${infer R}`
    ? `${Lowercase<H>}${Capitalize<CamelCase<R>>}`
    : Lowercase<S>;

type Ex1 = CamelCase<'USER_NAME'>;     // 'userName'
type Ex2 = CamelCase<'REQUEST_ID'>;    // 'requestId'

// 문자열 유틸리티 타입들
type Upper = Uppercase<'hello'>;       // 'HELLO'
type Lower = Lowercase<'WORLD'>;       // 'world'
type Cap = Capitalize<'hello'>;        // 'Hello'
type Uncap = Uncapitalize<'Hello'>;    // 'hello'
```

### 5. infer 패턴 (조건부 타입 안에서 타입 추론)

#### 함수 반환 타입 추출
```typescript
type Return<T> = T extends (...args: any) => infer R ? R : never;

function f() { return { ok: true as const, data: [1, 2, 3] as const }; }
type R = Return<typeof f>; // { ok: true; data: readonly [1, 2, 3] }
```

#### 함수 매개변수 타입 추출
```typescript
type FirstArg<T> = T extends (arg: infer A, ...rest: any) => any ? A : never;
type A1 = FirstArg<(x: { id: string }) => void>; // { id: string }

type AllArgs<T> = T extends (...args: infer A) => any ? A : never;
type Args = AllArgs<(x: string, y: number) => void>; // [string, number]
```

#### Promise 타입 추출
```typescript
type AwaitedDeep<T> = T extends Promise<infer U> ? AwaitedDeep<U> : T;
type D = AwaitedDeep<Promise<Promise<number>>>; // number
```

#### 튜플 타입 조작
```typescript
type Head<T extends any[]> = T extends [infer H, ...any[]] ? H : never;
type Tail<T extends any[]> = T extends [any, ...infer R] ? R : never;
type H1 = Head<[1, 2, 3]>; // 1
type T1 = Tail<[1, 2, 3]>; // [2, 3]
```

## 예시

### 1. 실제 사용 사례

#### API 응답 파이프라인
```typescript
type ApiHandler<T> = () => Promise<{ ok: boolean; data: T }>;
type ApiData<T extends ApiHandler<any>> = AwaitedDeep<Return<T>>['data'];

declare const getUser: ApiHandler<{ id: string; name: string }>;
type UserData = ApiData<typeof getUser>; // { id: string; name: string }

// 사용 예시
async function handleApiResponse<T extends ApiHandler<any>>(handler: T) {
    const response = await handler();
    if (response.ok) {
        return response.data; // 타입이 자동으로 추론됨
    }
    throw new Error('API 호출 실패');
}
```

#### 이벤트 시스템
```typescript
type EventMap = {
    'user:created': { userId: string; name: string };
    'user:updated': { userId: string; changes: Partial<{ name: string; email: string }> };
    'user:deleted': { userId: string };
};

type EventHandler<T extends keyof EventMap> = (data: EventMap[T]) => void;

class EventEmitter {
    private handlers: Map<keyof EventMap, EventHandler<any>[]> = new Map();

    on<T extends keyof EventMap>(event: T, handler: EventHandler<T>) {
        if (!this.handlers.has(event)) {
            this.handlers.set(event, []);
        }
        this.handlers.get(event)!.push(handler);
    }

    emit<T extends keyof EventMap>(event: T, data: EventMap[T]) {
        const handlers = this.handlers.get(event) || [];
        handlers.forEach(handler => handler(data));
    }
}

// 사용 예시
const emitter = new EventEmitter();

emitter.on('user:created', (data) => {
    console.log(`사용자 생성: ${data.name} (${data.userId})`);
    // data의 타입이 자동으로 추론됨
});

emitter.emit('user:created', { userId: '123', name: '홍길동' });
```

### 2. 고급 활용 패턴

#### 브랜드 타입
```typescript
type Brand<K, T> = K & { __brand: T };
type UserId = Brand<string, 'UserId'>;
type ProductId = Brand<string, 'ProductId'>;

function createUserId(id: string): UserId {
    return id as UserId;
}

function createProductId(id: string): ProductId {
    return id as ProductId;
}

// 타입 안전성 보장
const userId = createUserId('user123');
const productId = createProductId('prod456');

// userId = productId; // 오류: 타입이 다름
```

#### 깊은 부분 타입
```typescript
type DeepPartial<T> = {
    [K in keyof T]?: T[K] extends object ? DeepPartial<T[K]> : T[K];
};

interface User {
    id: number;
    profile: {
        name: string;
        address: {
            city: string;
            country: string;
        };
    };
}

type PartialUser = DeepPartial<User>;
// {
//   id?: number;
//   profile?: {
//     name?: string;
//     address?: {
//       city?: string;
//       country?: string;
//     };
//   };
// }
```

#### 조건부 유틸리티 타입
```typescript
type MaybeArray<T> = T | T[];
type ElementOf<T> = T extends (infer U)[] ? U : T;

type StringOrArray = MaybeArray<string>; // string | string[]
type Element = ElementOf<StringOrArray>; // string

// 사용 예시
function processData<T>(data: MaybeArray<T>): T[] {
    return Array.isArray(data) ? data : [data];
}
```

## 운영 팁

### 성능 최적화

#### 타입 캐싱
```typescript
// 복잡한 타입 계산을 미리 정의
type ComplexType<T> = T extends string 
    ? { type: 'string'; value: T }
    : T extends number
    ? { type: 'number'; value: T }
    : { type: 'unknown'; value: T };

// 자주 사용되는 타입 조합을 타입 별칭으로 정의
type CommonPattern<T> = DeepPartial<Readonly<T>>;
```

### 에러 처리

#### 타입 가드와 함께 사용
```typescript
function isString(value: unknown): value is string {
    return typeof value === 'string';
}

function processValue<T>(value: T): T extends string ? string[] : T {
    if (isString(value)) {
        return value.split('') as any;
    }
    return value as any;
}
```

## 참고

### 고급 타입 기법 체크리스트

1. **조건부 타입**: `T extends U ? X : Y` 형태로 타입 분기
2. **분배 조건부 타입**: 유니온 타입에서 각 원소별로 분배 적용
3. **매핑 타입**: `{ [K in keyof T]: ... }` 형태로 객체 타입 변환
4. **템플릿 리터럴 타입**: 문자열 타입 조합 및 조작
5. **infer 패턴**: 조건부 타입에서 타입 추론

### 자주 사용되는 패턴

```typescript
// 함수 타입 추출
type ReturnType<T> = T extends (...args: any) => infer R ? R : never;

// 배열 요소 타입 추출
type ArrayElement<T> = T extends (infer U)[] ? U : never;

// Promise 타입 추출
type PromiseType<T> = T extends Promise<infer U> ? U : never;

// 객체 키 타입 추출
type Keys<T> = keyof T;

// 객체 값 타입 추출
type Values<T> = T[keyof T];
```

### 결론
TypeScript의 고급 타입 기법은 강력한 타입 시스템을 구축하는 핵심 도구입니다.
조건부 타입, 매핑 타입, 템플릿 리터럴 타입, infer 패턴을 조합하여 복잡한 타입 로직을 구현할 수 있습니다.
실제 프로젝트에서 API 응답, 이벤트 시스템, 상태 관리 등에 널리 활용됩니다.
적절한 고급 타입 기법 사용으로 타입 안전성과 개발 효율성을 동시에 향상시킬 수 있습니다.
복잡한 타입은 단계적으로 분해하여 가독성과 유지보수성을 유지하세요.
