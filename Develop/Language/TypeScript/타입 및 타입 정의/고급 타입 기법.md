---
title: TypeScript 고급 타입 기법
tags: [language, typescript, 타입-및-타입-정의, advanced-types]
updated: 2025-11-01
---

# TypeScript 고급 타입 기법

## 배경

TypeScript의 고급 타입 기법은 복잡한 타입 시스템을 구축하고 타입 안전성을 극대화하는 데 사용됩니다. 단순히 interface나 type alias로는 표현하기 어려운 복잡한 타입 관계를 정의할 때 필요합니다.

### 고급 타입 기법의 필요성

프로젝트 규모가 커지면서 다음과 같은 상황에서 고급 타입 기법이 필요합니다:

- **타입 안전성 강화**: 컴파일 타임에 더 정확한 타입 검사를 통해 런타임 오류를 사전에 방지할 수 있습니다. 예를 들어 API 응답 타입과 실제 사용하는 데이터 타입이 일치하는지 보장할 수 있습니다.

- **코드 재사용성**: 복잡한 타입 로직을 재사용 가능한 형태로 만들 수 있습니다. 동일한 패턴의 타입을 매번 작성하는 대신, 제네릭과 조건부 타입을 활용해 유연하게 대응할 수 있습니다.

- **개발자 경험 향상**: IDE의 자동완성과 타입 추론을 극대화하여 개발 속도를 높일 수 있습니다. 특히 복잡한 객체 구조에서도 정확한 타입 힌트를 제공받을 수 있습니다.

- **타입 변환 자동화**: 하나의 타입에서 다른 타입으로 자동으로 변환하는 타입 유틸리티를 만들 수 있습니다. 예를 들어 API 요청 타입에서 응답 타입을 자동으로 도출하거나, DTO에서 Entity 타입을 생성할 수 있습니다.

### 핵심 개념

고급 타입 기법은 조건부 타입, 매핑 타입, 템플릿 리터럴 타입, infer 패턴 등을 조합하여 강력한 타입 시스템을 구축합니다. 이러한 기법들은 TypeScript의 타입 시스템이 제공하는 기능을 최대한 활용하여, 컴파일 타임에 복잡한 타입 로직을 수행할 수 있게 해줍니다.

실제 개발에서는 이런 고급 기법들이 라이브러리 타입 정의나 공통 유틸리티 타입을 만들 때 주로 사용되며, 한 번 잘 정의해두면 프로젝트 전체에서 타입 안전성을 크게 향상시킬 수 있습니다.

## 핵심

### 1. 조건부 타입 (Conditional Types)

조건부 타입은 입력된 타입에 따라 다른 타입을 반환하는 메커니즘입니다. 삼항 연산자와 비슷한 형태로 작성되며, 타입 레벨에서의 분기 처리를 가능하게 합니다.

#### 기본 조건부 타입
```typescript
type IsString<T> = T extends string ? true : false;

type A = IsString<'a'>; // true
type B = IsString<123>;  // false
```

**동작 원리**: `T extends U ? X : Y` 형태로 T가 U에 할당 가능하면(부분집합이면) X 타입을, 그렇지 않으면 Y 타입을 반환합니다. 이는 컴파일 타임에 평가되므로 런타임 오버헤드가 전혀 없습니다.

`extends` 키워드는 "할당 가능성"을 체크합니다. 즉, `T extends U`는 "T 타입의 값을 U 타입 변수에 할당할 수 있는가?"를 묻는 것입니다.

```typescript
// 더 실용적인 예시
type IsArray<T> = T extends any[] ? true : false;
type IsFunction<T> = T extends (...args: any[]) => any ? true : false;
type IsPromise<T> = T extends Promise<any> ? true : false;

type Test1 = IsArray<number[]>;     // true
type Test2 = IsArray<string>;       // false
type Test3 = IsFunction<() => void>; // true
type Test4 = IsPromise<Promise<string>>; // true
```

#### 중첩 조건부 타입
```typescript
type TypeName<T> =
    T extends string ? "string" :
    T extends number ? "number" :
    T extends boolean ? "boolean" :
    T extends undefined ? "undefined" :
    T extends Function ? "function" :
    "object";

type T1 = TypeName<string>;  // "string"
type T2 = TypeName<123>;     // "number"
type T3 = TypeName<true>;    // "boolean"
type T4 = TypeName<() => void>; // "function"
type T5 = TypeName<{ a: 1 }>;   // "object"
```

이런 패턴은 런타임의 `typeof` 연산자와 유사하지만, 타입 레벨에서 동작하므로 훨씬 강력하고 정확합니다.

#### 제네릭 함수에서의 활용
```typescript
function toArray<T>(value: T): T extends any[] ? T : T[] {
    // 구현부에서는 타입 단언이 필요할 수 있음
    // 조건부 타입의 반환 타입은 TypeScript가 추론하기 어렵기 때문
    return (Array.isArray(value) ? value : [value]) as any;
}

const result1 = toArray([1, 2, 3]); // number[] - 이미 배열이므로 그대로 반환
const result2 = toArray('hello');   // string[] - 문자열을 배열로 감싸서 반환
const result3 = toArray(42);        // number[] - 숫자를 배열로 감싸서 반환
```

주의할 점은 조건부 타입을 함수 반환 타입으로 사용할 때, 함수 내부에서는 TypeScript가 정확한 타입을 추론하지 못하는 경우가 많습니다. 이는 TypeScript의 제어 흐름 분석이 타입 매개변수의 조건부 타입까지는 추적하지 못하기 때문입니다.

#### 실제 사용 사례: 타입 안전한 설정 객체
```typescript
type Config<Environment extends 'dev' | 'prod'> = {
    apiUrl: string;
    timeout: number;
} & (Environment extends 'dev' 
    ? { debug: true; logLevel: 'verbose' | 'debug' } 
    : { debug: false });

// 개발 환경에서는 debug와 logLevel 필수
const devConfig: Config<'dev'> = {
    apiUrl: 'http://localhost:3000',
    timeout: 5000,
    debug: true,
    logLevel: 'verbose'
};

// 프로덕션 환경에서는 debug만 있으면 됨
const prodConfig: Config<'prod'> = {
    apiUrl: 'https://api.example.com',
    timeout: 30000,
    debug: false
};
```

### 2. 분배 조건부 타입 (Distributive Conditional Types)

분배 조건부 타입은 TypeScript의 강력한 기능 중 하나로, 유니온 타입에 조건부 타입을 적용할 때 각 멤버에 대해 개별적으로 타입 검사를 수행합니다.

#### 기본 분배 동작
```typescript
type ToPromise<T> = T extends any ? Promise<T> : never;

type P = ToPromise<string | number>; // Promise<string> | Promise<number>
```

**동작 메커니즘**: 
1. `string | number`가 `T`에 전달됩니다
2. TypeScript는 이를 `ToPromise<string> | ToPromise<number>`로 분배합니다
3. 각각 평가되어 `Promise<string> | Promise<number>`가 됩니다

이 분배는 자동으로 일어나며, 타입 매개변수가 "naked type parameter"(다른 타입으로 감싸지지 않은 순수한 형태)일 때만 발생합니다.

```typescript
// 분배가 일어나는 더 실용적인 예시
type Nullable<T> = T extends any ? T | null : never;
type StringOrNull = Nullable<string | number>; 
// string | null | number | null → string | number | null

// 배열 타입 필터링
type ArrayType<T> = T extends any[] ? T : never;
type OnlyArrays = ArrayType<string | number[] | boolean[]>; 
// never | number[] | boolean[] → number[] | boolean[]
```

#### 분배 방지

때로는 유니온 타입을 하나의 단위로 처리하고 싶을 때가 있습니다. 이때는 타입 매개변수를 다른 타입으로 감싸서 "naked"하지 않게 만들면 됩니다.

```typescript
// 분배가 일어나지 않도록 튜플로 감싸기
type NoDistribute<T> = [T] extends [any] ? Promise<T> : never;
type Q = NoDistribute<string | number>; // Promise<string | number>

// 비교: 분배가 일어나는 경우
type WithDistribute<T> = T extends any ? Promise<T> : never;
type R = WithDistribute<string | number>; // Promise<string> | Promise<number>
```

**왜 이런 차이가 발생할까?**
- `[T]`로 감싸면 T가 더 이상 naked type parameter가 아니므로 분배가 일어나지 않습니다
- TypeScript는 `[string | number]`를 하나의 튜플 타입으로 취급합니다

```typescript
// 실제 사용 예시: 유니온 타입의 모든 멤버가 특정 조건을 만족하는지 확인
type AllExtends<T, U> = [T] extends [U] ? true : false;
type Test1 = AllExtends<string | number, string | number | boolean>; // true
type Test2 = AllExtends<string | symbol, string | number>; // false

// 분배를 사용한다면?
type AnyExtends<T, U> = T extends U ? true : false;
type Test3 = AnyExtends<string | number, string | number | boolean>; // true
type Test4 = AnyExtends<string | symbol, string | number>; // boolean (true | false)
```

#### 유틸리티 타입에서의 활용

TypeScript에 내장된 유틸리티 타입들도 분배 조건부 타입을 활용합니다.

```typescript
// Extract: 두 번째 타입에 할당 가능한 타입만 추출
type OnlyString = Extract<string | number | boolean, string | boolean>; 
// string | boolean

// Exclude: 두 번째 타입에 할당 가능한 타입 제외
type NotNull = Exclude<string | null | undefined, null | undefined>;   
// string

// 실제 구현
type MyExtract<T, U> = T extends U ? T : never;
type MyExclude<T, U> = T extends U ? never : T;

// 더 실용적인 예시
type ApiResponse = 
    | { status: 'success'; data: string }
    | { status: 'error'; error: string }
    | { status: 'loading' };

// 성공/에러 응답만 추출
type DataResponse = Extract<ApiResponse, { data: any }>; 
// { status: 'success'; data: string }

type ErrorResponse = Extract<ApiResponse, { error: any }>; 
// { status: 'error'; error: string }

// status별로 필터링
type SuccessResponse = Extract<ApiResponse, { status: 'success' }>;
// { status: 'success'; data: string }
```

#### 함수 오버로드 타입 추출

```typescript
// 함수 유니온에서 특정 시그니처만 추출
type FnType = 
    | ((x: string) => string)
    | ((x: number) => number)
    | ((x: boolean) => boolean);

type StringFn = Extract<FnType, (x: string) => any>;
// (x: string) => string

type NumberOrBooleanFn = Exclude<FnType, (x: string) => any>;
// ((x: number) => number) | ((x: boolean) => boolean)
```

### 3. 매핑 타입 (Mapped Types)

매핑 타입은 기존 타입의 각 속성을 순회하면서 새로운 타입을 만들어내는 기법입니다. JavaScript의 `map` 함수와 비슷하게, 타입 레벨에서 변환 작업을 수행합니다.

#### 기본 매핑 타입
```typescript
type ReadonlyDeep<T> = {
    readonly [K in keyof T]: T[K] extends object ? ReadonlyDeep<T[K]> : T[K];
};

type PartialBy<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;

type User = { id: string; name: string; age?: number };
type UserReadonly = ReadonlyDeep<User>;
// { readonly id: string; readonly name: string; readonly age?: number }

type UserEditableName = PartialBy<User, 'name'>;
// { id: string; age?: number } & { name?: string }
```

**동작 원리**:
- `[K in keyof T]`: T의 모든 키를 순회합니다
- `K`는 현재 순회 중인 속성 이름입니다
- `T[K]`는 해당 속성의 타입을 의미합니다

```typescript
// 단계별로 이해하기
type User = { id: number; name: string };

// 1. keyof User → 'id' | 'name'
// 2. K in 'id' | 'name' → K는 'id', 'name'을 차례로 순회
// 3. 각 K에 대해 T[K] (즉, number, string) 추출

type MakeReadonly<T> = {
    readonly [K in keyof T]: T[K]
};

type ReadonlyUser = MakeReadonly<User>;
// { readonly id: number; readonly name: string }
```

#### 수식어 활용

매핑 타입에서는 `readonly`와 `?`(optional) 수식어를 추가하거나 제거할 수 있습니다.

```typescript
// readonly 추가
type ReadonlyKeys<T> = { 
    readonly [K in keyof T]: T[K] 
};

// optional 추가
type PartialKeys<T> = { 
    [K in keyof T]?: T[K] 
};

// optional 제거 (Required와 동일)
type RequiredKeys<T> = { 
    [K in keyof T]-?: T[K] 
};

// readonly 제거
type MutableKeys<T> = { 
    -readonly [K in keyof T]: T[K] 
};
```

**주의**: `-readonly`와 `-?`는 해당 수식어를 제거하는 것이지, 단순히 무시하는 것이 아닙니다.

```typescript
interface Person {
    readonly id: number;
    name?: string;
    age: number;
}

type MutablePerson = MutableKeys<Person>;
// { id: number; name?: string; age: number }

type RequiredPerson = RequiredKeys<Person>;
// { readonly id: number; name: string; age: number }

type FullyMutable = MutableKeys<RequiredKeys<Person>>;
// { id: number; name: string; age: number }
```

#### 키 필터링과 재매핑

TypeScript 4.1부터 `as` 절을 사용한 키 재매핑이 가능해졌습니다.

```typescript
// 특정 키만 선택
type PickByType<T, ValueType> = {
    [K in keyof T as T[K] extends ValueType ? K : never]: T[K]
};

interface Example {
    id: number;
    name: string;
    age: number;
    active: boolean;
}

type NumericFields = PickByType<Example, number>;
// { id: number; age: number }

type StringFields = PickByType<Example, string>;
// { name: string }

// Getter 타입 생성
type Getters<T> = {
    [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K]
};

type UserGetters = Getters<{ name: string; age: number }>;
// {
//   getName: () => string;
//   getAge: () => number;
// }

// 특정 접두사 제거
type RemovePrefix<T, Prefix extends string> = {
    [K in keyof T as K extends `${Prefix}${infer Rest}` ? Rest : K]: T[K]
};

type WithPrefix = {
    user_name: string;
    user_age: number;
    role: string;
};

type WithoutPrefix = RemovePrefix<WithPrefix, 'user_'>;
// { name: string; age: number; role: string }
```

#### 실전 활용: API 응답 변환

```typescript
// API에서 snake_case로 오는 데이터를 camelCase로 변환
type SnakeToCamelCase<S extends string> = 
    S extends `${infer First}_${infer Rest}`
        ? `${First}${Capitalize<SnakeToCamelCase<Rest>>}`
        : S;

type CamelCaseKeys<T> = {
    [K in keyof T as SnakeToCamelCase<string & K>]: T[K]
};

type ApiUser = {
    user_id: number;
    user_name: string;
    created_at: string;
};

type AppUser = CamelCaseKeys<ApiUser>;
// { userId: number; userName: string; createdAt: string }

// 실제 변환 함수와 함께 사용
function toCamelCase<T extends Record<string, any>>(obj: T): CamelCaseKeys<T> {
    const result: any = {};
    for (const key in obj) {
        const camelKey = key.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
        result[camelKey] = obj[key];
    }
    return result;
}
```

### 4. 템플릿 리터럴 타입 (Template Literal Types)

템플릿 리터럴 타입은 JavaScript의 템플릿 리터럴 문법을 타입 시스템에서 사용할 수 있게 해줍니다. 문자열 타입을 조합하고 패턴을 매칭하는 강력한 도구입니다.

#### 기본 템플릿 리터럴 타입
```typescript
type HttpMethod = 'get' | 'post' | 'put' | 'delete';
type Route<M extends HttpMethod> = `${M}:/api/${string}`;

type A = Route<'get'>;      // "get:/api/${string}"
type B = Route<'post'>;     // "post:/api/${string}"
```

**유니온 타입과의 조합**: 템플릿 리터럴 타입에 유니온을 사용하면 모든 조합이 생성됩니다.

```typescript
type HttpMethod = 'GET' | 'POST';
type Resource = 'users' | 'posts';
type Endpoint = `${HttpMethod} /api/${Resource}`;
// "GET /api/users" | "GET /api/posts" | "POST /api/users" | "POST /api/posts"

// 실용적인 예시: 이벤트 이름 생성
type EventType = 'click' | 'hover' | 'focus';
type Element = 'button' | 'input' | 'link';
type UIEvent = `${Element}:${EventType}`;
// "button:click" | "button:hover" | "button:focus" | 
// "input:click" | "input:hover" | "input:focus" | ...

// 타입 안전한 이벤트 리스너
function addEventListener(event: UIEvent, handler: () => void) {
    // event는 정확한 조합만 허용됨
}

addEventListener('button:click', () => {}); // OK
// addEventListener('button:invalid', () => {}); // 에러
```

#### 문자열 조작

TypeScript 4.1에서 추가된 내장 문자열 조작 타입들을 활용할 수 있습니다.

```typescript
// 문자열 유틸리티 타입들
type Upper = Uppercase<'hello'>;       // 'HELLO'
type Lower = Lowercase<'WORLD'>;       // 'world'
type Cap = Capitalize<'hello'>;        // 'Hello'
type Uncap = Uncapitalize<'Hello'>;    // 'hello'

// 재귀적 camelCase 변환
type CamelCase<S extends string> = S extends `${infer H}_${infer R}`
    ? `${Lowercase<H>}${Capitalize<CamelCase<R>>}`
    : Lowercase<S>;

type Ex1 = CamelCase<'USER_NAME'>;     // 'userName'
type Ex2 = CamelCase<'REQUEST_ID'>;    // 'requestId'
type Ex3 = CamelCase<'API_BASE_URL'>;  // 'apiBaseUrl'

// snake_case 변환 (반대 방향)
type SnakeCase<S extends string> = S extends `${infer First}${infer Rest}`
    ? Rest extends Uncapitalize<Rest>
        ? `${Lowercase<First>}${SnakeCase<Rest>}`
        : `${Lowercase<First>}_${SnakeCase<Rest>}`
    : S;

type Ex4 = SnakeCase<'userName'>;      // 'user_name'
type Ex5 = SnakeCase<'apiBaseUrl'>;    // 'api_base_url'
```

#### 패턴 매칭과 타입 추출

템플릿 리터럴 타입은 `infer`와 함께 사용하여 문자열에서 특정 부분을 추출할 수 있습니다.

```typescript
// URL 경로에서 파라미터 추출
type ExtractParams<Path extends string> =
    Path extends `${infer _Start}:${infer Param}/${infer Rest}`
        ? Param | ExtractParams<`/${Rest}`>
        : Path extends `${infer _Start}:${infer Param}`
        ? Param
        : never;

type Params1 = ExtractParams<'/users/:id/posts/:postId'>;
// 'id' | 'postId'

type Params2 = ExtractParams<'/api/:version/:resource'>;
// 'version' | 'resource'

// 실제 활용: 타입 안전한 라우터
type Route = '/users/:userId/posts/:postId';
type RouteParams = ExtractParams<Route>;
// 'userId' | 'postId'

function navigate(
    path: Route,
    params: Record<RouteParams, string>
) {
    // params는 userId와 postId를 반드시 포함해야 함
}

navigate('/users/:userId/posts/:postId', {
    userId: '123',
    postId: '456'
}); // OK

// navigate('/users/:userId/posts/:postId', {
//     userId: '123'
//     // postId 누락 - 에러
// });
```

#### CSS 클래스 이름 생성

```typescript
// BEM 스타일 클래스 이름
type Block = 'button' | 'input' | 'modal';
type Element = 'icon' | 'text' | 'label';
type Modifier = 'active' | 'disabled' | 'large';

type BEMClass = 
    | `${Block}`
    | `${Block}__${Element}`
    | `${Block}--${Modifier}`
    | `${Block}__${Element}--${Modifier}`;

const className: BEMClass = 'button__icon--large'; // OK
// const invalid: BEMClass = 'button-icon'; // 에러

// Tailwind 스타일 유틸리티
type Size = 'sm' | 'md' | 'lg';
type Spacing = '0' | '1' | '2' | '4' | '8';
type MarginClass = `m-${Spacing}` | `mt-${Spacing}` | `mr-${Spacing}` | `mb-${Spacing}` | `ml-${Spacing}`;

const margin: MarginClass = 'mt-4'; // OK
```

#### SQL 쿼리 빌더 타입

```typescript
// 타입 안전한 SQL 쿼리
type Table = 'users' | 'posts' | 'comments';
type Operation = 'SELECT' | 'INSERT' | 'UPDATE' | 'DELETE';
type SQLQuery<Op extends Operation, T extends Table> = `${Op} FROM ${T}`;

type UserQuery = SQLQuery<'SELECT', 'users'>;
// "SELECT FROM users"

// WHERE 절 포함
type WhereQuery<T extends Table, Column extends string> = 
    `SELECT FROM ${T} WHERE ${Column} = ?`;

type FindUserById = WhereQuery<'users', 'id'>;
// "SELECT FROM users WHERE id = ?"
```

### 5. infer 패턴 (조건부 타입 안에서 타입 추론)

`infer` 키워드는 조건부 타입 내에서 타입의 일부를 추론하고 변수에 할당하는 강력한 기능입니다. 패턴 매칭과 비슷하게 동작하며, 복잡한 타입에서 원하는 부분만 추출할 수 있습니다.

#### 함수 반환 타입 추출
```typescript
type Return<T> = T extends (...args: any) => infer R ? R : never;

function f() { return { ok: true as const, data: [1, 2, 3] as const }; }
type R = Return<typeof f>; // { ok: true; data: readonly [1, 2, 3] }
```

**동작 원리**:
1. `T extends (...args: any) => infer R`: T가 함수 타입인지 검사
2. `infer R`: 반환 타입을 R이라는 타입 변수에 할당
3. 조건이 참이면 R을 반환, 아니면 never

```typescript
// 여러 함수에 적용
function getString() { return 'hello'; }
function getNumber() { return 42; }
function getObject() { return { x: 10, y: 20 }; }

type R1 = Return<typeof getString>; // string
type R2 = Return<typeof getNumber>; // number
type R3 = Return<typeof getObject>; // { x: number; y: number }

// async 함수는 Promise를 반환
async function fetchData() { return { data: [1, 2, 3] }; }
type R4 = Return<typeof fetchData>; // Promise<{ data: number[] }>

// Promise 내부 타입 추출이 필요하면 Awaited 사용
type R5 = Awaited<Return<typeof fetchData>>; // { data: number[] }
```

#### 함수 매개변수 타입 추출

```typescript
// 첫 번째 인자만 추출
type FirstArg<T> = T extends (arg: infer A, ...rest: any) => any ? A : never;
type A1 = FirstArg<(x: { id: string }) => void>; // { id: string }
type A2 = FirstArg<(x: number, y: string) => void>; // number

// 모든 인자를 튜플로 추출
type AllArgs<T> = T extends (...args: infer A) => any ? A : never;
type Args = AllArgs<(x: string, y: number) => void>; // [string, number]

// 두 번째 인자 추출
type SecondArg<T> = T extends (first: any, second: infer S, ...rest: any) => any ? S : never;
type S1 = SecondArg<(a: string, b: number, c: boolean) => void>; // number

// 실제 활용: 이벤트 핸들러 타입 추출
type EventHandler = (event: MouseEvent, detail: { x: number; y: number }) => void;
type EventType = FirstArg<EventHandler>; // MouseEvent
type DetailType = SecondArg<EventHandler>; // { x: number; y: number }
```

#### Promise 타입 추출

```typescript
// 단일 Promise 언래핑
type Unpromise<T> = T extends Promise<infer U> ? U : T;
type U1 = Unpromise<Promise<string>>; // string
type U2 = Unpromise<number>; // number (Promise가 아니므로 그대로)

// 중첩 Promise 재귀적 언래핑
type AwaitedDeep<T> = T extends Promise<infer U> ? AwaitedDeep<U> : T;
type D1 = AwaitedDeep<Promise<Promise<number>>>; // number
type D2 = AwaitedDeep<Promise<Promise<Promise<string>>>>; // string

// 배열 내 Promise 언래핑
type UnpromiseArray<T> = T extends (Promise<infer U>)[] ? U[] : T;
type U3 = UnpromiseArray<Promise<number>[]>; // number[]
type U4 = UnpromiseArray<Promise<string>[]>; // string[]

// 실제 사용: API 응답 타입 추출
async function fetchUsers() {
    return [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];
}

type UsersResponse = Awaited<ReturnType<typeof fetchUsers>>;
// { id: number; name: string }[]

type User = UsersResponse[number];
// { id: number; name: string }
```

#### 튜플 타입 조작

```typescript
// 첫 번째 요소 추출
type Head<T extends any[]> = T extends [infer H, ...any[]] ? H : never;
type H1 = Head<[1, 2, 3]>; // 1
type H2 = Head<['hello', 42, true]>; // 'hello'

// 첫 번째를 제외한 나머지 추출
type Tail<T extends any[]> = T extends [any, ...infer R] ? R : never;
type T1 = Tail<[1, 2, 3]>; // [2, 3]
type T2 = Tail<['hello', 42, true]>; // [42, true]

// 마지막 요소 추출
type Last<T extends any[]> = T extends [...any[], infer L] ? L : never;
type L1 = Last<[1, 2, 3]>; // 3
type L2 = Last<['a', 'b', 'c']>; // 'c'

// 마지막을 제외한 나머지 추출
type Init<T extends any[]> = T extends [...infer I, any] ? I : never;
type I1 = Init<[1, 2, 3]>; // [1, 2]
type I2 = Init<['a', 'b', 'c']>; // ['a', 'b']

// 튜플 연결
type Concat<T extends any[], U extends any[]> = [...T, ...U];
type C1 = Concat<[1, 2], [3, 4]>; // [1, 2, 3, 4]

// 튜플 뒤집기
type Reverse<T extends any[]> = T extends [infer First, ...infer Rest]
    ? [...Reverse<Rest>, First]
    : [];
type Rev = Reverse<[1, 2, 3, 4]>; // [4, 3, 2, 1]
```

#### 객체 타입에서 값 추출

```typescript
// 특정 키의 값 타입 추출
type PropType<T, K extends keyof T> = T[K];
type User = { id: number; name: string; email: string };
type UserId = PropType<User, 'id'>; // number

// 중첩 객체의 값 추출
type DeepProp<T, K extends string> = 
    K extends `${infer First}.${infer Rest}`
        ? First extends keyof T
            ? DeepProp<T[First], Rest>
            : never
        : K extends keyof T
        ? T[K]
        : never;

type Config = {
    api: {
        endpoint: string;
        timeout: number;
    };
    features: {
        darkMode: boolean;
    };
};

type Endpoint = DeepProp<Config, 'api.endpoint'>; // string
type Timeout = DeepProp<Config, 'api.timeout'>; // number
type DarkMode = DeepProp<Config, 'features.darkMode'>; // boolean

// 실제 활용: 타입 안전한 getter
function getDeepProp<T, K extends string>(
    obj: T,
    path: K
): DeepProp<T, K> {
    const keys = path.split('.');
    let result: any = obj;
    for (const key of keys) {
        result = result[key];
    }
    return result;
}

const config: Config = {
    api: { endpoint: 'https://api.example.com', timeout: 5000 },
    features: { darkMode: true }
};

const endpoint = getDeepProp(config, 'api.endpoint'); // string
const darkMode = getDeepProp(config, 'features.darkMode'); // boolean
```

#### 클래스 인스턴스 타입 추출

```typescript
// 생성자 함수에서 인스턴스 타입 추출
type InstanceType2<T> = T extends new (...args: any) => infer I ? I : never;

class User {
    constructor(public name: string, public age: number) {}
}

type UserInstance = InstanceType2<typeof User>;
// User

// 생성자 매개변수 추출
type ConstructorParams<T> = T extends new (...args: infer P) => any ? P : never;
type UserParams = ConstructorParams<typeof User>;
// [name: string, age: number]
```

## 예시

### 1. 실제 사용 사례

#### API 응답 파이프라인
```typescript
type ApiHandler<T> = () => Promise<{ ok: boolean; data: T }>;
type ApiData<T extends ApiHandler<any>> = AwaitedDeep<Return<T>>['data'];

declare const getUser: ApiHandler<{ id: string; name: string }>;
type UserData = ApiData<typeof getUser>; // { id: string; name: string }

// 사용 예시
async function handleApiResponse<T extends ApiHandler<any>>(handler: T) {
    const response = await handler();
    if (response.ok) {
        return response.data; // 타입이 자동으로 추론됨
    }
    throw new Error('API 호출 실패');
}
```

#### 이벤트 시스템
```typescript
type EventMap = {
    'user:created': { userId: string; name: string };
    'user:updated': { userId: string; changes: Partial<{ name: string; email: string }> };
    'user:deleted': { userId: string };
};

type EventHandler<T extends keyof EventMap> = (data: EventMap[T]) => void;

class EventEmitter {
    private handlers: Map<keyof EventMap, EventHandler<any>[]> = new Map();

    on<T extends keyof EventMap>(event: T, handler: EventHandler<T>) {
        if (!this.handlers.has(event)) {
            this.handlers.set(event, []);
        }
        this.handlers.get(event)!.push(handler);
    }

    emit<T extends keyof EventMap>(event: T, data: EventMap[T]) {
        const handlers = this.handlers.get(event) || [];
        handlers.forEach(handler => handler(data));
    }
}

// 사용 예시
const emitter = new EventEmitter();

emitter.on('user:created', (data) => {
    console.log(`사용자 생성: ${data.name} (${data.userId})`);
    // data의 타입이 자동으로 추론됨
});

emitter.emit('user:created', { userId: '123', name: '홍길동' });
```

### 2. 고급 활용 패턴

#### 브랜드 타입
```typescript
type Brand<K, T> = K & { __brand: T };
type UserId = Brand<string, 'UserId'>;
type ProductId = Brand<string, 'ProductId'>;

function createUserId(id: string): UserId {
    return id as UserId;
}

function createProductId(id: string): ProductId {
    return id as ProductId;
}

// 타입 안전성 보장
const userId = createUserId('user123');
const productId = createProductId('prod456');

// userId = productId; // 오류: 타입이 다름
```

#### 깊은 부분 타입
```typescript
type DeepPartial<T> = {
    [K in keyof T]?: T[K] extends object ? DeepPartial<T[K]> : T[K];
};

interface User {
    id: number;
    profile: {
        name: string;
        address: {
            city: string;
            country: string;
        };
    };
}

type PartialUser = DeepPartial<User>;
// {
//   id?: number;
//   profile?: {
//     name?: string;
//     address?: {
//       city?: string;
//       country?: string;
//     };
//   };
// }
```

#### 조건부 유틸리티 타입
```typescript
type MaybeArray<T> = T | T[];
type ElementOf<T> = T extends (infer U)[] ? U : T;

type StringOrArray = MaybeArray<string>; // string | string[]
type Element = ElementOf<StringOrArray>; // string

// 사용 예시
function processData<T>(data: MaybeArray<T>): T[] {
    return Array.isArray(data) ? data : [data];
}
```

## 운영 팁

### 성능 최적화

TypeScript의 타입 체커도 연산 비용이 있으므로, 복잡한 타입은 컴파일 시간에 영향을 줄 수 있습니다.

#### 타입 계산 캐싱

```typescript
// 복잡한 타입 계산을 미리 정의
type ComplexType<T> = T extends string 
    ? { type: 'string'; value: T }
    : T extends number
    ? { type: 'number'; value: T }
    : { type: 'unknown'; value: T };

// 자주 사용되는 타입 조합을 타입 별칭으로 미리 정의
type CommonPattern<T> = DeepPartial<Readonly<T>>;

// 나쁜 예: 매번 복잡한 타입 계산
function process1<T>(data: DeepPartial<Readonly<T>>) { }
function process2<T>(data: DeepPartial<Readonly<T>>) { }
function process3<T>(data: DeepPartial<Readonly<T>>) { }

// 좋은 예: 타입 별칭으로 재사용
function process1<T>(data: CommonPattern<T>) { }
function process2<T>(data: CommonPattern<T>) { }
function process3<T>(data: CommonPattern<T>) { }
```

#### 재귀 깊이 제한

TypeScript는 재귀 타입의 깊이에 제한이 있습니다(약 50단계). 너무 깊은 재귀는 컴파일 에러를 발생시킬 수 있습니다.

```typescript
// 재귀 깊이 제한을 고려한 타입
type DeepReadonly<T, Depth extends number = 5> = 
    Depth extends 0 
        ? T
        : {
            readonly [K in keyof T]: T[K] extends object 
                ? DeepReadonly<T[K], Prev<Depth>>
                : T[K]
        };

// 숫자 카운터 타입 (깊이 추적용)
type Prev<N extends number> = [never, 0, 1, 2, 3, 4, 5][N];

// 실전에서는 대부분의 객체가 5단계 이상 중첩되지 않으므로 충분
```

#### 유니온 타입 최적화

너무 많은 유니온 멤버는 타입 체킹 성능에 영향을 줍니다.

```typescript
// 피해야 할 패턴: 수백 개의 유니온 생성
type BadPattern = `${string}-${string}-${string}-${string}`;
// 이론적으로 무한대의 조합 생성 가능

// 더 나은 패턴: 구체적인 유니온 사용
type GoodPattern = 
    | `user-${string}`
    | `post-${string}`
    | `comment-${string}`;
```

### 에러 처리와 디버깅

#### 타입 가드와 함께 사용

조건부 타입을 사용할 때, 런타임에서도 타입을 검증하는 타입 가드를 함께 사용하면 안전합니다.

```typescript
function isString(value: unknown): value is string {
    return typeof value === 'string';
}

function isArray<T>(value: unknown): value is T[] {
    return Array.isArray(value);
}

function processValue<T>(value: T): T extends string ? string[] : T {
    if (isString(value)) {
        return value.split('') as any;
    }
    return value as any;
}

// 더 나은 방법: 오버로드 사용
function processValue(value: string): string[];
function processValue<T>(value: T): T;
function processValue(value: unknown): unknown {
    if (typeof value === 'string') {
        return value.split('');
    }
    return value;
}
```

#### 타입 에러 디버깅

복잡한 타입에서 에러가 발생하면 중간 타입을 확인하면서 디버깅합니다.

```typescript
// 타입 디버깅 헬퍼
type Debug<T> = { [K in keyof T]: T[K] };

// 복잡한 타입을 단계별로 분해
type Step1<T> = { [K in keyof T]: T[K] };
type Step2<T> = Step1<T> & { extra: string };
type Step3<T> = Debug<Step2<T>>; // Debug로 감싸면 IDE에서 전체 타입 구조를 볼 수 있음

// never 타입 발생 시 확인
type CheckNever<T> = T extends never ? 'Type is never!' : T;

type Test = CheckNever<Extract<string, number>>; 
// 'Type is never!' - Extract가 never를 반환함을 알 수 있음
```

#### 명시적 타입 힌트 제공

```typescript
// TypeScript가 추론하기 어려운 경우 명시적 타입 제공
type SafeReturn<T> = T extends (...args: any[]) => infer R 
    ? R 
    : T extends { then: (onfulfilled: (value: infer U) => any) => any }
    ? U
    : never;

// 사용 시 명확한 타입 지정
const result: SafeReturn<typeof myFunction> = await myFunction();
```

### 유지보수성

#### 타입에 주석 추가

복잡한 타입은 주석으로 설명을 추가합니다.

```typescript
/**
 * API 응답에서 데이터 타입만 추출합니다.
 * @example
 * type Response = { ok: boolean; data: string[] }
 * type Data = ExtractData<Response> // string[]
 */
type ExtractData<T> = T extends { data: infer D } ? D : never;

/**
 * 객체의 모든 속성을 재귀적으로 readonly로 만듭니다.
 * 배열의 경우 readonly 배열로 변환하고, 객체는 모든 속성을 readonly로 만듭니다.
 */
type DeepReadonly<T> = T extends any[]
    ? ReadonlyArray<DeepReadonly<T[number]>>
    : T extends object
    ? { readonly [K in keyof T]: DeepReadonly<T[K]> }
    : T;
```

#### 의미 있는 타입 이름

```typescript
// 나쁜 예: 의미를 알 수 없는 이름
type T1<T> = T extends any[] ? T[0] : never;
type T2<T, U> = T extends U ? T : never;

// 좋은 예: 명확한 의미 전달
type FirstElement<T> = T extends any[] ? T[0] : never;
type FilterByType<T, U> = T extends U ? T : never;
```

### 실전 팁

#### 점진적 타입 적용

기존 프로젝트에 고급 타입을 적용할 때는 단계적으로 진행합니다.

```typescript
// 1단계: 기본 타입만 사용
interface User {
    id: number;
    name: string;
}

// 2단계: 유틸리티 타입 활용
type PartialUser = Partial<User>;
type ReadonlyUser = Readonly<User>;

// 3단계: 커스텀 유틸리티 타입 도입
type DeepPartialUser = DeepPartial<User>;
type PickByType<T, U> = { [K in keyof T as T[K] extends U ? K : never]: T[K] };

// 4단계: 프로젝트 전반에 적용
type ApiResponse<T> = { ok: boolean; data: T };
type ExtractData<T> = T extends ApiResponse<infer D> ? D : never;
```

#### 타입 테스트 작성

중요한 타입은 테스트 케이스를 작성하여 예상대로 동작하는지 확인합니다.

```typescript
// 타입 테스트 헬퍼
type Equals<X, Y> = 
    (<T>() => T extends X ? 1 : 2) extends 
    (<T>() => T extends Y ? 1 : 2) ? true : false;

type Assert<T extends true> = T;

// 타입 테스트
type Test1 = Assert<Equals<ExtractData<{ data: string }>, string>>;
type Test2 = Assert<Equals<FirstElement<[1, 2, 3]>, 1>>;
type Test3 = Assert<Equals<CamelCase<'user_name'>, 'userName'>>;

// 컴파일 에러가 발생하면 타입이 예상과 다른 것
```

## 참고

### 고급 타입 기법 체크리스트

#### 조건부 타입 활용 시나리오
- **타입 분기**: `T extends U ? X : Y` 형태로 타입에 따라 다른 결과 반환
- **타입 필터링**: 특정 조건을 만족하는 타입만 추출
- **타입 변환**: 입력 타입을 다른 형태로 변환
- **사용 시점**: 함수 오버로드가 복잡해질 때, 타입에 따라 다른 반환 타입이 필요할 때

#### 분배 조건부 타입 활용 시나리오  
- **유니온 타입 처리**: 각 유니온 멤버에 대해 개별 처리
- **타입 필터링**: Extract, Exclude 같은 유틸리티 타입 구현
- **분배 제어**: 튜플로 감싸서 분배 방지 가능
- **사용 시점**: 유니온 타입을 다룰 때, 각 타입별로 다른 처리가 필요할 때

#### 매핑 타입 활용 시나리오
- **타입 변환**: 기존 타입의 속성을 변환하여 새 타입 생성
- **키 재매핑**: `as` 절로 속성 이름 변경
- **수식어 조작**: readonly, optional 추가/제거
- **사용 시점**: DTO 변환, 폼 상태 관리, API 응답 변환 시

#### 템플릿 리터럴 타입 활용 시나리오
- **문자열 패턴**: 특정 패턴의 문자열 타입 정의
- **문자열 조합**: 여러 문자열 타입을 조합하여 새로운 타입 생성
- **패턴 매칭**: infer와 함께 사용하여 문자열에서 정보 추출
- **사용 시점**: API 엔드포인트, CSS 클래스명, 이벤트 이름 등 문자열 기반 타입이 필요할 때

#### infer 패턴 활용 시나리오
- **타입 추출**: 복잡한 타입에서 일부분만 추출
- **재귀 처리**: 중첩된 타입 구조 분해
- **패턴 매칭**: 특정 구조의 타입에서 정보 추출
- **사용 시점**: 라이브러리 타입 추론, 제네릭 함수의 반환 타입 추출, 복잡한 타입 분석

### 자주 사용되는 패턴

```typescript
// 1. 함수 관련 타입 추출
type ReturnType<T> = T extends (...args: any) => infer R ? R : never;
type Parameters<T> = T extends (...args: infer P) => any ? P : never;
type FirstParameter<T> = T extends (arg: infer P, ...args: any) => any ? P : never;

// 2. 배열/튜플 타입 추출
type ArrayElement<T> = T extends (infer U)[] ? U : never;
type FirstElement<T extends any[]> = T extends [infer F, ...any[]] ? F : never;
type LastElement<T extends any[]> = T extends [...any[], infer L] ? L : never;

// 3. Promise 타입 추출
type PromiseType<T> = T extends Promise<infer U> ? U : never;
type Awaited<T> = T extends Promise<infer U> ? Awaited<U> : T;

// 4. 객체 관련 타입 추출
type Keys<T> = keyof T;
type Values<T> = T[keyof T];
type ValueOf<T, K extends keyof T> = T[K];

// 5. 유니온 타입 조작
type UnionToIntersection<U> = 
    (U extends any ? (k: U) => void : never) extends 
    ((k: infer I) => void) ? I : never;

type LastOfUnion<T> = 
    UnionToIntersection<T extends any ? () => T : never> extends 
    () => infer R ? R : never;
```

### 실무에서 자주 마주치는 문제와 해결책

#### 1. 순환 참조 타입

```typescript
// 문제: 순환 참조로 인한 타입 에러
type Node = {
    value: string;
    children: Node[]; // 자기 자신을 참조
};

// 해결: 인터페이스 사용
interface Node {
    value: string;
    children: Node[];
}

// 또는 타입 별칭으로도 가능 (최신 TypeScript)
type TreeNode = {
    value: string;
    children: TreeNode[];
};
```

#### 2. 너무 복잡한 타입 단순화

```typescript
// 문제: 가독성이 떨어지는 복잡한 타입
type Complex<T> = T extends { data: infer D } 
    ? D extends Array<infer U> 
        ? U extends { id: infer I } 
            ? I 
            : never 
        : never 
    : never;

// 해결: 단계별로 분리
type ExtractData<T> = T extends { data: infer D } ? D : never;
type ExtractArrayElement<T> = T extends Array<infer U> ? U : never;
type ExtractId<T> = T extends { id: infer I } ? I : never;
type Complex<T> = ExtractId<ExtractArrayElement<ExtractData<T>>>;
```

#### 3. 타입 추론 실패

```typescript
// 문제: TypeScript가 타입을 추론하지 못함
function process<T>(value: T): T extends string ? string[] : T {
    if (typeof value === 'string') {
        return value.split(''); // 에러: string[]를 T extends string ? string[] : T에 할당 불가
    }
    return value; // 에러
}

// 해결 1: 함수 오버로드 사용
function process(value: string): string[];
function process<T>(value: T): T;
function process(value: unknown): unknown {
    if (typeof value === 'string') {
        return value.split('');
    }
    return value;
}

// 해결 2: 타입 단언 (권장하지 않음)
function process<T>(value: T): T extends string ? string[] : T {
    return (typeof value === 'string' ? value.split('') : value) as any;
}
```

#### 4. 제네릭 제약 조건 설정

```typescript
// 문제: 모든 타입을 받아서 런타임 에러 가능성
function getProperty<T>(obj: T, key: string) {
    return obj[key]; // 에러: T에 인덱스 시그니처 없음
}

// 해결: 적절한 제약 조건 추가
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
    return obj[key]; // OK
}

// 또는 Record 사용
function getProperty<T extends Record<string, any>>(obj: T, key: keyof T) {
    return obj[key];
}
```

### 학습 리소스

#### TypeScript 공식 문서
- [Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
- [Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
- [Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)

#### 추천 학습 순서
1. 기본 제네릭과 유틸리티 타입 숙지
2. 조건부 타입으로 간단한 타입 분기 구현
3. 매핑 타입으로 타입 변환 연습
4. infer를 사용한 타입 추출 패턴 학습
5. 템플릿 리터럴 타입으로 문자열 타입 조작
6. 실제 프로젝트에 점진적으로 적용

### 결론

TypeScript의 고급 타입 기법은 타입 안전성과 개발 효율성을 동시에 높이는 강력한 도구입니다. 처음에는 복잡해 보이지만, 패턴을 익히고 나면 코드의 품질을 크게 향상시킬 수 있습니다.

**핵심 포인트**:
- 조건부 타입으로 타입 분기와 필터링을 수행할 수 있습니다
- 매핑 타입으로 기존 타입을 변환하여 새로운 타입을 생성할 수 있습니다
- 템플릿 리터럴 타입으로 문자열 기반의 타입 안전성을 확보할 수 있습니다
- infer 패턴으로 복잡한 타입에서 필요한 부분만 추출할 수 있습니다

**실전 적용 시 주의사항**:
- 타입이 너무 복잡해지면 오히려 가독성이 떨어질 수 있으므로, 적절한 수준에서 균형을 유지해야 합니다
- 중요한 타입은 주석과 함께 예시를 제공하여 다른 개발자가 이해하기 쉽게 만듭니다
- 타입 에러가 발생하면 단계별로 분해하여 디버깅합니다
- 성능을 고려하여 과도한 재귀나 너무 많은 유니온 조합은 피합니다

고급 타입 기법을 적절히 활용하면, 런타임 에러를 컴파일 타임에 잡아낼 수 있고, IDE의 자동완성을 통해 개발 생산성을 크게 높일 수 있습니다. 하지만 모든 곳에 고급 기법을 사용할 필요는 없으며, 필요한 곳에 선택적으로 적용하는 것이 중요합니다.
