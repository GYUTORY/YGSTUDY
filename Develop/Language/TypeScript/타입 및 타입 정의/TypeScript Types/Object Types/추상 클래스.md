---
title: TypeScript 추상 클래스 완벽 가이드
tags: [language, typescript, 타입-및-타입-정의, typescript-types, object-types, abstract-class]
updated: 2025-08-10
---

# TypeScript 추상 클래스 완벽 가이드

## 배경

TypeScript에서 추상 클래스는 인스턴스를 직접 생성할 수 없는 클래스로, 다른 클래스에서 상속받아 기능을 확장하거나 구현하는 용도로 사용됩니다.

### 추상 클래스의 필요성
- **코드 재사용**: 공통된 동작을 추상 클래스로 정의하여 재사용
- **구조화**: 관련 클래스들의 공통 구조를 정의
- **확장성**: 하위 클래스에서 구체적인 구현을 통해 유연한 확장
- **타입 안전성**: 추상 메서드를 통한 강제 구현 보장

### 기본 개념
- **추상 클래스**: `abstract` 키워드로 정의되는 클래스
- **추상 메서드**: 구현이 없는 메서드, 하위 클래스에서 반드시 구현
- **구체 메서드**: 구현이 있는 메서드, 하위 클래스에서 상속
- **인스턴스화 불가**: 추상 클래스는 직접 인스턴스 생성 불가

## 핵심

### 1. 기본 추상 클래스 정의

#### 추상 메서드와 구체 메서드
```typescript
abstract class Animal {
    protected name: string;

    constructor(name: string) {
        this.name = name;
    }

    // 추상 메서드: 하위 클래스에서 반드시 구현해야 함
    abstract makeSound(): void;

    // 구체 메서드: 하위 클래스에서 상속받아 사용
    move(): void {
        console.log(`${this.name}이(가) 움직입니다.`);
    }

    // 추상 메서드: 매개변수와 반환 타입 정의
    abstract getInfo(): string;
}

class Dog extends Animal {
    constructor(name: string) {
        super(name);
    }

    // 추상 메서드 구현
    makeSound(): void {
        console.log(`${this.name}: 멍멍!`);
    }

    getInfo(): string {
        return `강아지 ${this.name}`;
    }
}

class Cat extends Animal {
    constructor(name: string) {
        super(name);
    }

    // 추상 메서드 구현
    makeSound(): void {
        console.log(`${this.name}: 야옹!`);
    }

    getInfo(): string {
        return `고양이 ${this.name}`;
    }
}

// 사용 예시
const dog = new Dog('멍멍이');
const cat = new Cat('야옹이');

dog.makeSound(); // "멍멍이: 멍멍!"
dog.move();      // "멍멍이이(가) 움직입니다."

cat.makeSound(); // "야옹이: 야옹!"
cat.move();      // "야옹이이(가) 움직입니다."

// 추상 클래스는 직접 인스턴스화할 수 없음
// const animal = new Animal('동물'); // 컴파일 오류
```

### 2. 추상 클래스와 인터페이스 조합

#### 추상 클래스와 인터페이스 함께 사용
```typescript
interface Flyable {
    fly(): void;
}

interface Swimmable {
    swim(): void;
}

abstract class Bird {
    protected name: string;
    protected wingspan: number;

    constructor(name: string, wingspan: number) {
        this.name = name;
        this.wingspan = wingspan;
    }

    abstract makeSound(): void;

    getInfo(): string {
        return `${this.name} (날개 길이: ${this.wingspan}cm)`;
    }
}

class Eagle extends Bird implements Flyable {
    constructor(name: string, wingspan: number) {
        super(name, wingspan);
    }

    makeSound(): void {
        console.log(`${this.name}: 끼이이익!`);
    }

    fly(): void {
        console.log(`${this.name}이(가) 높이 날아갑니다.`);
    }
}

class Duck extends Bird implements Flyable, Swimmable {
    constructor(name: string, wingspan: number) {
        super(name, wingspan);
    }

    makeSound(): void {
        console.log(`${this.name}: 꽥꽥!`);
    }

    fly(): void {
        console.log(`${this.name}이(가) 낮게 날아갑니다.`);
    }

    swim(): void {
        console.log(`${this.name}이(가) 수영합니다.`);
    }
}

// 사용 예시
const eagle = new Eagle('독수리', 200);
const duck = new Duck('오리', 80);

eagle.makeSound(); // "독수리: 끼이이익!"
eagle.fly();       // "독수리가 높이 날아갑니다."

duck.makeSound();  // "오리: 꽥꽥!"
duck.fly();        // "오리가 낮게 날아갑니다."
duck.swim();       // "오리가 수영합니다."
```

### 3. 추상 클래스의 고급 패턴

#### 템플릿 메서드 패턴
```typescript
abstract class DataProcessor {
    // 템플릿 메서드: 알고리즘의 골격을 정의
    process(): void {
        this.loadData();
        this.transformData();
        this.saveData();
        this.cleanup();
    }

    // 추상 메서드: 하위 클래스에서 구현
    abstract loadData(): void;
    abstract transformData(): void;
    abstract saveData(): void;

    // 훅 메서드: 선택적으로 오버라이드 가능
    cleanup(): void {
        console.log('기본 정리 작업 수행');
    }
}

class CSVProcessor extends DataProcessor {
    loadData(): void {
        console.log('CSV 파일에서 데이터 로드');
    }

    transformData(): void {
        console.log('CSV 데이터 변환');
    }

    saveData(): void {
        console.log('변환된 데이터를 JSON으로 저장');
    }

    cleanup(): void {
        console.log('CSV 임시 파일 정리');
    }
}

class JSONProcessor extends DataProcessor {
    loadData(): void {
        console.log('JSON 파일에서 데이터 로드');
    }

    transformData(): void {
        console.log('JSON 데이터 변환');
    }

    saveData(): void {
        console.log('변환된 데이터를 XML로 저장');
    }
}

// 사용 예시
const csvProcessor = new CSVProcessor();
const jsonProcessor = new JSONProcessor();

csvProcessor.process();
// CSV 파일에서 데이터 로드
// CSV 데이터 변환
// 변환된 데이터를 JSON으로 저장
// CSV 임시 파일 정리

jsonProcessor.process();
// JSON 파일에서 데이터 로드
// JSON 데이터 변환
// 변환된 데이터를 XML로 저장
// 기본 정리 작업 수행
```

## 예시

### 1. 실제 사용 사례

#### 데이터베이스 연결 추상화
```typescript
abstract class DatabaseConnection {
    protected connectionString: string;
    protected isConnected: boolean = false;

    constructor(connectionString: string) {
        this.connectionString = connectionString;
    }

    abstract connect(): Promise<void>;
    abstract disconnect(): Promise<void>;
    abstract query(sql: string): Promise<any[]>;

    // 공통 메서드
    async executeTransaction<T>(callback: () => Promise<T>): Promise<T> {
        await this.connect();
        try {
            const result = await callback();
            await this.disconnect();
            return result;
        } catch (error) {
            await this.disconnect();
            throw error;
        }
    }

    getConnectionInfo(): string {
        return `연결 상태: ${this.isConnected ? '연결됨' : '연결 안됨'}`;
    }
}

class MySQLConnection extends DatabaseConnection {
    async connect(): Promise<void> {
        console.log(`MySQL에 연결: ${this.connectionString}`);
        this.isConnected = true;
    }

    async disconnect(): Promise<void> {
        console.log('MySQL 연결 종료');
        this.isConnected = false;
    }

    async query(sql: string): Promise<any[]> {
        console.log(`MySQL 쿼리 실행: ${sql}`);
        return [{ id: 1, name: '홍길동' }];
    }
}

class PostgreSQLConnection extends DatabaseConnection {
    async connect(): Promise<void> {
        console.log(`PostgreSQL에 연결: ${this.connectionString}`);
        this.isConnected = true;
    }

    async disconnect(): Promise<void> {
        console.log('PostgreSQL 연결 종료');
        this.isConnected = false;
    }

    async query(sql: string): Promise<any[]> {
        console.log(`PostgreSQL 쿼리 실행: ${sql}`);
        return [{ id: 1, name: '김철수' }];
    }
}

// 사용 예시
async function main() {
    const mysql = new MySQLConnection('mysql://localhost:3306/db');
    const postgres = new PostgreSQLConnection('postgresql://localhost:5432/db');

    // 트랜잭션 실행
    await mysql.executeTransaction(async () => {
        const users = await mysql.query('SELECT * FROM users');
        console.log('MySQL 사용자:', users);
    });

    await postgres.executeTransaction(async () => {
        const users = await postgres.query('SELECT * FROM users');
        console.log('PostgreSQL 사용자:', users);
    });
}
```

### 2. 고급 패턴

#### 추상 팩토리 패턴
```typescript
abstract class UIComponent {
    abstract render(): string;
    abstract getType(): string;
}

abstract class Button extends UIComponent {
    protected text: string;

    constructor(text: string) {
        super();
        this.text = text;
    }

    getType(): string {
        return 'Button';
    }
}

abstract class Input extends UIComponent {
    protected placeholder: string;

    constructor(placeholder: string) {
        super();
        this.placeholder = placeholder;
    }

    getType(): string {
        return 'Input';
    }
}

abstract class UIFactory {
    abstract createButton(text: string): Button;
    abstract createInput(placeholder: string): Input;
}

class MaterialUIFactory extends UIFactory {
    createButton(text: string): Button {
        return new MaterialButton(text);
    }

    createInput(placeholder: string): Input {
        return new MaterialInput(placeholder);
    }
}

class BootstrapUIFactory extends UIFactory {
    createButton(text: string): Button {
        return new BootstrapButton(text);
    }

    createInput(placeholder: string): Input {
        return new BootstrapInput(placeholder);
    }
}

class MaterialButton extends Button {
    render(): string {
        return `<button class="material-button">${this.text}</button>`;
    }
}

class MaterialInput extends Input {
    render(): string {
        return `<input class="material-input" placeholder="${this.placeholder}">`;
    }
}

class BootstrapButton extends Button {
    render(): string {
        return `<button class="btn btn-primary">${this.text}</button>`;
    }
}

class BootstrapInput extends Input {
    render(): string {
        return `<input class="form-control" placeholder="${this.placeholder}">`;
    }
}

// 사용 예시
function createUI(factory: UIFactory) {
    const button = factory.createButton('클릭하세요');
    const input = factory.createInput('텍스트를 입력하세요');

    console.log(button.render());
    console.log(input.render());
}

createUI(new MaterialUIFactory());
// <button class="material-button">클릭하세요</button>
// <input class="material-input" placeholder="텍스트를 입력하세요">

createUI(new BootstrapUIFactory());
// <button class="btn btn-primary">클릭하세요</button>
// <input class="form-control" placeholder="텍스트를 입력하세요">
```

## 운영 팁

### 성능 최적화

#### 메모리 효율성
```typescript
abstract class EfficientProcessor {
    // 정적 메서드로 인스턴스 생성 없이 사용
    static processStatic(data: any[]): any[] {
        return data.map(item => item * 2);
    }

    // 추상 메서드는 최소한으로 유지
    abstract processInstance(data: any): any;

    // 공통 로직은 구체 메서드로 구현
    validateData(data: any): boolean {
        return data !== null && data !== undefined;
    }
}
```

### 에러 처리

#### 안전한 추상 클래스 설계
```typescript
abstract class SafeProcessor {
    protected validateInput(input: any): void {
        if (input === null || input === undefined) {
            throw new Error('입력값이 유효하지 않습니다.');
        }
    }

    abstract process(input: any): any;

    // 템플릿 메서드에서 에러 처리
    safeProcess(input: any): any {
        try {
            this.validateInput(input);
            return this.process(input);
        } catch (error) {
            console.error('처리 중 오류 발생:', error.message);
            throw error;
        }
    }
}
```

## 참고

### 추상 클래스 vs 인터페이스 비교표

| 특징 | 추상 클래스 | 인터페이스 |
|------|-------------|------------|
| **구현** | ✅ 부분 구현 가능 | ❌ 구현 없음 |
| **생성자** | ✅ 지원 | ❌ 지원 안함 |
| **접근 제어자** | ✅ 지원 | ❌ 지원 안함 |
| **상속** | extends | extends/implements |
| **다중 상속** | ❌ 불가능 | ✅ 가능 |
| **인스턴스화** | ❌ 불가능 | ❌ 불가능 |

### 추상 클래스 사용 권장사항

1. **공통 구현**: 여러 클래스가 공유하는 구현이 있을 때
2. **상태 관리**: 인스턴스 변수나 상태가 필요할 때
3. **접근 제어**: protected 멤버가 필요할 때
4. **생성자**: 초기화 로직이 필요할 때

### 결론
TypeScript의 추상 클래스는 코드 재사용과 구조화를 위한 강력한 도구입니다.
추상 메서드와 구체 메서드를 적절히 조합하여 유연한 설계를 구현하세요.
템플릿 메서드 패턴을 활용하여 알고리즘의 골격을 정의하세요.
인터페이스와 함께 사용하여 더욱 유연한 설계를 만드세요.
추상 클래스와 인터페이스의 차이를 이해하고 상황에 맞게 선택하세요.
안전한 에러 처리와 성능 최적화를 고려한 추상 클래스 설계를 하세요.

