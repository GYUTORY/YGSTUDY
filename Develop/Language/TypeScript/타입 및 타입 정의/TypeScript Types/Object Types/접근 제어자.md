---
title: TypeScript 접근 제어자 완벽 가이드
tags: [language, typescript, 타입-및-타입-정의, typescript-types, object-types, access-modifiers]
updated: 2025-08-10
---

# TypeScript 접근 제어자 완벽 가이드

## 배경

TypeScript의 접근 제어자(Access Modifiers)는 클래스 내부에서 어떤 속성이나 메서드가 외부에서 접근할 수 있는지 제어하는 기능입니다.

### 접근 제어자의 필요성
- **캡슐화**: 객체의 내부 상태를 외부로부터 보호
- **데이터 은닉**: 중요한 데이터의 직접 접근 방지
- **인터페이스 설계**: 외부에 노출할 API 명확화
- **유지보수성**: 내부 구현 변경 시 외부 영향 최소화

### 기본 개념
- **public**: 모든 곳에서 접근 가능 (기본값)
- **private**: 클래스 내부에서만 접근 가능
- **protected**: 클래스 내부 및 상속받은 클래스에서만 접근 가능

## 핵심

### 1. public 접근 제어자

#### 기본 public 속성과 메서드
```typescript
class Person {
    public name: string;
    public age: number;

    constructor(name: string, age: number) {
        this.name = name;
        this.age = age;
    }

    public greet(): void {
        console.log(`안녕하세요, 저는 ${this.name}입니다.`);
    }

    public getInfo(): string {
        return `${this.name} (${this.age}세)`;
    }
}

// 사용 예시
const person = new Person("홍길동", 30);
console.log(person.name);        // "홍길동"
console.log(person.age);         // 30
person.greet();                  // "안녕하세요, 저는 홍길동입니다."
console.log(person.getInfo());   // "홍길동 (30세)"
```

#### public 접근 제어자 생략
```typescript
class Car {
    // public은 기본값이므로 생략 가능
    brand: string;
    model: string;

    constructor(brand: string, model: string) {
        this.brand = brand;
        this.model = model;
    }

    start(): void {
        console.log(`${this.brand} ${this.model} 시동을 겁니다.`);
    }
}

const car = new Car("현대", "아반떼");
car.start(); // "현대 아반떼 시동을 겁니다."
```

### 2. private 접근 제어자

#### private 속성과 메서드
```typescript
class BankAccount {
    private balance: number;
    private accountNumber: string;

    constructor(accountNumber: string, initialBalance: number = 0) {
        this.accountNumber = accountNumber;
        this.balance = initialBalance;
    }

    public deposit(amount: number): void {
        if (amount > 0) {
            this.balance += amount;
            console.log(`${amount}원이 입금되었습니다.`);
        }
    }

    public withdraw(amount: number): boolean {
        if (amount > 0 && amount <= this.balance) {
            this.balance -= amount;
            console.log(`${amount}원이 출금되었습니다.`);
            return true;
        }
        console.log('잔액이 부족합니다.');
        return false;
    }

    public getBalance(): number {
        return this.balance;
    }

    private validateAmount(amount: number): boolean {
        return amount > 0 && amount <= this.balance;
    }
}

// 사용 예시
const account = new BankAccount("123-456-789", 10000);
account.deposit(5000);           // "5000원이 입금되었습니다."
console.log(account.getBalance()); // 15000

// account.balance = 20000;       // 오류: private 속성에 접근 불가
// account.validateAmount(1000);  // 오류: private 메서드에 접근 불가
```

#### private 생성자와 싱글톤 패턴
```typescript
class DatabaseConnection {
    private static instance: DatabaseConnection;
    private connectionString: string;

    private constructor(connectionString: string) {
        this.connectionString = connectionString;
    }

    public static getInstance(connectionString?: string): DatabaseConnection {
        if (!DatabaseConnection.instance) {
            DatabaseConnection.instance = new DatabaseConnection(connectionString || 'default');
        }
        return DatabaseConnection.instance;
    }

    public connect(): void {
        console.log(`데이터베이스에 연결: ${this.connectionString}`);
    }
}

// 사용 예시
const db1 = DatabaseConnection.getInstance('mysql://localhost:3306');
const db2 = DatabaseConnection.getInstance(); // 같은 인스턴스 반환

console.log(db1 === db2); // true
```

### 3. protected 접근 제어자

#### protected 속성과 메서드
```typescript
class Vehicle {
    protected brand: string;
    protected model: string;
    protected year: number;

    constructor(brand: string, model: string, year: number) {
        this.brand = brand;
        this.model = model;
        this.year = year;
    }

    protected getVehicleInfo(): string {
        return `${this.year} ${this.brand} ${this.model}`;
    }

    public start(): void {
        console.log(`${this.getVehicleInfo()} 시동을 겁니다.`);
    }
}

class Car extends Vehicle {
    private fuelType: string;

    constructor(brand: string, model: string, year: number, fuelType: string) {
        super(brand, model, year);
        this.fuelType = fuelType;
    }

    public getCarInfo(): string {
        // protected 메서드에 접근 가능
        return `${this.getVehicleInfo()} (${this.fuelType})`;
    }

    public refuel(): void {
        console.log(`${this.brand} ${this.model}에 ${this.fuelType}을 주유합니다.`);
    }
}

// 사용 예시
const car = new Car("현대", "아반떼", 2021, "가솔린");
car.start();           // "2021 현대 아반떼 시동을 겁니다."
car.getCarInfo();      // "2021 현대 아반떼 (가솔린)"
car.refuel();          // "현대 아반떼에 가솔린을 주유합니다."

// car.brand = "기아";  // 오류: protected 속성에 외부에서 접근 불가
```

## 예시

### 1. 실제 사용 사례

#### 사용자 관리 시스템
```typescript
abstract class User {
    protected id: number;
    protected name: string;
    protected email: string;
    protected createdAt: Date;

    constructor(id: number, name: string, email: string) {
        this.id = id;
        this.name = name;
        this.email = email;
        this.createdAt = new Date();
    }

    protected validateEmail(email: string): boolean {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
    }

    public getInfo(): string {
        return `ID: ${this.id}, Name: ${this.name}, Email: ${this.email}`;
    }

    abstract getRole(): string;
}

class AdminUser extends User {
    private permissions: string[];

    constructor(id: number, name: string, email: string, permissions: string[] = []) {
        super(id, name, email);
        this.permissions = permissions;
    }

    public addPermission(permission: string): void {
        if (!this.permissions.includes(permission)) {
            this.permissions.push(permission);
        }
    }

    public hasPermission(permission: string): boolean {
        return this.permissions.includes(permission);
    }

    public getRole(): string {
        return 'Admin';
    }

    public getPermissions(): string[] {
        return [...this.permissions]; // 복사본 반환
    }
}

class RegularUser extends User {
    private lastLogin: Date | null = null;

    constructor(id: number, name: string, email: string) {
        super(id, name, email);
    }

    public login(): void {
        this.lastLogin = new Date();
        console.log(`${this.name}이(가) 로그인했습니다.`);
    }

    public getRole(): string {
        return 'User';
    }

    public getLastLogin(): Date | null {
        return this.lastLogin;
    }
}

// 사용 예시
const admin = new AdminUser(1, '관리자', 'admin@example.com', ['read', 'write']);
const user = new RegularUser(2, '사용자', 'user@example.com');

admin.addPermission('delete');
console.log(admin.hasPermission('delete')); // true
console.log(admin.getPermissions()); // ['read', 'write', 'delete']

user.login(); // "사용자가 로그인했습니다."
```

### 2. 고급 패턴

#### 접근 제어자와 게터/세터
```typescript
class Product {
    private _price: number;
    private _stock: number;

    constructor(price: number, stock: number) {
        this._price = price;
        this._stock = stock;
    }

    // 게터 (getter)
    get price(): number {
        return this._price;
    }

    // 세터 (setter)
    set price(value: number) {
        if (value >= 0) {
            this._price = value;
        } else {
            throw new Error('가격은 0 이상이어야 합니다.');
        }
    }

    get stock(): number {
        return this._stock;
    }

    set stock(value: number) {
        if (value >= 0) {
            this._stock = value;
        } else {
            throw new Error('재고는 0 이상이어야 합니다.');
        }
    }

    public isAvailable(): boolean {
        return this._stock > 0;
    }

    public sell(quantity: number): boolean {
        if (quantity <= this._stock) {
            this._stock -= quantity;
            return true;
        }
        return false;
    }
}

// 사용 예시
const product = new Product(10000, 50);

console.log(product.price); // 10000
console.log(product.stock); // 50

product.price = 12000; // 가격 변경
product.stock = 30;    // 재고 변경

console.log(product.isAvailable()); // true
console.log(product.sell(10));      // true
console.log(product.stock);         // 20
```

#### 접근 제어자와 인터페이스
```typescript
interface ReadableUser {
    readonly id: number;
    readonly name: string;
    readonly email: string;
}

interface WritableUser {
    name: string;
    email: string;
}

class UserManager {
    private users: Map<number, User> = new Map();

    public createUser(name: string, email: string): ReadableUser {
        const id = this.generateId();
        const user = new User(id, name, email);
        this.users.set(id, user);
        return user;
    }

    public getUser(id: number): ReadableUser | null {
        return this.users.get(id) || null;
    }

    public updateUser(id: number, updates: Partial<WritableUser>): boolean {
        const user = this.users.get(id);
        if (user) {
            if (updates.name) user.name = updates.name;
            if (updates.email) user.email = updates.email;
            return true;
        }
        return false;
    }

    public deleteUser(id: number): boolean {
        return this.users.delete(id);
    }

    private generateId(): number {
        return Math.floor(Math.random() * 1000000);
    }
}

class User implements ReadableUser {
    constructor(
        public readonly id: number,
        public name: string,
        public email: string
    ) {}
}

// 사용 예시
const userManager = new UserManager();
const user = userManager.createUser('홍길동', 'hong@example.com');

console.log(user.id);    // 읽기 전용
console.log(user.name);  // 읽기 가능
// user.id = 999;        // 오류: 읽기 전용 속성

userManager.updateUser(user.id, { name: '김철수' });
console.log(user.name);  // "김철수"
```

## 운영 팁

### 성능 최적화

#### 접근 제어자와 메모리 효율성
```typescript
class OptimizedClass {
    // private 속성으로 내부 상태 보호
    private _cache: Map<string, any> = new Map();
    private _isInitialized: boolean = false;

    // public 메서드로 외부 인터페이스 제공
    public getData(key: string): any {
        if (!this._isInitialized) {
            this.initialize();
        }
        return this._cache.get(key);
    }

    // private 메서드로 내부 로직 캡슐화
    private initialize(): void {
        this._cache.set('default', 'value');
        this._isInitialized = true;
    }

    // protected 메서드로 상속 클래스에서 사용 가능
    protected clearCache(): void {
        this._cache.clear();
        this._isInitialized = false;
    }
}
```

### 에러 처리

#### 안전한 접근 제어자 사용
```typescript
class SafeClass {
    private _value: number = 0;

    // 안전한 게터
    get value(): number {
        return this._value;
    }

    // 안전한 세터
    set value(newValue: number) {
        if (typeof newValue === 'number' && !isNaN(newValue)) {
            this._value = newValue;
        } else {
            throw new Error('유효하지 않은 값입니다.');
        }
    }

    // private 메서드로 내부 검증
    private validateValue(value: number): boolean {
        return typeof value === 'number' && !isNaN(value) && value >= 0;
    }

    // public 메서드로 안전한 연산 제공
    public increment(amount: number = 1): void {
        if (this.validateValue(amount)) {
            this._value += amount;
        } else {
            throw new Error('유효하지 않은 증가값입니다.');
        }
    }
}
```

## 참고

### 접근 제어자 비교표

| 접근 제어자 | 클래스 내부 | 상속 클래스 | 외부 |
|-------------|-------------|-------------|------|
| **public** | ✅ | ✅ | ✅ |
| **protected** | ✅ | ✅ | ❌ |
| **private** | ✅ | ❌ | ❌ |

### 접근 제어자 사용 권장사항

1. **최소 권한 원칙**: 필요한 최소한의 접근 권한만 부여
2. **캡슐화**: 내부 구현을 외부로부터 보호
3. **인터페이스 설계**: 외부에 노출할 API를 명확히 정의
4. **상속 고려**: protected 사용 시 상속 관계 고려

### 결론
TypeScript의 접근 제어자는 객체지향 프로그래밍의 캡슐화를 구현하는 핵심 도구입니다.
적절한 접근 제어자를 사용하여 데이터의 안전성을 보장하세요.
private을 사용하여 내부 구현을 보호하고, public으로 외부 인터페이스를 명확히 하세요.
protected를 활용하여 상속 관계에서의 접근을 제어하세요.
게터와 세터를 통해 안전한 데이터 접근을 제공하세요.
접근 제어자를 통한 명확한 API 설계로 코드의 유지보수성을 향상시키세요.

