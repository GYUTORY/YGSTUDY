
# 📦 `tsc-alias` vs `workspace`: 왜 둘 다 필요할까?

## 📚 개요
`tsc-alias`와 `workspace`는 TypeScript 프로젝트에서 **경로 매핑과 의존성 관리**를 다루기 위한 도구입니다.

- **`tsc-alias`**: TypeScript 컴파일러의 **경로 매핑 문제**를 해결.
- **`workspace`**: 패키지 매니저(`pnpm`, `yarn`)의 **멀티 패키지 관리와 의존성 해석**을 담당.

---

# ✅ `tsc-alias`만 사용하는 경우

### 📦 `tsconfig.json` (A-Repo)
```json
{
  "compilerOptions": {
    "baseUrl": "./src",
    "paths": {
      "@core/*": ["../../B-Repo/lib/*"],
      "@utils/*": ["../../C-Repo/utils/*"]
    }
  }
}
```

### 📦 `A-Repo/src/index.ts`
```typescript
import { coreFunction } from "@core/index";
import { utilityFunction } from "@utils/helper";
```

### ✅ `tsc` 컴파일 후 (`dist/index.js`)
```javascript
const coreFunction = require("@core/index");  // 아직도 경로 매핑이 남아있음
const utilityFunction = require("@utils/helper");
```

### 🔧 **`tsc-alias`로 해결**
```bash
npx tsc
npx tsc-alias
```
✅ **컴파일 후 경로가 변환됨:**
```javascript
const coreFunction = require("../B-Repo/lib/index.js");
const utilityFunction = require("../C-Repo/utils/helper.js");
```

---

# ❌ `tsc-alias`만 사용할 때의 문제점

### 🎮 장난감 상자 상황
- **A-Repo**: 로봇 본체를 조립하는 상자
- **B-Repo**: 로봇의 팔과 다리가 들어있는 상자
- **C-Repo**: 로봇을 조립하는 나사가 들어있는 상자

`A-Repo`에서 **로봇을 완성**하려면 **B-Repo**와 **C-Repo**의 부품이 필요하지만, **`tsc-alias`만 사용했을 때** 문제가 발생합니다.

---

## ❌ 1. 의존성 관리 불가 (팔과 나사의 위치를 모름)

### 🎨 **상황 설명:**
- **A-Repo의 설명서:**  
  `"B-Repo에서 팔을 가져오세요."`  
  `"C-Repo에서 나사를 가져오세요."`

- **문제:** 상자 위치가 설명서에 **정확히 표시되지 않음.**
- 결과: **팔과 나사**를 찾기 위해 **방을 뒤져야 함.**

### ✅ **해결책 (workspace 사용 시)**
- **설명서가 이렇게 바뀜:**
    - `"B-Repo (2번 선반)"에서 팔을 가져오세요.`
    - `"C-Repo (3번 선반)"에서 나사를 가져오세요.`

✅ **결과:** 상자를 찾기 쉬워졌어요!

---

## ❌ 2. 빌드 순서 보장 불가 (팔과 다리 준비 전에 조립 시작)

### 🎨 **상황 설명:**
- **A-Repo**에서 **로봇 본체를 먼저 조립**하려고 함.
- **하지만 B-Repo(팔)**와 **C-Repo(나사)**가 **아직 상자에 잠겨있음!**

**→ 팔과 나사를 준비하기 전에 조립을 시작해서 엉망이 됨.**

### ✅ **해결책 (workspace 사용 시)**
- **Step 1:** `B-Repo`와 `C-Repo`를 먼저 열고 준비.
- **Step 2:** 준비 완료 후, `A-Repo`에서 조립 시작.

✅ **결과:** **순서대로 빌드가 진행**되므로, 오류가 발생하지 않음.

---

## ❌ 3. 런타임 경로 해석 불가 (팔과 다리 위치를 모른 채 조립)

### 🎨 **상황 설명:**
- **로봇을 조립하고 나서 친구에게 설명서**를 주었어요.
- 그런데 설명서에 이렇게 적혀있음:  
  `"팔: @core/index, 나사: @utils/helper"`

- **문제:** 친구는 `"@core/index"`가 **어디에 있는지 몰라서** 로봇을 완성하지 못함.

### ✅ **해결책 (workspace 사용 시)**
- **설명서가 정확한 위치로 바뀜:**  
  `"팔: ../B-Repo/lib/index.js"`  
  `"나사: ../C-Repo/utils/helper.js"`

✅ **결과:** 친구도 **정확한 경로**를 알고, 로봇을 완성할 수 있게 됨!

---

## 🎯 `tsc-alias` vs `workspace` 비교표

| 문제 상황                  | `tsc-alias`만 사용 | `workspace` 사용 |
|--------------------------|-------------------|-----------------|
| **의존성 관리 불가**       | 상자 위치를 모름 | ✅ 정확한 위치 제공 |
| **빌드 순서 보장 불가**    | 순서 없이 조립   | ✅ 순서 자동 보장  |
| **런타임 경로 해석 불가** | 조립 후 경로 모름 | ✅ 경로 자동 변환 |

---

## ✅ workspace 사용의 장점
1. **작업장 연결:** A, B, C 작업장이 하나의 큰 작업장처럼 동작.
2. **자동 의존성 관리:** 각 작업장 간 **필요한 작업 순서**를 자동으로 조정.
3. **코드 가독성:** 경로를 단축하고 **가독성 향상.**


---

# 🎯 `tsc-alias` vs `workspace` 비교표

| 기능                          | `tsc-alias`                     | `workspace`                  |
|-------------------------------|---------------------------------|---------------------------------|
| **주요 목적**                 | 경로 매핑 해결                   | 멀티 패키지 관리 및 의존성 해석 |
| **의존성 관리 가능 여부**      | ❌ 불가능                        | ✅ 가능 (`workspace:*`)         |
| **빌드 순서 보장**            | ❌ 불가능                        | ✅ 가능 (의존성 그래프 기반)     |
| **런타임 경로 문제 해결**      | ✅ 가능 (tsc-alias 실행 필요)   | ✅ 가능 (자동 해결)             |
| **대규모 프로젝트 적합성**     | ❌ 비효율적                     | ✅ 효율적 (모노레포 지원)       |

---

# ✅ 결론: 왜 `workspace`와 `tsc-alias`를 함께 써야 할까?

**`tsc-alias`만 사용할 경우:**
- **경로 매핑**만 해결.
- **패키지 의존성**과 **빌드 순서 보장 불가능**.

**`workspace`만 사용할 경우:**
- **패키지 의존성**과 **빌드 순서**는 해결 가능.
- 하지만 **코드 경로 단축**은 지원하지 않음.

### 🎯 **따라서:**
- ✅ **소규모 프로젝트:** `tsc-alias`만 사용해도 충분.
- ✅ **대규모 프로젝트 (모노레포 환경):** `tsc-alias` + `workspace` **함께 사용 필요!**
