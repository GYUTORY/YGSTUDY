---
title: TypeScript 유틸리티 타입 완벽 가이드
tags: [language, typescript, 타입-유틸리티, utility-types]
updated: 2025-11-28
---

# TypeScript 유틸리티 타입 완벽 가이드

## 배경

TypeScript는 타입 조작을 위한 다양한 유틸리티 타입을 제공합니다. 이를 통해 기존 타입을 변환하고 조합하여 더 강력한 타입 시스템을 구축할 수 있습니다.

### 유틸리티 타입의 필요성
- **타입 재사용성**: 기존 타입을 변환하여 새로운 타입 생성
- **타입 안전성**: 컴파일 타임에 타입 오류 감지
- **개발 효율성**: 반복적인 타입 정의 작업 자동화
- **코드 가독성**: 명확하고 의도가 드러나는 타입 정의

## 핵심

### 1. 속성을 조작하는 유틸리티 타입

#### Partial<T>
모든 속성을 선택적으로 변환합니다.

```typescript
type User = {
    id: number;
    name: string;
    age: number;
};

const partialUser: Partial<User> = { name: 'Alice' }; // 모든 속성이 선택적
```

**사용 사례**: API 요청에서 일부 필드만 업데이트할 때
```typescript
function updateUser(id: number, updates: Partial<User>) {
    // 기존 사용자 정보에 업데이트 내용을 병합
    return { ...getUser(id), ...updates };
}

// 사용 예시
updateUser(1, { name: 'Bob', age: 30 });
updateUser(1, { name: 'Bob' }); // 일부 필드만 업데이트
```

#### Pick<T, K>
특정 속성만 선택하여 새로운 타입을 생성합니다.

```typescript
type User = {
    id: number;
    name: string;
    age: number;
    email: string;
};

type UserName = Pick<User, 'name'>; // name 속성만 포함
type UserProfile = Pick<User, 'name' | 'age'>; // 여러 속성 선택

const userName: UserName = { name: 'Alice' };
const userProfile: UserProfile = { name: 'Alice', age: 25 };
```

**사용 사례**: 공개 프로필에서 민감한 정보 제외
```typescript
type PublicUser = Pick<User, 'name' | 'age'>;
type PrivateUser = Pick<User, 'id' | 'email'>;
```

#### Required<T>
모든 선택적 속성을 필수로 만듭니다.

```typescript
type User = {
    id?: number;
    name?: string;
    age?: number;
};

const user: Required<User> = { id: 1, name: 'Alice', age: 25 }; // 모든 속성이 필수
```

**사용 사례**: 설정 객체에서 모든 옵션을 필수로 만들 때
```typescript
type Config = {
    host?: string;
    port?: number;
    timeout?: number;
};

function createConnection(config: Required<Config>) {
    // 모든 설정이 보장됨
    return connect(config.host, config.port, config.timeout);
}
```

#### Readonly<T>
모든 속성을 읽기 전용으로 만듭니다.

```typescript
type User = {
    id: number;
    name: string;
};

const user: Readonly<User> = { id: 1, name: 'Alice' };

// user.id = 2; // 오류: 읽기 전용 속성은 수정 불가
// user.name = 'Bob'; // 오류: 읽기 전용 속성은 수정 불가
```

**사용 사례**: 불변 데이터 구조
```typescript
type Config = Readonly<{
    apiUrl: string;
    timeout: number;
}>;

const config: Config = {
    apiUrl: 'https://api.example.com',
    timeout: 5000
};
```

### 2. 속성을 선택/제외하는 유틸리티 타입

#### Omit<T, K>
특정 속성을 제외한 새로운 타입을 생성합니다.

```typescript
type User = {
    id: number;
    name: string;
    age: number;
    password: string;
};

type PublicUser = Omit<User, 'password'>; // password 속성 제외
type UserWithoutId = Omit<User, 'id' | 'password'>; // 여러 속성 제외

const publicUser: PublicUser = { name: 'Alice', age: 25 };
```

**사용 사례**: API 응답에서 민감한 정보 제외
```typescript
type UserResponse = Omit<User, 'password' | 'salt'>;
type CreateUserRequest = Omit<User, 'id' | 'createdAt'>;
```

#### Exclude<T, U>
유니온 타입에서 특정 타입을 제외합니다.

```typescript
type Status = 'pending' | 'loading' | 'success' | 'error';
type LoadingStatus = Exclude<Status, 'pending' | 'success' | 'error'>; // 'loading'

type Numbers = number | string | boolean;
type NonStringNumbers = Exclude<Numbers, string>; // number | boolean
```

**사용 사례**: 상태 관리에서 특정 상태 제외
```typescript
type AsyncState = 'idle' | 'loading' | 'success' | 'error';
type LoadingState = Exclude<AsyncState, 'idle' | 'success' | 'error'>;
```

#### Extract<T, U>
유니온 타입에서 특정 타입을 추출합니다.

```typescript
type Status = 'pending' | 'loading' | 'success' | 'error';
type SuccessStatus = Extract<Status, 'success'>; // 'success'

type Numbers = number | string | boolean;
type StringNumbers = Extract<Numbers, string>; // string
```

**사용 사례**: 특정 타입만 처리하는 함수
```typescript
type EventType = 'click' | 'hover' | 'focus' | 'blur';
type MouseEvent = Extract<EventType, 'click' | 'hover'>;
```

### 3. 객체 타입 생성

#### Record<K, T>
지정된 키와 값 타입을 가진 객체 타입을 생성합니다.

**내부 구현 원리**:
```typescript
// Record<K, T>의 실제 구현
type Record<K extends keyof any, T> = {
    [P in K]: T;
};
```

Record는 매핑 타입(Mapped Type)을 사용하여 구현됩니다:
- `K extends keyof any`: K는 string, number, symbol 중 하나여야 함
- `[P in K]`: K의 각 키를 순회
- `T`: 모든 키에 동일한 값 타입 T를 할당

**기본 사용법**:
```typescript
type UserRoles = Record<string, 'admin' | 'user' | 'guest'>;
const roles: UserRoles = {
    'user1': 'admin',
    'user2': 'user',
    'user3': 'guest'
};

type ApiEndpoints = Record<'users' | 'posts' | 'comments', string>;
const endpoints: ApiEndpoints = {
    users: '/api/users',
    posts: '/api/posts',
    comments: '/api/comments'
};
```

**다양한 키 타입 사용 예제**:

1. **문자열 키 (가장 일반적)**:
```typescript
type Config = Record<string, string>;
const appConfig: Config = {
    apiUrl: 'https://api.example.com',
    timeout: '5000',
    retryCount: '3'
};
```

2. **유니온 타입 키 (타입 안전성 강화)**:
```typescript
type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE';
type ApiRoutes = Record<HttpMethod, string>;

const routes: ApiRoutes = {
    GET: '/api/users',
    POST: '/api/users',
    PUT: '/api/users/:id',
    DELETE: '/api/users/:id'
    // PATCH: '/api/users' // 오류: HttpMethod에 없음
};
```

3. **리터럴 타입 키**:
```typescript
type StatusCode = Record<200 | 404 | 500, string>;
const statusMessages: StatusCode = {
    200: 'OK',
    404: 'Not Found',
    500: 'Internal Server Error'
};
```

4. **문자열 리터럴 유니온**:
```typescript
type Theme = 'light' | 'dark' | 'auto';
type ThemeConfig = Record<Theme, { primary: string; secondary: string }>;

const themes: ThemeConfig = {
    light: { primary: '#ffffff', secondary: '#000000' },
    dark: { primary: '#000000', secondary: '#ffffff' },
    auto: { primary: '#f0f0f0', secondary: '#333333' }
};
```

**Record vs 인덱스 시그니처 차이점**:

```typescript
// 인덱스 시그니처 방식
interface IndexSignature {
    [key: string]: number;
}

// Record 방식
type RecordType = Record<string, number>;

// 차이점 1: 인터페이스 확장 가능성
interface ExtendedIndex extends IndexSignature {
    name: string; // 오류: string은 number에 할당 불가
}

// Record는 타입 별칭이므로 교집합 타입으로 확장
type ExtendedRecord = Record<string, number> & {
    name: string; // 오류: 여전히 충돌
};

// 차이점 2: 특정 키 타입 제한
type SpecificKeys = Record<'id' | 'name' | 'email', string>;
// id, name, email만 허용

interface SpecificKeysInterface {
    [key: 'id' | 'name' | 'email']: string; // 오류: 인덱스 시그니처는 리터럴 타입 불가
}

// 차이점 3: 유틸리티 타입과의 조합
type PartialRecord = Partial<Record<string, number>>;
// { [key: string]?: number }

type ReadonlyRecord = Readonly<Record<string, number>>;
// { readonly [key: string]: number }
```

**실전 활용 패턴**:

1. **API 응답 타입 정의**:
```typescript
type ApiResponse<T> = Record<string, T> & {
    status: 'success' | 'error';
    message: string;
};

type UserResponse = ApiResponse<{
    id: number;
    name: string;
    email: string;
}>;
```

2. **설정 객체 관리**:
```typescript
type Environment = 'development' | 'staging' | 'production';
type Config = Record<Environment, {
    apiUrl: string;
    databaseUrl: string;
    logLevel: 'debug' | 'info' | 'warn' | 'error';
}>;

const config: Config = {
    development: {
        apiUrl: 'http://localhost:3000',
        databaseUrl: 'postgresql://localhost:5432/dev',
        logLevel: 'debug'
    },
    staging: {
        apiUrl: 'https://staging-api.example.com',
        databaseUrl: 'postgresql://staging-db:5432/staging',
        logLevel: 'info'
    },
    production: {
        apiUrl: 'https://api.example.com',
        databaseUrl: 'postgresql://prod-db:5432/prod',
        logLevel: 'warn'
    }
};
```

3. **매핑 테이블**:
```typescript
type ErrorCode = 'E001' | 'E002' | 'E003' | 'E004';
type ErrorMessages = Record<ErrorCode, string>;

const errorMessages: ErrorMessages = {
    E001: '사용자를 찾을 수 없습니다',
    E002: '권한이 없습니다',
    E003: '입력값이 올바르지 않습니다',
    E004: '서버 오류가 발생했습니다'
};

function getErrorMessage(code: ErrorCode): string {
    return errorMessages[code];
}
```

4. **폼 상태 관리**:
```typescript
type FormField = 'username' | 'email' | 'password' | 'confirmPassword';
type FormState = Record<FormField, {
    value: string;
    error: string | null;
    touched: boolean;
}>;

const initialFormState: FormState = {
    username: { value: '', error: null, touched: false },
    email: { value: '', error: null, touched: false },
    password: { value: '', error: null, touched: false },
    confirmPassword: { value: '', error: null, touched: false }
};
```

5. **다국어 지원**:
```typescript
type Language = 'ko' | 'en' | 'ja' | 'zh';
type TranslationKey = 'welcome' | 'goodbye' | 'thankYou' | 'error';
type Translations = Record<Language, Record<TranslationKey, string>>;

const translations: Translations = {
    ko: {
        welcome: '환영합니다',
        goodbye: '안녕히 가세요',
        thankYou: '감사합니다',
        error: '오류가 발생했습니다'
    },
    en: {
        welcome: 'Welcome',
        goodbye: 'Goodbye',
        thankYou: 'Thank you',
        error: 'An error occurred'
    },
    ja: {
        welcome: 'いらっしゃいませ',
        goodbye: 'さようなら',
        thankYou: 'ありがとうございます',
        error: 'エラーが発生しました'
    },
    zh: {
        welcome: '欢迎',
        goodbye: '再见',
        thankYou: '谢谢',
        error: '发生错误'
    }
};
```

**Record와 다른 유틸리티 타입 조합**:

1. **Partial과 조합**:
```typescript
type OptionalConfig = Partial<Record<string, string>>;
// { [key: string]?: string }

const partialConfig: OptionalConfig = {
    apiUrl: 'https://api.example.com'
    // 다른 키는 선택적
};
```

2. **Pick과 조합**:
```typescript
type AllConfig = Record<string, string | number | boolean>;
type StringConfig = Pick<Record<string, string>, string>;
// 특정 타입의 값만 선택
```

3. **Omit과 조합**:
```typescript
type FullConfig = Record<'apiUrl' | 'timeout' | 'retry', string | number>;
type WithoutRetry = Omit<FullConfig, 'retry'>;
// { apiUrl: string | number; timeout: string | number }
```

4. **Readonly와 조합**:
```typescript
type ReadonlyConfig = Readonly<Record<string, string>>;
// 모든 속성이 readonly

const config: ReadonlyConfig = {
    apiUrl: 'https://api.example.com'
};
// config.apiUrl = 'new'; // 오류: readonly 속성
```

**타입 안전성을 위한 제약 조건**:

1. **키 타입 제약**:
```typescript
// string 또는 number만 허용
type SafeRecord<K extends string | number, T> = Record<K, T>;

type UserIds = SafeRecord<number, { name: string }>;
const users: UserIds = {
    1: { name: 'Alice' },
    2: { name: 'Bob' }
};
```

2. **값 타입 제약**:
```typescript
// 특정 타입의 값만 허용
type StringRecord<K extends keyof any> = Record<K, string>;

type ConfigKeys = 'apiUrl' | 'timeout';
type Config = StringRecord<ConfigKeys>;
// { apiUrl: string; timeout: string }
```

3. **중첩 Record**:
```typescript
type NestedRecord = Record<string, Record<string, number>>;
// { [key: string]: { [key: string]: number } }

const matrix: NestedRecord = {
    row1: { col1: 1, col2: 2 },
    row2: { col1: 3, col2: 4 }
};
```

4. **조건부 타입과 조합**:
```typescript
type ConditionalRecord<T> = T extends string
    ? Record<string, T>
    : Record<string, unknown>;

type StringRecord = ConditionalRecord<string>;
// Record<string, string>

type NumberRecord = ConditionalRecord<number>;
// Record<string, unknown>
```

**실전 활용: 동적 객체 생성**:
```typescript
function createRecord<K extends string, T>(
    keys: K[],
    defaultValue: T
): Record<K, T> {
    return keys.reduce((acc, key) => {
        acc[key] = defaultValue;
        return acc;
    }, {} as Record<K, T>);
}

// 사용 예시
const statusFlags = createRecord(['pending', 'loading', 'success', 'error'], false);
// { pending: false, loading: false, success: false, error: false }

const counters = createRecord(['users', 'posts', 'comments'], 0);
// { users: 0, posts: 0, comments: 0 }
```

### 4. 함수 타입 추출

#### Parameters<T>
함수의 매개변수 타입을 튜플로 추출합니다.

```typescript
function createUser(name: string, age: number, email?: string) {
    return { name, age, email };
}

type CreateUserParams = Parameters<typeof createUser>; // [string, number, string?]
type FirstParam = Parameters<typeof createUser>[0]; // string
```

**사용 사례**: 함수 래퍼나 데코레이터
```typescript
function withLogging<T extends (...args: any[]) => any>(
    fn: T
): (...args: Parameters<T>) => ReturnType<T> {
    return (...args: Parameters<T>) => {
        console.log('함수 호출:', args);
        return fn(...args);
    };
}
```

#### ReturnType<T>
함수의 반환 타입을 추출합니다.

```typescript
function getUser(id: number) {
    return { id, name: 'Alice', age: 25 };
}

type User = ReturnType<typeof getUser>; // { id: number; name: string; age: number }
```

**사용 사례**: API 응답 타입 추출
```typescript
async function fetchUser(id: number) {
    const response = await fetch(`/api/users/${id}`);
    return response.json();
}

type UserResponse = Awaited<ReturnType<typeof fetchUser>>;
```

#### ConstructorParameters<T>
생성자 함수의 매개변수 타입을 튜플로 추출합니다.

```typescript
class Person {
    constructor(name: string, age: number) {
        this.name = name;
        this.age = age;
    }
}

type PersonParams = ConstructorParameters<typeof Person>; // [string, number]
```

**사용 사례**: 팩토리 함수
```typescript
function createInstance<T extends new (...args: any[]) => any>(
    constructor: T,
    ...args: ConstructorParameters<T>
): InstanceType<T> {
    return new constructor(...args);
}
```

#### InstanceType<T>
클래스 생성자의 인스턴스 타입을 추출합니다.

```typescript
class Person {
    name: string;
    constructor(name: string) {
        this.name = name;
    }
}

type PersonInstance = InstanceType<typeof Person>; // Person
```

**사용 사례**: 제네릭 팩토리
```typescript
function createArray<T extends new (...args: any[]) => any>(
    constructor: T,
    count: number,
    ...args: ConstructorParameters<T>
): InstanceType<T>[] {
    return Array.from({ length: count }, () => new constructor(...args));
}
```

### 5. 컨텍스트 타입 설정

#### ThisType<T>
`this` 컨텍스트의 타입을 지정합니다.

```typescript
type ObjectDescriptor<D, M> = {
    data?: D;
    methods?: M & ThisType<D & M>; // this의 타입 정의
};

const obj: ObjectDescriptor<{ x: number }, { addX(y: number): number }> = {
    data: { x: 10 },
    methods: {
        addX(y) {
            return this.x + y; // this는 data와 methods를 포함
        },
    },
};
```

**사용 사례**: Vue.js 스타일의 컴포넌트 정의
```typescript
type ComponentOptions<D, M> = {
    data?: () => D;
    methods?: M & ThisType<D & M>;
};

const component: ComponentOptions<{ count: number }, { increment(): void }> = {
    data() {
        return { count: 0 };
    },
    methods: {
        increment() {
            this.count++; // this.count에 접근 가능
        }
    }
};
```

## 예시

### 1. 실제 사용 사례

#### API 응답 타입 정의
```typescript
// 기본 사용자 타입
type User = {
    id: number;
    name: string;
    email: string;
    password: string;
    createdAt: Date;
    updatedAt: Date;
};

// API 응답에서 민감한 정보 제외
type UserResponse = Omit<User, 'password'>;

// 사용자 생성 요청 (ID와 타임스탬프 제외)
type CreateUserRequest = Omit<User, 'id' | 'createdAt' | 'updatedAt'>;

// 사용자 업데이트 요청 (일부 필드만 선택적)
type UpdateUserRequest = Partial<Pick<User, 'name' | 'email'>>;

// 공개 프로필 (민감한 정보 제외)
type PublicProfile = Pick<User, 'id' | 'name'>;

// 사용 예시
const userResponse: UserResponse = {
    id: 1,
    name: '홍길동',
    email: 'hong@example.com',
    createdAt: new Date(),
    updatedAt: new Date()
};

const createRequest: CreateUserRequest = {
    name: '김철수',
    email: 'kim@example.com',
    password: 'secret123'
};

const updateRequest: UpdateUserRequest = {
    name: '이영희'
};
```

#### 상태 관리 타입
```typescript
// 기본 상태 타입
type AsyncState = 'idle' | 'loading' | 'success' | 'error';

// 상태별 데이터 타입
type StateData<T> = {
    idle: null;
    loading: null;
    success: T;
    error: string;
};

// 완전한 상태 객체 타입
type AsyncStateObject<T> = {
    state: AsyncState;
    data: StateData<T>[keyof StateData<T>];
    error?: string;
};

// 특정 상태만 추출
type LoadingState = Extract<AsyncState, 'loading'>;
type NonLoadingState = Exclude<AsyncState, 'loading'>;

// 사용 예시
const userState: AsyncStateObject<User> = {
    state: 'success',
    data: {
        id: 1,
        name: '홍길동',
        email: 'hong@example.com'
    }
};
```

### 2. 고급 활용 패턴

#### 조건부 타입과 유틸리티 타입 조합
```typescript
// 조건부 타입 정의
type ConditionalPick<T, K extends keyof T> = T[K] extends string ? Pick<T, K> : never;

// 사용 예시
type User = {
    id: number;
    name: string;
    age: number;
    email: string;
};

type StringFields = ConditionalPick<User, keyof User>; // name, email만 포함

// 고급 조건부 타입
type DeepPartial<T> = {
    [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};

type NestedUser = {
    profile: {
        name: string;
        age: number;
    };
    settings: {
        theme: string;
        notifications: boolean;
    };
};

type PartialNestedUser = DeepPartial<NestedUser>;
// {
//   profile?: {
//     name?: string;
//     age?: number;
//   };
//   settings?: {
//     theme?: string;
//     notifications?: boolean;
//   };
// }
```

#### 함수 타입 조작
```typescript
// 함수 오버로드 타입
type FunctionOverloads<T> = T extends {
    (...args: infer A1): infer R1;
    (...args: infer A2): infer R2;
    (...args: infer A3): infer R3;
} ? [A1, A2, A3] : never;

// 함수 래퍼 타입
type AsyncFunction<T extends (...args: any[]) => any> = (
    ...args: Parameters<T>
) => Promise<Awaited<ReturnType<T>>>;

// 사용 예시
function syncFunction(x: number, y: string): boolean {
    return x > 0 && y.length > 0;
}

type AsyncSyncFunction = AsyncFunction<typeof syncFunction>;
// (x: number, y: string) => Promise<boolean>

// 실제 구현
const asyncWrapper: AsyncFunction<typeof syncFunction> = async (x, y) => {
    await new Promise(resolve => setTimeout(resolve, 100));
    return syncFunction(x, y);
};
```

## 운영 팁

### 성능 최적화

#### 타입 캐싱
```typescript
// 복잡한 타입 계산을 캐시
type ComplexType<T> = T extends string 
    ? { type: 'string'; value: T }
    : T extends number
    ? { type: 'number'; value: T }
    : { type: 'unknown'; value: T };

// 자주 사용되는 타입 조합을 미리 정의
type CommonUserFields = Pick<User, 'id' | 'name' | 'email'>;
type UserUpdateFields = Partial<Omit<User, 'id' | 'createdAt' | 'updatedAt'>>;
```

### 에러 처리

#### 타입 안전한 에러 처리
```typescript
// 에러 타입 정의
type ApiError = {
    code: string;
    message: string;
    details?: Record<string, any>;
};

// 성공/실패 결과 타입
type ApiResult<T> = 
    | { success: true; data: T }
    | { success: false; error: ApiError };

// 함수 시그니처
type ApiFunction<T> = (...args: any[]) => Promise<ApiResult<T>>;

// 사용 예시
async function fetchUser(id: number): Promise<ApiResult<User>> {
    try {
        const response = await fetch(`/api/users/${id}`);
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }
        const data = await response.json();
        return { success: true, data };
    } catch (error) {
        return {
            success: false,
            error: {
                code: 'FETCH_ERROR',
                message: error instanceof Error ? error.message : 'Unknown error'
            }
        };
    }
}
```

## 참고

### 유틸리티 타입 참조표

| 유틸리티 타입 | 기능 | 예시 |
|--------------|------|------|
| `Partial<T>` | 모든 속성을 선택적으로 변환 | `Partial<User>` |
| `Pick<T, K>` | 특정 속성만 선택 | `Pick<User, 'name' \| 'email'>` |
| `Required<T>` | 모든 선택적 속성을 필수로 변환 | `Required<User>` |
| `Readonly<T>` | 모든 속성을 읽기 전용으로 변환 | `Readonly<User>` |
| `Omit<T, K>` | 특정 속성을 제외 | `Omit<User, 'password'>` |
| `Exclude<T, U>` | 유니온 타입에서 특정 타입 제외 | `Exclude<Status, 'error'>` |
| `Extract<T, U>` | 유니온 타입에서 특정 타입 추출 | `Extract<Status, 'success'>` |
| `Record<K, T>` | 키-값 타입을 가진 객체 생성 | `Record<string, number>` |
| `Parameters<T>` | 함수 매개변수 타입 추출 | `Parameters<typeof fn>` |
| `ReturnType<T>` | 함수 반환 타입 추출 | `ReturnType<typeof fn>` |
| `ConstructorParameters<T>` | 생성자 매개변수 타입 추출 | `ConstructorParameters<typeof Class>` |
| `InstanceType<T>` | 클래스 인스턴스 타입 추출 | `InstanceType<typeof Class>` |
| `ThisType<T>` | this 컨텍스트 타입 설정 | `ThisType<Data & Methods>` |

### 결론
TypeScript의 유틸리티 타입은 타입 시스템을 더욱 강력하고 유연하게 만들어줍니다.
기존 타입을 변환하고 조합하여 새로운 타입을 쉽게 생성할 수 있습니다.
실제 프로젝트에서 API 응답, 상태 관리, 함수 타입 등에 널리 활용됩니다.
조건부 타입과 함께 사용하면 더욱 정교한 타입 정의가 가능합니다.
적절한 유틸리티 타입 사용으로 타입 안전성과 개발 효율성을 동시에 향상시킬 수 있습니다.
