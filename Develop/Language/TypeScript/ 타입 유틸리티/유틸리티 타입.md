---
title: TypeScript 유틸리티 타입 완벽 가이드
tags: [language, typescript, 타입-유틸리티, utility-types]
updated: 2025-08-10
---

# TypeScript 유틸리티 타입 완벽 가이드

## 배경

TypeScript는 타입 조작을 위한 다양한 유틸리티 타입을 제공합니다. 이를 통해 기존 타입을 변환하고 조합하여 더 강력한 타입 시스템을 구축할 수 있습니다.

### 유틸리티 타입의 필요성
- **타입 재사용성**: 기존 타입을 변환하여 새로운 타입 생성
- **타입 안전성**: 컴파일 타임에 타입 오류 감지
- **개발 효율성**: 반복적인 타입 정의 작업 자동화
- **코드 가독성**: 명확하고 의도가 드러나는 타입 정의

## 핵심

### 1. 속성을 조작하는 유틸리티 타입

#### Partial<T>
모든 속성을 선택적으로 변환합니다.

```typescript
type User = {
    id: number;
    name: string;
    age: number;
};

const partialUser: Partial<User> = { name: 'Alice' }; // 모든 속성이 선택적
```

**사용 사례**: API 요청에서 일부 필드만 업데이트할 때
```typescript
function updateUser(id: number, updates: Partial<User>) {
    // 기존 사용자 정보에 업데이트 내용을 병합
    return { ...getUser(id), ...updates };
}

// 사용 예시
updateUser(1, { name: 'Bob', age: 30 });
updateUser(1, { name: 'Bob' }); // 일부 필드만 업데이트
```

#### Pick<T, K>
특정 속성만 선택하여 새로운 타입을 생성합니다.

```typescript
type User = {
    id: number;
    name: string;
    age: number;
    email: string;
};

type UserName = Pick<User, 'name'>; // name 속성만 포함
type UserProfile = Pick<User, 'name' | 'age'>; // 여러 속성 선택

const userName: UserName = { name: 'Alice' };
const userProfile: UserProfile = { name: 'Alice', age: 25 };
```

**사용 사례**: 공개 프로필에서 민감한 정보 제외
```typescript
type PublicUser = Pick<User, 'name' | 'age'>;
type PrivateUser = Pick<User, 'id' | 'email'>;
```

#### Required<T>
모든 선택적 속성을 필수로 만듭니다.

```typescript
type User = {
    id?: number;
    name?: string;
    age?: number;
};

const user: Required<User> = { id: 1, name: 'Alice', age: 25 }; // 모든 속성이 필수
```

**사용 사례**: 설정 객체에서 모든 옵션을 필수로 만들 때
```typescript
type Config = {
    host?: string;
    port?: number;
    timeout?: number;
};

function createConnection(config: Required<Config>) {
    // 모든 설정이 보장됨
    return connect(config.host, config.port, config.timeout);
}
```

#### Readonly<T>
모든 속성을 읽기 전용으로 만듭니다.

```typescript
type User = {
    id: number;
    name: string;
};

const user: Readonly<User> = { id: 1, name: 'Alice' };

// user.id = 2; // 오류: 읽기 전용 속성은 수정 불가
// user.name = 'Bob'; // 오류: 읽기 전용 속성은 수정 불가
```

**사용 사례**: 불변 데이터 구조
```typescript
type Config = Readonly<{
    apiUrl: string;
    timeout: number;
}>;

const config: Config = {
    apiUrl: 'https://api.example.com',
    timeout: 5000
};
```

### 2. 속성을 선택/제외하는 유틸리티 타입

#### Omit<T, K>
특정 속성을 제외한 새로운 타입을 생성합니다.

```typescript
type User = {
    id: number;
    name: string;
    age: number;
    password: string;
};

type PublicUser = Omit<User, 'password'>; // password 속성 제외
type UserWithoutId = Omit<User, 'id' | 'password'>; // 여러 속성 제외

const publicUser: PublicUser = { name: 'Alice', age: 25 };
```

**사용 사례**: API 응답에서 민감한 정보 제외
```typescript
type UserResponse = Omit<User, 'password' | 'salt'>;
type CreateUserRequest = Omit<User, 'id' | 'createdAt'>;
```

#### Exclude<T, U>
유니온 타입에서 특정 타입을 제외합니다.

```typescript
type Status = 'pending' | 'loading' | 'success' | 'error';
type LoadingStatus = Exclude<Status, 'pending' | 'success' | 'error'>; // 'loading'

type Numbers = number | string | boolean;
type NonStringNumbers = Exclude<Numbers, string>; // number | boolean
```

**사용 사례**: 상태 관리에서 특정 상태 제외
```typescript
type AsyncState = 'idle' | 'loading' | 'success' | 'error';
type LoadingState = Exclude<AsyncState, 'idle' | 'success' | 'error'>;
```

#### Extract<T, U>
유니온 타입에서 특정 타입을 추출합니다.

```typescript
type Status = 'pending' | 'loading' | 'success' | 'error';
type SuccessStatus = Extract<Status, 'success'>; // 'success'

type Numbers = number | string | boolean;
type StringNumbers = Extract<Numbers, string>; // string
```

**사용 사례**: 특정 타입만 처리하는 함수
```typescript
type EventType = 'click' | 'hover' | 'focus' | 'blur';
type MouseEvent = Extract<EventType, 'click' | 'hover'>;
```

### 3. 객체 타입 생성

#### Record<K, T>
지정된 키와 값 타입을 가진 객체 타입을 생성합니다.

```typescript
type UserRoles = Record<string, 'admin' | 'user' | 'guest'>;
const roles: UserRoles = {
    'user1': 'admin',
    'user2': 'user',
    'user3': 'guest'
};

type ApiEndpoints = Record<'users' | 'posts' | 'comments', string>;
const endpoints: ApiEndpoints = {
    users: '/api/users',
    posts: '/api/posts',
    comments: '/api/comments'
};
```

**사용 사례**: 설정 객체나 매핑 테이블
```typescript
type ErrorMessages = Record<string, string>;
type ValidationRules = Record<string, RegExp>;
```

### 4. 함수 타입 추출

#### Parameters<T>
함수의 매개변수 타입을 튜플로 추출합니다.

```typescript
function createUser(name: string, age: number, email?: string) {
    return { name, age, email };
}

type CreateUserParams = Parameters<typeof createUser>; // [string, number, string?]
type FirstParam = Parameters<typeof createUser>[0]; // string
```

**사용 사례**: 함수 래퍼나 데코레이터
```typescript
function withLogging<T extends (...args: any[]) => any>(
    fn: T
): (...args: Parameters<T>) => ReturnType<T> {
    return (...args: Parameters<T>) => {
        console.log('함수 호출:', args);
        return fn(...args);
    };
}
```

#### ReturnType<T>
함수의 반환 타입을 추출합니다.

```typescript
function getUser(id: number) {
    return { id, name: 'Alice', age: 25 };
}

type User = ReturnType<typeof getUser>; // { id: number; name: string; age: number }
```

**사용 사례**: API 응답 타입 추출
```typescript
async function fetchUser(id: number) {
    const response = await fetch(`/api/users/${id}`);
    return response.json();
}

type UserResponse = Awaited<ReturnType<typeof fetchUser>>;
```

#### ConstructorParameters<T>
생성자 함수의 매개변수 타입을 튜플로 추출합니다.

```typescript
class Person {
    constructor(name: string, age: number) {
        this.name = name;
        this.age = age;
    }
}

type PersonParams = ConstructorParameters<typeof Person>; // [string, number]
```

**사용 사례**: 팩토리 함수
```typescript
function createInstance<T extends new (...args: any[]) => any>(
    constructor: T,
    ...args: ConstructorParameters<T>
): InstanceType<T> {
    return new constructor(...args);
}
```

#### InstanceType<T>
클래스 생성자의 인스턴스 타입을 추출합니다.

```typescript
class Person {
    name: string;
    constructor(name: string) {
        this.name = name;
    }
}

type PersonInstance = InstanceType<typeof Person>; // Person
```

**사용 사례**: 제네릭 팩토리
```typescript
function createArray<T extends new (...args: any[]) => any>(
    constructor: T,
    count: number,
    ...args: ConstructorParameters<T>
): InstanceType<T>[] {
    return Array.from({ length: count }, () => new constructor(...args));
}
```

### 5. 컨텍스트 타입 설정

#### ThisType<T>
`this` 컨텍스트의 타입을 지정합니다.

```typescript
type ObjectDescriptor<D, M> = {
    data?: D;
    methods?: M & ThisType<D & M>; // this의 타입 정의
};

const obj: ObjectDescriptor<{ x: number }, { addX(y: number): number }> = {
    data: { x: 10 },
    methods: {
        addX(y) {
            return this.x + y; // this는 data와 methods를 포함
        },
    },
};
```

**사용 사례**: Vue.js 스타일의 컴포넌트 정의
```typescript
type ComponentOptions<D, M> = {
    data?: () => D;
    methods?: M & ThisType<D & M>;
};

const component: ComponentOptions<{ count: number }, { increment(): void }> = {
    data() {
        return { count: 0 };
    },
    methods: {
        increment() {
            this.count++; // this.count에 접근 가능
        }
    }
};
```

## 예시

### 1. 실제 사용 사례

#### API 응답 타입 정의
```typescript
// 기본 사용자 타입
type User = {
    id: number;
    name: string;
    email: string;
    password: string;
    createdAt: Date;
    updatedAt: Date;
};

// API 응답에서 민감한 정보 제외
type UserResponse = Omit<User, 'password'>;

// 사용자 생성 요청 (ID와 타임스탬프 제외)
type CreateUserRequest = Omit<User, 'id' | 'createdAt' | 'updatedAt'>;

// 사용자 업데이트 요청 (일부 필드만 선택적)
type UpdateUserRequest = Partial<Pick<User, 'name' | 'email'>>;

// 공개 프로필 (민감한 정보 제외)
type PublicProfile = Pick<User, 'id' | 'name'>;

// 사용 예시
const userResponse: UserResponse = {
    id: 1,
    name: '홍길동',
    email: 'hong@example.com',
    createdAt: new Date(),
    updatedAt: new Date()
};

const createRequest: CreateUserRequest = {
    name: '김철수',
    email: 'kim@example.com',
    password: 'secret123'
};

const updateRequest: UpdateUserRequest = {
    name: '이영희'
};
```

#### 상태 관리 타입
```typescript
// 기본 상태 타입
type AsyncState = 'idle' | 'loading' | 'success' | 'error';

// 상태별 데이터 타입
type StateData<T> = {
    idle: null;
    loading: null;
    success: T;
    error: string;
};

// 완전한 상태 객체 타입
type AsyncStateObject<T> = {
    state: AsyncState;
    data: StateData<T>[keyof StateData<T>];
    error?: string;
};

// 특정 상태만 추출
type LoadingState = Extract<AsyncState, 'loading'>;
type NonLoadingState = Exclude<AsyncState, 'loading'>;

// 사용 예시
const userState: AsyncStateObject<User> = {
    state: 'success',
    data: {
        id: 1,
        name: '홍길동',
        email: 'hong@example.com'
    }
};
```

### 2. 고급 활용 패턴

#### 조건부 타입과 유틸리티 타입 조합
```typescript
// 조건부 타입 정의
type ConditionalPick<T, K extends keyof T> = T[K] extends string ? Pick<T, K> : never;

// 사용 예시
type User = {
    id: number;
    name: string;
    age: number;
    email: string;
};

type StringFields = ConditionalPick<User, keyof User>; // name, email만 포함

// 고급 조건부 타입
type DeepPartial<T> = {
    [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};

type NestedUser = {
    profile: {
        name: string;
        age: number;
    };
    settings: {
        theme: string;
        notifications: boolean;
    };
};

type PartialNestedUser = DeepPartial<NestedUser>;
// {
//   profile?: {
//     name?: string;
//     age?: number;
//   };
//   settings?: {
//     theme?: string;
//     notifications?: boolean;
//   };
// }
```

#### 함수 타입 조작
```typescript
// 함수 오버로드 타입
type FunctionOverloads<T> = T extends {
    (...args: infer A1): infer R1;
    (...args: infer A2): infer R2;
    (...args: infer A3): infer R3;
} ? [A1, A2, A3] : never;

// 함수 래퍼 타입
type AsyncFunction<T extends (...args: any[]) => any> = (
    ...args: Parameters<T>
) => Promise<Awaited<ReturnType<T>>>;

// 사용 예시
function syncFunction(x: number, y: string): boolean {
    return x > 0 && y.length > 0;
}

type AsyncSyncFunction = AsyncFunction<typeof syncFunction>;
// (x: number, y: string) => Promise<boolean>

// 실제 구현
const asyncWrapper: AsyncFunction<typeof syncFunction> = async (x, y) => {
    await new Promise(resolve => setTimeout(resolve, 100));
    return syncFunction(x, y);
};
```

## 운영 팁

### 성능 최적화

#### 타입 캐싱
```typescript
// 복잡한 타입 계산을 캐시
type ComplexType<T> = T extends string 
    ? { type: 'string'; value: T }
    : T extends number
    ? { type: 'number'; value: T }
    : { type: 'unknown'; value: T };

// 자주 사용되는 타입 조합을 미리 정의
type CommonUserFields = Pick<User, 'id' | 'name' | 'email'>;
type UserUpdateFields = Partial<Omit<User, 'id' | 'createdAt' | 'updatedAt'>>;
```

### 에러 처리

#### 타입 안전한 에러 처리
```typescript
// 에러 타입 정의
type ApiError = {
    code: string;
    message: string;
    details?: Record<string, any>;
};

// 성공/실패 결과 타입
type ApiResult<T> = 
    | { success: true; data: T }
    | { success: false; error: ApiError };

// 함수 시그니처
type ApiFunction<T> = (...args: any[]) => Promise<ApiResult<T>>;

// 사용 예시
async function fetchUser(id: number): Promise<ApiResult<User>> {
    try {
        const response = await fetch(`/api/users/${id}`);
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }
        const data = await response.json();
        return { success: true, data };
    } catch (error) {
        return {
            success: false,
            error: {
                code: 'FETCH_ERROR',
                message: error instanceof Error ? error.message : 'Unknown error'
            }
        };
    }
}
```

## 참고

### 유틸리티 타입 참조표

| 유틸리티 타입 | 기능 | 예시 |
|--------------|------|------|
| `Partial<T>` | 모든 속성을 선택적으로 변환 | `Partial<User>` |
| `Pick<T, K>` | 특정 속성만 선택 | `Pick<User, 'name' \| 'email'>` |
| `Required<T>` | 모든 선택적 속성을 필수로 변환 | `Required<User>` |
| `Readonly<T>` | 모든 속성을 읽기 전용으로 변환 | `Readonly<User>` |
| `Omit<T, K>` | 특정 속성을 제외 | `Omit<User, 'password'>` |
| `Exclude<T, U>` | 유니온 타입에서 특정 타입 제외 | `Exclude<Status, 'error'>` |
| `Extract<T, U>` | 유니온 타입에서 특정 타입 추출 | `Extract<Status, 'success'>` |
| `Record<K, T>` | 키-값 타입을 가진 객체 생성 | `Record<string, number>` |
| `Parameters<T>` | 함수 매개변수 타입 추출 | `Parameters<typeof fn>` |
| `ReturnType<T>` | 함수 반환 타입 추출 | `ReturnType<typeof fn>` |
| `ConstructorParameters<T>` | 생성자 매개변수 타입 추출 | `ConstructorParameters<typeof Class>` |
| `InstanceType<T>` | 클래스 인스턴스 타입 추출 | `InstanceType<typeof Class>` |
| `ThisType<T>` | this 컨텍스트 타입 설정 | `ThisType<Data & Methods>` |

### 결론
TypeScript의 유틸리티 타입은 타입 시스템을 더욱 강력하고 유연하게 만들어줍니다.
기존 타입을 변환하고 조합하여 새로운 타입을 쉽게 생성할 수 있습니다.
실제 프로젝트에서 API 응답, 상태 관리, 함수 타입 등에 널리 활용됩니다.
조건부 타입과 함께 사용하면 더욱 정교한 타입 정의가 가능합니다.
적절한 유틸리티 타입 사용으로 타입 안전성과 개발 효율성을 동시에 향상시킬 수 있습니다.
