---
title: JavaScript 비트 연산자 개념과 사용법
tags: [language, javascript, 01기본javascript, operator, bitwise-operators]
updated: 2025-08-10
---

# JavaScript 비트 연산자 개념과 사용법

## 배경

비트 연산자는 숫자를 32비트 정수로 변환하여 비트 단위로 연산을 수행하는 연산자입니다. JavaScript에서는 다양한 비트 연산자를 제공하여 효율적인 비트 조작과 플래그 처리를 할 수 있습니다.

### 비트 연산자의 필요성
- **플래그 처리**: 여러 상태를 하나의 숫자로 표현
- **성능 최적화**: 빠른 비트 단위 연산
- **메모리 효율성**: 적은 메모리로 많은 정보 저장
- **암호화/압축**: 비트 단위 데이터 처리

### 기본 개념
- **32비트 정수**: 모든 비트 연산은 32비트 정수로 변환
- **비트 단위 연산**: 각 비트를 개별적으로 처리
- **2의 보수**: 음수 표현 방식
- **시프트 연산**: 비트를 좌우로 이동

## 핵심

### 1. 비트 AND (&)

#### 기본 동작
```javascript
// 두 숫자의 각 비트를 비교하여 둘 다 1인 경우에만 1 반환
const a = 5;  // 0101 (2진수)
const b = 3;  // 0011 (2진수)
const result = a & b;  // 0001 (1)

// 비트별 연산 과정
// 0101 (5)
// 0011 (3)
// ----
// 0001 (1) - 결과
```

#### 실제 활용
```javascript
// 플래그 확인
const FLAG_A = 1;  // 0001
const FLAG_B = 2;  // 0010
const FLAG_C = 4;  // 0100

let flags = FLAG_A | FLAG_C;  // 0101 (플래그 A와 C 설정)
console.log(flags & FLAG_A);  // 1 (플래그 A가 설정됨)
console.log(flags & FLAG_B);  // 0 (플래그 B가 설정되지 않음)

// 짝수/홀수 판별
function isEven(num) {
    return (num & 1) === 0;
}

console.log(isEven(4));  // true
console.log(isEven(7));  // false

// 마지막 비트 제거
function removeLastBit(num) {
    return num & (num - 1);
}

console.log(removeLastBit(12));  // 8 (1100 -> 1000)
```

### 2. 비트 OR (|)

#### 기본 동작
```javascript
// 두 숫자의 각 비트를 비교하여 하나라도 1이면 1 반환
const a = 5;  // 0101
const b = 3;  // 0011
const result = a | b;  // 0111 (7)

// 비트별 연산 과정
// 0101 (5)
// 0011 (3)
// ----
// 0111 (7) - 결과
```

#### 실제 활용
```javascript
// 플래그 설정
const FLAG_A = 1;  // 0001
const FLAG_B = 2;  // 0010
const FLAG_C = 4;  // 0100

let flags = 0;
flags |= FLAG_A;  // 플래그 A 설정
flags |= FLAG_C;  // 플래그 C 설정
console.log(flags);  // 5 (0101)

// 기본값 설정
function setDefaultValue(value, defaultValue) {
    return value | defaultValue;
}

console.log(setDefaultValue(0, 10));  // 10
console.log(setDefaultValue(5, 10));  // 15 (5 | 10 = 15)
```

### 3. 비트 XOR (^)

#### 기본 동작
```javascript
// 두 숫자의 각 비트를 비교하여 서로 다른 경우에만 1 반환
const a = 5;  // 0101
const b = 3;  // 0011
const result = a ^ b;  // 0110 (6)

// 비트별 연산 과정
// 0101 (5)
// 0011 (3)
// ----
// 0110 (6) - 결과
```

#### 실제 활용
```javascript
// 플래그 토글
const FLAG_A = 1;
const FLAG_B = 2;

let flags = FLAG_A;  // 0001
flags ^= FLAG_A;     // 플래그 A 토글 (제거)
flags ^= FLAG_B;     // 플래그 B 토글 (추가)
console.log(flags);  // 2 (0010)

// 값 교환 (XOR 스왑)
let x = 5, y = 10;
x = x ^ y;
y = x ^ y;
x = x ^ y;
console.log(x, y);  // 10, 5

// 중복 제거
function findSingleNumber(nums) {
    let result = 0;
    for (const num of nums) {
        result ^= num;
    }
    return result;
}

console.log(findSingleNumber([4, 1, 2, 1, 2]));  // 4
```

### 4. 비트 NOT (~)

#### 기본 동작
```javascript
// 모든 비트를 반전 (0은 1로, 1은 0으로)
const a = 5;  // 0101
const result = ~a;  // -6

// 비트별 연산 과정
// ~0101 = 1010 (2의 보수)
// 32비트: 11111111111111111111111111111010
```

#### 실제 활용
```javascript
// 플래그 제거
const FLAG_A = 1;
const FLAG_B = 2;
const FLAG_C = 4;

let flags = FLAG_A | FLAG_B | FLAG_C;  // 7 (0111)
flags &= ~FLAG_B;  // 플래그 B 제거
console.log(flags);  // 5 (0101)

// 음수 변환
function negate(num) {
    return ~num + 1;
}

console.log(negate(5));  // -5
console.log(negate(-3)); // 3

// 범위 확인
function isInRange(num, min, max) {
    return (num >= min) & (num <= max);
}

console.log(isInRange(5, 1, 10));  // 1 (true)
console.log(isInRange(15, 1, 10)); // 0 (false)
```

### 5. 시프트 연산자

#### 왼쪽 시프트 (<<)
```javascript
// 모든 비트를 왼쪽으로 이동, 오른쪽은 0으로 채움
const a = 5;  // 0101
const result = a << 2;  // 10100 (20)

// 비트별 연산 과정
// 0101 -> 10100 (2비트 왼쪽 이동)

// 2의 거듭제곱 계산
function powerOfTwo(n) {
    return 1 << n;
}

console.log(powerOfTwo(3));  // 8 (2^3)
console.log(powerOfTwo(5));  // 32 (2^5)
```

#### 오른쪽 시프트 (>>)
```javascript
// 모든 비트를 오른쪽으로 이동, 왼쪽은 부호 비트로 채움
const a = 20;  // 10100
const result = a >> 2;  // 00101 (5)

// 비트별 연산 과정
// 10100 -> 00101 (2비트 오른쪽 이동)

// 2로 나누기
function divideByTwo(num) {
    return num >> 1;
}

console.log(divideByTwo(10));  // 5
console.log(divideByTwo(7));   // 3 (정수 나눗셈)
```

#### 부호 없는 오른쪽 시프트 (>>>)
```javascript
// 모든 비트를 오른쪽으로 이동, 왼쪽은 항상 0으로 채움
const a = -20;  // 11111111111111111111111111101100
const result = a >>> 2;  // 00111111111111111111111111111011

// 양수로 변환
function toUnsigned(num) {
    return num >>> 0;
}

console.log(toUnsigned(-1));  // 4294967295
```

## 예시

### 1. 실제 사용 사례

#### 권한 시스템
```javascript
// 권한 플래그 정의
const PERMISSIONS = {
    READ: 1,      // 0001
    WRITE: 2,     // 0010
    DELETE: 4,    // 0100
    ADMIN: 8      // 1000
};

class User {
    constructor(name) {
        this.name = name;
        this.permissions = 0;
    }
    
    // 권한 부여
    grantPermission(permission) {
        this.permissions |= permission;
    }
    
    // 권한 제거
    revokePermission(permission) {
        this.permissions &= ~permission;
    }
    
    // 권한 확인
    hasPermission(permission) {
        return (this.permissions & permission) === permission;
    }
    
    // 모든 권한 확인
    hasAllPermissions(...permissions) {
        const required = permissions.reduce((acc, perm) => acc | perm, 0);
        return (this.permissions & required) === required;
    }
    
    // 권한 목록 반환
    getPermissionList() {
        const list = [];
        for (const [name, flag] of Object.entries(PERMISSIONS)) {
            if (this.hasPermission(flag)) {
                list.push(name);
            }
        }
        return list;
    }
}

// 사용 예시
const user = new User('Alice');
user.grantPermission(PERMISSIONS.READ);
user.grantPermission(PERMISSIONS.WRITE);

console.log(user.hasPermission(PERMISSIONS.READ));  // true
console.log(user.hasPermission(PERMISSIONS.DELETE)); // false
console.log(user.getPermissionList()); // ['READ', 'WRITE']
```

#### 색상 처리
```javascript
// RGB 색상을 하나의 정수로 표현
function rgbToInt(r, g, b) {
    return (r << 16) | (g << 8) | b;
}

function intToRgb(color) {
    return {
        r: (color >> 16) & 255,
        g: (color >> 8) & 255,
        b: color & 255
    };
}

// 사용 예시
const red = rgbToInt(255, 0, 0);
const green = rgbToInt(0, 255, 0);
const blue = rgbToInt(0, 0, 255);

console.log(red);   // 16711680
console.log(green); // 65280
console.log(blue);  // 255

const color = intToRgb(16711680);
console.log(color); // { r: 255, g: 0, b: 0 }
```

### 2. 고급 패턴

#### 비트 마스킹
```javascript
// 특정 비트 패턴 추출
function extractBits(num, start, length) {
    const mask = (1 << length) - 1;
    return (num >> start) & mask;
}

// 비트 설정
function setBits(num, start, length, value) {
    const mask = (1 << length) - 1;
    const cleared = num & ~(mask << start);
    return cleared | (value << start);
}

// 사용 예시
const data = 0b10110110; // 182
console.log(extractBits(data, 2, 3)); // 6 (110)
console.log(setBits(data, 2, 3, 7));  // 190 (10111110)
```

#### 비트 카운팅
```javascript
// 1의 개수 세기 (Brian Kernighan 알고리즘)
function countSetBits(num) {
    let count = 0;
    while (num) {
        num &= (num - 1);
        count++;
    }
    return count;
}

// 최하위 비트 찾기
function getLowestSetBit(num) {
    return num & -num;
}

// 최하위 비트 제거
function removeLowestSetBit(num) {
    return num & (num - 1);
}

// 사용 예시
console.log(countSetBits(15));  // 4 (1111)
console.log(getLowestSetBit(12)); // 4 (1100 -> 0100)
console.log(removeLowestSetBit(12)); // 8 (1100 -> 1000)
```

## 운영 팁

### 성능 최적화

#### 빠른 연산
```javascript
// 2의 거듭제곱 확인
function isPowerOfTwo(num) {
    return num > 0 && (num & (num - 1)) === 0;
}

// 2로 나누기 (정수)
function fastDivideByTwo(num) {
    return num >> 1;
}

// 2 곱하기
function fastMultiplyByTwo(num) {
    return num << 1;
}

// 나머지 연산 (2의 거듭제곱으로 나누기)
function fastModulo(num, divisor) {
    return num & (divisor - 1);
}

// 사용 예시
console.log(isPowerOfTwo(8));  // true
console.log(isPowerOfTwo(10)); // false
console.log(fastModulo(17, 8)); // 1 (17 % 8)
```

### 에러 처리

#### 안전한 비트 연산
```javascript
// 32비트 정수 범위 확인
function safeBitwiseOperation(num) {
    // 32비트 정수로 변환
    return num >>> 0;
}

// 범위 검증
function validateBitRange(num, bits) {
    if (bits < 1 || bits > 32) {
        throw new Error('비트 수는 1-32 범위여야 합니다.');
    }
    
    const maxValue = (1 << bits) - 1;
    if (num < 0 || num > maxValue) {
        throw new Error(`값은 0-${maxValue} 범위여야 합니다.`);
    }
    
    return num;
}

// 사용 예시
try {
    const safeNum = safeBitwiseOperation(123456789);
    const validated = validateBitRange(255, 8);
    console.log('안전한 연산 완료');
} catch (error) {
    console.error('오류:', error.message);
}
```

## 참고

### 비트 연산자 우선순위

| 연산자 | 우선순위 | 설명 |
|--------|----------|------|
| **~** | 1 | NOT (가장 높음) |
| **<<, >>, >>>** | 2 | 시프트 |
| **&** | 3 | AND |
| **^** | 4 | XOR |
| **\|** | 5 | OR (가장 낮음) |

### 비트 연산자 사용 권장사항

| 상황 | 권장사항 | 이유 |
|------|----------|------|
| **플래그 처리** | 비트 연산자 사용 | 메모리 효율성 |
| **성능 중요** | 시프트 연산 사용 | 빠른 연산 |
| **색상 처리** | 비트 조작 사용 | RGB 값 압축 |
| **암호화** | XOR 사용 | 간단한 암호화 |
| **일반 계산** | 일반 연산자 사용 | 가독성 |

### 결론
비트 연산자는 JavaScript에서 효율적인 비트 단위 처리를 위한 강력한 도구입니다.
플래그 처리와 권한 시스템에서 메모리 효율성을 제공합니다.
시프트 연산을 활용하여 빠른 곱셈/나눗셈을 수행할 수 있습니다.
32비트 정수 범위를 고려하여 안전하게 사용하세요.
비트 연산자를 활용하여 성능 최적화와 메모리 효율성을 달성하세요.










