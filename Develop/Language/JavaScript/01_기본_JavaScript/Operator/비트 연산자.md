## 비트 연산자 (Bitwise Operators)

비트 연산자는 숫자를 32비트 정수로 변환하여 비트 단위로 연산을 수행하는 연산자입니다. JavaScript에서는 다음과 같은 비트 연산자들을 제공합니다.

### 1. 비트 AND (&)
- 두 숫자의 각 비트를 비교하여 둘 다 1인 경우에만 1을 반환합니다.
- 0과 1을 비교하면 0이 반환됩니다.

```javascript
const a = 5;  // 0101 (2진수)
const b = 3;  // 0011 (2진수)
const result = a & b;  // 0001 (1)
// 0101
// 0011
// ----
// 0001 (결과)
```

### 2. 비트 OR (|)
- 두 숫자의 각 비트를 비교하여 하나라도 1이면 1을 반환합니다.
- 둘 다 0인 경우에만 0이 반환됩니다.

```javascript
const a = 5;  // 0101
const b = 3;  // 0011
const result = a | b;  // 0111 (7)
// 0101
// 0011
// ----
// 0111 (결과)
```

### 3. 비트 XOR (^)
- 두 숫자의 각 비트를 비교하여 서로 다른 경우에만 1을 반환합니다.
- 같은 값이면 0이 반환됩니다.

```javascript
const a = 5;  // 0101
const b = 3;  // 0011
const result = a ^ b;  // 0110 (6)
// 0101
// 0011
// ----
// 0110 (결과)
```

### 4. 비트 NOT (~)
- 모든 비트를 반전시킵니다 (0은 1로, 1은 0으로).
- 결과는 2의 보수 형태로 반환됩니다.

```javascript
const a = 5;  // 0101
const result = ~a;  // -6
// ~0101 = 1010 (2의 보수)
```

### 5. 왼쪽 시프트 (<<)
- 모든 비트를 왼쪽으로 지정된 수만큼 이동시킵니다.
- 오른쪽은 0으로 채워집니다.

```javascript
const a = 5;  // 0101
const result = a << 2;  // 10100 (20)
// 0101 -> 10100
```

### 6. 오른쪽 시프트 (>>)
- 모든 비트를 오른쪽으로 지정된 수만큼 이동시킵니다.
- 왼쪽은 부호 비트로 채워집니다 (음수는 1, 양수는 0).

```javascript
const a = 20;  // 10100
const result = a >> 2;  // 00101 (5)
// 10100 -> 00101
```

### 7. 부호 없는 오른쪽 시프트 (>>>)
- 모든 비트를 오른쪽으로 지정된 수만큼 이동시킵니다.
- 왼쪽은 항상 0으로 채워집니다.

```javascript
const a = -20;  // 11111111111111111111111111101100
const result = a >>> 2;  // 00111111111111111111111111111011
```

### 실제 사용 사례

1. **플래그 처리**
```javascript
const FLAG_A = 1;  // 0001
const FLAG_B = 2;  // 0010
const FLAG_C = 4;  // 0100

let flags = FLAG_A | FLAG_C;  // 0101
console.log(flags & FLAG_A);  // 1 (true)
console.log(flags & FLAG_B);  // 0 (false)
```

2. **짝수/홀수 판별**
```javascript
function isEven(num) {
    return (num & 1) === 0;
}
console.log(isEven(4));  // true
console.log(isEven(7));  // false
```

3. **2의 거듭제곱 계산**
```javascript
function powerOfTwo(n) {
    return 1 << n;
}
console.log(powerOfTwo(3));  // 8 (2^3)
```

### 주의사항
1. 비트 연산자는 32비트 정수로 변환하여 연산하므로, 큰 숫자나 소수점이 있는 숫자를 사용할 때는 주의해야 합니다.
2. 비트 연산은 일반적인 산술 연산보다 빠르지만, 코드의 가독성이 떨어질 수 있습니다.
3. Boolean 값에 비트 연산자를 사용할 때는 &&나 ||와 달리 항상 양쪽 피연산자를 모두 평가합니다.

### 요약
- 비트 연산자는 저수준 연산에 유용하며, 특히 플래그 처리나 최적화가 필요한 경우에 사용됩니다.
- 각 연산자는 특정 비트 패턴을 조작하는 데 사용되며, 상황에 맞는 적절한 연산자를 선택해야 합니다.
- 코드의 가독성과 유지보수성을 고려하여 사용해야 합니다.