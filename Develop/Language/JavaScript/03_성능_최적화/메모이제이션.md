# JavaScript 메모이제이션(Memoization)

메모이제이션은 컴퓨터 프로그래밍에서 동일한 계산을 반복해야 할 때, 이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 제거하여 프로그램 실행 속도를 빠르게 하는 기술입니다. 이는 동적 프로그래밍의 핵심 개념 중 하나이며, 특히 JavaScript와 같은 함수형 프로그래밍에서 매우 유용하게 사용됩니다.

## 1. 메모이제이션의 기본 개념

### 1.1 메모이제이션이란?
메모이제이션은 함수의 입력값에 대한 결과를 캐시에 저장하고, 동일한 입력값이 들어올 경우 캐시된 결과를 반환하는 최적화 기법입니다. 이는 다음과 같은 특징을 가집니다:

- **순수 함수(Pure Function)**: 동일한 입력에 대해 항상 동일한 출력을 반환하는 함수
- **참조 투명성(Referential Transparency)**: 함수의 결과가 입력값에만 의존
- **부수 효과(Side Effect) 없음**: 외부 상태를 변경하지 않음

### 1.2 메모이제이션이 필요한 이유

1. **성능 최적화**
   - 동일한 계산의 반복 수행 방지
   - 특히 재귀 함수나 복잡한 계산에서 큰 성능 향상
   - 시간 복잡도 개선 (예: 피보나치 수열 계산의 경우 O(2^n) → O(n))

2. **자원 효율성**
   - CPU 사용량 감소
   - 메모리와 계산 시간의 트레이드오프
   - 대규모 데이터 처리 시 효율성 증가

3. **사용자 경험**
   - 응답 시간 단축
   - 애플리케이션 성능 향상
   - 실시간 데이터 처리 개선

## 2. 기본적인 메모이제이션 구현

### 2.1 기본 메모이제이션 함수
```javascript
function memoize(fn) {
    const cache = new Map();
    
    return function (...args) {
        const key = JSON.stringify(args);
        
        if (cache.has(key)) {
            console.log('Cache hit!');
            return cache.get(key);
        }
        
        console.log('Cache miss!');
        const result = fn.apply(this, args);
        cache.set(key, result);
        return result;
    };
}
```

### 2.2 고급 메모이제이션 함수 (타입 안전성 추가)
```javascript
function memoizeWithTypeSafety(fn) {
    const cache = new Map();
    
    return function (...args) {
        // 객체 참조를 위한 안전한 키 생성
        const key = args.map(arg => {
            if (typeof arg === 'object' && arg !== null) {
                return JSON.stringify(arg);
            }
            return String(arg);
        }).join('|');
        
        if (cache.has(key)) {
            return cache.get(key);
        }
        
        const result = fn.apply(this, args);
        cache.set(key, result);
        return result;
    };
}
```

## 3. 실제 사용 예시

### 3.1 피보나치 수열 계산
```javascript
// 일반적인 피보나치 함수 (비효율적)
function fibonacci(n) {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}

// 메모이제이션을 적용한 피보나치 함수
const memoizedFibonacci = memoize(function(n) {
    if (n <= 1) return n;
    return memoizedFibonacci(n - 1) + memoizedFibonacci(n - 2);
});

// 성능 비교
console.time('일반 피보나치');
console.log(fibonacci(40)); // 매우 느림
console.timeEnd('일반 피보나치');

console.time('메모이제이션 피보나치');
console.log(memoizedFibonacci(40)); // 매우 빠름
console.timeEnd('메모이제이션 피보나치');
```

### 3.2 팩토리얼 계산
```javascript
// 일반적인 팩토리얼 함수
function factorial(n) {
    if (n <= 1) return 1;
    return n * factorial(n - 1);
}

// 메모이제이션을 적용한 팩토리얼 함수
const memoizedFactorial = memoize(function(n) {
    if (n <= 1) return 1;
    return n * memoizedFactorial(n - 1);
});

// 성능 비교
console.time('일반 팩토리얼');
console.log(factorial(20));
console.timeEnd('일반 팩토리얼');

console.time('메모이제이션 팩토리얼');
console.log(memoizedFactorial(20));
console.timeEnd('메모이제이션 팩토리얼');
```

### 3.3 복잡한 계산 예시 (행렬 곱셈)
```javascript
function matrixMultiply(a, b) {
    const result = [];
    for (let i = 0; i < a.length; i++) {
        result[i] = [];
        for (let j = 0; j < b[0].length; j++) {
            let sum = 0;
            for (let k = 0; k < a[0].length; k++) {
                sum += a[i][k] * b[k][j];
            }
            result[i][j] = sum;
        }
    }
    return result;
}

const memoizedMatrixMultiply = memoize(matrixMultiply);

// 사용 예시
const matrixA = [[1, 2], [3, 4]];
const matrixB = [[5, 6], [7, 8]];

console.time('일반 행렬 곱셈');
console.log(matrixMultiply(matrixA, matrixB));
console.timeEnd('일반 행렬 곱셈');

console.time('메모이제이션 행렬 곱셈');
console.log(memoizedMatrixMultiply(matrixA, matrixB));
console.timeEnd('메모이제이션 행렬 곱셈');
```

## 4. 고급 메모이제이션 기법

### 4.1 LRU(Least Recently Used) 캐시 구현
```javascript
class LRUCache {
    constructor(capacity) {
        this.cache = new Map();
        this.capacity = capacity;
    }

    get(key) {
        if (!this.cache.has(key)) return -1;
        
        const value = this.cache.get(key);
        this.cache.delete(key);
        this.cache.set(key, value);
        return value;
    }

    put(key, value) {
        if (this.cache.has(key)) {
            this.cache.delete(key);
        } else if (this.cache.size >= this.capacity) {
            this.cache.delete(this.cache.keys().next().value);
        }
        this.cache.set(key, value);
    }
}

// LRU 캐시를 사용한 메모이제이션
function memoizeWithLRU(fn, capacity = 100) {
    const cache = new LRUCache(capacity);
    
    return function (...args) {
        const key = JSON.stringify(args);
        const cached = cache.get(key);
        
        if (cached !== -1) {
            return cached;
        }
        
        const result = fn.apply(this, args);
        cache.put(key, result);
        return result;
    };
}
```

### 4.2 WeakMap을 사용한 메모이제이션
```javascript
function memoizeWithWeakMap(fn) {
    const cache = new WeakMap();
    
    return function(obj) {
        if (!cache.has(obj)) {
            cache.set(obj, fn(obj));
        }
        return cache.get(obj);
    };
}

// 사용 예시
const expensiveOperation = memoizeWithWeakMap(function(obj) {
    // 객체에 대한 복잡한 연산
    return Object.keys(obj).reduce((acc, key) => acc + obj[key], '');
});
```

### 4.3 메모이제이션 데코레이터 (TypeScript)
```typescript
function Memoize() {
    return function (
        target: any,
        propertyKey: string,
        descriptor: PropertyDescriptor
    ) {
        const originalMethod = descriptor.value;
        const cache = new Map();

        descriptor.value = function (...args: any[]) {
            const key = JSON.stringify(args);
            
            if (cache.has(key)) {
                return cache.get(key);
            }
            
            const result = originalMethod.apply(this, args);
            cache.set(key, result);
            return result;
        };

        return descriptor;
    };
}

// 사용 예시
class Calculator {
    @Memoize()
    fibonacci(n: number): number {
        if (n <= 1) return n;
        return this.fibonacci(n - 1) + this.fibonacci(n - 2);
    }
}
```

## 5. 메모이제이션의 장단점

### 5.1 장점

1. **성능 향상**
   - 동일한 입력에 대한 계산 결과 재사용
   - 특히 복잡한 계산에서 큰 성능 향상
   - 재귀 함수의 실행 시간 단축

2. **코드 최적화**
   - 불필요한 계산 제거
   - 자원 사용 효율성 증가
   - 코드 가독성 향상

3. **확장성**
   - 대규모 데이터 처리 가능
   - 실시간 애플리케이션에 적합
   - 분산 시스템에서의 효율성

### 5.2 단점

1. **메모리 사용량**
   - 캐시된 결과를 저장하기 위한 추가 메모리 필요
   - 입력값이 많을 경우 메모리 부족 가능성
   - 메모리 누수 위험

2. **적용 제한**
   - 순수 함수에만 적용 가능
   - 부수 효과가 있는 함수에는 부적합
   - 비동기 함수 처리의 복잡성

3. **디버깅 어려움**
   - 캐시된 결과로 인한 예상치 못한 동작
   - 메모리 사용량 모니터링 필요
   - 테스트 복잡성 증가

## 6. 실제 사용 시 주의사항

### 6.1 메모리 관리
```javascript
// 캐시 크기 제한이 있는 메모이제이션
function memoizeWithLimit(fn, limit = 1000) {
    const cache = new Map();
    const keys = new Set();
    
    return function (...args) {
        const key = JSON.stringify(args);
        
        if (cache.has(key)) {
            return cache.get(key);
        }
        
        if (keys.size >= limit) {
            const firstKey = keys.values().next().value;
            keys.delete(firstKey);
            cache.delete(firstKey);
        }
        
        const result = fn.apply(this, args);
        cache.set(key, result);
        keys.add(key);
        return result;
    };
}
```

### 6.2 캐시 무효화
```javascript
function memoizeWithInvalidation(fn, ttl = 60000) {
    const cache = new Map();
    
    return function (...args) {
        const key = JSON.stringify(args);
        const now = Date.now();
        
        if (cache.has(key)) {
            const { value, timestamp } = cache.get(key);
            if (now - timestamp < ttl) {
                return value;
            }
            cache.delete(key);
        }
        
        const result = fn.apply(this, args);
        cache.set(key, { value: result, timestamp: now });
        return result;
    };
}
```

## 7. 테스트와 디버깅

### 7.1 성능 테스트
```javascript
function benchmark(fn, ...args) {
    console.time('Execution time');
    const result = fn(...args);
    console.timeEnd('Execution time');
    return result;
}

// 사용 예시
const result = benchmark(memoizedFibonacci, 40);
```

### 7.2 메모리 사용량 모니터링
```javascript
function monitorMemoryUsage() {
    const used = process.memoryUsage();
    console.log(`Memory usage: ${Math.round(used.heapUsed / 1024 / 1024)}MB`);
}

// 사용 예시
monitorMemoryUsage();
```

## 8. 결론

메모이제이션은 JavaScript에서 성능 최적화를 위한 강력한 도구입니다. 하지만 모든 상황에 적용하는 것이 아니라, 적절한 상황에서 신중하게 사용해야 합니다. 특히 다음과 같은 경우에 메모이제이션을 고려해볼 수 있습니다:

1. 복잡한 계산이 반복되는 경우
2. 재귀 함수의 성능이 중요한 경우
3. 대규모 데이터 처리가 필요한 경우
4. 실시간 응답이 필요한 경우

메모이제이션을 사용할 때는 항상 메모리 사용량과 성능 향상 사이의 균형을 고려해야 하며, 적절한 테스트와 모니터링을 통해 효과를 검증해야 합니다.
