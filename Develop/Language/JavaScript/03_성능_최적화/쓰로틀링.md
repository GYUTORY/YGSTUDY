# JavaScript 쓰로틀링(Throttling) 완벽 가이드

## 목차
1. [쓰로틀링이란?](#쓰로틀링이란)
2. [쓰로틀링 vs 디바운싱](#쓰로틀링-vs-디바운싱)
3. [쓰로틀링 구현 방법](#쓰로틀링-구현-방법)
4. [실제 사용 사례](#실제-사용-사례)
5. [성능 최적화 팁](#성능-최적화-팁)

## 쓰로틀링이란?

쓰로틀링은 특정 시간 동안 함수의 실행 횟수를 제한하는 기술입니다. 예를 들어, 1초에 한 번만 함수가 실행되도록 제한하는 것이 쓰로틀링의 대표적인 예입니다.

### 기본 개념
```javascript
// 기본적인 쓰로틀링 예시
function throttle(func, limit) {
    let inThrottle;
    return function(...args) {
        if (!inThrottle) {
            func.apply(this, args);
            inThrottle = true;
            setTimeout(() => inThrottle = false, limit);
        }
    }
}
```

## 쓰로틀링 vs 디바운싱

쓰로틀링과 디바운싱은 비슷해 보이지만 중요한 차이점이 있습니다:

- **쓰로틀링**: 일정 시간 동안 함수의 실행을 한 번만 허용
- **디바운싱**: 연속된 이벤트 발생 후 일정 시간이 지나면 함수 실행

### 비교 예시
```javascript
// 쓰로틀링 예시
const throttledScroll = throttle(() => {
    console.log('스크롤 이벤트 발생!');
}, 1000);

window.addEventListener('scroll', throttledScroll);

// 디바운싱 예시
const debouncedSearch = debounce(() => {
    console.log('검색 실행!');
}, 1000);

searchInput.addEventListener('input', debouncedSearch);
```

## 쓰로틀링 구현 방법

### 1. 기본 구현
```javascript
function throttle(func, limit) {
    let inThrottle;
    return function(...args) {
        if (!inThrottle) {
            func.apply(this, args);
            inThrottle = true;
            setTimeout(() => inThrottle = false, limit);
        }
    }
}
```

### 2. 타임스탬프 기반 구현
```javascript
function throttleWithTimestamp(func, limit) {
    let lastCall = 0;
    return function(...args) {
        const now = Date.now();
        if (now - lastCall >= limit) {
            func.apply(this, args);
            lastCall = now;
        }
    }
}
```

### 3. 최적화된 구현 (마지막 호출 보장)
```javascript
function throttleWithTrailing(func, limit) {
    let lastCall = 0;
    let timeoutId = null;
    
    return function(...args) {
        const now = Date.now();
        
        if (now - lastCall >= limit) {
            if (timeoutId) {
                clearTimeout(timeoutId);
                timeoutId = null;
            }
            func.apply(this, args);
            lastCall = now;
        } else if (!timeoutId) {
            timeoutId = setTimeout(() => {
                func.apply(this, args);
                lastCall = Date.now();
                timeoutId = null;
            }, limit - (now - lastCall));
        }
    }
}
```

## 실제 사용 사례

### 1. 스크롤 이벤트 처리
```javascript
// 무한 스크롤 구현
const loadMoreContent = throttle(() => {
    const scrollHeight = document.documentElement.scrollHeight;
    const scrollTop = window.scrollY;
    const clientHeight = document.documentElement.clientHeight;
    
    if (scrollTop + clientHeight >= scrollHeight - 100) {
        // 추가 콘텐츠 로드
        fetchMoreContent();
    }
}, 1000);

window.addEventListener('scroll', loadMoreContent);
```

### 2. 리사이즈 이벤트 처리
```javascript
// 반응형 레이아웃 조정
const handleResize = throttle(() => {
    const width = window.innerWidth;
    if (width < 768) {
        adjustMobileLayout();
    } else {
        adjustDesktopLayout();
    }
}, 250);

window.addEventListener('resize', handleResize);
```

### 3. 게임 컨트롤러 입력 처리
```javascript
class GameController {
    constructor() {
        this.movePlayer = throttle(this.movePlayer.bind(this), 16); // 약 60fps
    }
    
    movePlayer(direction) {
        // 플레이어 이동 로직
        this.player.x += direction.x;
        this.player.y += direction.y;
        this.updateGameState();
    }
    
    handleInput(event) {
        const direction = this.getDirectionFromInput(event);
        this.movePlayer(direction);
    }
}
```

### 4. API 요청 제한
```javascript
class APIClient {
    constructor() {
        this.request = throttle(this.makeRequest.bind(this), 1000);
    }
    
    async makeRequest(endpoint, data) {
        try {
            const response = await fetch(endpoint, {
                method: 'POST',
                body: JSON.stringify(data)
            });
            return await response.json();
        } catch (error) {
            console.error('API 요청 실패:', error);
        }
    }
}
```

## 성능 최적화 팁

### 1. 적절한 시간 간격 선택
```javascript
// 모바일 디바이스에서는 더 긴 간격 사용
const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
const throttleTime = isMobile ? 1000 : 500;

const optimizedHandler = throttle(() => {
    // 이벤트 처리 로직
}, throttleTime);
```

### 2. 메모리 누수 방지
```javascript
class ThrottledComponent {
    constructor() {
        this.handler = throttle(this.handleEvent.bind(this), 1000);
        this.setupEventListeners();
    }
    
    setupEventListeners() {
        window.addEventListener('scroll', this.handler);
    }
    
    cleanup() {
        window.removeEventListener('scroll', this.handler);
    }
}
```

### 3. 디바운싱과 조합
```javascript
function createOptimizedHandler() {
    const throttledHandler = throttle(() => {
        // 빈번한 업데이트가 필요한 작업
        updateUI();
    }, 16);
    
    const debouncedHandler = debounce(() => {
        // 최종 상태 저장
        saveState();
    }, 1000);
    
    return function(event) {
        throttledHandler(event);
        debouncedHandler(event);
    }
}
```

## 결론

쓰로틀링은 웹 애플리케이션의 성능을 최적화하는 강력한 도구입니다. 적절한 시간 간격을 선택하고, 사용 사례에 맞게 구현하면 사용자 경험을 크게 향상시킬 수 있습니다. 특히 스크롤, 리사이즈, 입력 처리와 같은 빈번한 이벤트를 다룰 때 매우 유용합니다.

### 추가 학습 자료
- [MDN Web Docs - Event Throttling](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener)
- [JavaScript.info - Throttling and Debouncing](https://javascript.info/throttling-debouncing)
- [Lodash Documentation - throttle](https://lodash.com/docs/#throttle)
