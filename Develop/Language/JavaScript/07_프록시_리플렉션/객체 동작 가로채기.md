---
title: JavaScript Proxy (객체 동작 가로채기)
tags: [language, javascript, proxy, reflection, 객체-동작-가로채기]
updated: 2024-12-19
---

# JavaScript Proxy (객체 동작 가로채기)

## 배경

JavaScript Proxy는 객체의 기본 동작을 가로채서 사용자가 원하는 대로 수정할 수 있게 해주는 기능입니다. 

가로채기란 마치 우체부가 편지를 전달하기 전에 내용을 확인하고 수정할 수 있는 것처럼, Proxy는 객체에 접근하기 전에 그 동작을 확인하고 변경할 수 있습니다.

### Proxy의 기본 구조
```javascript
const proxy = new Proxy(target, handler);
```

- **target**: 프록시로 감쌀 원본 객체
- **handler**: 동작을 가로채는 규칙들이 담긴 객체

### Proxy의 주요 용도
- 속성 접근 제어 및 검증
- 로깅 및 디버깅
- 기본값 제공
- 데이터 변환
- 보안 강화

## 핵심

### Proxy 기본 사용법

```javascript
// 1. 원본 객체
const originalUser = {
    name: '김철수',
    age: 25
};

// 2. 가로채기 규칙 (handler)
const handler = {
    // 속성에 접근할 때 실행되는 함수
    get: function(target, propertyName) {
        console.log(`${propertyName} 속성에 접근했습니다!`);
        return target[propertyName];
    },
    
    // 속성 값을 설정할 때 실행되는 함수
    set: function(target, propertyName, newValue) {
        console.log(`${propertyName} 속성을 ${newValue}로 변경합니다!`);
        target[propertyName] = newValue;
        return true; // 성공적으로 설정됨을 알림
    }
};

// 3. Proxy 객체 생성
const userProxy = new Proxy(originalUser, handler);

// 4. 사용해보기
console.log(userProxy.name); 
// 출력: "name 속성에 접근했습니다!"
// 출력: "김철수"

userProxy.age = 30;
// 출력: "age 속성을 30으로 변경합니다!"
```

### 주요 트랩(Trap) 메서드들

#### 1. get() - 속성 접근 가로채기

속성에 접근할 때 (`obj.property`, `obj['property']`) 실행됩니다.

```javascript
const handler = {
    get: function(target, propertyName, receiver) {
        // target: 원본 객체
        // propertyName: 접근하려는 속성 이름
        // receiver: Proxy 객체 자체
        
        console.log(`${propertyName} 속성을 찾고 있습니다...`);
        
        // 속성이 존재하는지 확인
        if (propertyName in target) {
            return target[propertyName];
        } else {
            return `${propertyName} 속성은 존재하지 않습니다.`;
        }
    }
};

const user = new Proxy({
    name: '김철수',
    age: 25
}, handler);

console.log(user.name);     // "김철수"
console.log(user.email);    // "email 속성은 존재하지 않습니다."
```

#### 2. set() - 속성 설정 가로채기

속성 값을 설정할 때 (`obj.property = value`) 실행됩니다.

```javascript
const handler = {
    set: function(target, propertyName, newValue) {
        console.log(`${propertyName} 속성을 ${newValue}로 설정하려고 합니다.`);
        
        // 나이에 대한 유효성 검사
        if (propertyName === 'age') {
            if (typeof newValue !== 'number') {
                throw new Error('나이는 숫자여야 합니다!');
            }
            if (newValue < 0 || newValue > 150) {
                throw new Error('나이는 0~150 사이여야 합니다!');
            }
        }
        
        // 이름에 대한 유효성 검사
        if (propertyName === 'name') {
            if (typeof newValue !== 'string') {
                throw new Error('이름은 문자열이어야 합니다!');
            }
            if (newValue.length < 2) {
                throw new Error('이름은 2글자 이상이어야 합니다!');
            }
        }
        
        // 모든 검사를 통과하면 실제로 설정
        target[propertyName] = newValue;
        console.log(`${propertyName} 속성이 성공적으로 설정되었습니다.`);
        return true;
    }
};

const user = new Proxy({}, handler);

user.name = '김철수';  // 성공
user.age = 25;        // 성공

// user.age = '스물다섯';  // Error: 나이는 숫자여야 합니다!
// user.age = -5;         // Error: 나이는 0~150 사이여야 합니다!
// user.name = '김';      // Error: 이름은 2글자 이상이어야 합니다!
```

#### 3. has() - 속성 존재 확인 가로채기

`in` 연산자를 사용할 때 (`'property' in obj`) 실행됩니다.

```javascript
const handler = {
    has: function(target, propertyName) {
        // 언더스코어(_)로 시작하는 속성은 private으로 처리
        if (propertyName.startsWith('_')) {
            console.log(`${propertyName}은 private 속성입니다.`);
            return false; // 존재하지 않는 것처럼 처리
        }
        
        return propertyName in target;
    }
};

const user = new Proxy({
    name: '김철수',
    age: 25,
    _password: 'secret123',
    _email: 'test@example.com'
}, handler);

console.log('name' in user);      // true
console.log('age' in user);       // true
console.log('_password' in user); // false (private 속성)
console.log('_email' in user);    // false (private 속성)
```

#### 4. deleteProperty() - 속성 삭제 가로채기

`delete` 연산자를 사용할 때 (`delete obj.property`) 실행됩니다.

```javascript
const handler = {
    deleteProperty: function(target, propertyName) {
        console.log(`${propertyName} 속성을 삭제하려고 합니다.`);
        
        // 중요한 속성은 삭제 방지
        if (propertyName === 'id' || propertyName === 'name') {
            throw new Error(`${propertyName}은 삭제할 수 없는 중요 속성입니다!`);
        }
        
        // private 속성도 삭제 방지
        if (propertyName.startsWith('_')) {
            throw new Error('private 속성은 삭제할 수 없습니다!');
        }
        
        delete target[propertyName];
        console.log(`${propertyName} 속성이 삭제되었습니다.`);
        return true;
    }
};

const user = new Proxy({
    id: 1,
    name: '김철수',
    age: 25,
    _password: 'secret123'
}, handler);

delete user.age;        // 성공
// delete user.name;    // Error: name은 삭제할 수 없는 중요 속성입니다!
// delete user._password; // Error: private 속성은 삭제할 수 없습니다!
```

## 예시

### 1. 기본값 제공 Proxy

```javascript
const defaultHandler = {
    get: function(target, propertyName) {
        if (propertyName in target) {
            return target[propertyName];
        } else {
            // 기본값 반환
            const defaults = {
                name: 'Unknown',
                age: 0,
                email: 'no-email@example.com'
            };
            return defaults[propertyName] || '기본값 없음';
        }
    }
};

const user = new Proxy({}, defaultHandler);

console.log(user.name);   // "Unknown"
console.log(user.age);    // 0
console.log(user.email);  // "no-email@example.com"
console.log(user.phone);  // "기본값 없음"
```

### 2. 로깅 Proxy

```javascript
const loggingHandler = {
    get: function(target, propertyName) {
        console.log(`[GET] ${propertyName} 속성에 접근`);
        return target[propertyName];
    },
    
    set: function(target, propertyName, value) {
        console.log(`[SET] ${propertyName} = ${value}`);
        target[propertyName] = value;
        return true;
    },
    
    deleteProperty: function(target, propertyName) {
        console.log(`[DELETE] ${propertyName} 속성 삭제`);
        delete target[propertyName];
        return true;
    }
};

const config = new Proxy({
    apiUrl: 'https://api.example.com',
    timeout: 5000
}, loggingHandler);

config.apiUrl = 'https://new-api.example.com';
// [SET] apiUrl = https://new-api.example.com

console.log(config.timeout);
// [GET] timeout 속성에 접근
// 5000

delete config.timeout;
// [DELETE] timeout 속성 삭제
```

### 3. 유효성 검사 Proxy

```javascript
const validationHandler = {
    set: function(target, propertyName, value) {
        const validators = {
            email: (email) => {
                const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                return emailRegex.test(email);
            },
            age: (age) => {
                return typeof age === 'number' && age >= 0 && age <= 150;
            },
            phone: (phone) => {
                const phoneRegex = /^[0-9-+()\s]+$/;
                return phoneRegex.test(phone);
            }
        };
        
        if (validators[propertyName]) {
            if (!validators[propertyName](value)) {
                throw new Error(`${propertyName}의 값이 유효하지 않습니다: ${value}`);
            }
        }
        
        target[propertyName] = value;
        return true;
    }
};

const user = new Proxy({}, validationHandler);

user.email = 'valid@example.com';  // 성공
user.age = 25;                     // 성공
user.phone = '010-1234-5678';      // 성공

// user.email = 'invalid-email';   // Error: email의 값이 유효하지 않습니다
// user.age = -5;                  // Error: age의 값이 유효하지 않습니다
```

### 4. 읽기 전용 Proxy

```javascript
const readOnlyHandler = {
    set: function(target, propertyName, value) {
        throw new Error(`${propertyName} 속성은 읽기 전용입니다!`);
    },
    
    deleteProperty: function(target, propertyName) {
        throw new Error(`${propertyName} 속성은 삭제할 수 없습니다!`);
    }
};

const constants = new Proxy({
    PI: 3.14159,
    GRAVITY: 9.8,
    MAX_SIZE: 1000
}, readOnlyHandler);

console.log(constants.PI);  // 3.14159

// constants.PI = 3.14;     // Error: PI 속성은 읽기 전용입니다!
// delete constants.PI;     // Error: PI 속성은 삭제할 수 없습니다!
```

### 5. 배열 인덱스 검증 Proxy

```javascript
const arrayHandler = {
    set: function(target, propertyName, value) {
        // 배열 인덱스 검증
        const index = parseInt(propertyName);
        if (!isNaN(index)) {
            if (index < 0) {
                throw new Error('배열 인덱스는 0 이상이어야 합니다!');
            }
            if (index > target.length) {
                throw new Error('배열의 길이를 초과하는 인덱스입니다!');
            }
        }
        
        target[propertyName] = value;
        return true;
    }
};

const numbers = new Proxy([1, 2, 3], arrayHandler);

numbers[1] = 10;     // 성공
numbers[0] = 5;      // 성공

// numbers[-1] = 0;   // Error: 배열 인덱스는 0 이상이어야 합니다!
// numbers[10] = 100; // Error: 배열의 길이를 초과하는 인덱스입니다!
```

## 운영 팁

### Proxy 사용 시 주의사항

#### 1. 성능 고려사항
```javascript
// Proxy는 일반 객체보다 성능이 느림
const normalObject = { name: 'test' };
const proxyObject = new Proxy({ name: 'test' }, {});

// 대량의 속성 접근 시 성능 차이 발생
for (let i = 0; i < 1000000; i++) {
    normalObject.name;  // 빠름
    proxyObject.name;   // 느림
}
```

#### 2. 무한 루프 방지
```javascript
const handler = {
    get: function(target, propertyName) {
        // 무한 루프 방지: target[propertyName] 대신 Reflect 사용
        return Reflect.get(target, propertyName);
    }
};
```

#### 3. 메서드 호출 가로채기
```javascript
const methodHandler = {
    get: function(target, propertyName) {
        const value = target[propertyName];
        
        // 함수인 경우에만 가로채기
        if (typeof value === 'function') {
            return function(...args) {
                console.log(`${propertyName} 메서드가 호출되었습니다.`);
                return value.apply(target, args);
            };
        }
        
        return value;
    }
};

const calculator = new Proxy({
    add: (a, b) => a + b,
    multiply: (a, b) => a * b
}, methodHandler);

calculator.add(5, 3);      // "add 메서드가 호출되었습니다." 출력 후 8 반환
calculator.multiply(4, 2); // "multiply 메서드가 호출되었습니다." 출력 후 8 반환
```

### Proxy와 Reflect 함께 사용하기

```javascript
const handler = {
    get: function(target, propertyName, receiver) {
        console.log(`${propertyName} 속성에 접근`);
        return Reflect.get(target, propertyName, receiver);
    },
    
    set: function(target, propertyName, value, receiver) {
        console.log(`${propertyName} 속성을 ${value}로 설정`);
        return Reflect.set(target, propertyName, value, receiver);
    }
};
```

## 참고

### Proxy의 모든 트랩 메서드

| 트랩 | 설명 | 트리거 |
|------|------|--------|
| `get` | 속성 읽기 | `obj.prop`, `obj['prop']` |
| `set` | 속성 쓰기 | `obj.prop = value` |
| `has` | 속성 존재 확인 | `'prop' in obj` |
| `deleteProperty` | 속성 삭제 | `delete obj.prop` |
| `ownKeys` | 속성 열거 | `Object.keys()`, `for...in` |
| `getOwnPropertyDescriptor` | 속성 설명자 | `Object.getOwnPropertyDescriptor()` |
| `defineProperty` | 속성 정의 | `Object.defineProperty()` |
| `preventExtensions` | 확장 방지 | `Object.preventExtensions()` |
| `isExtensible` | 확장 가능 여부 | `Object.isExtensible()` |
| `getPrototypeOf` | 프로토타입 가져오기 | `Object.getPrototypeOf()` |
| `setPrototypeOf` | 프로토타입 설정 | `Object.setPrototypeOf()` |
| `apply` | 함수 호출 | `func()`, `func.call()`, `func.apply()` |
| `construct` | 생성자 호출 | `new func()` |

### Proxy 사용 사례

#### 1. 데이터 바인딩
```javascript
// Vue.js의 반응형 시스템과 유사한 구현
function createReactive(obj) {
    const handler = {
        set: function(target, propertyName, value) {
            target[propertyName] = value;
            console.log(`UI 업데이트: ${propertyName} = ${value}`);
            return true;
        }
    };
    
    return new Proxy(obj, handler);
}

const data = createReactive({ count: 0 });
data.count = 1; // "UI 업데이트: count = 1" 출력
```

#### 2. API 래핑
```javascript
// API 호출을 가로채서 캐싱 추가
function createCachedAPI(api) {
    const cache = new Map();
    
    const handler = {
        get: function(target, propertyName) {
            return function(...args) {
                const key = `${propertyName}:${JSON.stringify(args)}`;
                
                if (cache.has(key)) {
                    console.log('캐시에서 반환');
                    return cache.get(key);
                }
                
                const result = target[propertyName].apply(target, args);
                cache.set(key, result);
                console.log('API 호출 후 캐시에 저장');
                return result;
            };
        }
    };
    
    return new Proxy(api, handler);
}
```

### 결론
JavaScript Proxy는 객체의 동작을 가로채서 다양한 기능을 추가할 수 있는 강력한 기능입니다.
유효성 검사, 로깅, 캐싱, 보안 강화 등 다양한 용도로 활용할 수 있으며,
적절히 사용하면 코드의 유지보수성과 안정성을 크게 향상시킬 수 있습니다.
다만 성능에 민감한 부분에서는 주의해서 사용해야 합니다.










## 🎯 Proxy가 필요한 이유

일반적인 객체 조작에서는 다음과 같은 제한이 있습니다:

```javascript
const user = {
    name: '김철수',
    age: 25
};

// 나이를 음수로 설정해도 아무런 제한이 없음
user.age = -10; // 문제가 있어도 막을 수 없음

// 존재하지 않는 속성에 접근해도 undefined만 반환
console.log(user.email); // undefined
```

Proxy를 사용하면 이런 상황들을 **미리 감지하고 처리**할 수 있습니다.

## 🔧 Proxy 기본 구조

