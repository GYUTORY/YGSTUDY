# JavaScript 객체 동작 가로채기 (Proxy)

## 1. Proxy란?

Proxy는 ES6에서 도입된 기능으로, 객체의 기본 동작을 가로채고 사용자 정의 동작을 추가할 수 있게 해주는 객체입니다. Proxy는 기본 객체의 동작을 대체하거나 수정할 수 있는 강력한 메타프로그래밍 기능을 제공합니다.

## 2. Proxy 생성 방법

Proxy는 `new Proxy(target, handler)` 형태로 생성됩니다:
- `target`: 프록시로 감싸질 대상 객체
- `handler`: 동작을 가로채는 메서드들이 있는 객체

```javascript
const target = {
    name: 'John',
    age: 30
};

const handler = {
    get: function(target, prop) {
        console.log(`속성 ${prop}에 접근했습니다.`);
        return target[prop];
    }
};

const proxy = new Proxy(target, handler);
console.log(proxy.name); // "속성 name에 접근했습니다." 출력 후 "John" 반환
```

## 3. 핸들러 메서드들

### 3.1 get(target, property, receiver)
객체의 속성에 접근할 때 호출됩니다.

```javascript
const handler = {
    get: function(target, prop, receiver) {
        if (prop in target) {
            return target[prop];
        }
        return `속성 ${prop}이(가) 존재하지 않습니다.`;
    }
};

const proxy = new Proxy({}, handler);
console.log(proxy.name); // "속성 name이(가) 존재하지 않습니다."
```

### 3.2 set(target, property, value, receiver)
객체의 속성 값을 설정할 때 호출됩니다.

```javascript
const handler = {
    set: function(target, prop, value) {
        if (prop === 'age') {
            if (!Number.isInteger(value)) {
                throw new TypeError('나이는 정수여야 합니다.');
            }
            if (value < 0) {
                throw new RangeError('나이는 0보다 커야 합니다.');
            }
        }
        target[prop] = value;
        return true;
    }
};

const person = new Proxy({}, handler);
person.age = 25; // 정상 동작
// person.age = -1; // RangeError 발생
// person.age = '25'; // TypeError 발생
```

### 3.3 has(target, property)
`in` 연산자를 사용할 때 호출됩니다.

```javascript
const handler = {
    has: function(target, prop) {
        if (prop.startsWith('_')) {
            return false; // private 속성처럼 동작
        }
        return prop in target;
    }
};

const proxy = new Proxy({name: 'John', _secret: '123'}, handler);
console.log('name' in proxy); // true
console.log('_secret' in proxy); // false
```

### 3.4 deleteProperty(target, property)
`delete` 연산자를 사용할 때 호출됩니다.

```javascript
const handler = {
    deleteProperty: function(target, prop) {
        if (prop.startsWith('_')) {
            throw new Error('private 속성은 삭제할 수 없습니다.');
        }
        delete target[prop];
        return true;
    }
};

const proxy = new Proxy({name: 'John', _secret: '123'}, handler);
delete proxy.name; // 정상 동작
// delete proxy._secret; // Error 발생
```

### 3.5 apply(target, thisArg, argumentsList)
함수를 호출할 때 호출됩니다.

```javascript
function sum(a, b) {
    return a + b;
}

const handler = {
    apply: function(target, thisArg, argumentsList) {
        console.log('함수가 호출되었습니다.');
        console.log('인자:', argumentsList);
        return target.apply(thisArg, argumentsList);
    }
};

const proxy = new Proxy(sum, handler);
console.log(proxy(1, 2)); // "함수가 호출되었습니다." 출력 후 3 반환
```

### 3.6 construct(target, argumentsList, newTarget)
`new` 연산자를 사용할 때 호출됩니다.

```javascript
class Person {
    constructor(name) {
        this.name = name;
    }
}

const handler = {
    construct: function(target, args) {
        console.log('새로운 인스턴스가 생성되었습니다.');
        return new target(...args);
    }
};

const ProxyPerson = new Proxy(Person, handler);
const person = new ProxyPerson('John'); // "새로운 인스턴스가 생성되었습니다." 출력
```

## 4. 실제 사용 사례

### 4.1 유효성 검사

```javascript
const validator = {
    set: function(obj, prop, value) {
        if (prop === 'age') {
            if (!Number.isInteger(value)) {
                throw new TypeError('나이는 정수여야 합니다.');
            }
            if (value < 0 || value > 150) {
                throw new RangeError('나이는 0에서 150 사이여야 합니다.');
            }
        }
        if (prop === 'name') {
            if (typeof value !== 'string') {
                throw new TypeError('이름은 문자열이어야 합니다.');
            }
            if (value.length < 2) {
                throw new Error('이름은 최소 2자 이상이어야 합니다.');
            }
        }
        obj[prop] = value;
        return true;
    }
};

const person = new Proxy({}, validator);
person.name = 'John'; // 정상
person.age = 25; // 정상
// person.age = '25'; // TypeError
// person.age = 200; // RangeError
// person.name = 'J'; // Error
```

### 4.2 로깅

```javascript
const logger = {
    get: function(target, prop) {
        console.log(`속성 ${prop}에 접근했습니다.`);
        return target[prop];
    },
    set: function(target, prop, value) {
        console.log(`속성 ${prop}이(가) ${value}로 설정되었습니다.`);
        target[prop] = value;
        return true;
    }
};

const user = new Proxy({}, logger);
user.name = 'John'; // "속성 name이(가) John으로 설정되었습니다." 출력
console.log(user.name); // "속성 name에 접근했습니다." 출력 후 "John" 반환
```

### 4.3 캐싱

```javascript
function createCacheProxy(fn) {
    const cache = new Map();
    
    return new Proxy(fn, {
        apply: function(target, thisArg, args) {
            const key = JSON.stringify(args);
            
            if (cache.has(key)) {
                console.log('캐시된 결과를 반환합니다.');
                return cache.get(key);
            }
            
            const result = target.apply(thisArg, args);
            cache.set(key, result);
            console.log('새로운 결과를 계산하고 캐시합니다.');
            return result;
        }
    });
}

function expensiveOperation(n) {
    console.log('계산 중...');
    return n * n;
}

const cachedOperation = createCacheProxy(expensiveOperation);
console.log(cachedOperation(5)); // 계산 후 25 반환
console.log(cachedOperation(5)); // 캐시된 결과 25 반환
```

### 4.4 속성 접근 제한

```javascript
const privateHandler = {
    get: function(target, prop) {
        if (prop.startsWith('_')) {
            throw new Error('private 속성에 접근할 수 없습니다.');
        }
        return target[prop];
    },
    set: function(target, prop, value) {
        if (prop.startsWith('_')) {
            throw new Error('private 속성을 수정할 수 없습니다.');
        }
        target[prop] = value;
        return true;
    }
};

class User {
    constructor(name, password) {
        this.name = name;
        this._password = password;
    }
}

const user = new Proxy(new User('John', 'secret123'), privateHandler);
console.log(user.name); // "John"
// console.log(user._password); // Error
// user._password = 'newpass'; // Error
```

## 5. 주의사항

1. Proxy는 완벽한 투명성을 제공하지 않습니다. `Object.prototype.toString.call(proxy)`는 `[object Object]`를 반환합니다.

2. 일부 내장 객체나 메서드는 Proxy와 완벽하게 호환되지 않을 수 있습니다.

3. 성능 오버헤드가 있을 수 있으므로, 꼭 필요한 경우에만 사용해야 합니다.

## 6. 결론

Proxy는 JavaScript에서 강력한 메타프로그래밍 기능을 제공합니다. 유효성 검사, 로깅, 캐싱, 속성 접근 제한 등 다양한 용도로 활용할 수 있습니다. 하지만 성능과 호환성 측면에서 주의가 필요하며, 적절한 상황에서 신중하게 사용해야 합니다.
