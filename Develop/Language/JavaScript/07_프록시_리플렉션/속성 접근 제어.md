---
title: JavaScript 속성 접근 제어 (Property Access Control)
tags: [language, javascript, 07프록시리플렉션, 속성-접근-제어, property-access]
updated: 2025-08-10
---

# JavaScript 속성 접근 제어 (Property Access Control)

## 배경

JavaScript에서 객체의 속성에 대한 접근을 제어하는 방법들을 알아봅니다. 이를 통해 데이터를 보호하고, 유효성을 검사하며, 객체의 동작을 커스터마이즈할 수 있습니다.

### 속성 접근 제어의 필요성
- **데이터 보호**: 객체의 내부 상태를 외부로부터 보호
- **유효성 검사**: 속성 값 설정 시 데이터 검증
- **동작 커스터마이징**: 속성 접근 시 추가 로직 실행
- **캡슐화**: 객체의 내부 구현을 숨기고 인터페이스만 노출

### 접근 제어 방법의 종류
- **Object.defineProperty()**: 속성의 동작을 세밀하게 제어
- **Getter/Setter**: 속성 접근 시 자동으로 실행되는 함수
- **Proxy**: 객체의 모든 동작을 가로채어 제어
- **Symbol**: 고유한 속성 키를 생성하여 접근 제한

## 핵심

### Object.defineProperty()

`Object.defineProperty()`는 객체에 새로운 속성을 추가하거나 기존 속성을 수정할 때 사용하는 메서드입니다. 이 메서드를 통해 속성이 어떻게 동작할지 세밀하게 제어할 수 있습니다.

#### 기본 문법
```javascript
Object.defineProperty(객체, 속성명, 설정객체)
```

#### 속성 설정 옵션
```javascript
const config = {
    value: 42,           // 속성의 값
    writable: true,      // 값 변경 가능 여부
    enumerable: true,    // 열거 가능 여부 (for...in, Object.keys)
    configurable: true   // 속성 재정의 가능 여부
};
```

#### 읽기 전용 속성 예제
```javascript
const person = {};

// 읽기 전용 속성 정의
Object.defineProperty(person, 'name', {
    value: 'John',
    writable: false,      // 값 변경 불가
    enumerable: true,     // 열거 가능
    configurable: false   // 속성 재정의 불가
});

console.log(person.name); // 'John'
person.name = 'Jane';    // 변경 시도 (무시됨)
console.log(person.name); // 여전히 'John'

// 속성 정보 확인
console.log(Object.getOwnPropertyDescriptor(person, 'name'));
```

#### 숨겨진 속성 예제
```javascript
const config = {
    value: 42,
    writable: true,
    enumerable: false,    // 열거 불가능 (숨겨진 속성)
    configurable: true
};

const obj = {};
Object.defineProperty(obj, 'number', config);

// 일반적인 방법으로는 접근 가능
console.log(obj.number); // 42

// 열거 불가능하므로 for...in에서 제외됨
for (let key in obj) {
    console.log(key); // 아무것도 출력되지 않음
}

// Object.keys에서도 제외됨
console.log(Object.keys(obj)); // []

// Object.getOwnPropertyNames으로는 확인 가능
console.log(Object.getOwnPropertyNames(obj)); // ['number']
```

### Getter와 Setter

Getter와 Setter는 속성에 접근하거나 값을 설정할 때 자동으로 실행되는 함수입니다. 이를 통해 데이터 검증, 로깅, 계산된 값 등을 구현할 수 있습니다.

#### 기본 문법
```javascript
const 객체 = {
    _내부변수: 초기값,
    
    get 속성명() {
        return this._내부변수;
    },
    
    set 속성명(새값) {
        this._내부변수 = 새값;
    }
};
```

#### 계산된 속성 예제
```javascript
const rectangle = {
    _width: 0,
    _height: 0,
    
    get width() {
        return this._width;
    },
    
    set width(value) {
        if (value > 0) {
            this._width = value;
        } else {
            throw new Error('너비는 0보다 커야 합니다.');
        }
    },
    
    get height() {
        return this._height;
    },
    
    set height(value) {
        if (value > 0) {
            this._height = value;
        } else {
            throw new Error('높이는 0보다 커야 합니다.');
        }
    },
    
    get area() {
        return this._width * this._height;
    },
    
    get perimeter() {
        return 2 * (this._width + this._height);
    }
};

// 사용 예시
rectangle.width = 10;
rectangle.height = 5;

console.log(rectangle.area);      // 50
console.log(rectangle.perimeter); // 30

// 잘못된 값 설정 시 오류
try {
    rectangle.width = -5;
} catch (error) {
    console.error(error.message); // "너비는 0보다 커야 합니다."
}
```

## 예시

### 실용적인 속성 접근 제어 예제

#### 사용자 객체 클래스
```javascript
class User {
    constructor(name, email, age) {
        this._name = '';
        this._email = '';
        this._age = 0;
        this._createdAt = new Date();
        
        // 속성 설정
        this.name = name;
        this.email = email;
        this.age = age;
    }
    
    get name() {
        return this._name;
    }
    
    set name(value) {
        if (typeof value === 'string' && value.trim().length > 0) {
            this._name = value.trim();
        } else {
            throw new Error('이름은 비어있지 않은 문자열이어야 합니다.');
        }
    }
    
    get email() {
        return this._email;
    }
    
    set email(value) {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        if (emailRegex.test(value)) {
            this._email = value.toLowerCase();
        } else {
            throw new Error('유효한 이메일 주소를 입력해주세요.');
        }
    }
    
    get age() {
        return this._age;
    }
    
    set age(value) {
        const numAge = parseInt(value);
        if (numAge >= 0 && numAge <= 150) {
            this._age = numAge;
        } else {
            throw new Error('나이는 0에서 150 사이의 숫자여야 합니다.');
        }
    }
    
    get createdAt() {
        return new Date(this._createdAt);
    }
    
    get isAdult() {
        return this._age >= 18;
    }
    
    get displayName() {
        return `${this._name} (${this._age}세)`;
    }
    
    toJSON() {
        return {
            name: this._name,
            email: this._email,
            age: this._age,
            isAdult: this.isAdult,
            createdAt: this._createdAt.toISOString()
        };
    }
}

// 사용 예시
try {
    const user = new User('John Doe', 'john@example.com', 25);
    console.log(user.displayName); // "John Doe (25세)"
    console.log(user.isAdult);     // true
    
    // 잘못된 값 설정 시도
    user.email = 'invalid-email';
} catch (error) {
    console.error('오류:', error.message);
}
```

#### 은행 계좌 클래스
```javascript
class BankAccount {
    constructor(accountNumber, initialBalance = 0) {
        this._accountNumber = accountNumber;
        this._balance = 0;
        this._transactions = [];
        
        if (initialBalance > 0) {
            this.deposit(initialBalance);
        }
    }
    
    get accountNumber() {
        return this._accountNumber;
    }
    
    get balance() {
        return this._balance;
    }
    
    get transactions() {
        return [...this._transactions]; // 복사본 반환
    }
    
    get lastTransaction() {
        return this._transactions[this._transactions.length - 1];
    }
    
    deposit(amount) {
        if (amount <= 0) {
            throw new Error('입금 금액은 0보다 커야 합니다.');
        }
        
        this._balance += amount;
        this._addTransaction('deposit', amount);
        
        return this._balance;
    }
    
    withdraw(amount) {
        if (amount <= 0) {
            throw new Error('출금 금액은 0보다 커야 합니다.');
        }
        
        if (amount > this._balance) {
            throw new Error('잔액이 부족합니다.');
        }
        
        this._balance -= amount;
        this._addTransaction('withdraw', amount);
        
        return this._balance;
    }
    
    _addTransaction(type, amount) {
        const transaction = {
            id: Date.now(),
            type: type,
            amount: amount,
            balance: this._balance,
            timestamp: new Date()
        };
        
        this._transactions.push(transaction);
    }
    
    getTransactionHistory(limit = 10) {
        return this._transactions
            .slice(-limit)
            .reverse()
            .map(t => ({
                ...t,
                timestamp: t.timestamp.toISOString()
            }));
    }
}

// 사용 예시
const account = new BankAccount('1234567890', 1000);

console.log(account.balance); // 1000

account.deposit(500);
console.log(account.balance); // 1500

account.withdraw(200);
console.log(account.balance); // 1300

console.log(account.getTransactionHistory());
```

### 고급 속성 접근 제어 예제

#### 캐시된 속성
```javascript
class ExpensiveCalculator {
    constructor() {
        this._cache = new Map();
        this._calculationCount = 0;
    }
    
    get expensiveValue() {
        // 캐시된 값이 있으면 반환
        if (this._cache.has('expensiveValue')) {
            console.log('캐시된 값 사용');
            return this._cache.get('expensiveValue');
        }
        
        // 계산 수행
        console.log('복잡한 계산 수행 중...');
        this._calculationCount++;
        
        // 시뮬레이션된 복잡한 계산
        const result = this._performExpensiveCalculation();
        
        // 결과 캐시
        this._cache.set('expensiveValue', result);
        
        return result;
    }
    
    _performExpensiveCalculation() {
        // 실제로는 복잡한 계산이 여기에 들어감
        let result = 0;
        for (let i = 0; i < 1000000; i++) {
            result += Math.sqrt(i);
        }
        return result;
    }
    
    // 캐시 무효화
    invalidateCache() {
        this._cache.clear();
        console.log('캐시가 무효화되었습니다.');
    }
    
    get calculationCount() {
        return this._calculationCount;
    }
}

// 사용 예시
const calculator = new ExpensiveCalculator();

console.log(calculator.expensiveValue); // 계산 수행
console.log(calculator.expensiveValue); // 캐시된 값 사용
console.log(calculator.calculationCount); // 1
```

#### 로깅이 포함된 속성
```javascript
class LoggedObject {
    constructor() {
        this._data = {};
        this._accessLog = [];
    }
    
    _logAccess(property, action, value = null) {
        const logEntry = {
            timestamp: new Date(),
            property: property,
            action: action, // 'get' 또는 'set'
            value: value,
            stack: new Error().stack
        };
        
        this._accessLog.push(logEntry);
        console.log(`[${logEntry.timestamp.toISOString()}] ${action.toUpperCase()} ${property}: ${value}`);
    }
    
    get accessLog() {
        return [...this._accessLog];
    }
    
    // 동적으로 속성 생성
    createLoggedProperty(name, initialValue = null) {
        let value = initialValue;
        
        Object.defineProperty(this, name, {
            get() {
                this._logAccess(name, 'get', value);
                return value;
            },
            set(newValue) {
                this._logAccess(name, 'set', newValue);
                value = newValue;
            },
            enumerable: true,
            configurable: true
        });
    }
}

// 사용 예시
const loggedObj = new LoggedObject();

loggedObj.createLoggedProperty('username', 'john_doe');
loggedObj.createLoggedProperty('email', 'john@example.com');

console.log(loggedObj.username); // 접근 로그 출력
loggedObj.username = 'jane_doe'; // 설정 로그 출력

console.log(loggedObj.accessLog);
```

#### 유효성 검사가 포함된 속성 팩토리
```javascript
class PropertyValidator {
    static createValidatedProperty(validators = {}) {
        return function(target, propertyName) {
            let value = target[propertyName];
            
            Object.defineProperty(target, propertyName, {
                get() {
                    return value;
                },
                set(newValue) {
                    // 유효성 검사 실행
                    for (const [validatorName, validator] of Object.entries(validators)) {
                        if (!validator(newValue)) {
                            throw new Error(`${propertyName} 속성의 ${validatorName} 검증 실패`);
                        }
                    }
                    
                    value = newValue;
                },
                enumerable: true,
                configurable: true
            });
        };
    }
    
    // 미리 정의된 유효성 검사기들
    static validators = {
        required: (value) => value !== null && value !== undefined && value !== '',
        string: (value) => typeof value === 'string',
        number: (value) => typeof value === 'number' && !isNaN(value),
        positive: (value) => typeof value === 'number' && value > 0,
        email: (value) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value),
        minLength: (min) => (value) => typeof value === 'string' && value.length >= min,
        maxLength: (max) => (value) => typeof value === 'string' && value.length <= max,
        range: (min, max) => (value) => typeof value === 'number' && value >= min && value <= max
    };
}

// 사용 예시
class Product {
    constructor() {
        this._name = '';
        this._price = 0;
        this._description = '';
        
        // 유효성 검사가 포함된 속성 생성
        PropertyValidator.createValidatedProperty({
            required: PropertyValidator.validators.required,
            string: PropertyValidator.validators.string,
            minLength: PropertyValidator.validators.minLength(2)
        })(this, '_name');
        
        PropertyValidator.createValidatedProperty({
            required: PropertyValidator.validators.required,
            number: PropertyValidator.validators.number,
            positive: PropertyValidator.validators.positive
        })(this, '_price');
        
        PropertyValidator.createValidatedProperty({
            string: PropertyValidator.validators.string,
            maxLength: PropertyValidator.validators.maxLength(500)
        })(this, '_description');
    }
    
    get name() { return this._name; }
    set name(value) { this._name = value; }
    
    get price() { return this._price; }
    set price(value) { this._price = value; }
    
    get description() { return this._description; }
    set description(value) { this._description = value; }
}

// 사용 예시
const product = new Product();

try {
    product.name = 'Laptop'; // 성공
    product.price = 999.99;  // 성공
    product.description = 'High-performance laptop'; // 성공
    
    product.name = 'A'; // 오류: 최소 길이 검증 실패
} catch (error) {
    console.error(error.message);
}
```

## 운영 팁

### 성능 최적화

#### 속성 접근 최적화 기법
```javascript
// 1. 캐시를 활용한 성능 최적화
class OptimizedCalculator {
    constructor() {
        this._cache = new WeakMap();
        this._computedValues = new Map();
    }
    
    // 계산된 값을 캐시하는 getter
    get expensiveComputation() {
        if (!this._computedValues.has('expensiveComputation')) {
            const result = this._performExpensiveCalculation();
            this._computedValues.set('expensiveComputation', result);
        }
        return this._computedValues.get('expensiveComputation');
    }
    
    // 의존성이 있는 계산된 값
    get computedValue() {
        const dependencies = this._getDependencies();
        const cacheKey = JSON.stringify(dependencies);
        
        if (!this._computedValues.has(cacheKey)) {
            const result = this._computeValue(dependencies);
            this._computedValues.set(cacheKey, result);
        }
        
        return this._computedValues.get(cacheKey);
    }
    
    // 캐시 무효화
    invalidateCache() {
        this._computedValues.clear();
    }
    
    _performExpensiveCalculation() {
        // 복잡한 계산 시뮬레이션
        let result = 0;
        for (let i = 0; i < 100000; i++) {
            result += Math.sqrt(i);
        }
        return result;
    }
    
    _getDependencies() {
        return {
            timestamp: Date.now(),
            // 다른 의존성들...
        };
    }
    
    _computeValue(dependencies) {
        // 의존성을 기반으로 한 계산
        return Object.values(dependencies).reduce((sum, val) => sum + val, 0);
    }
}

// 2. 지연 초기화 (Lazy Initialization)
class LazyInitializedObject {
    constructor() {
        this._heavyResource = null;
        this._isInitialized = false;
    }
    
    get heavyResource() {
        if (!this._isInitialized) {
            console.log('무거운 리소스 초기화 중...');
            this._heavyResource = this._initializeHeavyResource();
            this._isInitialized = true;
        }
        return this._heavyResource;
    }
    
    _initializeHeavyResource() {
        // 실제로는 데이터베이스 연결, 파일 로드 등
        return {
            data: new Array(1000000).fill(0).map((_, i) => i),
            metadata: { initialized: new Date() }
        };
    }
}

// 3. 메모리 사용량 모니터링
class MemoryMonitor {
    constructor() {
        this._propertyAccessCount = new Map();
        this._startTime = Date.now();
    }
    
    createMonitoredProperty(target, propertyName) {
        let value = target[propertyName];
        
        Object.defineProperty(target, propertyName, {
            get() {
                const count = this._propertyAccessCount.get(propertyName) || 0;
                this._propertyAccessCount.set(propertyName, count + 1);
                
                // 메모리 사용량 체크
                if (count % 1000 === 0) {
                    this._checkMemoryUsage();
                }
                
                return value;
            },
            set(newValue) {
                value = newValue;
            },
            enumerable: true,
            configurable: true
        });
    }
    
    _checkMemoryUsage() {
        const memUsage = process.memoryUsage();
        const heapUsedMB = Math.round(memUsage.heapUsed / 1024 / 1024);
        
        if (heapUsedMB > 100) {
            console.warn(`높은 메모리 사용량: ${heapUsedMB}MB`);
        }
    }
    
    getAccessStats() {
        const stats = {};
        for (const [property, count] of this._propertyAccessCount) {
            stats[property] = {
                accessCount: count,
                accessRate: count / ((Date.now() - this._startTime) / 1000)
            };
        }
        return stats;
    }
}
```

### 디버깅 및 모니터링

#### 속성 접근 디버깅 도구
```javascript
// 1. 속성 접근 추적기
class PropertyTracker {
    constructor() {
        this._tracking = new Map();
        this._callStack = [];
    }
    
    trackProperty(target, propertyName) {
        let value = target[propertyName];
        
        Object.defineProperty(target, propertyName, {
            get() {
                this._logAccess(propertyName, 'get', value);
                return value;
            },
            set(newValue) {
                this._logAccess(propertyName, 'set', newValue);
                value = newValue;
            },
            enumerable: true,
            configurable: true
        });
    }
    
    _logAccess(propertyName, action, value) {
        const stack = new Error().stack;
        const caller = stack.split('\n')[2]?.trim() || 'unknown';
        
        const logEntry = {
            timestamp: new Date(),
            property: propertyName,
            action: action,
            value: value,
            caller: caller
        };
        
        if (!this._tracking.has(propertyName)) {
            this._tracking.set(propertyName, []);
        }
        
        this._tracking.get(propertyName).push(logEntry);
        
        console.log(`[${logEntry.timestamp.toISOString()}] ${action.toUpperCase()} ${propertyName} = ${value} (${caller})`);
    }
    
    getPropertyHistory(propertyName) {
        return this._tracking.get(propertyName) || [];
    }
    
    getAllHistory() {
        const history = {};
        for (const [property, entries] of this._tracking) {
            history[property] = entries;
        }
        return history;
    }
}

// 2. 성능 측정기
class PerformanceMonitor {
    constructor() {
        this._measurements = new Map();
    }
    
    measurePropertyAccess(target, propertyName) {
        let value = target[propertyName];
        
        Object.defineProperty(target, propertyName, {
            get() {
                const start = performance.now();
                const result = value;
                const duration = performance.now() - start;
                
                this._recordMeasurement(propertyName, 'get', duration);
                return result;
            },
            set(newValue) {
                const start = performance.now();
                value = newValue;
                const duration = performance.now() - start;
                
                this._recordMeasurement(propertyName, 'set', duration);
            },
            enumerable: true,
            configurable: true
        });
    }
    
    _recordMeasurement(propertyName, action, duration) {
        const key = `${propertyName}_${action}`;
        
        if (!this._measurements.has(key)) {
            this._measurements.set(key, {
                count: 0,
                totalTime: 0,
                minTime: Infinity,
                maxTime: 0,
                averageTime: 0
            });
        }
        
        const measurement = this._measurements.get(key);
        measurement.count++;
        measurement.totalTime += duration;
        measurement.minTime = Math.min(measurement.minTime, duration);
        measurement.maxTime = Math.max(measurement.maxTime, duration);
        measurement.averageTime = measurement.totalTime / measurement.count;
        
        // 느린 접근 경고
        if (duration > 1) { // 1ms 이상
            console.warn(`느린 속성 접근: ${propertyName}.${action} (${duration.toFixed(2)}ms)`);
        }
    }
    
    getPerformanceReport() {
        const report = {};
        for (const [key, measurement] of this._measurements) {
            report[key] = {
                ...measurement,
                totalTime: measurement.totalTime.toFixed(2) + 'ms',
                averageTime: measurement.averageTime.toFixed(2) + 'ms',
                minTime: measurement.minTime.toFixed(2) + 'ms',
                maxTime: measurement.maxTime.toFixed(2) + 'ms'
            };
        }
        return report;
    }
}

// 사용 예시
const tracker = new PropertyTracker();
const monitor = new PerformanceMonitor();

const obj = { _value: 42 };

tracker.trackProperty(obj, '_value');
monitor.measurePropertyAccess(obj, '_value');

// 속성 접근 테스트
obj._value = 100;
console.log(obj._value);

console.log('접근 기록:', tracker.getPropertyHistory('_value'));
console.log('성능 리포트:', monitor.getPerformanceReport());
```

## 참고

### 속성 설명자 (Property Descriptor)

#### 속성 설명자 상세 정보
```javascript
// 속성 설명자 가져오기
const obj = { name: 'John' };
const descriptor = Object.getOwnPropertyDescriptor(obj, 'name');

console.log(descriptor);
// {
//   value: 'John',
//   writable: true,
//   enumerable: true,
//   configurable: true
// }

// 모든 속성의 설명자 가져오기
const allDescriptors = Object.getOwnPropertyDescriptors(obj);
console.log(allDescriptors);

// 속성 설명자 설정
Object.defineProperties(obj, {
    age: {
        value: 30,
        writable: false,
        enumerable: true,
        configurable: false
    },
    email: {
        get() { return this._email; },
        set(value) { this._email = value; },
        enumerable: true,
        configurable: true
    }
});
```

### Symbol을 사용한 속성 접근 제어

#### Symbol을 활용한 private 속성
```javascript
// Symbol을 사용한 private 속성 구현
const _privateData = Symbol('privateData');
const _privateMethod = Symbol('privateMethod');

class PrivateObject {
    constructor() {
        this[_privateData] = {
            secret: 'This is private',
            counter: 0
        };
    }
    
    [_privateMethod]() {
        this[_privateData].counter++;
        return this[_privateData].secret;
    }
    
    get publicInfo() {
        return this[_privateMethod]();
    }
    
    // Symbol을 사용한 메타데이터
    get [Symbol.toStringTag]() {
        return 'PrivateObject';
    }
}

// 사용 예시
const privateObj = new PrivateObject();
console.log(privateObj.publicInfo); // "This is private"

// Symbol 속성은 일반적인 방법으로 접근할 수 없음
console.log(Object.getOwnPropertyNames(privateObj)); // ['publicInfo']
console.log(Object.getOwnPropertySymbols(privateObj)); // [Symbol(privateData), Symbol(privateMethod)]
```

### 결론
속성 접근 제어는 JavaScript에서 데이터 보호와 캡슐화를 구현하는 중요한 기법입니다.
Object.defineProperty()를 사용하여 속성의 동작을 세밀하게 제어할 수 있습니다.
Getter와 Setter를 통해 데이터 검증과 로깅을 구현할 수 있습니다.
성능 최적화와 디버깅을 위해 캐싱과 모니터링 기법을 활용해야 합니다.
Symbol을 사용하여 진정한 private 속성을 구현할 수 있습니다.

