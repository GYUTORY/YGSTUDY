# JavaScript 속성 접근 제어 (Property Access Control)

JavaScript에서 객체의 속성에 대한 접근을 제어하는 방법은 여러 가지가 있습니다. 이 글에서는 다양한 속성 접근 제어 방법과 그 사용 사례를 자세히 살펴보겠습니다.

## 1. Object.defineProperty()

`Object.defineProperty()`는 객체의 속성을 정의하거나 수정할 때 사용하는 기본적인 메서드입니다. 이 메서드를 통해 속성의 특성(descriptor)을 세밀하게 제어할 수 있습니다.

```javascript
const person = {};

Object.defineProperty(person, 'name', {
    value: 'John',
    writable: false,      // 값 변경 불가
    enumerable: true,     // 열거 가능
    configurable: false   // 속성 재정의 불가
});

console.log(person.name); // 'John'
person.name = 'Jane';    // 변경 시도
console.log(person.name); // 여전히 'John' (변경되지 않음)
```

### 1.1 속성 특성(Descriptor) 종류

1. **value**: 속성의 값
2. **writable**: 값 변경 가능 여부 (boolean)
3. **enumerable**: 열거 가능 여부 (boolean)
4. **configurable**: 속성 재정의 가능 여부 (boolean)

```javascript
const config = {
    value: 42,
    writable: true,
    enumerable: true,
    configurable: true
};

const obj = {};
Object.defineProperty(obj, 'number', config);

// 속성 확인
console.log(Object.getOwnPropertyDescriptor(obj, 'number'));
// {
//     value: 42,
//     writable: true,
//     enumerable: true,
//     configurable: true
// }
```

## 2. Getter와 Setter

Getter와 Setter를 사용하면 속성에 접근하거나 값을 설정할 때 커스텀 로직을 실행할 수 있습니다.

```javascript
const user = {
    _name: '',
    _age: 0,

    get name() {
        return this._name;
    },

    set name(value) {
        if (typeof value !== 'string') {
            throw new Error('이름은 문자열이어야 합니다.');
        }
        this._name = value;
    },

    get age() {
        return this._age;
    },

    set age(value) {
        if (value < 0 || value > 150) {
            throw new Error('유효하지 않은 나이입니다.');
        }
        this._age = value;
    }
};

// 사용 예시
user.name = 'John';
user.age = 25;

console.log(user.name); // 'John'
console.log(user.age);  // 25

try {
    user.age = 200; // Error: 유효하지 않은 나이입니다.
} catch (error) {
    console.error(error.message);
}
```

## 3. Object.defineProperties()

여러 속성을 한 번에 정의할 때 사용하는 메서드입니다.

```javascript
const bankAccount = {};

Object.defineProperties(bankAccount, {
    balance: {
        value: 0,
        writable: true,
        enumerable: true
    },
    accountNumber: {
        value: '123-456-789',
        writable: false,
        enumerable: true
    },
    _pin: {
        value: '1234',
        writable: true,
        enumerable: false
    }
});

// 사용 예시
bankAccount.balance = 1000;
console.log(bankAccount.balance);     // 1000
console.log(bankAccount.accountNumber); // '123-456-789'
console.log(bankAccount._pin);        // '1234'

// 열거 가능한 속성만 출력
console.log(Object.keys(bankAccount)); // ['balance', 'accountNumber']
```

## 4. Object.freeze()와 Object.seal()

### 4.1 Object.freeze()
객체를 완전히 불변하게 만듭니다.

```javascript
const settings = {
    theme: 'dark',
    language: 'ko',
    notifications: true
};

Object.freeze(settings);

// 변경 시도
settings.theme = 'light';        // 무시됨
settings.newProperty = 'value';  // 무시됨
delete settings.language;        // 무시됨

console.log(settings); // 원래 상태 유지
```

### 4.2 Object.seal()
객체의 속성 추가/삭제를 방지하지만, 기존 속성의 값은 변경 가능합니다.

```javascript
const config = {
    apiKey: 'abc123',
    endpoint: 'https://api.example.com'
};

Object.seal(config);

// 변경 시도
config.apiKey = 'xyz789';        // 가능
config.newProperty = 'value';    // 무시됨
delete config.endpoint;          // 무시됨

console.log(config); // { apiKey: 'xyz789', endpoint: 'https://api.example.com' }
```

## 5. Proxy 객체

Proxy는 객체의 기본 동작을 가로채고 커스터마이즈할 수 있는 강력한 기능을 제공합니다.

```javascript
const handler = {
    get(target, prop) {
        if (prop in target) {
            return target[prop];
        }
        return `속성 "${prop}"이(가) 존재하지 않습니다.`;
    },
    set(target, prop, value) {
        if (prop === 'age') {
            if (value < 0 || value > 150) {
                throw new Error('유효하지 않은 나이입니다.');
            }
        }
        target[prop] = value;
        return true;
    },
    deleteProperty(target, prop) {
        if (prop === 'id') {
            throw new Error('ID는 삭제할 수 없습니다.');
        }
        delete target[prop];
        return true;
    }
};

const person = new Proxy({}, handler);

// 사용 예시
person.name = 'John';
person.age = 25;

console.log(person.name);    // 'John'
console.log(person.age);     // 25
console.log(person.unknown); // '속성 "unknown"이(가) 존재하지 않습니다.'

try {
    person.age = 200; // Error: 유효하지 않은 나이입니다.
} catch (error) {
    console.error(error.message);
}

delete person.name; // 성공
try {
    delete person.id; // Error: ID는 삭제할 수 없습니다.
} catch (error) {
    console.error(error.message);
}
```

## 6. 실제 사용 사례

### 6.1 데이터 검증

```javascript
class User {
    constructor() {
        return new Proxy(this, {
            set(target, prop, value) {
                switch (prop) {
                    case 'email':
                        if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value)) {
                            throw new Error('유효하지 않은 이메일 형식입니다.');
                        }
                        break;
                    case 'password':
                        if (value.length < 8) {
                            throw new Error('비밀번호는 최소 8자 이상이어야 합니다.');
                        }
                        break;
                }
                target[prop] = value;
                return true;
            }
        });
    }
}

const user = new User();

try {
    user.email = 'invalid-email';
} catch (error) {
    console.error(error.message); // '유효하지 않은 이메일 형식입니다.'
}

try {
    user.password = '123';
} catch (error) {
    console.error(error.message); // '비밀번호는 최소 8자 이상이어야 합니다.'
}
```

### 6.2 로깅과 디버깅

```javascript
const createLoggingProxy = (target) => {
    return new Proxy(target, {
        get(target, prop) {
            console.log(`속성 "${prop}"에 접근`);
            return target[prop];
        },
        set(target, prop, value) {
            console.log(`속성 "${prop}"을(를) "${value}"로 설정`);
            target[prop] = value;
            return true;
        }
    });
};

const data = createLoggingProxy({
    name: 'John',
    age: 30
});

console.log(data.name); // '속성 "name"에 접근' 출력 후 'John' 반환
data.age = 31;         // '속성 "age"을(를) "31"로 설정' 출력
```

### 6.3 캐싱

```javascript
const createCachingProxy = (target) => {
    const cache = new Map();
    
    return new Proxy(target, {
        get(target, prop) {
            if (cache.has(prop)) {
                console.log(`캐시에서 "${prop}" 반환`);
                return cache.get(prop);
            }
            
            const value = target[prop];
            cache.set(prop, value);
            console.log(`"${prop}" 계산 후 캐시에 저장`);
            return value;
        }
    });
};

const expensiveOperation = {
    computeValue(n) {
        console.log('복잡한 계산 수행 중...');
        return n * n;
    }
};

const cachedOperation = createCachingProxy(expensiveOperation);

console.log(cachedOperation.computeValue(5)); // 계산 수행
console.log(cachedOperation.computeValue(5)); // 캐시에서 반환
```

## 7. 주의사항과 모범 사례

1. **성능 고려**: Proxy는 일반적인 속성 접근보다 약간 더 느립니다. 성능이 중요한 경우 신중하게 사용해야 합니다.

2. **명확성 유지**: 복잡한 Proxy 핸들러는 코드의 가독성을 해칠 수 있습니다. 가능한 한 단순하게 유지하세요.

3. **에러 처리**: Proxy에서 발생하는 에러를 적절히 처리하고, 사용자에게 명확한 에러 메시지를 제공하세요.

4. **불변성**: 객체의 불변성이 필요한 경우 `Object.freeze()`를 사용하세요.

5. **타입 체크**: TypeScript를 사용하는 경우, Proxy와 관련된 타입 정의를 올바르게 설정하세요.

## 8. 결론

JavaScript의 속성 접근 제어는 객체의 데이터를 보호하고, 유효성을 검사하며, 동작을 커스터마이즈할 수 있는 강력한 기능을 제공합니다. 적절한 상황에서 이러한 기능들을 활용하면 더 안전하고 유지보수하기 쉬운 코드를 작성할 수 있습니다.

각 방법은 고유한 사용 사례가 있으며, 프로젝트의 요구사항에 따라 적절한 방법을 선택하는 것이 중요합니다. `Object.defineProperty()`는 기본적인 속성 제어에, Getter/Setter는 단순한 검증에, Proxy는 복잡한 동작 커스터마이징에 적합합니다.
