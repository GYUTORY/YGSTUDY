---
title: 함수형 프로그래밍 (Functional Programming)
tags: [framework, node, 함수형-프로그래밍, functional-programming, nodejs]
updated: 2024-12-19
---

# 함수형 프로그래밍 (Functional Programming)

## 배경

### 함수형 프로그래밍이란?
함수형 프로그래밍은 함수를 일급 객체로 다루며, 불변성과 순수 함수를 중심으로 설계하는 프로그래밍 패러다임입니다.

### 주요 특징
- **순수 함수**: 같은 입력에 대해 항상 같은 출력을 반환
- **부작용 없음**: 외부 상태 변경을 금지
- **일급 객체**: 함수를 변수, 인자, 반환값으로 사용 가능
- **고차 함수**: 함수를 인자로 받거나 반환하는 함수
- **불변성**: 데이터 변경 대신 새 데이터를 생성

### 함수형 프로그래밍의 장점
- 코드의 예측 가능성과 테스트 용이성 향상
- 부작용으로 인한 버그 감소
- 병렬 처리와 최적화에 유리
- 코드의 재사용성과 모듈화 개선

## 핵심

### 1. 순수 함수 (Pure Function)

순수 함수는 같은 입력에 대해 항상 같은 출력을 반환하며, 외부 상태에 영향을 주지 않는 함수입니다.

#### 좋은 예시
```javascript
// 순수 함수
const add = (a, b) => a + b;
const multiply = (a, b) => a * b;
const formatName = (firstName, lastName) => `${firstName} ${lastName}`;
```

#### 나쁜 예시
```javascript
// 부작용이 있는 함수
let total = 0;
const addToTotal = (num) => {
    total += num; // 외부 상태 변경
    return total;
};

const getCurrentTime = () => new Date(); // 매번 다른 결과
```

### 2. 불변성 (Immutability)

불변성은 데이터를 직접 변경하지 않고, 새로운 데이터를 생성하는 원칙입니다.

#### 객체 업데이트
```javascript
// 변경 가능한 방식
const user = { name: '김철수', age: 25 };
user.age = 26; // 원본 객체 변경

// 불변 방식
const updateAge = (user, newAge) => ({ ...user, age: newAge });
const updatedUser = updateAge(user, 26); // 새 객체 생성
```

#### 배열 조작
```javascript
const numbers = [1, 2, 3, 4, 5];

// 변경 가능한 방식
numbers.push(6); // 원본 배열 변경

// 불변 방식
const newNumbers = [...numbers, 6]; // 새 배열 생성
const doubledNumbers = numbers.map(n => n * 2);
```

### 3. 고차 함수 (Higher-Order Function)

고차 함수는 함수를 인자로 받거나 함수를 반환하는 함수입니다.

```javascript
// 함수를 인자로 받는 고차 함수
const withLogging = (fn) => {
    return (...args) => {
        console.log(`함수 실행: ${fn.name}`);
        const result = fn(...args);
        console.log(`결과: ${result}`);
        return result;
    };
};

// 사용 예시
const add = (a, b) => a + b;
const addWithLogging = withLogging(add);
addWithLogging(5, 3); // 로그와 함께 실행
```

## 예시

### 함수형 프로그래밍 패턴들

#### 1. 함수 합성 (Function Composition)
```javascript
// 함수들을 조합하여 새로운 함수 생성
const compose = (...fns) => (x) => 
    fns.reduceRight((acc, fn) => fn(acc), x);

const addOne = x => x + 1;
const multiplyByTwo = x => x * 2;
const square = x => x * x;

const composed = compose(square, multiplyByTwo, addOne);
console.log(composed(3)); // ((3 + 1) * 2)² = 64
```

#### 2. 커링 (Currying)
```javascript
// 여러 인자를 받는 함수를 하나씩 받는 함수들로 변환
const curry = (fn) => {
    return function curried(...args) {
        if (args.length >= fn.length) {
            return fn.apply(this, args);
        }
        return function(...moreArgs) {
            return curried.apply(this, args.concat(moreArgs));
        };
    };
};

const add = curry((a, b, c) => a + b + c);
const addFive = add(5);
const addFiveAndThree = addFive(3);
console.log(addFiveAndThree(2)); // 10
```

#### 3. 부분 적용 (Partial Application)
```javascript
// 함수의 일부 인자를 미리 고정
const partial = (fn, ...presetArgs) => {
    return function(...laterArgs) {
        return fn.apply(this, presetArgs.concat(laterArgs));
    };
};

const greet = (greeting, name) => `${greeting}, ${name}!`;
const sayHello = partial(greet, 'Hello');
console.log(sayHello('World')); // "Hello, World!"
```

#### 4. 함수형 유틸리티
```javascript
// 함수형 프로그래밍에서 자주 사용되는 유틸리티 함수들
const map = (fn, arr) => arr.map(fn);
const filter = (predicate, arr) => arr.filter(predicate);
const reduce = (fn, initial, arr) => arr.reduce(fn, initial);

// 사용 예시
const numbers = [1, 2, 3, 4, 5];
const doubled = map(x => x * 2, numbers);
const evens = filter(x => x % 2 === 0, numbers);
const sum = reduce((acc, x) => acc + x, 0, numbers);

console.log(doubled); // [2, 4, 6, 8, 10]
console.log(evens);   // [2, 4]
console.log(sum);     // 15
```

#### 5. Maybe 모나드
```javascript
// null/undefined 처리를 위한 Maybe 모나드
class Maybe {
    constructor(value) {
        this.value = value;
    }

    static of(value) {
        return new Maybe(value);
    }

    map(fn) {
        return this.value === null || this.value === undefined
            ? Maybe.of(null)
            : Maybe.of(fn(this.value));
    }

    getOrElse(defaultValue) {
        return this.value === null || this.value === undefined
            ? defaultValue
            : this.value;
    }
}

// 사용 예시
const user = { name: 'John', age: 30 };
const getName = user => user?.name;
const toUpperCase = str => str?.toUpperCase();

const result = Maybe.of(user)
    .map(getName)
    .map(toUpperCase)
    .getOrElse('Unknown');

console.log(result); // "JOHN"
```

#### 6. Either 모나드
```javascript
// 에러 처리를 위한 Either 모나드
class Either {
    constructor(left, right) {
        this.left = left;
        this.right = right;
    }

    static left(value) {
        return new Either(value, null);
    }

    static right(value) {
        return new Either(null, value);
    }

    map(fn) {
        return this.right !== null
            ? Either.right(fn(this.right))
            : Either.left(this.left);
    }

    getOrElse(defaultValue) {
        return this.right !== null ? this.right : defaultValue;
    }
}

// 사용 예시
const divide = (a, b) => {
    return b === 0 
        ? Either.left('Division by zero')
        : Either.right(a / b);
};

const result = divide(10, 2)
    .map(x => x * 2)
    .getOrElse(0);

console.log(result); // 10
```

## 운영 팁

### 함수형 프로그래밍 모범 사례

#### 1. 순수 함수 작성하기
```javascript
// 좋은 예시: 순수 함수
const calculateTax = (income, rate) => income * rate;

// 나쁜 예시: 부작용이 있는 함수
let taxRate = 0.1;
const calculateTaxWithSideEffect = (income) => {
    taxRate = Math.random() * 0.2; // 외부 상태 변경
    return income * taxRate;
};
```

#### 2. 불변성 유지하기
```javascript
// 객체 업데이트
const updateUser = (user, updates) => ({ ...user, ...updates });

// 배열 조작
const addItem = (list, item) => [...list, item];
const removeItem = (list, index) => list.filter((_, i) => i !== index);
```

#### 3. 고차 함수 활용하기
```javascript
// 함수 팩토리
const createValidator = (predicate, errorMessage) => {
    return (value) => predicate(value) ? null : errorMessage;
};

const isRequired = createValidator(
    value => value !== null && value !== undefined && value !== '',
    'This field is required'
);

const isEmail = createValidator(
    value => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value),
    'Invalid email format'
);

// 사용 예시
console.log(isRequired('')); // "This field is required"
console.log(isEmail('test@example.com')); // null
```

### 성능 최적화
```javascript
// 메모이제이션을 통한 성능 최적화
const memoize = (fn) => {
    const cache = new Map();
    return (...args) => {
        const key = JSON.stringify(args);
        if (cache.has(key)) {
            return cache.get(key);
        }
        const result = fn(...args);
        cache.set(key, result);
        return result;
    };
};

const expensiveCalculation = memoize((n) => {
    console.log('계산 중...');
    return n * n;
});

console.log(expensiveCalculation(5)); // 계산 중... 25
console.log(expensiveCalculation(5)); // 25 (캐시에서 반환)
```

## 참고

### 함수형 프로그래밍 vs 객체지향 프로그래밍

| 특징 | 함수형 프로그래밍 | 객체지향 프로그래밍 |
|------|------------------|-------------------|
| **상태 관리** | 불변성, 부작용 없음 | 객체 상태 변경 |
| **데이터 처리** | 함수 합성, 고차 함수 | 메서드 체이닝 |
| **에러 처리** | Maybe, Either 모나드 | 예외 처리 |
| **테스트** | 순수 함수로 테스트 용이 | 모킹 필요 |
| **병렬 처리** | 부작용 없어 안전 | 동기화 필요 |

### 함수형 프로그래밍 라이브러리
- **Ramda**: 함수형 유틸리티 라이브러리
- **Lodash/fp**: 함수형 프로그래밍을 위한 Lodash
- **Folktale**: 함수형 프로그래밍을 위한 모나드 라이브러리

### 결론
함수형 프로그래밍은 코드의 예측 가능성과 유지보수성을 크게 향상시킵니다.
순수 함수와 불변성을 통해 부작용으로 인한 버그를 줄이고,
고차 함수와 함수 합성을 통해 코드의 재사용성을 높일 수 있습니다.
특히 JavaScript에서는 함수가 일급 객체이기 때문에 함수형 프로그래밍 패러다임을 자연스럽게 적용할 수 있습니다.
