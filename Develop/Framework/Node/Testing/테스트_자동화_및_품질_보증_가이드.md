---
title: 테스트 자동화 및 품질 보증
tags: [testing, automation, quality-assurance, test-pyramid, performance-testing, ci-cd, container-testing]
updated: 2025-10-02
---

# 테스트 자동화 및 품질 보증 (Test Automation and Quality Assurance)

## 📋 목차
1. [TDD (Test-Driven Development) 방법론](#tdd-test-driven-development-방법론)
2. [테스트 피라미드 실제 구현](#테스트-피라미드-실제-구현)
3. [테스트 격리 및 환경 관리](#테스트-격리-및-환경-관리)
4. [성능 테스트 자동화](#성능-테스트-자동화)
5. [테스트 커버리지 관리](#테스트-커버리지-관리)
6. [E2E 테스트 통합 전략](#e2e-테스트-통합-전략)
7. [컨테이너 기반 테스트 환경 구축](#컨테이너-기반-테스트-환경-구축)
8. [테스트 데이터 관리 및 시드](#테스트-데이터-관리-및-시드)
9. [CI/CD 파이프라인에서의 품질 게이트](#cicd-파이프라인에서의-품질-게이트)

### 📌 통합된 기존 파일들
이 가이드는 다음 기존 파일들의 내용을 통합하여 더 체계적으로 정리한 것입니다:
- **TDD**: 테스트 주도 개발 → 테스트 피라미드 전략으로 확장
- **테스트 커버리지 관리**: 커버리지 측정 → 품질 게이트로 확장
- **Bitbucket Pipeline**: 기본 CI/CD → 품질 보증 파이프라인으로 확장
- **E2E 테스트 도구 비교**: 도구 비교 → 자동화 전략으로 확장
- **API E2E 테스트 패턴**: API 테스트 → 통합 테스트 자동화로 확장
- **Database Integration Testing**: DB 테스트 → 테스트 데이터 관리로 확장

---

## TDD (Test-Driven Development) 방법론

### 1. TDD 핵심 개념

#### TDD란?
TDD(Test-Driven Development, 테스트 주도 개발)는 테스트를 먼저 작성하고, 이후에 실제 코드를 구현하는 방식입니다. 즉, 기능을 개발하기 전에 먼저 테스트를 작성한 후, 테스트를 통과할 수 있도록 코드를 작성하는 개발 방법론입니다.

#### TDD의 핵심 원칙
- **테스트 우선**: 기능 구현 전에 테스트를 먼저 작성
- **작은 단위**: 작은 기능 단위로 테스트와 구현을 반복
- **지속적 리팩토링**: 코드 개선을 통한 품질 향상

#### TDD의 장점
- 코드의 품질과 신뢰성 향상
- 설계 개선 및 리팩토링 용이
- 문서화 효과
- 버그 조기 발견

### 2. TDD 개발 프로세스

TDD는 **Red → Green → Refactor** 3단계를 반복합니다.

#### Red (실패) 단계
```javascript
// 1. 먼저 테스트를 작성하고 실행 → 당연히 처음에는 실패
describe('UserService', () => {
  describe('createUser', () => {
    it('should create a new user with valid data', () => {
      // Given
      const userData = {
        email: 'test@example.com',
        password: 'password123',
        name: 'Test User'
      };

      // When
      const result = UserService.createUser(userData);

      // Then
      expect(result).toBeDefined();
      expect(result.email).toBe(userData.email);
      expect(result.name).toBe(userData.name);
      expect(result.id).toBeDefined();
    });
  });
});
```

#### Green (성공) 단계
```javascript
// 2. 테스트를 통과할 수 있는 최소한의 코드 작성
class UserService {
  static createUser(userData) {
    // 최소한의 구현으로 테스트 통과
    return {
      id: Date.now().toString(),
      email: userData.email,
      name: userData.name,
      createdAt: new Date()
    };
  }
}
```

#### Refactor (리팩토링) 단계
```javascript
// 3. 코드를 개선하고 최적화
class UserService {
  static createUser(userData) {
    // 입력 검증 추가
    this.validateUserData(userData);
    
    // 비즈니스 로직 개선
    const hashedPassword = this.hashPassword(userData.password);
    
    // 데이터베이스 저장
    const user = {
      id: this.generateUserId(),
      email: userData.email,
      name: userData.name,
      password: hashedPassword,
      createdAt: new Date()
    };
    
    return this.saveUser(user);
  }

  static validateUserData(userData) {
    if (!userData.email || !userData.password || !userData.name) {
      throw new Error('필수 필드가 누락되었습니다.');
    }
    
    if (!this.isValidEmail(userData.email)) {
      throw new Error('유효하지 않은 이메일 형식입니다.');
    }
  }

  static hashPassword(password) {
    const crypto = require('crypto');
    return crypto.createHash('sha256').update(password).digest('hex');
  }

  static generateUserId() {
    return `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  static saveUser(user) {
    // 실제 데이터베이스 저장 로직
    return user;
  }
}
```

### 3. TDD 실전 예제: 주문 시스템

#### 단계 1: 주문 생성 테스트 작성
```javascript
// tests/order.test.js
describe('OrderService', () => {
  describe('createOrder', () => {
    it('should create order with valid items', () => {
      // Given
      const orderData = {
        userId: 'user123',
        items: [
          { productId: 'prod1', quantity: 2, price: 1000 },
          { productId: 'prod2', quantity: 1, price: 2000 }
        ]
      };

      // When
      const order = OrderService.createOrder(orderData);

      // Then
      expect(order).toBeDefined();
      expect(order.id).toBeDefined();
      expect(order.userId).toBe(orderData.userId);
      expect(order.items).toHaveLength(2);
      expect(order.totalAmount).toBe(4000); // (2 * 1000) + (1 * 2000)
      expect(order.status).toBe('PENDING');
    });

    it('should throw error for empty items', () => {
      // Given
      const orderData = {
        userId: 'user123',
        items: []
      };

      // When & Then
      expect(() => OrderService.createOrder(orderData))
        .toThrow('주문 항목이 없습니다.');
    });

    it('should calculate total amount correctly', () => {
      // Given
      const orderData = {
        userId: 'user123',
        items: [
          { productId: 'prod1', quantity: 3, price: 500 },
          { productId: 'prod2', quantity: 2, price: 1500 }
        ]
      };

      // When
      const order = OrderService.createOrder(orderData);

      // Then
      expect(order.totalAmount).toBe(4500); // (3 * 500) + (2 * 1500)
    });
  });
});
```

#### 단계 2: 최소 구현으로 테스트 통과
```javascript
// src/services/OrderService.js
class OrderService {
  static createOrder(orderData) {
    if (!orderData.items || orderData.items.length === 0) {
      throw new Error('주문 항목이 없습니다.');
    }

    const totalAmount = orderData.items.reduce((sum, item) => {
      return sum + (item.quantity * item.price);
    }, 0);

    return {
      id: `order_${Date.now()}`,
      userId: orderData.userId,
      items: orderData.items,
      totalAmount: totalAmount,
      status: 'PENDING',
      createdAt: new Date()
    };
  }
}

module.exports = OrderService;
```

#### 단계 3: 리팩토링 및 개선
```javascript
// src/services/OrderService.js
const { v4: uuidv4 } = require('uuid');
const OrderRepository = require('../repositories/OrderRepository');
const ProductService = require('./ProductService');

class OrderService {
  static async createOrder(orderData) {
    // 입력 검증
    this.validateOrderData(orderData);
    
    // 상품 재고 확인
    await this.validateProductAvailability(orderData.items);
    
    // 주문 생성
    const order = this.buildOrder(orderData);
    
    // 데이터베이스 저장
    const savedOrder = await OrderRepository.save(order);
    
    // 이벤트 발행
    await this.publishOrderCreatedEvent(savedOrder);
    
    return savedOrder;
  }

  static validateOrderData(orderData) {
    if (!orderData.userId) {
      throw new Error('사용자 ID가 필요합니다.');
    }
    
    if (!orderData.items || orderData.items.length === 0) {
      throw new Error('주문 항목이 없습니다.');
    }
    
    orderData.items.forEach((item, index) => {
      if (!item.productId || !item.quantity || !item.price) {
        throw new Error(`주문 항목 ${index + 1}의 필수 정보가 누락되었습니다.`);
      }
      
      if (item.quantity <= 0) {
        throw new Error(`주문 항목 ${index + 1}의 수량은 0보다 커야 합니다.`);
      }
      
      if (item.price <= 0) {
        throw new Error(`주문 항목 ${index + 1}의 가격은 0보다 커야 합니다.`);
      }
    });
  }

  static async validateProductAvailability(items) {
    for (const item of items) {
      const product = await ProductService.getProduct(item.productId);
      
      if (!product) {
        throw new Error(`상품 ${item.productId}를 찾을 수 없습니다.`);
      }
      
      if (product.stock < item.quantity) {
        throw new Error(`상품 ${product.name}의 재고가 부족합니다. (요청: ${item.quantity}, 재고: ${product.stock})`);
      }
    }
  }

  static buildOrder(orderData) {
    const totalAmount = orderData.items.reduce((sum, item) => {
      return sum + (item.quantity * item.price);
    }, 0);

    return {
      id: uuidv4(),
      userId: orderData.userId,
      items: orderData.items.map(item => ({
        productId: item.productId,
        quantity: item.quantity,
        price: item.price,
        subtotal: item.quantity * item.price
      })),
      totalAmount: totalAmount,
      status: 'PENDING',
      createdAt: new Date(),
      updatedAt: new Date()
    };
  }

  static async publishOrderCreatedEvent(order) {
    const EventBus = require('../events/EventBus');
    await EventBus.publish('order.created', {
      orderId: order.id,
      userId: order.userId,
      totalAmount: order.totalAmount,
      timestamp: order.createdAt
    });
  }
}

module.exports = OrderService;
```

### 4. TDD 모범 사례

#### 테스트 작성 원칙
```javascript
// ✅ 좋은 테스트 예제
describe('UserService', () => {
  describe('authenticateUser', () => {
    it('should return user when valid credentials provided', async () => {
      // Given - 명확한 테스트 데이터 설정
      const credentials = {
        email: 'test@example.com',
        password: 'validPassword123'
      };
      const expectedUser = {
        id: 'user123',
        email: 'test@example.com',
        name: 'Test User'
      };
      
      // Mock 설정
      UserRepository.findByEmail.mockResolvedValue(expectedUser);
      PasswordService.verify.mockResolvedValue(true);

      // When - 단일 동작 실행
      const result = await UserService.authenticateUser(credentials);

      // Then - 명확한 검증
      expect(result).toEqual(expectedUser);
      expect(UserRepository.findByEmail).toHaveBeenCalledWith(credentials.email);
      expect(PasswordService.verify).toHaveBeenCalledWith(
        credentials.password, 
        expectedUser.passwordHash
      );
    });

    it('should throw error when invalid credentials provided', async () => {
      // Given
      const credentials = {
        email: 'test@example.com',
        password: 'wrongPassword'
      };
      
      UserRepository.findByEmail.mockResolvedValue(null);

      // When & Then
      await expect(UserService.authenticateUser(credentials))
        .rejects
        .toThrow('인증에 실패했습니다.');
    });
  });
});
```

#### 테스트 구조화
```javascript
// tests/unit/services/UserService.test.js
describe('UserService', () => {
  let userService;
  let mockUserRepository;
  let mockPasswordService;

  beforeEach(() => {
    // 각 테스트마다 깨끗한 상태로 초기화
    mockUserRepository = {
      findByEmail: jest.fn(),
      save: jest.fn(),
      update: jest.fn()
    };
    
    mockPasswordService = {
      hash: jest.fn(),
      verify: jest.fn()
    };

    userService = new UserService(mockUserRepository, mockPasswordService);
  });

  afterEach(() => {
    // Mock 초기화
    jest.clearAllMocks();
  });

  describe('createUser', () => {
    it('should create user successfully', async () => {
      // 테스트 구현
    });
  });

  describe('updateUser', () => {
    it('should update user successfully', async () => {
      // 테스트 구현
    });
  });
});
```

---

## 테스트 피라미드 실제 구현

### 1. 테스트 피라미드 개념 및 구조

#### 테스트 피라미드 구조
```
        E2E Tests (10%)
       ┌─────────────────┐
      │   Playwright     │
      │   사용자 시나리오  │
      └─────────────────┘
     ┌─────────────────────┐
    │   Integration Tests  │
    │   Supertest API      │
    │   (20%)              │
    └─────────────────────┘
   ┌─────────────────────────┐
  │     Unit Tests (70%)     │
  │     Jest 순수 함수       │
  │     비즈니스 로직        │
  └─────────────────────────┘
```

### 2. Unit Tests (70%) - Jest 기반

#### 순수 함수 테스트
```javascript
// tests/unit/utils/calculator.test.js
describe('Calculator', () => {
  describe('calculateTotal', () => {
    it('should calculate total with tax correctly', () => {
      // Given
      const items = [
        { price: 1000, quantity: 2 },
        { price: 2000, quantity: 1 }
      ];
      const taxRate = 0.1;

      // When
      const result = Calculator.calculateTotal(items, taxRate);

      // Then
      expect(result.subtotal).toBe(4000); // (1000 * 2) + (2000 * 1)
      expect(result.tax).toBe(400); // 4000 * 0.1
      expect(result.total).toBe(4400); // 4000 + 400
    });

    it('should handle empty items array', () => {
      // Given
      const items = [];
      const taxRate = 0.1;

      // When
      const result = Calculator.calculateTotal(items, taxRate);

      // Then
      expect(result.subtotal).toBe(0);
      expect(result.tax).toBe(0);
      expect(result.total).toBe(0);
    });

    it('should handle zero tax rate', () => {
      // Given
      const items = [{ price: 1000, quantity: 1 }];
      const taxRate = 0;

      // When
      const result = Calculator.calculateTotal(items, taxRate);

      // Then
      expect(result.subtotal).toBe(1000);
      expect(result.tax).toBe(0);
      expect(result.total).toBe(1000);
    });
  });

  describe('formatCurrency', () => {
    it('should format currency with Korean won', () => {
      // Given
      const amount = 1234567;

      // When
      const result = Calculator.formatCurrency(amount, 'KRW');

      // Then
      expect(result).toBe('₩1,234,567');
    });

    it('should format currency with US dollar', () => {
      // Given
      const amount = 1234.56;

      // When
      const result = Calculator.formatCurrency(amount, 'USD');

      // Then
      expect(result).toBe('$1,234.56');
    });
  });
});
```

#### 비즈니스 로직 테스트
```javascript
// tests/unit/services/OrderService.test.js
describe('OrderService', () => {
  let orderService;
  let mockOrderRepository;
  let mockProductService;
  let mockEventBus;

  beforeEach(() => {
    mockOrderRepository = {
      save: jest.fn(),
      findById: jest.fn(),
      update: jest.fn()
    };
    
    mockProductService = {
      getProduct: jest.fn(),
      updateStock: jest.fn()
    };
    
    mockEventBus = {
      publish: jest.fn()
    };

    orderService = new OrderService(
      mockOrderRepository,
      mockProductService,
      mockEventBus
    );
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('createOrder', () => {
    it('should create order successfully', async () => {
      // Given
      const orderData = {
        userId: 'user123',
        items: [
          { productId: 'prod1', quantity: 2, price: 1000 }
        ]
      };
      
      const mockProduct = { id: 'prod1', name: 'Product 1', stock: 10 };
      const mockOrder = { id: 'order123', ...orderData, totalAmount: 2000 };

      mockProductService.getProduct.mockResolvedValue(mockProduct);
      mockOrderRepository.save.mockResolvedValue(mockOrder);
      mockEventBus.publish.mockResolvedValue();

      // When
      const result = await orderService.createOrder(orderData);

      // Then
      expect(result).toEqual(mockOrder);
      expect(mockProductService.getProduct).toHaveBeenCalledWith('prod1');
      expect(mockOrderRepository.save).toHaveBeenCalled();
      expect(mockEventBus.publish).toHaveBeenCalledWith('order.created', expect.any(Object));
    });

    it('should throw error when product not found', async () => {
      // Given
      const orderData = {
        userId: 'user123',
        items: [{ productId: 'nonexistent', quantity: 1, price: 1000 }]
      };

      mockProductService.getProduct.mockResolvedValue(null);

      // When & Then
      await expect(orderService.createOrder(orderData))
        .rejects
        .toThrow('상품 nonexistent를 찾을 수 없습니다.');
    });

    it('should throw error when insufficient stock', async () => {
      // Given
      const orderData = {
        userId: 'user123',
        items: [{ productId: 'prod1', quantity: 5, price: 1000 }]
      };
      
      const mockProduct = { id: 'prod1', name: 'Product 1', stock: 3 };

      mockProductService.getProduct.mockResolvedValue(mockProduct);

      // When & Then
      await expect(orderService.createOrder(orderData))
        .rejects
        .toThrow('상품 Product 1의 재고가 부족합니다. (요청: 5, 재고: 3)');
    });
  });

  describe('cancelOrder', () => {
    it('should cancel order successfully', async () => {
      // Given
      const orderId = 'order123';
      const mockOrder = {
        id: orderId,
        status: 'PENDING',
        items: [{ productId: 'prod1', quantity: 2 }]
      };

      mockOrderRepository.findById.mockResolvedValue(mockOrder);
      mockOrderRepository.update.mockResolvedValue({ ...mockOrder, status: 'CANCELLED' });
      mockEventBus.publish.mockResolvedValue();

      // When
      const result = await orderService.cancelOrder(orderId);

      // Then
      expect(result.status).toBe('CANCELLED');
      expect(mockOrderRepository.update).toHaveBeenCalledWith(orderId, { status: 'CANCELLED' });
      expect(mockEventBus.publish).toHaveBeenCalledWith('order.cancelled', expect.any(Object));
    });

    it('should throw error when order not found', async () => {
      // Given
      const orderId = 'nonexistent';

      mockOrderRepository.findById.mockResolvedValue(null);

      // When & Then
      await expect(orderService.cancelOrder(orderId))
        .rejects
        .toThrow('주문 nonexistent를 찾을 수 없습니다.');
    });

    it('should throw error when order already cancelled', async () => {
      // Given
      const orderId = 'order123';
      const mockOrder = { id: orderId, status: 'CANCELLED' };

      mockOrderRepository.findById.mockResolvedValue(mockOrder);

      // When & Then
      await expect(orderService.cancelOrder(orderId))
        .rejects
        .toThrow('이미 취소된 주문입니다.');
    });
  });
});
```

### 3. Integration Tests (20%) - Supertest 기반

#### API 엔드포인트 테스트
```javascript
// tests/integration/api/orders.test.js
const request = require('supertest');
const app = require('../../src/app');
const { setupTestDatabase, cleanupTestDatabase } = require('../helpers/database');
const { createTestUser, createTestProduct } = require('../helpers/factory');

describe('Orders API', () => {
  let testUser;
  let testProduct;
  let authToken;

  beforeAll(async () => {
    await setupTestDatabase();
    testUser = await createTestUser();
    testProduct = await createTestProduct();
    authToken = await getAuthToken(testUser);
  });

  afterAll(async () => {
    await cleanupTestDatabase();
  });

  beforeEach(async () => {
    // 각 테스트마다 깨끗한 상태로 초기화
    await cleanupTestData();
  });

  describe('POST /api/orders', () => {
    it('should create order successfully', async () => {
      // Given
      const orderData = {
        items: [
          { productId: testProduct.id, quantity: 2, price: testProduct.price }
        ]
      };

      // When
      const response = await request(app)
        .post('/api/orders')
        .set('Authorization', `Bearer ${authToken}`)
        .send(orderData)
        .expect(201);

      // Then
      expect(response.body).toMatchObject({
        id: expect.any(String),
        userId: testUser.id,
        items: expect.arrayContaining([
          expect.objectContaining({
            productId: testProduct.id,
            quantity: 2,
            price: testProduct.price
          })
        ]),
        totalAmount: testProduct.price * 2,
        status: 'PENDING'
      });
    });

    it('should return 400 for invalid order data', async () => {
      // Given
      const invalidOrderData = {
        items: [] // 빈 배열
      };

      // When & Then
      await request(app)
        .post('/api/orders')
        .set('Authorization', `Bearer ${authToken}`)
        .send(invalidOrderData)
        .expect(400)
        .expect((res) => {
          expect(res.body.error).toContain('주문 항목이 없습니다');
        });
    });

    it('should return 401 for unauthenticated request', async () => {
      // Given
      const orderData = {
        items: [{ productId: testProduct.id, quantity: 1, price: testProduct.price }]
      };

      // When & Then
      await request(app)
        .post('/api/orders')
        .send(orderData)
        .expect(401);
    });
  });

  describe('GET /api/orders/:id', () => {
    it('should return order details', async () => {
      // Given
      const order = await createTestOrder(testUser.id, [testProduct]);

      // When
      const response = await request(app)
        .get(`/api/orders/${order.id}`)
        .set('Authorization', `Bearer ${authToken}`)
        .expect(200);

      // Then
      expect(response.body).toMatchObject({
        id: order.id,
        userId: testUser.id,
        status: 'PENDING'
      });
    });

    it('should return 404 for non-existent order', async () => {
      // When & Then
      await request(app)
        .get('/api/orders/nonexistent')
        .set('Authorization', `Bearer ${authToken}`)
        .expect(404);
    });
  });

  describe('PUT /api/orders/:id/cancel', () => {
    it('should cancel order successfully', async () => {
      // Given
      const order = await createTestOrder(testUser.id, [testProduct]);

      // When
      const response = await request(app)
        .put(`/api/orders/${order.id}/cancel`)
        .set('Authorization', `Bearer ${authToken}`)
        .expect(200);

      // Then
      expect(response.body.status).toBe('CANCELLED');
    });

    it('should return 400 for already cancelled order', async () => {
      // Given
      const order = await createTestOrder(testUser.id, [testProduct], 'CANCELLED');

      // When & Then
      await request(app)
        .put(`/api/orders/${order.id}/cancel`)
        .set('Authorization', `Bearer ${authToken}`)
        .expect(400)
        .expect((res) => {
          expect(res.body.error).toContain('이미 취소된 주문입니다');
        });
    });
  });
});
```

#### 미들웨어 테스트
```javascript
// tests/integration/middleware/auth.test.js
const request = require('supertest');
const express = require('express');
const authMiddleware = require('../../src/middleware/auth');
const jwt = require('jsonwebtoken');

describe('Auth Middleware', () => {
  let app;
  const secretKey = 'test-secret-key';

  beforeEach(() => {
    app = express();
    app.use(express.json());
    app.use(authMiddleware(secretKey));
    
    app.get('/protected', (req, res) => {
      res.json({ user: req.user });
    });
  });

  it('should allow access with valid token', async () => {
    // Given
    const user = { id: 'user123', email: 'test@example.com' };
    const token = jwt.sign(user, secretKey, { expiresIn: '1h' });

    // When
    const response = await request(app)
      .get('/protected')
      .set('Authorization', `Bearer ${token}`)
      .expect(200);

    // Then
    expect(response.body.user).toMatchObject(user);
  });

  it('should reject request without token', async () => {
    // When & Then
    await request(app)
      .get('/protected')
      .expect(401)
      .expect((res) => {
        expect(res.body.error).toContain('인증 토큰이 필요합니다');
      });
  });

  it('should reject request with invalid token', async () => {
    // When & Then
    await request(app)
      .get('/protected')
      .set('Authorization', 'Bearer invalid-token')
      .expect(401)
      .expect((res) => {
        expect(res.body.error).toContain('유효하지 않은 토큰입니다');
      });
  });

  it('should reject request with expired token', async () => {
    // Given
    const user = { id: 'user123', email: 'test@example.com' };
    const token = jwt.sign(user, secretKey, { expiresIn: '-1h' }); // 만료된 토큰

    // When & Then
    await request(app)
      .get('/protected')
      .set('Authorization', `Bearer ${token}`)
      .expect(401)
      .expect((res) => {
        expect(res.body.error).toContain('토큰이 만료되었습니다');
      });
  });
});
```

### 4. E2E Tests (10%) - Playwright 기반

#### 사용자 시나리오 테스트
```javascript
// tests/e2e/order-flow.spec.js
const { test, expect } = require('@playwright/test');

test.describe('Order Flow', () => {
  test.beforeEach(async ({ page }) => {
    // 각 테스트마다 로그인
    await page.goto('/login');
    await page.fill('[data-testid="email"]', 'test@example.com');
    await page.fill('[data-testid="password"]', 'password123');
    await page.click('[data-testid="login-button"]');
    await expect(page).toHaveURL('/dashboard');
  });

  test('should complete order flow successfully', async ({ page }) => {
    // 1. 상품 목록 페이지로 이동
    await page.goto('/products');
    await expect(page.locator('[data-testid="product-list"]')).toBeVisible();

    // 2. 첫 번째 상품을 장바구니에 추가
    await page.click('[data-testid="product-item"]:first-child [data-testid="add-to-cart"]');
    await expect(page.locator('[data-testid="cart-count"]')).toHaveText('1');

    // 3. 장바구니 페이지로 이동
    await page.click('[data-testid="cart-icon"]');
    await expect(page).toHaveURL('/cart');
    await expect(page.locator('[data-testid="cart-item"]')).toHaveCount(1);

    // 4. 주문하기 버튼 클릭
    await page.click('[data-testid="checkout-button"]');
    await expect(page).toHaveURL('/checkout');

    // 5. 배송 정보 입력
    await page.fill('[data-testid="shipping-name"]', '홍길동');
    await page.fill('[data-testid="shipping-address"]', '서울시 강남구 테헤란로 123');
    await page.fill('[data-testid="shipping-phone"]', '010-1234-5678');

    // 6. 결제 정보 입력
    await page.fill('[data-testid="card-number"]', '1234-5678-9012-3456');
    await page.fill('[data-testid="card-expiry"]', '12/25');
    await page.fill('[data-testid="card-cvv"]', '123');

    // 7. 주문 완료
    await page.click('[data-testid="place-order-button"]');
    
    // 8. 주문 완료 페이지 확인
    await expect(page).toHaveURL(/\/orders\/\d+/);
    await expect(page.locator('[data-testid="order-success"]')).toBeVisible();
    await expect(page.locator('[data-testid="order-number"]')).toBeVisible();
  });

  test('should show error for invalid payment information', async ({ page }) => {
    // Given - 장바구니에 상품이 있는 상태
    await page.goto('/products');
    await page.click('[data-testid="product-item"]:first-child [data-testid="add-to-cart"]');
    await page.click('[data-testid="cart-icon"]');
    await page.click('[data-testid="checkout-button"]');

    // When - 잘못된 결제 정보 입력
    await page.fill('[data-testid="shipping-name"]', '홍길동');
    await page.fill('[data-testid="shipping-address"]', '서울시 강남구 테헤란로 123');
    await page.fill('[data-testid="shipping-phone"]', '010-1234-5678');
    await page.fill('[data-testid="card-number"]', 'invalid-card');
    await page.fill('[data-testid="card-expiry"]', '12/25');
    await page.fill('[data-testid="card-cvv"]', '123');

    await page.click('[data-testid="place-order-button"]');

    // Then - 에러 메시지 표시
    await expect(page.locator('[data-testid="payment-error"]')).toBeVisible();
    await expect(page.locator('[data-testid="payment-error"]')).toContainText('유효하지 않은 카드 번호');
  });

  test('should handle out of stock scenario', async ({ page }) => {
    // Given - 재고가 없는 상품
    await page.goto('/products/out-of-stock-product');

    // When - 장바구니에 추가 시도
    await page.click('[data-testid="add-to-cart"]');

    // Then - 재고 부족 메시지 표시
    await expect(page.locator('[data-testid="stock-error"]')).toBeVisible();
    await expect(page.locator('[data-testid="stock-error"]')).toContainText('재고가 부족합니다');
  });
});
```

#### 모바일 반응형 테스트
```javascript
// tests/e2e/mobile-order.spec.js
const { test, expect, devices } = require('@playwright/test');

test.describe('Mobile Order Flow', () => {
  test.use({ ...devices['iPhone 12'] });

  test('should complete order on mobile device', async ({ page }) => {
    // 모바일 환경에서 주문 플로우 테스트
    await page.goto('/login');
    
    // 모바일 터치 인터랙션
    await page.tap('[data-testid="email"]');
    await page.fill('[data-testid="email"]', 'test@example.com');
    
    await page.tap('[data-testid="password"]');
    await page.fill('[data-testid="password"]', 'password123');
    
    await page.tap('[data-testid="login-button"]');
    await expect(page).toHaveURL('/dashboard');

    // 모바일 네비게이션
    await page.tap('[data-testid="mobile-menu"]');
    await page.tap('[data-testid="products-link"]');
    
    // 스와이프 제스처
    await page.touchscreen.tap(200, 400);
    await page.touchscreen.tap(200, 300);
    
    // 모바일 주문 플로우 계속...
  });
});
```

### 5. 테스트 설정 및 실행

#### Jest 설정
```javascript
// jest.config.js
module.exports = {
  // 테스트 환경
  testEnvironment: 'node',
  
  // 테스트 파일 패턴
  testMatch: [
    '<rootDir>/tests/unit/**/*.test.js',
    '<rootDir>/tests/integration/**/*.test.js'
  ],
  
  // 커버리지 설정
  collectCoverage: true,
  coverageDirectory: 'coverage',
  coverageReporters: ['text', 'lcov', 'html'],
  collectCoverageFrom: [
    'src/**/*.js',
    '!src/**/*.test.js',
    '!src/**/*.spec.js'
  ],
  
  // 커버리지 임계값
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80
    }
  },
  
  // 테스트 설정
  setupFilesAfterEnv: ['<rootDir>/tests/setup.js'],
  
  // 모듈 매핑
  moduleNameMapping: {
    '^@/(.*)$': '<rootDir>/src/$1'
  },
  
  // 병렬 실행
  maxWorkers: '50%',
  
  // 타임아웃
  testTimeout: 10000
};
```

#### Playwright 설정
```javascript
// playwright.config.js
const { defineConfig, devices } = require('@playwright/test');

module.exports = defineConfig({
  // 테스트 디렉토리
  testDir: './tests/e2e',
  
  // 병렬 실행
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  
  // 리포터
  reporter: [
    ['html'],
    ['json', { outputFile: 'test-results/results.json' }]
  ],
  
  // 전역 설정
  use: {
    baseURL: 'http://localhost:3000',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure'
  },
  
  // 프로젝트 설정
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] }
    },
    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] }
    },
    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] }
    },
    {
      name: 'Mobile Chrome',
      use: { ...devices['Pixel 5'] }
    },
    {
      name: 'Mobile Safari',
      use: { ...devices['iPhone 12'] }
    }
  ],
  
  // 웹 서버 설정
  webServer: {
    command: 'npm run start:test',
    url: 'http://localhost:3000',
    reuseExistingServer: !process.env.CI
  }
});
```

#### 통합 테스트 실행 스크립트
```json
// package.json
{
  "scripts": {
    "test": "jest",
    "test:unit": "jest --testPathPattern=tests/unit",
    "test:integration": "jest --testPathPattern=tests/integration",
    "test:e2e": "playwright test",
    "test:e2e:ui": "playwright test --ui",
    "test:all": "npm run test:unit && npm run test:integration && npm run test:e2e",
    "test:coverage": "jest --coverage",
    "test:watch": "jest --watch",
    "test:ci": "jest --ci --coverage --watchAll=false"
  }
}
```

---

## 테스트 격리 및 환경 관리
```
        🔺 E2E Tests (10%)
       🔺🔺 Integration Tests (20%)
      🔺🔺🔺 Unit Tests (70%)
```

#### 테스트 전략 수립
```javascript
class TestStrategy {
  constructor() {
    this.testTypes = {
      unit: {
        ratio: 70,
        description: '개별 함수/메서드 테스트',
        tools: ['Jest', 'Mocha', 'Jasmine'],
        executionTime: '빠름 (< 1ms)',
        maintenance: '낮음'
      },
      integration: {
        ratio: 20,
        description: '모듈/서비스 간 통합 테스트',
        tools: ['Supertest', 'Chai', 'Sinon'],
        executionTime: '보통 (1-100ms)',
        maintenance: '중간'
      },
      e2e: {
        ratio: 10,
        description: '사용자 시나리오 전체 테스트',
        tools: ['Playwright', 'Cypress', 'Selenium'],
        executionTime: '느림 (> 1s)',
        maintenance: '높음'
      }
    };
  }

  // 프로젝트별 테스트 전략 수립
  createProjectStrategy(projectType) {
    const strategies = {
      api: {
        unit: '비즈니스 로직, 유틸리티 함수',
        integration: '데이터베이스 연동, 외부 API 호출',
        e2e: 'API 엔드포인트 전체 플로우'
      },
      web: {
        unit: '컴포넌트 로직, 상태 관리',
        integration: '컴포넌트 간 상호작용, API 호출',
        e2e: '사용자 워크플로우'
      },
      mobile: {
        unit: '비즈니스 로직, 유틸리티',
        integration: '네이티브 기능, API 연동',
        e2e: '앱 전체 사용자 여정'
      }
    };

    return strategies[projectType] || strategies.api;
  }
}
```

### 2. 테스트 자동화 전략

#### 테스트 자동화 레벨
```javascript
class TestAutomationStrategy {
  constructor() {
    this.automationLevels = {
      level1: '단위 테스트 자동화',
      level2: '통합 테스트 자동화', 
      level3: 'E2E 테스트 자동화',
      level4: '성능 테스트 자동화',
      level5: '보안 테스트 자동화'
    };
  }

  // 테스트 자동화 우선순위 결정
  determinePriority(project) {
    const priorities = [];
    
    // 필수: 단위 테스트와 통합 테스트
    priorities.push({
      level: 1,
      type: 'unit',
      reason: '기본적인 코드 품질 보장',
      effort: 'low',
      impact: 'high'
    });

    priorities.push({
      level: 2, 
      type: 'integration',
      reason: '모듈 간 상호작용 검증',
      effort: 'medium',
      impact: 'high'
    });

    // 선택적: 프로젝트 특성에 따라
    if (project.hasUI) {
      priorities.push({
        level: 3,
        type: 'e2e',
        reason: '사용자 경험 검증',
        effort: 'high',
        impact: 'medium'
      });
    }

    if (project.performanceCritical) {
      priorities.push({
        level: 4,
        type: 'performance',
        reason: '성능 요구사항 충족',
        effort: 'high',
        impact: 'high'
      });
    }

    return priorities.sort((a, b) => a.level - b.level);
  }
}
```

---

## 성능 테스트 자동화

### 1. K6 성능 테스트

#### K6 기본 설정 및 스크립트
```javascript
// k6-performance-tests.js
import http from 'k6/http';
import { check, sleep } from 'k6';
import { Rate } from 'k6/metrics';

// 커스텀 메트릭
export const errorRate = new Rate('errors');

export let options = {
  stages: [
    { duration: '2m', target: 100 }, // 2분간 100 사용자까지 증가
    { duration: '5m', target: 100 }, // 5분간 100 사용자 유지
    { duration: '2m', target: 200 }, // 2분간 200 사용자까지 증가
    { duration: '5m', target: 200 }, // 5분간 200 사용자 유지
    { duration: '2m', target: 0 },   // 2분간 0 사용자까지 감소
  ],
  thresholds: {
    http_req_duration: ['p(95)<500'], // 95% 요청이 500ms 미만
    http_req_failed: ['rate<0.1'],    // 에러율 10% 미만
    errors: ['rate<0.1'],             // 커스텀 에러율 10% 미만
  },
};

export default function() {
  const baseUrl = __ENV.BASE_URL || 'http://localhost:3000';
  
  // API 엔드포인트 테스트
  const endpoints = [
    '/api/users',
    '/api/products',
    '/api/orders'
  ];
  
  for (const endpoint of endpoints) {
    const response = http.get(`${baseUrl}${endpoint}`, {
      headers: { 'Content-Type': 'application/json' },
    });
    
    check(response, {
      'status is 200': (r) => r.status === 200,
      'response time < 500ms': (r) => r.timings.duration < 500,
      'response has data': (r) => r.json().length > 0,
    }) || errorRate.add(1);
    
    sleep(1);
  }
}

// 스트레스 테스트
export function stressTest() {
  return {
    executor: 'ramping-vus',
    startVUs: 0,
    stages: [
      { duration: '5m', target: 100 },
      { duration: '10m', target: 200 },
      { duration: '5m', target: 300 },
      { duration: '10m', target: 400 },
      { duration: '5m', target: 0 },
    ],
  };
}

// 스파이크 테스트
export function spikeTest() {
  return {
    executor: 'ramping-vus',
    startVUs: 0,
    stages: [
      { duration: '1m', target: 10 },
      { duration: '1m', target: 100 },
      { duration: '1m', target: 10 },
      { duration: '1m', target: 0 },
    ],
  };
}
```

#### K6 CI/CD 통합
```yaml
# .github/workflows/performance-test.yml
name: Performance Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  performance-test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v2
    
    - name: Setup Node.js
      uses: actions/setup-node@v2
      with:
        node-version: '18'
        
    - name: Install dependencies
      run: npm ci
      
    - name: Start application
      run: |
        npm run build
        npm start &
        sleep 30
        
    - name: Run K6 performance tests
      run: |
        docker run --rm -i grafana/k6 run - <k6-performance-tests.js
        
    - name: Upload performance results
      uses: actions/upload-artifact@v2
      with:
        name: performance-results
        path: performance-results/
```

### 2. Artillery 성능 테스트

#### Artillery 설정 및 시나리오
```yaml
# artillery-config.yml
config:
  target: 'http://localhost:3000'
  phases:
    - duration: 60
      arrivalRate: 10
    - duration: 120
      arrivalRate: 20
    - duration: 60
      arrivalRate: 10
  defaults:
    headers:
      Content-Type: 'application/json'
  plugins:
    metrics-by-endpoint: {}
  ensure:
    p95: 500
    maxErrorRate: 5

scenarios:
  - name: "API Load Test"
    weight: 100
    flow:
      - get:
          url: "/api/health"
          expect:
            - statusCode: 200
      - post:
          url: "/api/auth/login"
          json:
            email: "test@example.com"
            password: "password123"
          capture:
            - json: "$.token"
              as: "authToken"
      - get:
          url: "/api/users"
          headers:
            Authorization: "Bearer {{ authToken }}"
          expect:
            - statusCode: 200
            - hasHeader: "content-type"
      - think: 2
```

#### Artillery 자동화 스크립트
```javascript
// artillery-automation.js
const artillery = require('artillery');
const fs = require('fs');

class ArtilleryManager {
  constructor() {
    this.configFile = 'artillery-config.yml';
    this.resultsDir = './performance-results';
  }

  async runPerformanceTest(testType = 'load') {
    const configs = {
      load: {
        phases: [
          { duration: 60, arrivalRate: 10 },
          { duration: 120, arrivalRate: 20 }
        ],
        ensure: { p95: 500, maxErrorRate: 5 }
      },
      stress: {
        phases: [
          { duration: 60, arrivalRate: 10 },
          { duration: 120, arrivalRate: 50 },
          { duration: 60, arrivalRate: 100 }
        ],
        ensure: { maxErrorRate: 10 }
      },
      spike: {
        phases: [
          { duration: 30, arrivalRate: 10 },
          { duration: 60, arrivalRate: 100 },
          { duration: 30, arrivalRate: 10 }
        ]
      }
    };

    const config = configs[testType];
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const resultsFile = `${this.resultsDir}/artillery-${testType}-${timestamp}.json`;

    return new Promise((resolve, reject) => {
      const runner = artillery.runner(config, {
        target: process.env.TARGET_URL || 'http://localhost:3000',
        output: resultsFile
      });

      runner.on('done', (results) => {
        console.log(`Performance test completed: ${testType}`);
        resolve({
          type: testType,
          results,
          file: resultsFile
        });
      });

      runner.on('error', (error) => {
        reject(error);
      });
    });
  }

  // 성능 테스트 결과 분석
  analyzeResults(resultsFile) {
    const results = JSON.parse(fs.readFileSync(resultsFile, 'utf8'));
    
    return {
      summary: results.aggregate,
      metrics: {
        requests: results.aggregate.counters['http.requests'],
        errors: results.aggregate.counters['http.request_rate'],
        responseTime: {
          min: results.aggregate.summaries['http.response_time'].min,
          max: results.aggregate.summaries['http.response_time'].max,
          median: results.aggregate.summaries['http.response_time'].median,
          p95: results.aggregate.summaries['http.response_time'].p95,
          p99: results.aggregate.summaries['http.response_time'].p99
        }
      },
      passRate: this.calculatePassRate(results),
      recommendations: this.generateRecommendations(results)
    };
  }
}
```

---

## 컨테이너 기반 테스트 환경 구축

### 1. Docker 기반 테스트 환경

#### 테스트용 Docker Compose 설정
```yaml
# docker-compose.test.yml
version: '3.8'

services:
  app-test:
    build:
      context: .
      dockerfile: Dockerfile.test
    environment:
      - NODE_ENV=test
      - DATABASE_URL=postgresql://test:test@postgres-test:5432/testdb
      - REDIS_URL=redis://redis-test:6379
    depends_on:
      - postgres-test
      - redis-test
    volumes:
      - ./test-results:/app/test-results
    networks:
      - test-network

  postgres-test:
    image: postgres:13
    environment:
      - POSTGRES_DB=testdb
      - POSTGRES_USER=test
      - POSTGRES_PASSWORD=test
    ports:
      - "5433:5432"
    volumes:
      - postgres-test-data:/var/lib/postgresql/data
    networks:
      - test-network

  redis-test:
    image: redis:6-alpine
    ports:
      - "6380:6379"
    volumes:
      - redis-test-data:/data
    networks:
      - test-network

  nginx-test:
    image: nginx:alpine
    ports:
      - "8080:80"
    volumes:
      - ./nginx-test.conf:/etc/nginx/nginx.conf
    depends_on:
      - app-test
    networks:
      - test-network

volumes:
  postgres-test-data:
  redis-test-data:

networks:
  test-network:
    driver: bridge
```

#### 테스트용 Dockerfile
```dockerfile
# Dockerfile.test
FROM node:18-alpine

WORKDIR /app

# 테스트 의존성 설치
COPY package*.json ./
RUN npm ci --only=development

# 소스 코드 복사
COPY . .

# 테스트 실행 권한 설정
RUN chmod +x scripts/run-tests.sh

# 테스트 실행
CMD ["npm", "run", "test:docker"]
```

### 2. Kubernetes 기반 테스트 환경

#### 테스트용 Kubernetes 매니페스트
```yaml
# k8s-test-environment.yml
apiVersion: v1
kind: Namespace
metadata:
  name: test-environment

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: test-app
  namespace: test-environment
spec:
  replicas: 1
  selector:
    matchLabels:
      app: test-app
  template:
    metadata:
      labels:
        app: test-app
    spec:
      containers:
      - name: app
        image: myapp:test
        env:
        - name: NODE_ENV
          value: "test"
        - name: DATABASE_URL
          value: "postgresql://test:test@postgres-test:5432/testdb"
        - name: REDIS_URL
          value: "redis://redis-test:6379"
        ports:
        - containerPort: 3000

---
apiVersion: v1
kind: Service
metadata:
  name: test-app-service
  namespace: test-environment
spec:
  selector:
    app: test-app
  ports:
  - port: 3000
    targetPort: 3000

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: postgres-test
  namespace: test-environment
spec:
  replicas: 1
  selector:
    matchLabels:
      app: postgres-test
  template:
    metadata:
      labels:
        app: postgres-test
    spec:
      containers:
      - name: postgres
        image: postgres:13
        env:
        - name: POSTGRES_DB
          value: "testdb"
        - name: POSTGRES_USER
          value: "test"
        - name: POSTGRES_PASSWORD
          value: "test"
        ports:
        - containerPort: 5432
```

#### 테스트 실행 자동화 스크립트
```bash
#!/bin/bash
# scripts/run-container-tests.sh

set -e

echo "🚀 Starting container-based test environment..."

# 테스트 환경 네임스페이스 생성
kubectl create namespace test-environment --dry-run=client -o yaml | kubectl apply -f -

# 테스트 환경 배포
echo "📦 Deploying test environment..."
kubectl apply -f k8s-test-environment.yml

# 테스트 환경 준비 대기
echo "⏳ Waiting for test environment to be ready..."
kubectl wait --for=condition=available --timeout=300s deployment/test-app -n test-environment

# 테스트 실행
echo "🧪 Running tests..."
kubectl exec -n test-environment deployment/test-app -- npm test

# 성능 테스트 실행
echo "⚡ Running performance tests..."
kubectl exec -n test-environment deployment/test-app -- npm run test:performance

# 테스트 결과 수집
echo "📊 Collecting test results..."
kubectl cp test-environment/test-app-pod:/app/test-results ./test-results

# 테스트 환경 정리
echo "🧹 Cleaning up test environment..."
kubectl delete namespace test-environment

echo "✅ Container-based tests completed!"
```

---

## 테스트 데이터 관리 및 시드

### 1. 테스트 데이터 생성 및 관리

#### 테스트 데이터 팩토리
```javascript
// test/factories/UserFactory.js
const { faker } = require('@faker-js/faker');

class UserFactory {
  static create(overrides = {}) {
    return {
      id: faker.datatype.uuid(),
      name: faker.name.fullName(),
      email: faker.internet.email(),
      phone: faker.phone.number(),
      address: {
        street: faker.address.streetAddress(),
        city: faker.address.city(),
        zipCode: faker.address.zipCode()
      },
      role: faker.helpers.arrayElement(['user', 'admin', 'moderator']),
      createdAt: faker.date.past(),
      updatedAt: faker.date.recent(),
      ...overrides
    };
  }

  static createMany(count, overrides = {}) {
    return Array.from({ length: count }, () => this.create(overrides));
  }

  static createAdmin(overrides = {}) {
    return this.create({
      role: 'admin',
      permissions: ['read', 'write', 'delete'],
      ...overrides
    });
  }

  static createWithSpecificData(specificData) {
    return this.create({
      ...specificData,
      // 항상 필요한 기본 데이터는 보장
      email: specificData.email || faker.internet.email(),
      createdAt: specificData.createdAt || faker.date.past()
    });
  }
}

module.exports = UserFactory;
```

#### 테스트 데이터베이스 시더
```javascript
// test/seeders/TestDataSeeder.js
const { Pool } = require('pg');
const UserFactory = require('../factories/UserFactory');
const ProductFactory = require('../factories/ProductFactory');

class TestDataSeeder {
  constructor() {
    this.pool = new Pool({
      host: process.env.DB_HOST || 'localhost',
      port: process.env.DB_PORT || 5432,
      database: process.env.DB_NAME || 'testdb',
      user: process.env.DB_USER || 'test',
      password: process.env.DB_PASSWORD || 'test'
    });
  }

  async seed() {
    try {
      await this.cleanDatabase();
      await this.seedUsers();
      await this.seedProducts();
      await this.seedOrders();
      console.log('✅ Test data seeded successfully');
    } catch (error) {
      console.error('❌ Error seeding test data:', error);
      throw error;
    } finally {
      await this.pool.end();
    }
  }

  async cleanDatabase() {
    const tables = ['orders', 'products', 'users'];
    
    for (const table of tables) {
      await this.pool.query(`TRUNCATE TABLE ${table} RESTART IDENTITY CASCADE`);
    }
  }

  async seedUsers(count = 100) {
    const users = UserFactory.createMany(count);
    
    for (const user of users) {
      await this.pool.query(
        'INSERT INTO users (id, name, email, phone, address, role, created_at, updated_at) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)',
        [user.id, user.name, user.email, user.phone, JSON.stringify(user.address), user.role, user.createdAt, user.updatedAt]
      );
    }
    
    console.log(`📊 Seeded ${count} users`);
  }

  async seedProducts(count = 50) {
    const products = ProductFactory.createMany(count);
    
    for (const product of products) {
      await this.pool.query(
        'INSERT INTO products (id, name, description, price, category, created_at, updated_at) VALUES ($1, $2, $3, $4, $5, $6, $7)',
        [product.id, product.name, product.description, product.price, product.category, product.createdAt, product.updatedAt]
      );
    }
    
    console.log(`📊 Seeded ${count} products`);
  }

  async seedOrders() {
    // 사용자와 상품을 연결한 주문 데이터 생성
    const users = await this.pool.query('SELECT id FROM users LIMIT 20');
    const products = await this.pool.query('SELECT id FROM products LIMIT 30');
    
    for (let i = 0; i < 100; i++) {
      const user = users.rows[Math.floor(Math.random() * users.rows.length)];
      const product = products.rows[Math.floor(Math.random() * products.rows.length)];
      
      await this.pool.query(
        'INSERT INTO orders (id, user_id, product_id, quantity, status, created_at) VALUES ($1, $2, $3, $4, $5, $6)',
        [faker.datatype.uuid(), user.id, product.id, faker.datatype.number({ min: 1, max: 5 }), 'pending', new Date()]
      );
    }
    
    console.log('📊 Seeded 100 orders');
  }
}

module.exports = TestDataSeeder;
```

### 2. 테스트 데이터 격리 및 정리

#### 테스트 격리 관리자
```javascript
// test/helpers/TestIsolationManager.js
class TestIsolationManager {
  constructor() {
    this.testData = new Map();
    this.cleanupTasks = [];
  }

  // 테스트 시작 시 격리 환경 설정
  async setupTestIsolation() {
    // 트랜잭션 시작
    await this.beginTransaction();
    
    // 테스트 데이터 초기화
    await this.initializeTestData();
    
    // 정리 작업 등록
    this.registerCleanupTasks();
  }

  // 테스트 종료 시 격리 환경 정리
  async cleanup() {
    try {
      // 등록된 정리 작업 실행
      for (const task of this.cleanupTasks) {
        await task();
      }
      
      // 트랜잭션 롤백
      await this.rollbackTransaction();
      
      console.log('✅ Test isolation cleanup completed');
    } catch (error) {
      console.error('❌ Error during test cleanup:', error);
    }
  }

  async beginTransaction() {
    // 데이터베이스 트랜잭션 시작
    this.transaction = await this.pool.query('BEGIN');
  }

  async rollbackTransaction() {
    // 트랜잭션 롤백으로 모든 변경사항 취소
    await this.pool.query('ROLLBACK');
  }

  // 테스트 데이터 생성 및 추적
  async createTestData(type, data) {
    const record = await this.insertRecord(type, data);
    
    // 생성된 데이터를 추적하여 정리 시 사용
    if (!this.testData.has(type)) {
      this.testData.set(type, []);
    }
    this.testData.get(type).push(record.id);
    
    return record;
  }

  registerCleanupTasks() {
    // 데이터베이스 정리
    this.cleanupTasks.push(async () => {
      for (const [type, ids] of this.testData) {
        await this.deleteRecords(type, ids);
      }
    });

    // 파일 시스템 정리
    this.cleanupTasks.push(async () => {
      await this.cleanupTestFiles();
    });

    // 외부 서비스 정리
    this.cleanupTasks.push(async () => {
      await this.cleanupExternalServices();
    });
  }
}

module.exports = TestIsolationManager;
```

---

## CI/CD 파이프라인에서의 품질 게이트

### 1. 품질 게이트 정의 및 설정

#### 품질 게이트 매니저
```javascript
// scripts/quality-gate-manager.js
class QualityGateManager {
  constructor() {
    this.gates = {
      unitTests: {
        threshold: 90, // 90% 이상 통과
        weight: 30
      },
      integrationTests: {
        threshold: 85, // 85% 이상 통과
        weight: 25
      },
      codeCoverage: {
        threshold: 80, // 80% 이상 커버리지
        weight: 20
      },
      securityScan: {
        threshold: 0, // 보안 취약점 0개
        weight: 15
      },
      performanceTests: {
        threshold: 500, // 500ms 이하 응답시간
        weight: 10
      }
    };
  }

  async evaluateQuality(allResults) {
    const scores = {};
    let totalScore = 0;
    let totalWeight = 0;

    for (const [gateName, config] of Object.entries(this.gates)) {
      const result = allResults[gateName];
      const score = this.calculateGateScore(gateName, result, config);
      
      scores[gateName] = {
        score,
        passed: score >= config.threshold,
        weight: config.weight
      };
      
      totalScore += score * config.weight;
      totalWeight += config.weight;
    }

    const overallScore = totalWeight > 0 ? totalScore / totalWeight : 0;
    const passed = Object.values(scores).every(gate => gate.passed);

    return {
      overallScore,
      passed,
      gates: scores,
      recommendation: this.generateRecommendation(scores)
    };
  }

  calculateGateScore(gateName, result, config) {
    switch (gateName) {
      case 'unitTests':
        return (result.passed / result.total) * 100;
      
      case 'codeCoverage':
        return result.percentage;
      
      case 'securityScan':
        return result.vulnerabilities === 0 ? 100 : Math.max(0, 100 - result.vulnerabilities * 10);
      
      case 'performanceTests':
        return result.averageResponseTime <= config.threshold ? 100 : 
               Math.max(0, 100 - ((result.averageResponseTime - config.threshold) / config.threshold) * 100);
      
      default:
        return (result.passed / result.total) * 100;
    }
  }
}
```

### 2. GitHub Actions 품질 게이트 파이프라인

#### GitHub Actions 워크플로우
```yaml
# .github/workflows/quality-gate.yml
name: Quality Gate Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  quality-gate:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'
        
    - name: Install dependencies
      run: npm ci
      
    # 1. 코드 품질 검사
    - name: Code Quality Check
      run: |
        npm run lint
        npm run type-check
        
    # 2. 단위 테스트
    - name: Unit Tests
      run: |
        npm run test:unit -- --coverage --passWithNoTests
        
    # 3. 통합 테스트
    - name: Integration Tests
      run: |
        npm run test:integration
        
    # 4. E2E 테스트 (필요시)
    - name: E2E Tests
      run: |
        npm run test:e2e
      if: github.event_name == 'push' && github.ref == 'refs/heads/main'
      
    # 5. 성능 테스트
    - name: Performance Tests
      run: |
        npm run test:performance
      if: github.event_name == 'push'
      
    # 6. 보안 스캔
    - name: Security Scan
      run: |
        npm audit --audit-level=high
        npm run security:scan
        
    # 7. 빌드 검증
    - name: Build Verification
      run: |
        npm run build
        
    # 8. 품질 게이트 평가
    - name: Quality Gate Evaluation
      run: |
        node scripts/evaluate-quality-gate.js
        
    # 9. 결과 보고
    - name: Quality Report
      if: always()
      uses: actions/upload-artifact@v3
      with:
        name: quality-report
        path: quality-report.json
        
    # 10. 품질 게이트 실패 시 빌드 중단
    - name: Fail if quality gate failed
      run: |
        if [ -f quality-report.json ]; then
          QUALITY_PASSED=$(node -p "require('./quality-report.json').passed")
          if [ "$QUALITY_PASSED" != "true" ]; then
            echo "❌ Quality gate failed"
            exit 1
          fi
        fi
```

### 3. 품질 게이트 자동화 스크립트

#### 품질 게이트 평가 스크립트
```javascript
// scripts/evaluate-quality-gate.js
const { execSync } = require('child_process');
const fs = require('fs');
const QualityGateManager = require('./quality-gate-manager');

async function evaluateQualityGate() {
  console.log('🔍 Evaluating quality gates...');
  
  const qualityManager = new QualityGateManager();
  const results = {};
  
  try {
    // 1. 단위 테스트 결과 수집
    console.log('📊 Collecting unit test results...');
    results.unitTests = await collectUnitTestResults();
    
    // 2. 통합 테스트 결과 수집
    console.log('🔗 Collecting integration test results...');
    results.integrationTests = await collectIntegrationTestResults();
    
    // 3. 코드 커버리지 수집
    console.log('📈 Collecting code coverage...');
    results.codeCoverage = await collectCoverageResults();
    
    // 4. 보안 스캔 결과 수집
    console.log('🔒 Collecting security scan results...');
    results.securityScan = await collectSecurityScanResults();
    
    // 5. 성능 테스트 결과 수집
    console.log('⚡ Collecting performance test results...');
    results.performanceTests = await collectPerformanceResults();
    
    // 6. 품질 게이트 평가
    console.log('⚖️ Evaluating quality gates...');
    const evaluation = await qualityManager.evaluateQuality(results);
    
    // 7. 결과 저장
    fs.writeFileSync('quality-report.json', JSON.stringify(evaluation, null, 2));
    
    // 8. 결과 출력
    printQualityReport(evaluation);
    
    // 9. 품질 게이트 통과 여부에 따른 종료 코드 설정
    process.exit(evaluation.passed ? 0 : 1);
    
  } catch (error) {
    console.error('❌ Error evaluating quality gates:', error);
    process.exit(1);
  }
}

async function collectUnitTestResults() {
  try {
    const output = execSync('npm run test:unit -- --json', { encoding: 'utf8' });
    const results = JSON.parse(output);
    
    return {
      total: results.numTotalTests,
      passed: results.numPassedTests,
      failed: results.numFailedTests,
      percentage: (results.numPassedTests / results.numTotalTests) * 100
    };
  } catch (error) {
    console.error('Failed to collect unit test results:', error.message);
    return { total: 0, passed: 0, failed: 0, percentage: 0 };
  }
}

async function collectCoverageResults() {
  try {
    const output = execSync('npm run test:coverage', { encoding: 'utf8' });
    
    // 커버리지 결과에서 퍼센티지 추출
    const coverageMatch = output.match(/All files[^|]*\|([^|]*)/);
    if (coverageMatch) {
      const coverage = parseFloat(coverageMatch[1]);
      return { percentage: coverage };
    }
    
    return { percentage: 0 };
  } catch (error) {
    console.error('Failed to collect coverage results:', error.message);
    return { percentage: 0 };
  }
}

function printQualityReport(evaluation) {
  console.log('\n📋 Quality Gate Report');
  console.log('========================');
  console.log(`Overall Score: ${evaluation.overallScore.toFixed(1)}%`);
  console.log(`Status: ${evaluation.passed ? '✅ PASSED' : '❌ FAILED'}`);
  console.log('\nGate Details:');
  
  for (const [gateName, gate] of Object.entries(evaluation.gates)) {
    const status = gate.passed ? '✅' : '❌';
    console.log(`  ${status} ${gateName}: ${gate.score.toFixed(1)}% (threshold: ${this.gates[gateName].threshold}%)`);
  }
  
  if (evaluation.recommendation) {
    console.log(`\n💡 Recommendation: ${evaluation.recommendation}`);
  }
}

// 스크립트 실행
if (require.main === module) {
  evaluateQualityGate();
}

module.exports = { evaluateQualityGate };
```

---

## 결론

테스트 자동화 및 품질 보증은 지속적인 소프트웨어 품질 향상을 위한 핵심 요소입니다.

### 핵심 원칙 요약

1. **테스트 피라미드**: 단위 테스트 70%, 통합 테스트 20%, E2E 테스트 10%
2. **자동화 우선**: 모든 테스트를 CI/CD 파이프라인에 통합
3. **품질 게이트**: 자동화된 품질 검증 및 배포 차단
4. **환경 격리**: 일관된 테스트 환경 구축 및 관리
5. **데이터 관리**: 체계적인 테스트 데이터 생성 및 정리

### 실무 적용 가이드

- **개발 단계**: 테스트 우선 개발 및 지속적 통합
- **테스트 단계**: 자동화된 테스트 실행 및 결과 분석
- **배포 단계**: 품질 게이트를 통한 자동 배포 제어

이러한 원칙들을 바탕으로 신뢰성 높은 소프트웨어를 지속적으로 배포할 수 있습니다.

