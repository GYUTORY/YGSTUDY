---
title: PM2 Cluster Mode
tags: [framework, node, process-management-tool, pm2, clustermode]
updated: 2025-12-02
---

# PM2 클러스터 모드 (Cluster Mode)

## 목차
- [개념 이해](#개념-이해)
- [기본 사용법](#기본-사용법)
- [설정 파일 활용](#설정-파일-활용)
- [주요 명령어](#주요-명령어)
- [모니터링 및 관리](#모니터링-및-관리)
- [동작 원리](#동작-원리)
- [실제 사용 예시](#실제-사용-예시)
- [주의사항 및 고려사항](#주의사항-및-고려사항)
- [장점 및 특징](#장점-및-특징)

---

## 개념 이해

### PM2 클러스터 모드란?

PM2의 클러스터 모드는 단일 애플리케이션을 여러 인스턴스로 실행하여 멀티코어 CPU를 활용하는 방식입니다. Node.js는 기본적으로 싱글 스레드로 동작하므로, 단일 프로세스는 하나의 CPU 코어만 사용할 수 있습니다. 클러스터 모드를 사용하면 모든 CPU 코어를 활용하여 처리량을 크게 향상시킬 수 있습니다.

**핵심 특징:**
- **로드 밸런싱**: 요청을 각 인스턴스에 고르게 분배
- **CPU 최대 활용**: Node.js 싱글 스레드 한계 극복
- **자동 장애 복구**: 프로세스 중단 시 자동 재시작
- **간편한 관리**: 설정 파일을 통한 중앙 집중식 관리

### 왜 클러스터 모드가 필요한가?

Node.js는 이벤트 루프 기반의 비동기 처리로 높은 동시성을 제공하지만, CPU 집약적인 작업에서는 단일 코어의 한계가 있습니다. 클러스터 모드를 사용하면:

1. **성능 향상**: 여러 CPU 코어를 동시에 활용하여 처리량 증가
2. **안정성 증대**: 하나의 프로세스가 크래시되어도 다른 프로세스가 계속 서비스 제공
3. **확장성**: CPU 코어 수에 따라 자동으로 인스턴스 수 조정

---

## 기본 사용법

### 1. 모든 CPU 코어 활용

```bash
pm2 start app.js -i max
```

이 명령어는 시스템의 모든 CPU 코어 수만큼 인스턴스를 생성합니다.

### 2. 특정 인스턴스 개수 지정

```bash
pm2 start app.js -i 4
```

4개의 인스턴스를 실행합니다. CPU 코어 수보다 많은 인스턴스를 지정할 수 있지만, 일반적으로 코어 수와 동일하거나 그 이하로 설정하는 것이 효율적입니다.

### 3. CPU 코어 수만큼 자동 설정

```bash
pm2 start app.js -i 0
```

`0`을 지정하면 CPU 코어 수만큼 자동으로 인스턴스가 생성됩니다. `max`와 동일한 효과입니다.

### 4. 애플리케이션 이름 지정

```bash
pm2 start app.js --name "my-app" -i max
```

애플리케이션에 이름을 지정하면 관리가 용이해집니다.

**옵션 설명:**
- `-i max`: 사용 가능한 모든 CPU 코어 사용
- `-i 4`: 4개의 인스턴스 실행
- `-i 0`: CPU 코어 수만큼 자동 설정
- `--name`: 애플리케이션 이름 지정

---

## 설정 파일 활용

### ecosystem.config.js 생성

설정 파일을 사용하면 더 체계적으로 클러스터 모드를 관리할 수 있습니다.

```javascript
module.exports = {
  apps: [
    {
      name: "my-cluster-app",        // 애플리케이션 이름
      script: "app.js",              // 실행할 파일
      instances: "max",              // 모든 CPU 코어 사용
      exec_mode: "cluster",          // 클러스터 모드 활성화
      watch: false,                  // 프로덕션에서는 false 권장
      max_memory_restart: "1G",      // 메모리 초과 시 재시작
      min_uptime: "10s",             // 최소 실행 시간
      max_restarts: 10,              // 최대 재시작 횟수
      autorestart: true,             // 자동 재시작 활성화
      env: {                         // 기본 환경 변수
        NODE_ENV: "development",
        PORT: 3000
      },
      env_production: {              // 프로덕션 환경 변수
        NODE_ENV: "production",
        PORT: 3000
      },
      error_file: "./logs/err.log",  // 에러 로그 파일
      out_file: "./logs/out.log",    // 출력 로그 파일
      log_file: "./logs/combined.log", // 통합 로그 파일
      time: true,                    // 로그에 타임스탬프 추가
      log_date_format: "YYYY-MM-DD HH:mm:ss Z",
      merge_logs: true,              // 모든 인스턴스 로그 병합
      ignore_watch: ["node_modules", "logs"] // 감시 제외 디렉토리
    }
  ]
}
```

### 설정 파일로 실행

```bash
# 기본 실행
pm2 start ecosystem.config.js

# 프로덕션 환경으로 실행
pm2 start ecosystem.config.js --env production

# 설정 파일로 재시작
pm2 restart ecosystem.config.js

# 설정 파일로 무중단 재시작
pm2 reload ecosystem.config.js
```

---

## 주요 명령어

### 프로세스 관리

| 명령어 | 설명 | 예시 |
|--------|------|------|
| `pm2 list` | 실행 중인 프로세스 목록 확인 | `pm2 list` |
| `pm2 show <id>` | 특정 프로세스 상세 정보 | `pm2 show 0` |
| `pm2 stop <id>` | 프로세스 중지 | `pm2 stop all` |
| `pm2 restart <id>` | 프로세스 재시작 | `pm2 restart all` |
| `pm2 reload <id>` | 무중단 재시작 (롤링 재시작) | `pm2 reload all` |
| `pm2 delete <id>` | 프로세스 삭제 | `pm2 delete all` |
| `pm2 scale <name> <number>` | 클러스터 크기 조정 | `pm2 scale my-app 4` |

### 로그 관리

| 명령어 | 설명 | 예시 |
|--------|------|------|
| `pm2 logs` | 모든 로그 확인 | `pm2 logs` |
| `pm2 logs <id>` | 특정 프로세스 로그 | `pm2 logs 0` |
| `pm2 logs --lines <n>` | 최근 N줄 로그 확인 | `pm2 logs --lines 100` |
| `pm2 logs --follow` | 실시간 로그 스트리밍 | `pm2 logs --follow` |
| `pm2 flush` | 로그 파일 초기화 | `pm2 flush` |

### 모니터링

| 명령어 | 설명 | 예시 |
|--------|------|------|
| `pm2 monit` | 실시간 모니터링 대시보드 | `pm2 monit` |
| `pm2 status` | 프로세스 상태 확인 | `pm2 status` |
| `pm2 show <id>` | 프로세스 상세 정보 | `pm2 show 0` |

---

## 모니터링 및 관리

### PM2 대시보드 실행

```bash
pm2 monit
```

대시보드에서 확인 가능한 정보:
- CPU 사용률 (각 인스턴스별)
- 메모리 사용량 (각 인스턴스별)
- 프로세스 상태
- 실시간 로그
- 재시작 횟수
- 업타임

### 로그 확인 및 관리

```bash
# 모든 로그 확인
pm2 logs

# 최근 100줄 로그 확인
pm2 logs --lines 100

# 특정 애플리케이션의 최근 50줄 로그
pm2 logs my-app --lines 50

# 실시간 로그 스트리밍
pm2 logs --follow

# JSON 형식으로 로그 출력
pm2 logs --json
```

### 클러스터 크기 동적 조정

```bash
# 실행 중인 애플리케이션의 인스턴스 수 변경
pm2 scale my-app 4

# 인스턴스 수 증가
pm2 scale my-app +2

# 인스턴스 수 감소
pm2 scale my-app -1
```

---

## 동작 원리

### 클러스터 모드의 구조

PM2 클러스터 모드는 Node.js의 내장 `cluster` 모듈을 기반으로 동작합니다:

1. **마스터 프로세스**: PM2가 생성하는 메인 프로세스로, 워커 프로세스들을 관리합니다.
2. **워커 프로세스**: 실제 애플리케이션 코드를 실행하는 프로세스들입니다.

### 로드 밸런싱 방식

PM2는 라운드 로빈(Round Robin) 방식으로 요청을 분배합니다:
- 각 워커 프로세스가 순차적으로 요청을 처리
- 운영체제 레벨에서 TCP 연결을 각 워커에 분배
- 모든 워커가 동일한 포트를 공유

### 무중단 재시작 (Reload) 프로세스

`pm2 reload` 명령을 실행하면:

1. **순차적 재시작**: PM2는 한 번에 하나씩 워커 프로세스를 재시작합니다.
2. **로드 밸런싱**: 활성 상태인 다른 워커들이 요청을 처리합니다.
3. **헬스 체크**: 새로운 워커가 정상적으로 시작되면 다음 워커를 재시작합니다.
4. **완료**: 모든 워커가 새로운 코드로 업데이트됩니다.

이 과정에서 서비스 중단 없이 애플리케이션을 업데이트할 수 있습니다.

### reload vs restart

- **reload**: 무중단 재시작. 워커 프로세스를 순차적으로 재시작하여 서비스 중단 없이 업데이트합니다.
- **restart**: 일반 재시작. 모든 프로세스를 동시에 재시작하여 일시적인 서비스 중단이 발생할 수 있습니다.

---

## 실제 사용 예시

### 1. Express.js 애플리케이션 클러스터 모드 실행

```javascript
// app.js
const express = require('express');
const app = express();
const port = process.env.PORT || 3000;

app.get('/', (req, res) => {
  res.json({
    message: 'Hello from PM2 Cluster Mode!',
    processId: process.pid,
    instanceId: process.env.NODE_APP_INSTANCE || 0,
    timestamp: new Date().toISOString()
  });
});

app.get('/health', (req, res) => {
  res.status(200).json({
    status: 'OK',
    processId: process.pid,
    uptime: process.uptime(),
    memory: process.memoryUsage()
  });
});

app.listen(port, () => {
  console.log(`Server running on port ${port} with PID: ${process.pid}`);
});
```

### 2. 프로덕션 환경 설정

```javascript
// ecosystem.config.js
module.exports = {
  apps: [
    {
      name: "api-server",
      script: "app.js",
      instances: "max",
      exec_mode: "cluster",
      env: {
        NODE_ENV: "development",
        PORT: 3000
      },
      env_production: {
        NODE_ENV: "production",
        PORT: 3000
      },
      max_memory_restart: "1G",
      min_uptime: "10s",
      max_restarts: 10,
      autorestart: true,
      watch: false,
      ignore_watch: ["node_modules", "logs", ".git"],
      log_date_format: "YYYY-MM-DD HH:mm:ss Z",
      error_file: "./logs/err.log",
      out_file: "./logs/out.log",
      log_file: "./logs/combined.log",
      time: true,
      merge_logs: true,
      node_args: "--max-old-space-size=1024"
    }
  ]
};
```

### 3. 배포 스크립트 예시

```bash
#!/bin/bash
# deploy.sh

echo "Starting deployment..."

# 기존 애플리케이션 중지
pm2 stop api-server

# 코드 업데이트 (git pull 등)
git pull origin main

# 의존성 설치
npm install --production

# 무중단 재시작
pm2 reload ecosystem.config.js --env production

# 상태 확인
pm2 status

echo "Deployment completed!"
```

---

## 주의사항 및 고려사항

### 메모리 사용량

각 인스턴스가 독립적인 메모리 공간을 사용하므로, 전체 메모리 사용량은 다음과 같습니다:

```
전체 메모리 사용량 = 인스턴스 수 × 단일 인스턴스 메모리
```

예를 들어, 4개의 인스턴스가 각각 200MB를 사용하면 총 800MB의 메모리가 필요합니다. 서버의 메모리 용량을 고려하여 인스턴스 수를 조정해야 합니다.

### 세션 관리

클러스터 모드에서는 각 워커 프로세스가 독립적인 메모리 공간을 가지므로, 메모리 기반 세션 스토리지를 사용하면 문제가 발생할 수 있습니다. 사용자가 요청할 때마다 다른 워커로 라우팅될 수 있기 때문입니다.

**해결 방법:**
- Redis, Memcached 등의 외부 세션 스토리지 사용
- JWT(JSON Web Token) 같은 stateless 인증 방식 사용
- Sticky session 사용 (권장하지 않음, 로드 밸런싱 효율 저하)

### 파일 업로드 및 임시 파일

파일 업로드 시 각 워커 프로세스가 독립적인 파일 시스템을 가지므로, 임시 파일 관리에 주의해야 합니다.

**해결 방법:**
- 공유 스토리지 사용 (NFS, S3 등)
- 파일 업로드 후 즉시 공유 스토리지로 이동
- 각 워커가 접근 가능한 공통 디렉토리 사용

### 상태 공유

워커 프로세스 간에 상태를 공유해야 하는 경우, 메모리 기반 저장소를 사용할 수 없습니다.

**해결 방법:**
- Redis, Memcached 등의 외부 캐시 사용
- 데이터베이스 사용
- 메시지 큐를 통한 프로세스 간 통신

### CPU 코어 수 고려

일반적으로 인스턴스 수는 CPU 코어 수와 동일하게 설정하는 것이 효율적입니다. CPU 코어 수보다 많은 인스턴스를 실행하면 컨텍스트 스위칭 오버헤드가 발생할 수 있습니다.

```bash
# CPU 코어 수 확인
node -e "console.log(require('os').cpus().length)"

# 또는
nproc  # Linux
sysctl -n hw.ncpu  # macOS
```

### 포트 바인딩

클러스터 모드에서는 모든 워커 프로세스가 동일한 포트를 공유합니다. 운영체제가 TCP 연결을 각 워커에 분배합니다. 따라서 애플리케이션 코드에서 포트를 직접 바인딩하면 안 되며, 마스터 프로세스가 이를 처리합니다.

---

## 장점 및 특징

### 성능 향상

- **CPU 코어 최대 활용**: 모든 코어를 사용하여 처리량 증가
- **로드 밸런싱**: 요청을 여러 프로세스에 분산하여 부하 분산
- **응답 시간 단축**: 병렬 처리로 인한 성능 향상
- **동시 처리 능력 향상**: 여러 요청을 동시에 처리

### 안정성 증대

- **자동 장애 복구**: 프로세스 중단 시 자동 재시작
- **무중단 배포**: 롤링 업데이트 지원으로 서비스 중단 없이 배포 가능
- **메모리 관리**: 메모리 초과 시 자동 재시작으로 메모리 누수 방지
- **고가용성**: 하나의 프로세스가 실패해도 다른 프로세스가 서비스 계속 제공

### 개발 편의성

- **간편한 설정**: JSON 설정 파일로 직관적 관리
- **실시간 모니터링**: 대시보드를 통한 상태 확인
- **로그 관리**: 중앙집중식 로그 수집 및 관리
- **동적 스케일링**: 실행 중에도 인스턴스 수 조정 가능

---

## 참고 자료

- [PM2 공식 문서](https://pm2.keymetrics.io/)
- [PM2 GitHub Repository](https://github.com/Unitech/pm2)
- [Node.js Cluster Module](https://nodejs.org/api/cluster.html)
