---
title: ë¶„ì‚° íŠ¸ëœì­ì…˜ ì „ëµ
tags: [framework, node, distributed-transaction, saga, event-sourcing, cqrs, consistency]
updated: 2025-11-24
---

# ğŸ”„ ë¶„ì‚° íŠ¸ëœì­ì…˜ ì „ëµ

## ğŸ“Œ ê°œìš”

> **ë¶„ì‚° íŠ¸ëœì­ì…˜**ì€ ì—¬ëŸ¬ ì„œë¹„ìŠ¤ë‚˜ ë°ì´í„°ë² ì´ìŠ¤ì— ê±¸ì³ ë°ì´í„° ì¼ê´€ì„±ì„ ë³´ì¥í•˜ëŠ” ë³µì¡í•œ ë¬¸ì œì…ë‹ˆë‹¤. Node.js í™˜ê²½ì—ì„œ ì‹¤ìš©ì ì¸ ë¶„ì‚° íŠ¸ëœì­ì…˜ íŒ¨í„´ì„ ë‹¤ë£¹ë‹ˆë‹¤.

### ğŸ¯ ë¶„ì‚° íŠ¸ëœì­ì…˜ì˜ ë„ì „ ê³¼ì œ

```mermaid
mindmap
  root((ë¶„ì‚° íŠ¸ëœì­ì…˜))
    ì¼ê´€ì„±
      ACID ë³´ì¥ ì–´ë ¤ì›€
      ë„¤íŠ¸ì›Œí¬ ì§€ì—°
      ë¶€ë¶„ ì‹¤íŒ¨
    ì„±ëŠ¥
      2PC ì˜¤ë²„í—¤ë“œ
      ë½ ê²½í•©
      ì‘ë‹µ ì‹œê°„ ì¦ê°€
    ë³µì¡ì„±
      ìƒíƒœ ê´€ë¦¬
      ë¡¤ë°± ì²˜ë¦¬
      ì¥ì•  ë³µêµ¬
```

### ğŸ“Š ë¶„ì‚° íŠ¸ëœì­ì…˜ íŒ¨í„´

```mermaid
graph TD
    A[ë¶„ì‚° íŠ¸ëœì­ì…˜] --> B[Saga íŒ¨í„´]
    A --> C[ì´ë²¤íŠ¸ ì†Œì‹±]
    A --> D[CQRS]
    A --> E[ìµœì¢… ì¼ê´€ì„±]
    
    B --> F[Choreography]
    B --> G[Orchestration]
    
    C --> H[ì´ë²¤íŠ¸ ì €ì¥]
    C --> I[ìƒíƒœ ì¬êµ¬ì„±]
    
    D --> J[ì½ê¸°/ì“°ê¸° ë¶„ë¦¬]
    D --> K[ì´ë²¤íŠ¸ ê¸°ë°˜]
    
    style A fill:#4fc3f7
    style B fill:#66bb6a
    style C fill:#ff9800
    style D fill:#9c27b0
```

## ğŸ­ Saga íŒ¨í„´

### Saga íŒ¨í„´ ê°œìš”

Saga íŒ¨í„´ì€ ê¸´ íŠ¸ëœì­ì…˜ì„ ì—¬ëŸ¬ ì‘ì€ íŠ¸ëœì­ì…˜ìœ¼ë¡œ ë¶„í• í•˜ê³ , ê° ë‹¨ê³„ë§ˆë‹¤ ë³´ìƒ(Compensating) íŠ¸ëœì­ì…˜ì„ ì •ì˜í•˜ëŠ” íŒ¨í„´ì…ë‹ˆë‹¤.

```mermaid
sequenceDiagram
    participant O as Orchestrator
    participant U as User Service
    participant I as Inventory Service
    participant P as Payment Service
    participant O2 as Order Service
    
    O->>U: ì‚¬ìš©ì ê²€ì¦
    U-->>O: ì„±ê³µ
    O->>I: ì¬ê³  ì°¨ê°
    I-->>O: ì„±ê³µ
    O->>P: ê²°ì œ ì²˜ë¦¬
    P-->>O: ì‹¤íŒ¨
    
    Note over O,P: ë³´ìƒ íŠ¸ëœì­ì…˜ ì‹œì‘
    O->>I: ì¬ê³  ë³µêµ¬
    O->>U: ì‚¬ìš©ì ìƒíƒœ ë³µêµ¬
```

### Orchestration íŒ¨í„´

#### Saga Orchestrator êµ¬í˜„

```javascript
class SagaOrchestrator {
  constructor() {
    this.sagas = new Map();
    this.executions = new Map();
  }
  
  // Saga ì •ì˜
  defineSaga(name, steps) {
    this.sagas.set(name, {
      steps,
      compensations: new Map()
    });
  }
  
  // Saga ì‹¤í–‰
  async execute(sagaName, initialData) {
    const saga = this.sagas.get(sagaName);
    if (!saga) {
      throw new Error(`Saga ${sagaName} not found`);
    }
    
    const executionId = this.generateExecutionId();
    const execution = {
      id: executionId,
      sagaName,
      steps: [],
      currentStep: 0,
      data: initialData,
      status: 'running'
    };
    
    this.executions.set(executionId, execution);
    
    try {
      // ê° ë‹¨ê³„ ì‹¤í–‰
      for (let i = 0; i < saga.steps.length; i++) {
        execution.currentStep = i;
        const step = saga.steps[i];
        
        const result = await this.executeStep(step, execution.data);
        execution.steps.push({
          step: step.name,
          result,
          completed: true
        });
        
        // ê²°ê³¼ë¥¼ ë‹¤ìŒ ë‹¨ê³„ë¡œ ì „ë‹¬
        execution.data = { ...execution.data, ...result };
      }
      
      execution.status = 'completed';
      return execution;
    } catch (error) {
      execution.status = 'failed';
      execution.error = error.message;
      
      // ë³´ìƒ íŠ¸ëœì­ì…˜ ì‹¤í–‰
      await this.compensate(executionId);
      
      throw error;
    }
  }
  
  // ë‹¨ê³„ ì‹¤í–‰
  async executeStep(step, data) {
    try {
      const result = await step.action(data);
      return result;
    } catch (error) {
      throw new Error(`Step ${step.name} failed: ${error.message}`);
    }
  }
  
  // ë³´ìƒ íŠ¸ëœì­ì…˜
  async compensate(executionId) {
    const execution = this.executions.get(executionId);
    if (!execution) return;
    
    const saga = this.sagas.get(execution.sagaName);
    
    // ì—­ìˆœìœ¼ë¡œ ë³´ìƒ ì‹¤í–‰
    for (let i = execution.currentStep; i >= 0; i--) {
      const step = saga.steps[i];
      if (step.compensate && execution.steps[i]?.completed) {
        try {
          await step.compensate(execution.data);
          console.log(`Compensated step: ${step.name}`);
        } catch (error) {
          console.error(`Compensation failed for ${step.name}:`, error);
        }
      }
    }
    
    execution.status = 'compensated';
  }
  
  generateExecutionId() {
    return `saga-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
}

// ì£¼ë¬¸ ìƒì„± Saga ì •ì˜
const orchestrator = new SagaOrchestrator();

orchestrator.defineSaga('createOrder', [
  {
    name: 'validateUser',
    action: async (data) => {
      const user = await userService.getUser(data.userId);
      if (!user || user.status !== 'active') {
        throw new Error('Invalid user');
      }
      return { user };
    },
    compensate: async (data) => {
      // ì‚¬ìš©ì ê²€ì¦ì€ ë³´ìƒ ë¶ˆí•„ìš”
    }
  },
  {
    name: 'reserveInventory',
    action: async (data) => {
      const reservation = await inventoryService.reserve(data.items);
      return { reservationId: reservation.id };
    },
    compensate: async (data) => {
      await inventoryService.release(data.reservationId);
    }
  },
  {
    name: 'processPayment',
    action: async (data) => {
      const payment = await paymentService.charge({
        userId: data.userId,
        amount: data.total
      });
      return { paymentId: payment.id };
    },
    compensate: async (data) => {
      await paymentService.refund(data.paymentId);
    }
  },
  {
    name: 'createOrder',
    action: async (data) => {
      const order = await orderService.create({
        userId: data.userId,
        items: data.items,
        reservationId: data.reservationId,
        paymentId: data.paymentId
      });
      return { orderId: order.id };
    },
    compensate: async (data) => {
      await orderService.cancel(data.orderId);
    }
  }
]);

// Saga ì‹¤í–‰
const result = await orchestrator.execute('createOrder', {
  userId: '123',
  items: [{ productId: '1', quantity: 2 }],
  total: 10000
});
```

### Choreography íŒ¨í„´

#### ì´ë²¤íŠ¸ ê¸°ë°˜ Saga

```javascript
class SagaChoreography {
  constructor(eventBus) {
    this.eventBus = eventBus;
    this.sagaState = new Map();
    this.setupEventHandlers();
  }
  
  setupEventHandlers() {
    // ì£¼ë¬¸ ìƒì„± ì´ë²¤íŠ¸
    this.eventBus.subscribe('order.create.initiated', async (event) => {
      const sagaId = event.data.sagaId;
      this.sagaState.set(sagaId, {
        status: 'started',
        steps: []
      });
      
      // ì‚¬ìš©ì ê²€ì¦ ì´ë²¤íŠ¸ ë°œí–‰
      await this.eventBus.publish('user.validate.requested', {
        sagaId,
        userId: event.data.userId
      });
    });
    
    // ì‚¬ìš©ì ê²€ì¦ ì™„ë£Œ
    this.eventBus.subscribe('user.validate.completed', async (event) => {
      const sagaId = event.data.sagaId;
      this.updateSagaState(sagaId, 'userValidated', event.data);
      
      // ì¬ê³  ì˜ˆì•½ ì´ë²¤íŠ¸ ë°œí–‰
      await this.eventBus.publish('inventory.reserve.requested', {
        sagaId,
        items: event.data.items
      });
    });
    
    // ì¬ê³  ì˜ˆì•½ ì™„ë£Œ
    this.eventBus.subscribe('inventory.reserve.completed', async (event) => {
      const sagaId = event.data.sagaId;
      this.updateSagaState(sagaId, 'inventoryReserved', event.data);
      
      // ê²°ì œ ì²˜ë¦¬ ì´ë²¤íŠ¸ ë°œí–‰
      await this.eventBus.publish('payment.process.requested', {
        sagaId,
        userId: event.data.userId,
        amount: event.data.total
      });
    });
    
    // ê²°ì œ ì²˜ë¦¬ ì™„ë£Œ
    this.eventBus.subscribe('payment.process.completed', async (event) => {
      const sagaId = event.data.sagaId;
      this.updateSagaState(sagaId, 'paymentProcessed', event.data);
      
      // ì£¼ë¬¸ ìƒì„± ì´ë²¤íŠ¸ ë°œí–‰
      await this.eventBus.publish('order.create.requested', {
        sagaId,
        ...event.data
      });
    });
    
    // ì—ëŸ¬ ì²˜ë¦¬
    this.eventBus.subscribe('saga.failed', async (event) => {
      await this.compensate(event.data.sagaId);
    });
  }
  
  updateSagaState(sagaId, step, data) {
    const state = this.sagaState.get(sagaId);
    if (state) {
      state.steps.push({ step, data, timestamp: Date.now() });
    }
  }
  
  async compensate(sagaId) {
    const state = this.sagaState.get(sagaId);
    if (!state) return;
    
    // ì—­ìˆœìœ¼ë¡œ ë³´ìƒ ì´ë²¤íŠ¸ ë°œí–‰
    const steps = state.steps.reverse();
    
    for (const step of steps) {
      if (step.step === 'inventoryReserved') {
        await this.eventBus.publish('inventory.release.requested', {
          sagaId,
          reservationId: step.data.reservationId
        });
      } else if (step.step === 'paymentProcessed') {
        await this.eventBus.publish('payment.refund.requested', {
          sagaId,
          paymentId: step.data.paymentId
        });
      }
    }
  }
}
```

## ğŸ“ ì´ë²¤íŠ¸ ì†Œì‹±

### ì´ë²¤íŠ¸ ì†Œì‹± ê°œë…

ì´ë²¤íŠ¸ ì†Œì‹±ì€ ìƒíƒœ ë³€ê²½ì„ ì´ë²¤íŠ¸ë¡œ ì €ì¥í•˜ê³ , ì´ë²¤íŠ¸ë¥¼ ì¬ìƒí•˜ì—¬ í˜„ì¬ ìƒíƒœë¥¼ ì¬êµ¬ì„±í•˜ëŠ” íŒ¨í„´ì…ë‹ˆë‹¤.

```mermaid
graph LR
    A[ëª…ë ¹] --> B[ì´ë²¤íŠ¸ ìƒì„±]
    B --> C[ì´ë²¤íŠ¸ ì €ì¥]
    C --> D[ìƒíƒœ ì¬êµ¬ì„±]
    
    E[ì´ë²¤íŠ¸ ìŠ¤íŠ¸ë¦¼] --> D
    
    style A fill:#4fc3f7
    style B fill:#66bb6a
    style C fill:#ff9800
    style D fill:#9c27b0
```

### ì´ë²¤íŠ¸ ì†Œì‹± êµ¬í˜„

```javascript
class EventStore {
  constructor() {
    this.events = [];
    this.projections = new Map();
  }
  
  // ì´ë²¤íŠ¸ ì €ì¥
  async append(streamId, eventType, eventData, expectedVersion = null) {
    const currentVersion = this.getStreamVersion(streamId);
    
    // ë‚™ê´€ì  ë™ì‹œì„± ì œì–´
    if (expectedVersion !== null && currentVersion !== expectedVersion) {
      throw new Error('Concurrency conflict');
    }
    
    const event = {
      streamId,
      type: eventType,
      data: eventData,
      version: currentVersion + 1,
      timestamp: Date.now(),
      id: this.generateEventId()
    };
    
    this.events.push(event);
    
    // í”„ë¡œì ì…˜ ì—…ë°ì´íŠ¸
    await this.updateProjections(event);
    
    return event;
  }
  
  // ìŠ¤íŠ¸ë¦¼ ì¡°íšŒ
  getStream(streamId) {
    return this.events
      .filter(e => e.streamId === streamId)
      .sort((a, b) => a.version - b.version);
  }
  
  // ìƒíƒœ ì¬êµ¬ì„±
  async replay(streamId, initialState = {}) {
    const events = this.getStream(streamId);
    
    return events.reduce((state, event) => {
      return this.applyEvent(state, event);
    }, initialState);
  }
  
  // ì´ë²¤íŠ¸ ì ìš©
  applyEvent(state, event) {
    switch (event.type) {
      case 'order.created':
        return {
          ...state,
          id: event.data.orderId,
          status: 'created',
          items: event.data.items
        };
      case 'order.confirmed':
        return {
          ...state,
          status: 'confirmed'
        };
      case 'order.cancelled':
        return {
          ...state,
          status: 'cancelled',
          cancelledAt: event.timestamp
        };
      default:
        return state;
    }
  }
  
  // í”„ë¡œì ì…˜ ë“±ë¡
  registerProjection(name, handler) {
    this.projections.set(name, handler);
  }
  
  // í”„ë¡œì ì…˜ ì—…ë°ì´íŠ¸
  async updateProjections(event) {
    for (const [name, handler] of this.projections) {
      await handler(event);
    }
  }
  
  getStreamVersion(streamId) {
    const stream = this.getStream(streamId);
    return stream.length > 0 ? stream[stream.length - 1].version : 0;
  }
  
  generateEventId() {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
}

// ì‚¬ìš© ì˜ˆì‹œ
const eventStore = new EventStore();

// ì£¼ë¬¸ í”„ë¡œì ì…˜
eventStore.registerProjection('order', async (event) => {
  if (event.type === 'order.created') {
    await db.orders.create({
      id: event.streamId,
      ...event.data
    });
  }
});

// ì´ë²¤íŠ¸ ì €ì¥
await eventStore.append('order-123', 'order.created', {
  orderId: 'order-123',
  userId: 'user-456',
  items: [{ productId: '1', quantity: 2 }],
  total: 10000
});

// ìƒíƒœ ì¬êµ¬ì„±
const orderState = await eventStore.replay('order-123');
```

## ğŸ“Š CQRS íŒ¨í„´

### CQRS ê°œë…

CQRS(Command Query Responsibility Segregation)ëŠ” ëª…ë ¹(Command)ê³¼ ì¡°íšŒ(Query)ë¥¼ ë¶„ë¦¬í•˜ëŠ” íŒ¨í„´ì…ë‹ˆë‹¤.

```mermaid
graph TD
    A[í´ë¼ì´ì–¸íŠ¸] --> B[Command]
    A --> C[Query]
    
    B --> D[Command Handler]
    C --> E[Query Handler]
    
    D --> F[Write Model]
    E --> G[Read Model]
    
    F --> H[ì´ë²¤íŠ¸ ë°œí–‰]
    H --> I[Read Model ì—…ë°ì´íŠ¸]
    
    style A fill:#4fc3f7
    style B fill:#ef5350,color:#fff
    style C fill:#66bb6a
    style F fill:#ff9800
    style G fill:#9c27b0
```

### CQRS êµ¬í˜„

```javascript
class CQRSBus {
  constructor(eventStore) {
    this.eventStore = eventStore;
    this.commandHandlers = new Map();
    this.queryHandlers = new Map();
    this.readModels = new Map();
  }
  
  // Command í•¸ë“¤ëŸ¬ ë“±ë¡
  registerCommand(commandType, handler) {
    this.commandHandlers.set(commandType, handler);
  }
  
  // Query í•¸ë“¤ëŸ¬ ë“±ë¡
  registerQuery(queryType, handler) {
    this.queryHandlers.set(queryType, handler);
  }
  
  // Command ì‹¤í–‰
  async executeCommand(command) {
    const handler = this.commandHandlers.get(command.type);
    if (!handler) {
      throw new Error(`Command handler not found: ${command.type}`);
    }
    
    // Command ì²˜ë¦¬
    const result = await handler(command.data);
    
    // ì´ë²¤íŠ¸ ì €ì¥
    if (result.events) {
      for (const event of result.events) {
        await this.eventStore.append(
          command.streamId,
          event.type,
          event.data
        );
      }
    }
    
    return result;
  }
  
  // Query ì‹¤í–‰
  async executeQuery(query) {
    const handler = this.queryHandlers.get(query.type);
    if (!handler) {
      throw new Error(`Query handler not found: ${query.type}`);
    }
    
    return await handler(query.data);
  }
  
  // Read Model ë“±ë¡
  registerReadModel(name, handler) {
    this.readModels.set(name, handler);
    
    // ì´ë²¤íŠ¸ êµ¬ë…
    this.eventStore.registerProjection(name, async (event) => {
      await handler(event);
    });
  }
}

// Command ì •ì˜
class CreateOrderCommand {
  constructor(userId, items, total) {
    this.type = 'createOrder';
    this.streamId = `order-${Date.now()}`;
    this.data = { userId, items, total };
  }
}

// Command Handler
async function createOrderHandler(data) {
  // ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
  const order = {
    id: generateId(),
    userId: data.userId,
    items: data.items,
    total: data.total,
    status: 'created'
  };
  
  // ì´ë²¤íŠ¸ ìƒì„±
  return {
    order,
    events: [{
      type: 'order.created',
      data: order
    }]
  };
}

// Query ì •ì˜
class GetOrderQuery {
  constructor(orderId) {
    this.type = 'getOrder';
    this.data = { orderId };
  }
}

// Query Handler (Read Modelì—ì„œ ì¡°íšŒ)
async function getOrderHandler(data) {
  // Read Modelì—ì„œ ì¡°íšŒ (ìµœì í™”ëœ ì¿¼ë¦¬)
  return await readModelDb.orders.findById(data.orderId);
}

// Read Model ì—…ë°ì´íŠ¸
async function updateOrderReadModel(event) {
  if (event.type === 'order.created') {
    await readModelDb.orders.create({
      id: event.streamId,
      ...event.data,
      createdAt: event.timestamp
    });
  } else if (event.type === 'order.status.changed') {
    await readModelDb.orders.update(event.streamId, {
      status: event.data.status,
      updatedAt: event.timestamp
    });
  }
}

// ì‚¬ìš© ì˜ˆì‹œ
const eventStore = new EventStore();
const bus = new CQRSBus(eventStore);

// í•¸ë“¤ëŸ¬ ë“±ë¡
bus.registerCommand('createOrder', createOrderHandler);
bus.registerQuery('getOrder', getOrderHandler);
bus.registerReadModel('order', updateOrderReadModel);

// Command ì‹¤í–‰
const command = new CreateOrderCommand('user-123', [...], 10000);
const result = await bus.executeCommand(command);

// Query ì‹¤í–‰
const query = new GetOrderQuery(result.order.id);
const order = await bus.executeQuery(query);
```

## ğŸ”„ ìµœì¢… ì¼ê´€ì„± ë³´ì¥

### ìµœì¢… ì¼ê´€ì„± ì „ëµ

```mermaid
graph TD
    A[ì¼ê´€ì„± ë³´ì¥] --> B[ì´ë²¤íŠ¸ ê¸°ë°˜]
    A --> C[í´ë§ ê¸°ë°˜]
    A --> D[ì›¹í›… ê¸°ë°˜]
    
    B --> E[ì‹¤ì‹œê°„ ë™ê¸°í™”]
    C --> F[ì£¼ê¸°ì  ë™ê¸°í™”]
    D --> G[ì¦‰ì‹œ ì•Œë¦¼]
    
    style A fill:#4fc3f7
    style B fill:#66bb6a
    style C fill:#ff9800
    style D fill:#9c27b0
```

#### ì´ë²¤íŠ¸ ê¸°ë°˜ ë™ê¸°í™”

```javascript
class ConsistencyManager {
  constructor(eventBus) {
    this.eventBus = eventBus;
    this.syncState = new Map();
    this.setupSyncHandlers();
  }
  
  setupSyncHandlers() {
    // ì£¼ë¬¸ ìƒì„± ì´ë²¤íŠ¸
    this.eventBus.subscribe('order.created', async (event) => {
      // ì—¬ëŸ¬ Read Model ë™ê¸°í™”
      await Promise.all([
        this.syncOrderReadModel(event),
        this.syncUserOrderCount(event),
        this.syncInventoryReadModel(event)
      ]);
    });
  }
  
  async syncOrderReadModel(event) {
    await readModelDb.orders.create({
      id: event.data.orderId,
      ...event.data
    });
  }
  
  async syncUserOrderCount(event) {
    await readModelDb.users.incrementOrderCount(event.data.userId);
  }
  
  async syncInventoryReadModel(event) {
    for (const item of event.data.items) {
      await readModelDb.inventory.decreaseStock(
        item.productId,
        item.quantity
      );
    }
  }
}
```

#### í´ë§ ê¸°ë°˜ ë™ê¸°í™”

```javascript
class PollingSync {
  constructor(sourceDb, targetDb) {
    this.sourceDb = sourceDb;
    this.targetDb = targetDb;
    this.lastSyncTime = Date.now();
  }
  
  async startSync(interval = 5000) {
    setInterval(async () => {
      await this.sync();
    }, interval);
  }
  
  async sync() {
    // ë³€ê²½ëœ ë°ì´í„° ì¡°íšŒ
    const changes = await this.sourceDb.orders.find({
      updatedAt: { $gt: new Date(this.lastSyncTime) }
    });
    
    // Read Model ë™ê¸°í™”
    for (const order of changes) {
      await this.targetDb.orders.upsert({
        id: order.id
      }, order);
    }
    
    this.lastSyncTime = Date.now();
  }
}
```

## ğŸ¯ ì‹¤ì „ ì˜ˆì œ: ì™„ì „í•œ ë¶„ì‚° íŠ¸ëœì­ì…˜ ì‹œìŠ¤í…œ

```javascript
class DistributedTransactionManager {
  constructor(eventStore, eventBus) {
    this.eventStore = eventStore;
    this.eventBus = eventBus;
    this.sagas = new Map();
    this.cqrsBus = new CQRSBus(eventStore);
  }
  
  // Saga ê¸°ë°˜ ì£¼ë¬¸ ìƒì„±
  async createOrderWithSaga(userId, items, total) {
    const sagaId = `saga-${Date.now()}`;
    
    try {
      // 1. ì‚¬ìš©ì ê²€ì¦
      const user = await this.validateUser(userId);
      
      // 2. ì¬ê³  ì˜ˆì•½
      const reservation = await this.reserveInventory(items);
      
      // 3. ê²°ì œ ì²˜ë¦¬
      const payment = await this.processPayment(userId, total);
      
      // 4. ì£¼ë¬¸ ìƒì„± (ì´ë²¤íŠ¸ ì €ì¥)
      const order = await this.cqrsBus.executeCommand(
        new CreateOrderCommand(userId, items, total)
      );
      
      return order;
    } catch (error) {
      // ë³´ìƒ íŠ¸ëœì­ì…˜
      await this.compensate(sagaId, error);
      throw error;
    }
  }
  
  async validateUser(userId) {
    const user = await userService.getUser(userId);
    if (!user || user.status !== 'active') {
      throw new Error('Invalid user');
    }
    return user;
  }
  
  async reserveInventory(items) {
    const reservation = await inventoryService.reserve(items);
    return reservation;
  }
  
  async processPayment(userId, amount) {
    const payment = await paymentService.charge(userId, amount);
    return payment;
  }
  
  async compensate(sagaId, error) {
    // ë³´ìƒ ì´ë²¤íŠ¸ ë°œí–‰
    await this.eventBus.publish('saga.compensation.started', {
      sagaId,
      error: error.message
    });
    
    // ê° ë‹¨ê³„ì˜ ë³´ìƒ ì‹¤í–‰
    // (êµ¬í˜„ ìƒëµ)
  }
}

// ì‚¬ìš© ì˜ˆì‹œ
const manager = new DistributedTransactionManager(eventStore, eventBus);

try {
  const order = await manager.createOrderWithSaga(
    'user-123',
    [{ productId: '1', quantity: 2 }],
    10000
  );
  
  console.log('Order created:', order);
} catch (error) {
  console.error('Transaction failed:', error);
  // ë³´ìƒ íŠ¸ëœì­ì…˜ì´ ìë™ ì‹¤í–‰ë¨
}
```

## ğŸ“ ê²°ë¡ 

ë¶„ì‚° íŠ¸ëœì­ì…˜ì€ ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ ì•„í‚¤í…ì²˜ì—ì„œ í•„ìˆ˜ì ì¸ íŒ¨í„´ì…ë‹ˆë‹¤.

### í•µì‹¬ í¬ì¸íŠ¸

- âœ… **Saga íŒ¨í„´**: ê¸´ íŠ¸ëœì­ì…˜ì„ ì‘ì€ ë‹¨ìœ„ë¡œ ë¶„í• 
- âœ… **ì´ë²¤íŠ¸ ì†Œì‹±**: ìƒíƒœ ë³€ê²½ì„ ì´ë²¤íŠ¸ë¡œ ì €ì¥
- âœ… **CQRS**: ëª…ë ¹ê³¼ ì¡°íšŒ ë¶„ë¦¬ë¡œ ì„±ëŠ¥ í–¥ìƒ
- âœ… **ìµœì¢… ì¼ê´€ì„±**: ì™„ë²½í•œ ì¼ê´€ì„± ëŒ€ì‹  ì‹¤ìš©ì  ì ‘ê·¼
- âœ… **ë³´ìƒ íŠ¸ëœì­ì…˜**: ì‹¤íŒ¨ ì‹œ ë¡¤ë°± ëŒ€ì‹  ë³´ìƒ

### ëª¨ë²” ì‚¬ë¡€

1. **Saga ì„ íƒ**: Orchestration (ì œì–´) vs Choreography (ììœ¨)
2. **ì´ë²¤íŠ¸ ì†Œì‹±**: ê°ì‚¬ ì¶”ì ì´ ì¤‘ìš”í•œ ê²½ìš°
3. **CQRS**: ì½ê¸°/ì“°ê¸° ë¶€í•˜ê°€ ë‹¤ë¥¸ ê²½ìš°
4. **ìµœì¢… ì¼ê´€ì„±**: ì‹¤ì‹œê°„ ì¼ê´€ì„±ë³´ë‹¤ ì„±ëŠ¥ì´ ì¤‘ìš”í•œ ê²½ìš°
5. **ë³´ìƒ ì „ëµ**: ëª¨ë“  ë‹¨ê³„ì— ë³´ìƒ ë¡œì§ ì •ì˜

### ê´€ë ¨ ë¬¸ì„œ

- [ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ í†µì‹  íŒ¨í„´](../ì•„í‚¤í…ì²˜/ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤_í†µì‹ _íŒ¨í„´.md) - ì„œë¹„ìŠ¤ ê°„ í†µì‹ 
- [ORM ì‹¬í™” ì „ëµ](./ORM_ì‹¬í™”_ì „ëµ.md) - íŠ¸ëœì­ì…˜ ê´€ë¦¬
- [ì—ëŸ¬ í•¸ë“¤ë§](../ì—ëŸ¬_í•¸ë“¤ë§/ì—ëŸ¬_í•¸ë“¤ë§_ì „ëµ.md) - ë¶„ì‚° íŠ¸ëœì­ì…˜ ì—ëŸ¬ ì²˜ë¦¬
- [Observability ì „ëµ](../ëª¨ë‹ˆí„°ë§/Observability_ì „ëµ.md) - ë¶„ì‚° ì¶”ì 

