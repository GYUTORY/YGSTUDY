---
title: ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° í’€ ê´€ë¦¬ ì „ëµ
tags: [framework, node, database, connection-pool, performance, optimization]
updated: 2025-11-24
---

# ğŸ”Œ ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° í’€ ê´€ë¦¬ ì „ëµ

## ğŸ“Œ ê°œìš”

> **ì—°ê²° í’€ (Connection Pool)**ì€ ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²°ì„ ë¯¸ë¦¬ ìƒì„±í•˜ê³  ì¬ì‚¬ìš©í•˜ì—¬ ì—°ê²° ì˜¤ë²„í—¤ë“œë¥¼ ì¤„ì´ê³  ì„±ëŠ¥ì„ í–¥ìƒì‹œí‚¤ëŠ” ë©”ì»¤ë‹ˆì¦˜ì…ë‹ˆë‹¤.

### ğŸ¯ ì—°ê²° í’€ì˜ ëª©ì 

```mermaid
mindmap
  root((ì—°ê²° í’€))
    ì„±ëŠ¥ í–¥ìƒ
      ì—°ê²° ì¬ì‚¬ìš©
      ì—°ê²° ì˜¤ë²„í—¤ë“œ ê°ì†Œ
      ì‘ë‹µ ì‹œê°„ ë‹¨ì¶•
    ë¦¬ì†ŒìŠ¤ ê´€ë¦¬
      ì—°ê²° ìˆ˜ ì œí•œ
      ë©”ëª¨ë¦¬ íš¨ìœ¨ì„±
      ì„œë²„ ë¶€í•˜ ê°ì†Œ
    ì•ˆì •ì„±
      ì—°ê²° íƒ€ì„ì•„ì›ƒ ê´€ë¦¬
      ìë™ ì¬ì—°ê²°
      ì¥ì•  ëŒ€ì‘
```

### ğŸ“Š ì—°ê²° í’€ vs ì§ì ‘ ì—°ê²°

```mermaid
sequenceDiagram
    participant A as ì• í”Œë¦¬ì¼€ì´ì…˜
    participant P as ì—°ê²° í’€
    participant D as ë°ì´í„°ë² ì´ìŠ¤
    
    Note over A,D: ì—°ê²° í’€ ì‚¬ìš©
    A->>P: ì—°ê²° ìš”ì²­
    P->>D: ê¸°ì¡´ ì—°ê²° ì¬ì‚¬ìš©
    D-->>P: ì—°ê²° ë°˜í™˜
    P-->>A: ì—°ê²° ì œê³µ
    A->>D: ì¿¼ë¦¬ ì‹¤í–‰
    A->>P: ì—°ê²° ë°˜í™˜
    
    Note over A,D: ì§ì ‘ ì—°ê²° (ë¹„íš¨ìœ¨ì )
    A->>D: ìƒˆ ì—°ê²° ìƒì„±
    D-->>A: ì—°ê²° ìˆ˜ë¦½
    A->>D: ì¿¼ë¦¬ ì‹¤í–‰
    A->>D: ì—°ê²° ì¢…ë£Œ
```

## ğŸ—ï¸ ì—°ê²° í’€ êµ¬ì¡°

### ì—°ê²° í’€ ì•„í‚¤í…ì²˜

ì—°ê²° í’€ì€ ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²°ì„ íš¨ìœ¨ì ìœ¼ë¡œ ê´€ë¦¬í•˜ëŠ” í•µì‹¬ ë©”ì»¤ë‹ˆì¦˜ì…ë‹ˆë‹¤. ë‹¤ìŒ ë‹¤ì´ì–´ê·¸ë¨ì€ ì—°ê²° í’€ì˜ ì „ì²´ êµ¬ì¡°ë¥¼ ë³´ì—¬ì¤ë‹ˆë‹¤.

```mermaid
graph TB
    subgraph "ì• í”Œë¦¬ì¼€ì´ì…˜ ê³„ì¸µ"
        APP[ì• í”Œë¦¬ì¼€ì´ì…˜]
        REQ[ìš”ì²­]
    end
    
    subgraph "ì—°ê²° í’€ ë§¤ë‹ˆì €"
        POOL[ì—°ê²° í’€]
        MANAGER[í’€ ë§¤ë‹ˆì €]
    end
    
    subgraph "ì—°ê²° ìƒíƒœ"
        ACTIVE[í™œì„± ì—°ê²°<br/>Active]
        IDLE[ìœ íœ´ ì—°ê²°<br/>Idle]
        PENDING[ëŒ€ê¸° ìš”ì²­<br/>Pending]
        CLOSED[ì¢…ë£Œëœ ì—°ê²°<br/>Closed]
    end
    
    subgraph "ì„¤ì • íŒŒë¼ë¯¸í„°"
        MAX[ìµœëŒ€ ì—°ê²° ìˆ˜]
        MIN[ìµœì†Œ ì—°ê²° ìˆ˜]
        TIMEOUT[íƒ€ì„ì•„ì›ƒ]
        IDLE_TIME[ìœ íœ´ íƒ€ì„ì•„ì›ƒ]
    end
    
    subgraph "ë°ì´í„°ë² ì´ìŠ¤"
        DB[(ë°ì´í„°ë² ì´ìŠ¤)]
    end
    
    APP --> REQ
    REQ --> POOL
    POOL --> MANAGER
    
    MANAGER --> ACTIVE
    MANAGER --> IDLE
    MANAGER --> PENDING
    MANAGER --> CLOSED
    
    MAX --> MANAGER
    MIN --> MANAGER
    TIMEOUT --> MANAGER
    IDLE_TIME --> MANAGER
    
    ACTIVE --> DB
    IDLE --> DB
    
    style APP fill:#4fc3f7
    style POOL fill:#66bb6a
    style ACTIVE fill:#ff9800
    style IDLE fill:#9e9e9e
    style DB fill:#9c27b0
```

### ì—°ê²° í’€ ìƒëª…ì£¼ê¸°

ì—°ê²°ì´ ìƒì„±ë˜ì–´ í•´ì œë˜ê¸°ê¹Œì§€ì˜ ì „ì²´ ìƒëª…ì£¼ê¸°ë¥¼ ì´í•´í•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•©ë‹ˆë‹¤:

```mermaid
stateDiagram-v2
    [*] --> ì´ˆê¸°í™”: í’€ ìƒì„±
    ì´ˆê¸°í™” --> ìµœì†Œì—°ê²°ìƒì„±: ìµœì†Œ ì—°ê²° ìˆ˜ ìƒì„±
    
    ìµœì†Œì—°ê²°ìƒì„± --> ìœ íœ´: ì—°ê²° ì¤€ë¹„ ì™„ë£Œ
    
    ìœ íœ´ --> í™œì„±: ìš”ì²­ ìˆ˜ì‹ 
    í™œì„± --> ìœ íœ´: ì¿¼ë¦¬ ì™„ë£Œ
    
    ìœ íœ´ --> ìœ íœ´íƒ€ì„ì•„ì›ƒ: ìœ íœ´ ì‹œê°„ ì´ˆê³¼
    ìœ íœ´íƒ€ì„ì•„ì›ƒ --> ì¢…ë£Œ: ì—°ê²° ì¢…ë£Œ
    
    í™œì„± --> ì˜¤ë¥˜: ì—°ê²° ì˜¤ë¥˜
    ì˜¤ë¥˜ --> ì¢…ë£Œ: ì—°ê²° ì¢…ë£Œ
    
    í™œì„± --> ìµœëŒ€ì—°ê²°ë„ë‹¬: ìµœëŒ€ ì—°ê²° ìˆ˜ ë„ë‹¬
    ìµœëŒ€ì—°ê²°ë„ë‹¬ --> ëŒ€ê¸°: ìš”ì²­ ëŒ€ê¸°
    
    ëŒ€ê¸° --> í™œì„±: ì—°ê²° ì‚¬ìš© ê°€ëŠ¥
    ëŒ€ê¸° --> íƒ€ì„ì•„ì›ƒ: ëŒ€ê¸° ì‹œê°„ ì´ˆê³¼
    íƒ€ì„ì•„ì›ƒ --> ì˜¤ë¥˜ë°˜í™˜: ì˜¤ë¥˜ ë°˜í™˜
    
    ì¢…ë£Œ --> [*]
    ì˜¤ë¥˜ë°˜í™˜ --> [*]
    
    note right of ìœ íœ´
        ì¬ì‚¬ìš© ê°€ëŠ¥í•œ ì—°ê²°
        ìµœì†Œ ì—°ê²° ìˆ˜ ìœ ì§€
    end note
    
    note right of í™œì„±
        ì¿¼ë¦¬ ì‹¤í–‰ ì¤‘
        ìµœëŒ€ ì—°ê²° ìˆ˜ ì œí•œ
    end note
```

### ì—°ê²° í’€ ìƒíƒœ ì „ì´

ì—°ê²°ì´ ë‹¤ì–‘í•œ ìƒíƒœë¥¼ ê±°ì¹˜ë©° ì „ì´ë˜ëŠ” ê³¼ì •:

```mermaid
flowchart TD
    START([ì—°ê²° ìš”ì²­]) --> CHECK1{í’€ì— ìœ íœ´<br/>ì—°ê²° ìˆìŒ?}
    
    CHECK1 -->|ì˜ˆ| GET[ìœ íœ´ ì—°ê²° íšë“]
    CHECK1 -->|ì•„ë‹ˆì˜¤| CHECK2{ìµœëŒ€ ì—°ê²° ìˆ˜<br/>ë„ë‹¬?}
    
    CHECK2 -->|ì•„ë‹ˆì˜¤| CREATE[ìƒˆ ì—°ê²° ìƒì„±]
    CHECK2 -->|ì˜ˆ| WAIT[ëŒ€ê¸° íì— ì¶”ê°€]
    
    CREATE --> VALIDATE[ì—°ê²° ê²€ì¦]
    VALIDATE -->|ì„±ê³µ| ACTIVE[í™œì„± ìƒíƒœ]
    VALIDATE -->|ì‹¤íŒ¨| RETRY{ì¬ì‹œë„?}
    RETRY -->|ì˜ˆ| CREATE
    RETRY -->|ì•„ë‹ˆì˜¤| ERROR[ì˜¤ë¥˜ ë°˜í™˜]
    
    GET --> ACTIVE
    WAIT --> TIMEOUT_CHECK{íƒ€ì„ì•„ì›ƒ?}
    TIMEOUT_CHECK -->|ì˜ˆ| ERROR
    TIMEOUT_CHECK -->|ì•„ë‹ˆì˜¤| CHECK1
    
    ACTIVE --> QUERY[ì¿¼ë¦¬ ì‹¤í–‰]
    QUERY --> RELEASE[ì—°ê²° ë°˜í™˜]
    RELEASE --> IDLE[ìœ íœ´ ìƒíƒœ]
    
    IDLE --> IDLE_CHECK{ìœ íœ´ íƒ€ì„ì•„ì›ƒ?}
    IDLE_CHECK -->|ì˜ˆ| CLOSE[ì—°ê²° ì¢…ë£Œ]
    IDLE_CHECK -->|ì•„ë‹ˆì˜¤| CHECK1
    
    CLOSE --> END([ì¢…ë£Œ])
    ERROR --> END
    
    style START fill:#4fc3f7
    style ACTIVE fill:#ff9800
    style IDLE fill:#66bb6a
    style ERROR fill:#ef5350,color:#fff
```

### ì—°ê²° í’€ ìƒíƒœ

| ìƒíƒœ | ì„¤ëª… | íŠ¹ì§• |
|------|------|------|
| **Active** | í˜„ì¬ ì‚¬ìš© ì¤‘ì¸ ì—°ê²° | ì¿¼ë¦¬ ì‹¤í–‰ ì¤‘ |
| **Idle** | ì‚¬ìš© ê°€ëŠ¥í•œ ì—°ê²° | ì¬ì‚¬ìš© ëŒ€ê¸° |
| **Pending** | ì—°ê²° ìš”ì²­ ëŒ€ê¸° | í’€ì´ ê°€ë“ ì°¬ ê²½ìš° |
| **Closed** | ì¢…ë£Œëœ ì—°ê²° | ì •ë¦¬ í•„ìš” |

## âš™ï¸ ì—°ê²° í’€ ì„¤ì • ë° ìµœì í™”

### ê¸°ë³¸ ì„¤ì •

```javascript
const { Pool } = require('pg');

const pool = new Pool({
  host: process.env.DB_HOST,
  port: process.env.DB_PORT || 5432,
  database: process.env.DB_NAME,
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  
  // ì—°ê²° í’€ ì„¤ì •
  max: 20,                    // ìµœëŒ€ ì—°ê²° ìˆ˜
  min: 5,                     // ìµœì†Œ ì—°ê²° ìˆ˜
  idleTimeoutMillis: 30000,   // ìœ íœ´ ì—°ê²° íƒ€ì„ì•„ì›ƒ (30ì´ˆ)
  connectionTimeoutMillis: 2000, // ì—°ê²° íƒ€ì„ì•„ì›ƒ (2ì´ˆ)
  
  // ì¬ì‹œë„ ì„¤ì •
  maxUses: 7500,              // ì—°ê²° ì¬ì‚¬ìš© ìµœëŒ€ íšŸìˆ˜
  allowExitOnIdle: false      // ìœ íœ´ ì‹œ ì¢…ë£Œ í—ˆìš©
});
```

### ìµœì í™”ëœ ì„¤ì •

```javascript
class DatabasePoolManager {
  constructor(config) {
    this.config = {
      // ê¸°ë³¸ ì„¤ì •
      ...config,
      
      // ì—°ê²° í’€ ìµœì í™”
      max: this.calculateMaxConnections(),
      min: Math.ceil(this.calculateMaxConnections() * 0.25),
      idleTimeoutMillis: 30000,
      connectionTimeoutMillis: 2000,
      
      // ì„±ëŠ¥ ìµœì í™”
      statement_timeout: 30000,  // ì¿¼ë¦¬ íƒ€ì„ì•„ì›ƒ
      query_timeout: 30000,
      application_name: 'node-app',
      
      // ëª¨ë‹ˆí„°ë§
      log: (msg) => {
        if (process.env.NODE_ENV === 'development') {
          console.log('[DB Pool]', msg);
        }
      }
    };
    
    this.pool = new Pool(this.config);
    this.setupEventHandlers();
  }
  
  // ìµœëŒ€ ì—°ê²° ìˆ˜ ê³„ì‚° (ë°ì´í„°ë² ì´ìŠ¤ ì œí•œ ê³ ë ¤)
  calculateMaxConnections() {
    const dbMaxConnections = parseInt(process.env.DB_MAX_CONNECTIONS || '100');
    const appInstances = parseInt(process.env.APP_INSTANCES || '1');
    
    // ë°ì´í„°ë² ì´ìŠ¤ ìµœëŒ€ ì—°ê²° ìˆ˜ / ì• í”Œë¦¬ì¼€ì´ì…˜ ì¸ìŠ¤í„´ìŠ¤ ìˆ˜
    // 80% ì‚¬ìš© (20% ì—¬ìœ )
    return Math.floor((dbMaxConnections * 0.8) / appInstances);
  }
  
  setupEventHandlers() {
    // ì—°ê²° ì˜¤ë¥˜ ì²˜ë¦¬
    this.pool.on('error', (err, client) => {
      console.error('Unexpected error on idle client', err);
      // ì—°ê²° ì œê±° ë° ì¬ì—°ê²°
    });
    
    // ì—°ê²° íšë“ ì´ë²¤íŠ¸
    this.pool.on('connect', (client) => {
      console.log('New client connected');
    });
    
    // ì—°ê²° ì œê±° ì´ë²¤íŠ¸
    this.pool.on('remove', (client) => {
      console.log('Client removed from pool');
    });
  }
  
  async getConnection() {
    try {
      const client = await this.pool.connect();
      return client;
    } catch (error) {
      console.error('Failed to get connection from pool', error);
      throw error;
    }
  }
  
  async query(text, params) {
    const start = Date.now();
    try {
      const result = await this.pool.query(text, params);
      const duration = Date.now() - start;
      
      // ëŠë¦° ì¿¼ë¦¬ ë¡œê¹…
      if (duration > 1000) {
        console.warn('Slow query detected', {
          query: text,
          duration,
          params
        });
      }
      
      return result;
    } catch (error) {
      console.error('Query error', {
        query: text,
        error: error.message
      });
      throw error;
    }
  }
  
  async getPoolStats() {
    return {
      totalCount: this.pool.totalCount,
      idleCount: this.pool.idleCount,
      waitingCount: this.pool.waitingCount
    };
  }
}
```

## â±ï¸ íƒ€ì„ì•„ì›ƒ ë° ì¬ì—°ê²° ì „ëµ

### íƒ€ì„ì•„ì›ƒ ì„¤ì •

```mermaid
graph TD
    A[ì—°ê²° ìš”ì²­] --> B{ì—°ê²° í’€ì—<br/>ì—°ê²° ìˆìŒ?}
    B -->|ì˜ˆ| C[ì—°ê²° ì œê³µ]
    B -->|ì•„ë‹ˆì˜¤| D{ìµœëŒ€ ì—°ê²° ìˆ˜<br/>ë„ë‹¬?}
    
    D -->|ì•„ë‹ˆì˜¤| E[ìƒˆ ì—°ê²° ìƒì„±]
    D -->|ì˜ˆ| F[ëŒ€ê¸°]
    
    F --> G{íƒ€ì„ì•„ì›ƒ<br/>ì´ˆê³¼?}
    G -->|ì˜ˆ| H[ì—ëŸ¬ ë°˜í™˜]
    G -->|ì•„ë‹ˆì˜¤| I[ì—°ê²° ëŒ€ê¸°]
    
    style A fill:#4fc3f7
    style C fill:#66bb6a
    style H fill:#ef5350,color:#fff
```

#### íƒ€ì„ì•„ì›ƒ êµ¬í˜„

```javascript
class ConnectionPoolWithTimeout {
  constructor(config) {
    this.pool = new Pool(config);
    this.connectionTimeout = config.connectionTimeoutMillis || 2000;
    this.queryTimeout = config.queryTimeout || 30000;
  }
  
  async getConnectionWithTimeout() {
    return new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        reject(new Error('Connection timeout: Pool is full'));
      }, this.connectionTimeout);
      
      this.pool.connect()
        .then(client => {
          clearTimeout(timeout);
          resolve(client);
        })
        .catch(error => {
          clearTimeout(timeout);
          reject(error);
        });
    });
  }
  
  async queryWithTimeout(text, params) {
    return Promise.race([
      this.pool.query(text, params),
      new Promise((_, reject) => {
        setTimeout(() => {
          reject(new Error('Query timeout'));
        }, this.queryTimeout);
      })
    ]);
  }
}
```

### ì¬ì—°ê²° ì „ëµ

```javascript
class ResilientConnectionPool {
  constructor(config) {
    this.config = config;
    this.pool = null;
    this.reconnectAttempts = 0;
    this.maxReconnectAttempts = 5;
    this.reconnectDelay = 1000;
    
    this.initializePool();
  }
  
  initializePool() {
    this.pool = new Pool(this.config);
    this.setupReconnectHandlers();
  }
  
  setupReconnectHandlers() {
    this.pool.on('error', async (err, client) => {
      console.error('Pool error:', err);
      
      // ì—°ê²° ì˜¤ë¥˜ì¸ ê²½ìš° ì¬ì—°ê²° ì‹œë„
      if (err.code === 'ECONNREFUSED' || err.code === 'ETIMEDOUT') {
        await this.reconnect();
      }
    });
  }
  
  async reconnect() {
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      console.error('Max reconnect attempts reached');
      return;
    }
    
    this.reconnectAttempts++;
    const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1);
    
    console.log(`Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts})`);
    
    await new Promise(resolve => setTimeout(resolve, delay));
    
    try {
      // ê¸°ì¡´ í’€ ì¢…ë£Œ
      await this.pool.end();
      
      // ìƒˆ í’€ ìƒì„±
      this.initializePool();
      
      // ì—°ê²° í…ŒìŠ¤íŠ¸
      await this.pool.query('SELECT 1');
      
      console.log('Reconnection successful');
      this.reconnectAttempts = 0;
    } catch (error) {
      console.error('Reconnection failed:', error);
      await this.reconnect();
    }
  }
  
  async healthCheck() {
    try {
      const result = await this.pool.query('SELECT 1');
      return { healthy: true, result };
    } catch (error) {
      return { healthy: false, error: error.message };
    }
  }
}
```

## ğŸ“Š Read/Write ë¶„ë¦¬

### Master-Slave êµ¬ì¡°

Read/Write ë¶„ë¦¬ëŠ” ë°ì´í„°ë² ì´ìŠ¤ ë¶€í•˜ë¥¼ ë¶„ì‚°í•˜ê³  ì„±ëŠ¥ì„ í–¥ìƒì‹œí‚¤ëŠ” í•µì‹¬ ì „ëµì…ë‹ˆë‹¤. ë‹¤ìŒ ë‹¤ì´ì–´ê·¸ë¨ì€ Master-Slave êµ¬ì¡°ì˜ ì „ì²´ ì•„í‚¤í…ì²˜ë¥¼ ë³´ì—¬ì¤ë‹ˆë‹¤.

```mermaid
graph TB
    subgraph "ì• í”Œë¦¬ì¼€ì´ì…˜ ê³„ì¸µ"
        APP[ì• í”Œë¦¬ì¼€ì´ì…˜]
        QUERY[ì¿¼ë¦¬ ìš”ì²­]
    end
    
    subgraph "ì—°ê²° í’€ ë§¤ë‹ˆì €"
        MANAGER[í’€ ë§¤ë‹ˆì €]
        ROUTER[ë¼ìš°í„°]
    end
    
    subgraph "Write í’€"
        MASTER_POOL[Master Pool]
        WRITE[Write ì¿¼ë¦¬]
    end
    
    subgraph "Read í’€"
        SLAVE1_POOL[Slave Pool 1]
        SLAVE2_POOL[Slave Pool 2]
        SLAVE3_POOL[Slave Pool 3]
        READ[Read ì¿¼ë¦¬]
    end
    
    subgraph "ë°ì´í„°ë² ì´ìŠ¤ ê³„ì¸µ"
        MASTER_DB[(Master DB<br/>Primary)]
        SLAVE1_DB[(Slave DB 1<br/>Replica)]
        SLAVE2_DB[(Slave DB 2<br/>Replica)]
        SLAVE3_DB[(Slave DB 3<br/>Replica)]
    end
    
    subgraph "ë³µì œ"
        REPLICATION[ë°ì´í„° ë³µì œ]
    end
    
    APP --> QUERY
    QUERY --> MANAGER
    MANAGER --> ROUTER
    
    ROUTER -->|INSERT/UPDATE/DELETE| WRITE
    ROUTER -->|SELECT| READ
    
    WRITE --> MASTER_POOL
    READ --> SLAVE1_POOL
    READ --> SLAVE2_POOL
    READ --> SLAVE3_POOL
    
    MASTER_POOL --> MASTER_DB
    SLAVE1_POOL --> SLAVE1_DB
    SLAVE2_POOL --> SLAVE2_DB
    SLAVE3_POOL --> SLAVE3_DB
    
    MASTER_DB --> REPLICATION
    REPLICATION --> SLAVE1_DB
    REPLICATION --> SLAVE2_DB
    REPLICATION --> SLAVE3_DB
    
    style APP fill:#4fc3f7
    style MASTER_POOL fill:#ef5350,color:#fff
    style SLAVE1_POOL fill:#66bb6a
    style SLAVE2_POOL fill:#66bb6a
    style SLAVE3_POOL fill:#66bb6a
    style REPLICATION fill:#ff9800
```

### Read/Write ë¶„ë¦¬ ë¼ìš°íŒ… ì „ëµ

Read ì¿¼ë¦¬ë¥¼ ì—¬ëŸ¬ Slaveì— ë¶„ì‚°í•˜ëŠ” ë‹¤ì–‘í•œ ì „ëµ:

```mermaid
graph TD
    subgraph "ë¼ìš°íŒ… ì „ëµ"
        ROUND_ROBIN[Round Robin<br/>ìˆœí™˜ ë°©ì‹]
        WEIGHTED[Weighted<br/>ê°€ì¤‘ì¹˜ ë°©ì‹]
        RANDOM[Random<br/>ë¬´ì‘ìœ„ ë°©ì‹]
        LEAST_CONN[Least Connection<br/>ìµœì†Œ ì—°ê²° ë°©ì‹]
    end
    
    subgraph "Round Robin"
        RR1[ìš”ì²­ 1 â†’ Slave 1]
        RR2[ìš”ì²­ 2 â†’ Slave 2]
        RR3[ìš”ì²­ 3 â†’ Slave 3]
        RR4[ìš”ì²­ 4 â†’ Slave 1]
    end
    
    subgraph "Weighted"
        W1[ê°€ì¤‘ì¹˜ 3 â†’ Slave 1]
        W2[ê°€ì¤‘ì¹˜ 2 â†’ Slave 2]
        W3[ê°€ì¤‘ì¹˜ 1 â†’ Slave 3]
    end
    
    subgraph "Random"
        R1[ë¬´ì‘ìœ„ ì„ íƒ]
        R2[ê· ë“± ë¶„ì‚°]
    end
    
    subgraph "Least Connection"
        LC1[ì—°ê²° ìˆ˜ í™•ì¸]
        LC2[ìµœì†Œ ì—°ê²° ì„ íƒ]
    end
    
    ROUND_ROBIN --> RR1
    ROUND_ROBIN --> RR2
    ROUND_ROBIN --> RR3
    ROUND_ROBIN --> RR4
    
    WEIGHTED --> W1
    WEIGHTED --> W2
    WEIGHTED --> W3
    
    RANDOM --> R1
    RANDOM --> R2
    
    LEAST_CONN --> LC1
    LEAST_CONN --> LC2
    
    style ROUND_ROBIN fill:#4fc3f7
    style WEIGHTED fill:#66bb6a
    style RANDOM fill:#ff9800
    style LEAST_CONN fill:#9c27b0
```

### Read/Write ë¶„ë¦¬ ìš”ì²­ íë¦„

ìš”ì²­ì´ ì–´ë–»ê²Œ Writeì™€ Readë¡œ ë¶„ë¦¬ë˜ì–´ ì²˜ë¦¬ë˜ëŠ”ì§€:

```mermaid
sequenceDiagram
    participant APP as ì• í”Œë¦¬ì¼€ì´ì…˜
    participant ROUTER as ë¼ìš°í„°
    participant MASTER as Master Pool
    participant SLAVE as Slave Pool
    participant MASTER_DB as Master DB
    participant SLAVE_DB as Slave DB
    
    Note over APP: Write ìš”ì²­
    APP->>ROUTER: INSERT/UPDATE/DELETE
    ROUTER->>MASTER: Write ì¿¼ë¦¬
    MASTER->>MASTER_DB: ì¿¼ë¦¬ ì‹¤í–‰
    MASTER_DB-->>MASTER: ê²°ê³¼
    MASTER-->>ROUTER: ê²°ê³¼
    ROUTER-->>APP: ì‘ë‹µ
    
    Note over MASTER_DB,SLAVE_DB: ë°ì´í„° ë³µì œ
    MASTER_DB->>SLAVE_DB: ë³µì œ
    
    Note over APP: Read ìš”ì²­
    APP->>ROUTER: SELECT
    ROUTER->>SLAVE: Read ì¿¼ë¦¬ (ë¼ìš°íŒ…)
    SLAVE->>SLAVE_DB: ì¿¼ë¦¬ ì‹¤í–‰
    SLAVE_DB-->>SLAVE: ê²°ê³¼
    SLAVE-->>ROUTER: ê²°ê³¼
    ROUTER-->>APP: ì‘ë‹µ
```

### ì‹¤ë¬´ ìš´ì˜ ì‹œë‚˜ë¦¬ì˜¤: Read/Write ë¶„ë¦¬

**ì‹œë‚˜ë¦¬ì˜¤ 1: ë¶€í•˜ ë¶„ì‚°**
- Read ì¿¼ë¦¬ê°€ ë§ì€ ê²½ìš° ì—¬ëŸ¬ Slaveë¡œ ë¶„ì‚°í•˜ì—¬ ë¶€í•˜ë¥¼ ì¤„ì…ë‹ˆë‹¤
- ê° Slaveì˜ ì„±ëŠ¥ì— ë”°ë¼ ê°€ì¤‘ì¹˜ë¥¼ ì¡°ì •í•©ë‹ˆë‹¤

**ì‹œë‚˜ë¦¬ì˜¤ 2: ê³ ê°€ìš©ì„±**
- Master ì¥ì•  ì‹œ ìë™ìœ¼ë¡œ Slaveë¥¼ Masterë¡œ ìŠ¹ê²©í•©ë‹ˆë‹¤
- Read ì¿¼ë¦¬ëŠ” ê³„ì† ì²˜ë¦¬í•  ìˆ˜ ìˆë„ë¡ í•©ë‹ˆë‹¤

**ì‹œë‚˜ë¦¬ì˜¤ 3: ì§€ë¦¬ì  ë¶„ì‚°**
- ì§€ì—­ë³„ë¡œ Slaveë¥¼ ë°°ì¹˜í•˜ì—¬ ì§€ì—° ì‹œê°„ì„ ì¤„ì…ë‹ˆë‹¤
- ì‚¬ìš©ì ìœ„ì¹˜ì— ë”°ë¼ ê°€ì¥ ê°€ê¹Œìš´ Slaveë¡œ ë¼ìš°íŒ…í•©ë‹ˆë‹¤

#### Read/Write ë¶„ë¦¬ êµ¬í˜„

```javascript
class ReadWritePoolManager {
  constructor(config) {
    // Master (Write) Pool
    this.masterPool = new Pool({
      ...config.master,
      max: config.master.max || 10,
      min: config.master.min || 2
    });
    
    // Slave (Read) Pools
    this.slavePools = config.slaves.map(slaveConfig => ({
      pool: new Pool({
        ...slaveConfig,
        max: slaveConfig.max || 10,
        min: slaveConfig.min || 2
      }),
      weight: slaveConfig.weight || 1
    }));
    
    this.currentSlaveIndex = 0;
  }
  
  // Write ì¿¼ë¦¬ (Master)
  async writeQuery(text, params) {
    return await this.masterPool.query(text, params);
  }
  
  // Read ì¿¼ë¦¬ (Slave - Round Robin)
  async readQuery(text, params) {
    if (this.slavePools.length === 0) {
      // Slaveê°€ ì—†ìœ¼ë©´ Master ì‚¬ìš©
      return await this.masterPool.query(text, params);
    }
    
    // Round Robin ë°©ì‹ìœ¼ë¡œ Slave ì„ íƒ
    const slave = this.slavePools[this.currentSlaveIndex];
    this.currentSlaveIndex = (this.currentSlaveIndex + 1) % this.slavePools.length;
    
    try {
      return await slave.pool.query(text, params);
    } catch (error) {
      // Slave ì‹¤íŒ¨ ì‹œ ë‹¤ë¥¸ Slave ì‹œë„
      console.error('Slave query failed, trying next slave', error);
      return await this.readQueryWithFallback(text, params);
    }
  }
  
  async readQueryWithFallback(text, params) {
    for (const slave of this.slavePools) {
      try {
        return await slave.pool.query(text, params);
      } catch (error) {
        console.error('Slave query failed', error);
        continue;
      }
    }
    
    // ëª¨ë“  Slave ì‹¤íŒ¨ ì‹œ Master ì‚¬ìš©
    console.warn('All slaves failed, using master');
    return await this.masterPool.query(text, params);
  }
  
  // ê°€ì¤‘ì¹˜ ê¸°ë°˜ Read ì¿¼ë¦¬
  async readQueryWithWeight(text, params) {
    if (this.slavePools.length === 0) {
      return await this.masterPool.query(text, params);
    }
    
    // ê°€ì¤‘ì¹˜ ê¸°ë°˜ ì„ íƒ
    const totalWeight = this.slavePools.reduce((sum, s) => sum + s.weight, 0);
    let random = Math.random() * totalWeight;
    
    for (const slave of this.slavePools) {
      random -= slave.weight;
      if (random <= 0) {
        return await slave.pool.query(text, params);
      }
    }
    
    // Fallback
    return await this.slavePools[0].pool.query(text, params);
  }
}

// ì‚¬ìš© ì˜ˆì‹œ
const dbManager = new ReadWritePoolManager({
  master: {
    host: 'master.db.example.com',
    database: 'mydb',
    user: 'user',
    password: 'password'
  },
  slaves: [
    {
      host: 'slave1.db.example.com',
      database: 'mydb',
      user: 'user',
      password: 'password',
      weight: 2
    },
    {
      host: 'slave2.db.example.com',
      database: 'mydb',
      user: 'user',
      password: 'password',
      weight: 1
    }
  ]
});

// Write ì¿¼ë¦¬
await dbManager.writeQuery('INSERT INTO users (name, email) VALUES ($1, $2)', ['John', 'john@example.com']);

// Read ì¿¼ë¦¬
const users = await dbManager.readQuery('SELECT * FROM users WHERE id = $1', [userId]);
```

## ğŸ“ˆ ì—°ê²° í’€ ëª¨ë‹ˆí„°ë§

### ëª¨ë‹ˆí„°ë§ ë©”íŠ¸ë¦­

```mermaid
graph TD
    A[ì—°ê²° í’€ ëª¨ë‹ˆí„°ë§] --> B[ì—°ê²° ìˆ˜]
    A --> C[ëŒ€ê¸° ì‹œê°„]
    A --> D[ì¿¼ë¦¬ ì„±ëŠ¥]
    A --> E[ì—ëŸ¬ìœ¨]
    
    B --> F[í™œì„± ì—°ê²°]
    B --> G[ìœ íœ´ ì—°ê²°]
    B --> H[ëŒ€ê¸° ì¤‘ì¸ ìš”ì²­]
    
    C --> I[ì—°ê²° íšë“ ì‹œê°„]
    C --> J[ì¿¼ë¦¬ ì‹¤í–‰ ì‹œê°„]
    
    style A fill:#4fc3f7
    style B fill:#66bb6a
    style C fill:#ff9800
    style D fill:#9c27b0
    style E fill:#ef5350,color:#fff
```

#### ëª¨ë‹ˆí„°ë§ êµ¬í˜„

```javascript
class PoolMonitor {
  constructor(pool) {
    this.pool = pool;
    this.metrics = {
      totalConnections: 0,
      activeConnections: 0,
      idleConnections: 0,
      waitingRequests: 0,
      queryCount: 0,
      errorCount: 0,
      slowQueries: 0,
      averageQueryTime: 0,
      connectionAcquisitionTime: []
    };
    
    this.startMonitoring();
  }
  
  startMonitoring() {
    // ì£¼ê¸°ì ìœ¼ë¡œ ë©”íŠ¸ë¦­ ìˆ˜ì§‘
    setInterval(() => {
      this.collectMetrics();
    }, 5000); // 5ì´ˆë§ˆë‹¤
    
    // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì •
    this.pool.on('connect', () => {
      this.metrics.totalConnections++;
    });
    
    this.pool.on('acquire', () => {
      this.metrics.activeConnections++;
    });
    
    this.pool.on('release', () => {
      this.metrics.activeConnections--;
      this.metrics.idleConnections++;
    });
  }
  
  collectMetrics() {
    const stats = {
      total: this.pool.totalCount,
      idle: this.pool.idleCount,
      waiting: this.pool.waitingCount,
      active: this.pool.totalCount - this.pool.idleCount
    };
    
    this.metrics.activeConnections = stats.active;
    this.metrics.idleConnections = stats.idle;
    this.metrics.waitingRequests = stats.waiting;
    
    // ë©”íŠ¸ë¦­ ë¡œê¹…
    if (process.env.NODE_ENV === 'development') {
      console.log('Pool Metrics:', stats);
    }
    
    // ì•Œë¦¼ ì²´í¬
    this.checkAlerts(stats);
  }
  
  checkAlerts(stats) {
    // ì—°ê²° í’€ ê°€ë“ ì°¸
    if (stats.waiting > 10) {
      console.warn('âš ï¸ Pool is full, many requests waiting:', stats.waiting);
    }
    
    // í™œì„± ì—°ê²° ë¹„ìœ¨ì´ ë†’ìŒ
    const activeRatio = stats.active / stats.total;
    if (activeRatio > 0.9) {
      console.warn('âš ï¸ High active connection ratio:', activeRatio);
    }
    
    // ìœ íœ´ ì—°ê²°ì´ ì—†ìŒ
    if (stats.idle === 0 && stats.waiting > 0) {
      console.warn('âš ï¸ No idle connections available');
    }
  }
  
  getMetrics() {
    return {
      ...this.metrics,
      poolStats: {
        total: this.pool.totalCount,
        idle: this.pool.idleCount,
        waiting: this.pool.waitingCount,
        active: this.pool.totalCount - this.pool.idleCount
      }
    };
  }
  
  // ì¿¼ë¦¬ ì„±ëŠ¥ ì¶”ì 
  async trackQuery(queryFn) {
    const start = Date.now();
    try {
      const result = await queryFn();
      const duration = Date.now() - start;
      
      this.metrics.queryCount++;
      this.updateAverageQueryTime(duration);
      
      if (duration > 1000) {
        this.metrics.slowQueries++;
      }
      
      return result;
    } catch (error) {
      this.metrics.errorCount++;
      throw error;
    }
  }
  
  updateAverageQueryTime(duration) {
    const currentAvg = this.metrics.averageQueryTime;
    const count = this.metrics.queryCount;
    this.metrics.averageQueryTime = 
      (currentAvg * (count - 1) + duration) / count;
  }
}

// ì‚¬ìš© ì˜ˆì‹œ
const pool = new Pool(config);
const monitor = new PoolMonitor(pool);

// ë©”íŠ¸ë¦­ ì¡°íšŒ
app.get('/metrics/pool', (req, res) => {
  res.json(monitor.getMetrics());
});
```

## ğŸ›¡ï¸ ì¥ì•  ëŒ€ì‘ ì „ëµ

### ì¥ì•  ì‹œë‚˜ë¦¬ì˜¤

```mermaid
graph TD
    A[ì¥ì•  ë°œìƒ] --> B{ì¥ì•  íƒ€ì…}
    B -->|ì—°ê²° ì‹¤íŒ¨| C[ì¬ì—°ê²° ì‹œë„]
    B -->|ì¿¼ë¦¬ íƒ€ì„ì•„ì›ƒ| D[ì¿¼ë¦¬ ì·¨ì†Œ]
    B -->|ì—°ê²° í’€ ê³ ê°ˆ| E[ëŒ€ê¸° ë˜ëŠ” ì—ëŸ¬]
    
    C --> F{ì¬ì—°ê²° ì„±ê³µ?}
    F -->|ì˜ˆ| G[ì •ìƒ ë³µêµ¬]
    F -->|ì•„ë‹ˆì˜¤| H[Fallback]
    
    D --> I[ì—ëŸ¬ ë°˜í™˜]
    E --> J[Circuit Breaker]
    
    style A fill:#ef5350,color:#fff
    style G fill:#66bb6a
    style H fill:#ff9800
```

#### Circuit Breaker íŒ¨í„´

```javascript
class CircuitBreaker {
  constructor(options = {}) {
    this.failureThreshold = options.failureThreshold || 5;
    this.resetTimeout = options.resetTimeout || 60000;
    this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN
    this.failureCount = 0;
    this.nextAttempt = Date.now();
  }
  
  async execute(fn) {
    if (this.state === 'OPEN') {
      if (Date.now() < this.nextAttempt) {
        throw new Error('Circuit breaker is OPEN');
      }
      this.state = 'HALF_OPEN';
    }
    
    try {
      const result = await fn();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }
  
  onSuccess() {
    this.failureCount = 0;
    this.state = 'CLOSED';
  }
  
  onFailure() {
    this.failureCount++;
    if (this.failureCount >= this.failureThreshold) {
      this.state = 'OPEN';
      this.nextAttempt = Date.now() + this.resetTimeout;
    }
  }
}

// ì—°ê²° í’€ì— Circuit Breaker ì ìš©
class ResilientPool {
  constructor(config) {
    this.pool = new Pool(config);
    this.circuitBreaker = new CircuitBreaker({
      failureThreshold: 5,
      resetTimeout: 60000
    });
  }
  
  async query(text, params) {
    return await this.circuitBreaker.execute(async () => {
      return await this.pool.query(text, params);
    });
  }
}
```

### Graceful Degradation

```javascript
class DegradablePool {
  constructor(config) {
    this.primaryPool = new Pool(config.primary);
    this.fallbackPool = config.fallback ? new Pool(config.fallback) : null;
    this.degraded = false;
  }
  
  async query(text, params) {
    try {
      return await this.primaryPool.query(text, params);
    } catch (error) {
      if (this.fallbackPool) {
        console.warn('Primary pool failed, using fallback', error);
        this.degraded = true;
        return await this.fallbackPool.query(text, params);
      }
      throw error;
    }
  }
  
  async healthCheck() {
    try {
      await this.primaryPool.query('SELECT 1');
      if (this.degraded) {
        this.degraded = false;
        console.log('Primary pool recovered');
      }
      return { healthy: true, degraded: false };
    } catch (error) {
      if (this.fallbackPool) {
        try {
          await this.fallbackPool.query('SELECT 1');
          return { healthy: true, degraded: true };
        } catch (fallbackError) {
          return { healthy: false, error: fallbackError.message };
        }
      }
      return { healthy: false, error: error.message };
    }
  }
}
```

## ğŸ¯ ì‹¤ì „ ì˜ˆì œ: ì™„ì „í•œ ì—°ê²° í’€ ì‹œìŠ¤í…œ

```javascript
const { Pool } = require('pg');
const EventEmitter = require('events');

class ProductionReadyPool extends EventEmitter {
  constructor(config) {
    super();
    this.config = config;
    this.masterPool = null;
    this.slavePools = [];
    this.monitor = null;
    this.circuitBreaker = null;
    
    this.initialize();
  }
  
  initialize() {
    // Master Pool
    this.masterPool = new Pool({
      ...this.config.master,
      max: this.calculateMaxConnections('master'),
      min: Math.ceil(this.calculateMaxConnections('master') * 0.25),
      idleTimeoutMillis: 30000,
      connectionTimeoutMillis: 2000
    });
    
    // Slave Pools
    if (this.config.slaves) {
      this.slavePools = this.config.slaves.map(slaveConfig => ({
        pool: new Pool({
          ...slaveConfig,
          max: this.calculateMaxConnections('slave'),
          min: Math.ceil(this.calculateMaxConnections('slave') * 0.25),
          idleTimeoutMillis: 30000,
          connectionTimeoutMillis: 2000
        }),
        weight: slaveConfig.weight || 1
      }));
    }
    
    this.setupEventHandlers();
    this.startMonitoring();
  }
  
  calculateMaxConnections(type) {
    const dbMax = parseInt(process.env.DB_MAX_CONNECTIONS || '100');
    const instances = parseInt(process.env.APP_INSTANCES || '1');
    const poolCount = type === 'master' ? 1 : this.config.slaves?.length || 1;
    
    return Math.floor((dbMax * 0.8) / (instances * poolCount));
  }
  
  setupEventHandlers() {
    [this.masterPool, ...this.slavePools.map(s => s.pool)].forEach(pool => {
      pool.on('error', (err, client) => {
        this.emit('error', err);
        console.error('Pool error:', err);
      });
      
      pool.on('connect', (client) => {
        this.emit('connect', client);
      });
    });
  }
  
  startMonitoring() {
    setInterval(() => {
      const metrics = this.getMetrics();
      this.emit('metrics', metrics);
      
      // ì•Œë¦¼ ì²´í¬
      if (metrics.master.waiting > 10) {
        this.emit('alert', {
          type: 'pool_full',
          message: 'Master pool is full',
          metrics
        });
      }
    }, 5000);
  }
  
  async writeQuery(text, params) {
    try {
      const start = Date.now();
      const result = await this.masterPool.query(text, params);
      const duration = Date.now() - start;
      
      if (duration > 1000) {
        this.emit('slow_query', { query: text, duration });
      }
      
      return result;
    } catch (error) {
      this.emit('query_error', { query: text, error });
      throw error;
    }
  }
  
  async readQuery(text, params) {
    if (this.slavePools.length === 0) {
      return await this.writeQuery(text, params);
    }
    
    // Round Robinìœ¼ë¡œ Slave ì„ íƒ
    const slave = this.slavePools[
      Math.floor(Math.random() * this.slavePools.length)
    ];
    
    try {
      return await slave.pool.query(text, params);
    } catch (error) {
      // Slave ì‹¤íŒ¨ ì‹œ Master ì‚¬ìš©
      console.warn('Slave query failed, using master', error);
      return await this.writeQuery(text, params);
    }
  }
  
  getMetrics() {
    return {
      master: {
        total: this.masterPool.totalCount,
        idle: this.masterPool.idleCount,
        waiting: this.masterPool.waitingCount,
        active: this.masterPool.totalCount - this.masterPool.idleCount
      },
      slaves: this.slavePools.map((slave, index) => ({
        index,
        total: slave.pool.totalCount,
        idle: slave.pool.idleCount,
        waiting: slave.pool.waitingCount,
        active: slave.pool.totalCount - slave.pool.idleCount
      }))
    };
  }
  
  async healthCheck() {
    const checks = {
      master: await this.checkPool(this.masterPool),
      slaves: await Promise.all(
        this.slavePools.map(s => this.checkPool(s.pool))
      )
    };
    
    return {
      healthy: checks.master && checks.slaves.every(s => s),
      details: checks
    };
  }
  
  async checkPool(pool) {
    try {
      await pool.query('SELECT 1');
      return true;
    } catch (error) {
      return false;
    }
  }
  
  async close() {
    await Promise.all([
      this.masterPool.end(),
      ...this.slavePools.map(s => s.pool.end())
    ]);
  }
}

// ì‚¬ìš© ì˜ˆì‹œ
const dbPool = new ProductionReadyPool({
  master: {
    host: process.env.DB_MASTER_HOST,
    database: process.env.DB_NAME,
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD
  },
  slaves: [
    {
      host: process.env.DB_SLAVE1_HOST,
      database: process.env.DB_NAME,
      user: process.env.DB_USER,
      password: process.env.DB_PASSWORD,
      weight: 2
    },
    {
      host: process.env.DB_SLAVE2_HOST,
      database: process.env.DB_NAME,
      user: process.env.DB_USER,
      password: process.env.DB_PASSWORD,
      weight: 1
    }
  ]
});

// ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
dbPool.on('alert', (alert) => {
  console.error('Pool alert:', alert);
  // ì•Œë¦¼ ì‹œìŠ¤í…œì— ì „ì†¡
});

dbPool.on('slow_query', (data) => {
  console.warn('Slow query detected:', data);
});

// í—¬ìŠ¤ì²´í¬ ì—”ë“œí¬ì¸íŠ¸
app.get('/health/db', async (req, res) => {
  const health = await dbPool.healthCheck();
  const metrics = dbPool.getMetrics();
  
  res.json({
    health,
    metrics
  });
});
```

## ğŸ“ ê²°ë¡ 

íš¨ê³¼ì ì¸ ì—°ê²° í’€ ê´€ë¦¬ëŠ” ë°ì´í„°ë² ì´ìŠ¤ ì„±ëŠ¥ê³¼ ì•ˆì •ì„±ì„ ë³´ì¥í•˜ëŠ” í•µì‹¬ ìš”ì†Œì…ë‹ˆë‹¤.

### í•µì‹¬ í¬ì¸íŠ¸

- âœ… **ì—°ê²° í’€ ì„¤ì •**: ìµœëŒ€/ìµœì†Œ ì—°ê²° ìˆ˜, íƒ€ì„ì•„ì›ƒ ìµœì í™”
- âœ… **Read/Write ë¶„ë¦¬**: Master-Slave êµ¬ì¡°ë¡œ ë¶€í•˜ ë¶„ì‚°
- âœ… **ëª¨ë‹ˆí„°ë§**: ì—°ê²° ìƒíƒœ, ì¿¼ë¦¬ ì„±ëŠ¥ ì¶”ì 
- âœ… **ì¥ì•  ëŒ€ì‘**: Circuit Breaker, Graceful Degradation
- âœ… **ì¬ì—°ê²° ì „ëµ**: ìë™ ì¬ì—°ê²° ë° ë³µêµ¬

### ëª¨ë²” ì‚¬ë¡€

1. **ì ì ˆí•œ ì—°ê²° ìˆ˜**: ë°ì´í„°ë² ì´ìŠ¤ ì œí•œê³¼ ì• í”Œë¦¬ì¼€ì´ì…˜ ì¸ìŠ¤í„´ìŠ¤ ìˆ˜ ê³ ë ¤
2. **íƒ€ì„ì•„ì›ƒ ì„¤ì •**: ì—°ê²° ë° ì¿¼ë¦¬ íƒ€ì„ì•„ì›ƒ ì ì ˆíˆ ì„¤ì •
3. **ëª¨ë‹ˆí„°ë§**: ì§€ì†ì ì¸ ë©”íŠ¸ë¦­ ìˆ˜ì§‘ ë° ì•Œë¦¼
4. **ì¥ì•  ëŒ€ì‘**: Circuit Breaker ë° Fallback ì „ëµ
5. **Read/Write ë¶„ë¦¬**: ë¶€í•˜ ë¶„ì‚° ë° ì„±ëŠ¥ í–¥ìƒ

### ê´€ë ¨ ë¬¸ì„œ

- [ORM ì‹¬í™” ì „ëµ](./ORM_ì‹¬í™”_ì „ëµ.md) - ORMê³¼ ì—°ê²° í’€ í†µí•©
- [Observability ì „ëµ](../ëª¨ë‹ˆí„°ë§/Observability_ì „ëµ.md) - ì—°ê²° í’€ ë©”íŠ¸ë¦­ ëª¨ë‹ˆí„°ë§
- [ì„±ëŠ¥ ìµœì í™”](../Performance/Node.js_ì„±ëŠ¥_ìµœì í™”_ë°_í”„ë¡œíŒŒì¼ë§.md) - ë°ì´í„°ë² ì´ìŠ¤ ì„±ëŠ¥ ìµœì í™”
- [ì—ëŸ¬ í•¸ë“¤ë§](../ì—ëŸ¬_í•¸ë“¤ë§/ì—ëŸ¬_í•¸ë“¤ë§_ì „ëµ.md) - ì—°ê²° ì‹¤íŒ¨ ì—ëŸ¬ ì²˜ë¦¬

