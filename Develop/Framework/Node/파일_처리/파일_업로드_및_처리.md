---
title: Node.js íŒŒì¼ ì—…ë¡œë“œ ë° ì²˜ë¦¬
tags: [framework, node, file-upload, multer, s3, image-processing, storage]
updated: 2025-11-25
---

# ğŸ“ Node.js íŒŒì¼ ì—…ë¡œë“œ ë° ì²˜ë¦¬

## ğŸ“Œ ê°œìš”

> **íŒŒì¼ ì—…ë¡œë“œ**ëŠ” í˜„ëŒ€ ì›¹ ì• í”Œë¦¬ì¼€ì´ì…˜ì˜ í•µì‹¬ ê¸°ëŠ¥ìœ¼ë¡œ, ì‚¬ìš©ì ìƒì„± ì½˜í…ì¸ , í”„ë¡œí•„ ì´ë¯¸ì§€, ë¬¸ì„œ ë“±ì„ ì²˜ë¦¬í•©ë‹ˆë‹¤.

### ğŸ¯ íŒŒì¼ ì—…ë¡œë“œì˜ ì£¼ìš” ê³ ë ¤ì‚¬í•­

```mermaid
mindmap
  root((íŒŒì¼ ì—…ë¡œë“œ))
    ë³´ì•ˆ
      íŒŒì¼ íƒ€ì… ê²€ì¦
      íŒŒì¼ í¬ê¸° ì œí•œ
      ë°”ì´ëŸ¬ìŠ¤ ìŠ¤ìº”
      ê²½ë¡œ íƒìƒ‰ ë°©ì§€
    ì„±ëŠ¥
      ìŠ¤íŠ¸ë¦¬ë° ì—…ë¡œë“œ
      ë©€í‹°íŒŒíŠ¸ ì—…ë¡œë“œ
      ë³‘ë ¬ ì²˜ë¦¬
    ì €ì¥ì†Œ
      ë¡œì»¬ íŒŒì¼ ì‹œìŠ¤í…œ
      í´ë¼ìš°ë“œ ìŠ¤í† ë¦¬ì§€
      CDN ì—°ë™
```

### ğŸ“Š íŒŒì¼ ì—…ë¡œë“œ íë¦„

```mermaid
sequenceDiagram
    participant C as í´ë¼ì´ì–¸íŠ¸
    participant S as ì„œë²„
    participant V as ê²€ì¦
    participant St as ì €ì¥ì†Œ
    
    C->>S: íŒŒì¼ ì—…ë¡œë“œ ìš”ì²­
    S->>V: íŒŒì¼ ê²€ì¦
    V-->>S: ê²€ì¦ ê²°ê³¼
    S->>St: íŒŒì¼ ì €ì¥
    St-->>S: ì €ì¥ ì™„ë£Œ
    S-->>C: ì‘ë‹µ (URL)
```

## ğŸ”§ Multer ì„¤ì • ë° ìµœì í™”

### Multer ê¸°ë³¸ ì„¤ì •

```javascript
const multer = require('multer');
const path = require('path');
const fs = require('fs');

// ì—…ë¡œë“œ ë””ë ‰í† ë¦¬ ìƒì„±
const uploadDir = 'uploads';
if (!fs.existsSync(uploadDir)) {
  fs.mkdirSync(uploadDir, { recursive: true });
}

// ì €ì¥ì†Œ ì„¤ì •
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    // íŒŒì¼ íƒ€ì…ë³„ ë””ë ‰í† ë¦¬ ë¶„ë¦¬
    let dir = uploadDir;
    if (file.mimetype.startsWith('image/')) {
      dir = path.join(uploadDir, 'images');
    } else if (file.mimetype.startsWith('video/')) {
      dir = path.join(uploadDir, 'videos');
    } else {
      dir = path.join(uploadDir, 'documents');
    }
    
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
    
    cb(null, dir);
  },
  filename: (req, file, cb) => {
    // ê³ ìœ í•œ íŒŒì¼ëª… ìƒì„±
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    const ext = path.extname(file.originalname);
    const name = path.basename(file.originalname, ext);
    cb(null, `${name}-${uniqueSuffix}${ext}`);
  }
});

// íŒŒì¼ í•„í„°
const fileFilter = (req, file, cb) => {
  // í—ˆìš©ëœ íŒŒì¼ íƒ€ì…
  const allowedTypes = /jpeg|jpg|png|gif|pdf|doc|docx/;
  const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());
  const mimetype = allowedTypes.test(file.mimetype);
  
  if (extname && mimetype) {
    cb(null, true);
  } else {
    cb(new Error('Invalid file type. Only images and documents are allowed.'));
  }
};

// Multer ì„¤ì •
const upload = multer({
  storage: storage,
  limits: {
    fileSize: 10 * 1024 * 1024, // 10MB
    files: 5 // ìµœëŒ€ 5ê°œ íŒŒì¼
  },
  fileFilter: fileFilter
});

// Express ë¼ìš°í„°
app.post('/upload', upload.single('file'), (req, res) => {
  if (!req.file) {
    return res.status(400).json({ error: 'No file uploaded' });
  }
  
  res.json({
    message: 'File uploaded successfully',
    file: {
      filename: req.file.filename,
      originalname: req.file.originalname,
      mimetype: req.file.mimetype,
      size: req.file.size,
      path: req.file.path
    }
  });
});

// ì—¬ëŸ¬ íŒŒì¼ ì—…ë¡œë“œ
app.post('/upload/multiple', upload.array('files', 5), (req, res) => {
  if (!req.files || req.files.length === 0) {
    return res.status(400).json({ error: 'No files uploaded' });
  }
  
  const files = req.files.map(file => ({
    filename: file.filename,
    originalname: file.originalname,
    mimetype: file.mimetype,
    size: file.size,
    path: file.path
  }));
  
  res.json({
    message: 'Files uploaded successfully',
    files
  });
});
```

### ë©”ëª¨ë¦¬ ìŠ¤í† ë¦¬ì§€ (ì„ì‹œ ì €ì¥)

```javascript
const multer = require('multer');

// ë©”ëª¨ë¦¬ ìŠ¤í† ë¦¬ì§€ (S3 ì—…ë¡œë“œ ì „ ì„ì‹œ ì €ì¥)
const memoryStorage = multer.memoryStorage();

const upload = multer({
  storage: memoryStorage,
  limits: {
    fileSize: 10 * 1024 * 1024 // 10MB
  }
});

app.post('/upload-to-s3', upload.single('file'), async (req, res) => {
  if (!req.file) {
    return res.status(400).json({ error: 'No file uploaded' });
  }
  
  // S3ì— ì—…ë¡œë“œ
  const s3Url = await uploadToS3(req.file.buffer, req.file.originalname);
  
  res.json({
    message: 'File uploaded to S3',
    url: s3Url
  });
});
```

## â˜ï¸ S3 ì—…ë¡œë“œ (ë©€í‹°íŒŒíŠ¸)

### ê¸°ë³¸ S3 ì—…ë¡œë“œ

```javascript
const AWS = require('aws-sdk');
const multer = require('multer');
const multerS3 = require('multer-s3');

// S3 ì„¤ì •
const s3 = new AWS.S3({
  accessKeyId: process.env.AWS_ACCESS_KEY_ID,
  secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
  region: process.env.AWS_REGION
});

// S3 ìŠ¤í† ë¦¬ì§€ ì„¤ì •
const s3Storage = multerS3({
  s3: s3,
  bucket: process.env.S3_BUCKET_NAME,
  acl: 'public-read',
  key: (req, file, cb) => {
    const folder = file.mimetype.startsWith('image/') ? 'images' : 'documents';
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    const ext = path.extname(file.originalname);
    const filename = `${folder}/${uniqueSuffix}${ext}`;
    cb(null, filename);
  },
  contentType: multerS3.AUTO_CONTENT_TYPE
});

const upload = multer({
  storage: s3Storage,
  limits: {
    fileSize: 50 * 1024 * 1024 // 50MB
  }
});

app.post('/upload-s3', upload.single('file'), (req, res) => {
  res.json({
    message: 'File uploaded to S3',
    url: req.file.location,
    key: req.file.key
  });
});
```

### ë©€í‹°íŒŒíŠ¸ ì—…ë¡œë“œ (ëŒ€ìš©ëŸ‰ íŒŒì¼)

```mermaid
graph TD
    A[ëŒ€ìš©ëŸ‰ íŒŒì¼] --> B[íŒŒì¼ ë¶„í• ]
    B --> C[íŒŒíŠ¸ 1 ì—…ë¡œë“œ]
    B --> D[íŒŒíŠ¸ 2 ì—…ë¡œë“œ]
    B --> E[íŒŒíŠ¸ 3 ì—…ë¡œë“œ]
    
    C --> F[ì—…ë¡œë“œ ID]
    D --> F
    E --> F
    
    F --> G[íŒŒíŠ¸ ì™„ë£Œ]
    G --> H[ì „ì²´ ì™„ë£Œ]
    
    style A fill:#4fc3f7
    style F fill:#66bb6a
    style H fill:#66bb6a
```

#### ë©€í‹°íŒŒíŠ¸ ì—…ë¡œë“œ êµ¬í˜„

```javascript
const AWS = require('aws-sdk');
const fs = require('fs');
const path = require('path');

class S3MultipartUpload {
  constructor() {
    this.s3 = new AWS.S3({
      accessKeyId: process.env.AWS_ACCESS_KEY_ID,
      secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
      region: process.env.AWS_REGION
    });
    this.bucket = process.env.S3_BUCKET_NAME;
    this.partSize = 5 * 1024 * 1024; // 5MB per part
  }
  
  async uploadLargeFile(filePath, key) {
    const fileSize = fs.statSync(filePath).size;
    const partCount = Math.ceil(fileSize / this.partSize);
    
    // ë©€í‹°íŒŒíŠ¸ ì—…ë¡œë“œ ì‹œì‘
    const { UploadId } = await this.s3.createMultipartUpload({
      Bucket: this.bucket,
      Key: key,
      ContentType: 'application/octet-stream'
    }).promise();
    
    const parts = [];
    
    // ê° íŒŒíŠ¸ ì—…ë¡œë“œ
    for (let partNumber = 1; partNumber <= partCount; partNumber++) {
      const start = (partNumber - 1) * this.partSize;
      const end = Math.min(start + this.partSize, fileSize);
      
      const partData = fs.createReadStream(filePath, { start, end });
      
      const { ETag } = await this.s3.uploadPart({
        Bucket: this.bucket,
        Key: key,
        PartNumber: partNumber,
        UploadId: UploadId,
        Body: partData
      }).promise();
      
      parts.push({
        ETag,
        PartNumber: partNumber
      });
      
      console.log(`Part ${partNumber}/${partCount} uploaded`);
    }
    
    // ë©€í‹°íŒŒíŠ¸ ì—…ë¡œë“œ ì™„ë£Œ
    const { Location } = await this.s3.completeMultipartUpload({
      Bucket: this.bucket,
      Key: key,
      UploadId: UploadId,
      MultipartUpload: {
        Parts: parts
      }
    }).promise();
    
    return Location;
  }
  
  async uploadLargeFileStream(stream, key, fileSize) {
    const partCount = Math.ceil(fileSize / this.partSize);
    
    // ë©€í‹°íŒŒíŠ¸ ì—…ë¡œë“œ ì‹œì‘
    const { UploadId } = await this.s3.createMultipartUpload({
      Bucket: this.bucket,
      Key: key,
      ContentType: 'application/octet-stream'
    }).promise();
    
    const parts = [];
    let partNumber = 1;
    let buffer = Buffer.alloc(0);
    
    return new Promise((resolve, reject) => {
      stream.on('data', async (chunk) => {
        buffer = Buffer.concat([buffer, chunk]);
        
        while (buffer.length >= this.partSize) {
          const partData = buffer.slice(0, this.partSize);
          buffer = buffer.slice(this.partSize);
          
          try {
            const { ETag } = await this.s3.uploadPart({
              Bucket: this.bucket,
              Key: key,
              PartNumber: partNumber,
              UploadId: UploadId,
              Body: partData
            }).promise();
            
            parts.push({
              ETag,
              PartNumber: partNumber
            });
            
            partNumber++;
          } catch (error) {
            reject(error);
            return;
          }
        }
      });
      
      stream.on('end', async () => {
        // ë§ˆì§€ë§‰ íŒŒíŠ¸ ì—…ë¡œë“œ
        if (buffer.length > 0) {
          try {
            const { ETag } = await this.s3.uploadPart({
              Bucket: this.bucket,
              Key: key,
              PartNumber: partNumber,
              UploadId: UploadId,
              Body: buffer
            }).promise();
            
            parts.push({
              ETag,
              PartNumber: partNumber
            });
          } catch (error) {
            reject(error);
            return;
          }
        }
        
        // ë©€í‹°íŒŒíŠ¸ ì—…ë¡œë“œ ì™„ë£Œ
        try {
          const { Location } = await this.s3.completeMultipartUpload({
            Bucket: this.bucket,
            Key: key,
            UploadId: UploadId,
            MultipartUpload: {
              Parts: parts
            }
          }).promise();
          
          resolve(Location);
        } catch (error) {
          reject(error);
        }
      });
      
      stream.on('error', reject);
    });
  }
}

// ì‚¬ìš© ì˜ˆì‹œ
const multipartUpload = new S3MultipartUpload();

app.post('/upload-large', upload.single('file'), async (req, res) => {
  if (!req.file) {
    return res.status(400).json({ error: 'No file uploaded' });
  }
  
  const key = `uploads/${Date.now()}-${req.file.originalname}`;
  
  try {
    const url = await multipartUpload.uploadLargeFile(req.file.path, key);
    
    // ì„ì‹œ íŒŒì¼ ì‚­ì œ
    fs.unlinkSync(req.file.path);
    
    res.json({
      message: 'Large file uploaded successfully',
      url
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});
```

## ğŸ–¼ï¸ ì´ë¯¸ì§€ ë¦¬ì‚¬ì´ì§• ë° ìµœì í™”

### Sharpë¥¼ ì‚¬ìš©í•œ ì´ë¯¸ì§€ ì²˜ë¦¬

```javascript
const sharp = require('sharp');
const multer = require('multer');
const path = require('path');

// ë©”ëª¨ë¦¬ ìŠ¤í† ë¦¬ì§€
const upload = multer({
  storage: multer.memoryStorage(),
  fileFilter: (req, file, cb) => {
    if (file.mimetype.startsWith('image/')) {
      cb(null, true);
    } else {
      cb(new Error('Only images are allowed'));
    }
  },
  limits: {
    fileSize: 10 * 1024 * 1024 // 10MB
  }
});

// ì´ë¯¸ì§€ ë¦¬ì‚¬ì´ì§• ë° ìµœì í™”
async function processImage(buffer, options = {}) {
  const {
    width = 800,
    height = 600,
    quality = 80,
    format = 'jpeg'
  } = options;
  
  let image = sharp(buffer);
  
  // ë©”íƒ€ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
  const metadata = await image.metadata();
  
  // ë¦¬ì‚¬ì´ì§•
  image = image.resize(width, height, {
    fit: 'inside',
    withoutEnlargement: true
  });
  
  // í¬ë§· ë³€í™˜ ë° ìµœì í™”
  if (format === 'jpeg' || format === 'jpg') {
    image = image.jpeg({ quality });
  } else if (format === 'png') {
    image = image.png({ compressionLevel: 9 });
  } else if (format === 'webp') {
    image = image.webp({ quality });
  }
  
  return {
    buffer: await image.toBuffer(),
    metadata: {
      width: metadata.width,
      height: metadata.height,
      format: metadata.format
    }
  };
}

// ì—¬ëŸ¬ í¬ê¸°ë¡œ ë¦¬ì‚¬ì´ì§•
async function generateThumbnails(buffer) {
  const sizes = [
    { name: 'thumbnail', width: 150, height: 150 },
    { name: 'small', width: 400, height: 400 },
    { name: 'medium', width: 800, height: 800 },
    { name: 'large', width: 1200, height: 1200 }
  ];
  
  const thumbnails = {};
  
  for (const size of sizes) {
    const { buffer: resized } = await processImage(buffer, {
      width: size.width,
      height: size.height,
      format: 'webp',
      quality: 85
    });
    
    thumbnails[size.name] = resized;
  }
  
  return thumbnails;
}

// Express ë¼ìš°í„°
app.post('/upload-image', upload.single('image'), async (req, res) => {
  if (!req.file) {
    return res.status(400).json({ error: 'No image uploaded' });
  }
  
  try {
    // ì›ë³¸ ì´ë¯¸ì§€ ì €ì¥
    const originalKey = `images/original/${Date.now()}-${req.file.originalname}`;
    await uploadToS3(req.file.buffer, originalKey);
    
    // ì¸ë„¤ì¼ ìƒì„±
    const thumbnails = await generateThumbnails(req.file.buffer);
    
    // ì¸ë„¤ì¼ ì—…ë¡œë“œ
    const thumbnailUrls = {};
    for (const [size, buffer] of Object.entries(thumbnails)) {
      const key = `images/${size}/${Date.now()}-${size}.webp`;
      const url = await uploadToS3(buffer, key);
      thumbnailUrls[size] = url;
    }
    
    res.json({
      message: 'Image uploaded and processed',
      original: `https://${process.env.S3_BUCKET_NAME}.s3.amazonaws.com/${originalKey}`,
      thumbnails: thumbnailUrls
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});
```

## ğŸ”’ íŒŒì¼ ê²€ì¦ ë° ë³´ì•ˆ

### íŒŒì¼ ê²€ì¦

```javascript
const fileType = require('file-type');
const crypto = require('crypto');

class FileValidator {
  // í—ˆìš©ëœ MIME íƒ€ì…
  static allowedMimeTypes = {
    image: ['image/jpeg', 'image/png', 'image/gif', 'image/webp'],
    document: ['application/pdf', 'application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'],
    video: ['video/mp4', 'video/webm']
  };
  
  // í—ˆìš©ëœ íŒŒì¼ í™•ì¥ì
  static allowedExtensions = {
    image: ['.jpg', '.jpeg', '.png', '.gif', '.webp'],
    document: ['.pdf', '.doc', '.docx'],
    video: ['.mp4', '.webm']
  };
  
  // íŒŒì¼ íƒ€ì… ê²€ì¦
  static async validateFileType(buffer, originalname) {
    // íŒŒì¼ ì‹œê·¸ë‹ˆì²˜ í™•ì¸ (ë§¤ì§ ë„˜ë²„)
    const type = await fileType.fromBuffer(buffer);
    
    if (!type) {
      throw new Error('Unable to determine file type');
    }
    
    // í™•ì¥ì í™•ì¸
    const ext = path.extname(originalname).toLowerCase();
    const allowedExts = [
      ...this.allowedExtensions.image,
      ...this.allowedExtensions.document,
      ...this.allowedExtensions.video
    ];
    
    if (!allowedExts.includes(ext)) {
      throw new Error('Invalid file extension');
    }
    
    // MIME íƒ€ì… í™•ì¸
    const allowedMimes = [
      ...this.allowedMimeTypes.image,
      ...this.allowedMimeTypes.document,
      ...this.allowedMimeTypes.video
    ];
    
    if (!allowedMimes.includes(type.mime)) {
      throw new Error('Invalid MIME type');
    }
    
    // í™•ì¥ìì™€ MIME íƒ€ì… ì¼ì¹˜ í™•ì¸
    const expectedMime = this.getMimeFromExtension(ext);
    if (expectedMime && expectedMime !== type.mime) {
      throw new Error('File extension and MIME type mismatch');
    }
    
    return type;
  }
  
  // í™•ì¥ìì—ì„œ MIME íƒ€ì… ê°€ì ¸ì˜¤ê¸°
  static getMimeFromExtension(ext) {
    const mimeMap = {
      '.jpg': 'image/jpeg',
      '.jpeg': 'image/jpeg',
      '.png': 'image/png',
      '.gif': 'image/gif',
      '.webp': 'image/webp',
      '.pdf': 'application/pdf',
      '.doc': 'application/msword',
      '.docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
      '.mp4': 'video/mp4',
      '.webm': 'video/webm'
    };
    
    return mimeMap[ext.toLowerCase()];
  }
  
  // íŒŒì¼ í¬ê¸° ê²€ì¦
  static validateFileSize(size, maxSize = 10 * 1024 * 1024) {
    if (size > maxSize) {
      throw new Error(`File size exceeds maximum allowed size of ${maxSize / 1024 / 1024}MB`);
    }
  }
  
  // íŒŒì¼ëª… ê²€ì¦ (ê²½ë¡œ íƒìƒ‰ ë°©ì§€)
  static validateFileName(filename) {
    // ìœ„í—˜í•œ ë¬¸ì ì œê±°
    const dangerous = /[<>:"|?*\x00-\x1f]/g;
    if (dangerous.test(filename)) {
      throw new Error('Invalid characters in filename');
    }
    
    // ê²½ë¡œ íƒìƒ‰ ë°©ì§€
    if (filename.includes('..') || filename.includes('/') || filename.includes('\\')) {
      throw new Error('Path traversal detected');
    }
    
    return filename.replace(dangerous, '');
  }
  
  // íŒŒì¼ í•´ì‹œ ìƒì„± (ì¤‘ë³µ ê²€ì‚¬)
  static generateFileHash(buffer) {
    return crypto.createHash('sha256').update(buffer).digest('hex');
  }
}

// ì‚¬ìš© ì˜ˆì‹œ
app.post('/upload-secure', upload.single('file'), async (req, res) => {
  if (!req.file) {
    return res.status(400).json({ error: 'No file uploaded' });
  }
  
  try {
    // íŒŒì¼ íƒ€ì… ê²€ì¦
    await FileValidator.validateFileType(req.file.buffer, req.file.originalname);
    
    // íŒŒì¼ í¬ê¸° ê²€ì¦
    FileValidator.validateFileSize(req.file.size, 10 * 1024 * 1024);
    
    // íŒŒì¼ëª… ê²€ì¦
    const safeFilename = FileValidator.validateFileName(req.file.originalname);
    
    // íŒŒì¼ í•´ì‹œ ìƒì„±
    const fileHash = FileValidator.generateFileHash(req.file.buffer);
    
    // ì¤‘ë³µ íŒŒì¼ í™•ì¸
    const existingFile = await db.files.findOne({ hash: fileHash });
    if (existingFile) {
      return res.json({
        message: 'File already exists',
        url: existingFile.url
      });
    }
    
    // íŒŒì¼ ì €ì¥
    const key = `uploads/${fileHash}-${safeFilename}`;
    const url = await uploadToS3(req.file.buffer, key);
    
    // ë°ì´í„°ë² ì´ìŠ¤ì— ê¸°ë¡
    await db.files.create({
      filename: safeFilename,
      hash: fileHash,
      url: url,
      size: req.file.size,
      mimetype: req.file.mimetype
    });
    
    res.json({
      message: 'File uploaded successfully',
      url
    });
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});
```

## ğŸ“ ê²°ë¡ 

íŒŒì¼ ì—…ë¡œë“œ ë° ì²˜ë¦¬ëŠ” ë³´ì•ˆê³¼ ì„±ëŠ¥ì„ ëª¨ë‘ ê³ ë ¤í•´ì•¼ í•˜ëŠ” ë³µì¡í•œ ì‘ì—…ì…ë‹ˆë‹¤.

### í•µì‹¬ í¬ì¸íŠ¸

- âœ… **Multer ì„¤ì •**: ì ì ˆí•œ ìŠ¤í† ë¦¬ì§€ ë° ì œí•œ ì„¤ì •
- âœ… **S3 ì—…ë¡œë“œ**: ë©€í‹°íŒŒíŠ¸ ì—…ë¡œë“œë¡œ ëŒ€ìš©ëŸ‰ íŒŒì¼ ì²˜ë¦¬
- âœ… **ì´ë¯¸ì§€ ìµœì í™”**: Sharpë¥¼ ì‚¬ìš©í•œ ë¦¬ì‚¬ì´ì§• ë° í¬ë§· ë³€í™˜
- âœ… **íŒŒì¼ ê²€ì¦**: íƒ€ì…, í¬ê¸°, íŒŒì¼ëª… ê²€ì¦
- âœ… **ë³´ì•ˆ**: ê²½ë¡œ íƒìƒ‰ ë°©ì§€, íŒŒì¼ ì‹œê·¸ë‹ˆì²˜ í™•ì¸

### ëª¨ë²” ì‚¬ë¡€

1. **íŒŒì¼ íƒ€ì… ê²€ì¦**: MIME íƒ€ì…ê³¼ íŒŒì¼ ì‹œê·¸ë‹ˆì²˜ ëª¨ë‘ í™•ì¸
2. **íŒŒì¼ í¬ê¸° ì œí•œ**: ì„œë²„ ë° í´ë¼ì´ì–¸íŠ¸ ëª¨ë‘ì—ì„œ ì œí•œ
3. **ì•ˆì „í•œ íŒŒì¼ëª…**: ìœ„í—˜í•œ ë¬¸ì ì œê±° ë° ê²½ë¡œ íƒìƒ‰ ë°©ì§€
4. **ì´ë¯¸ì§€ ìµœì í™”**: ì—¬ëŸ¬ í¬ê¸°ë¡œ ë¦¬ì‚¬ì´ì§• ë° í¬ë§· ë³€í™˜
5. **í´ë¼ìš°ë“œ ìŠ¤í† ë¦¬ì§€**: ë¡œì»¬ ì €ì¥ì†Œ ëŒ€ì‹  S3 ë“± ì‚¬ìš©
6. **ì¤‘ë³µ íŒŒì¼ ê²€ì‚¬**: í•´ì‹œë¥¼ ì‚¬ìš©í•œ ì¤‘ë³µ ë°©ì§€

### ê´€ë ¨ ë¬¸ì„œ

- [ë³´ì•ˆ ëª¨ë²” ì‚¬ë¡€](../ë³´ì•ˆ/Node.js_ë³´ì•ˆ_ëª¨ë²”ì‚¬ë¡€.md) - íŒŒì¼ ì—…ë¡œë“œ ë³´ì•ˆ
- [ë°±ê·¸ë¼ìš´ë“œ ì‘ì—…](../ë°±ê·¸ë¼ìš´ë“œ_ì‘ì—…/ì‘ì—…_í_ì²˜ë¦¬.md) - ëŒ€ìš©ëŸ‰ íŒŒì¼ ì²˜ë¦¬ ì‘ì—… í
- [ì„±ëŠ¥ ìµœì í™”](../Performance/Node.js_ì„±ëŠ¥_ìµœì í™”_ë°_í”„ë¡œíŒŒì¼ë§.md) - íŒŒì¼ ì²˜ë¦¬ ì„±ëŠ¥ ìµœì í™”
- [ì—ëŸ¬ í•¸ë“¤ë§](../ì—ëŸ¬_í•¸ë“¤ë§/ì—ëŸ¬_í•¸ë“¤ë§_ì „ëµ.md) - íŒŒì¼ ì—…ë¡œë“œ ì—ëŸ¬ ì²˜ë¦¬

