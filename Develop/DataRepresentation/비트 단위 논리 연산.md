# 비트 단위 논리 연산
- 컴퓨터에서 데이터를 비트(bit) 단위로 처리하는 논리 연산을 의미합니다.
- 논리 연산은 주로 논리적인 조건을 판단하거나 비트 단위의 데이터를 조작하는 데 사용됩니다.
- 일반적으로 AND, OR, XOR, NOT 등의 비트 논리 연산자가 사용됩니다. 
- 각각에 대해 자세히 설명하겠습니다.


1. AND 연산:
   AND 연산은 두 개의 비트를 비교하여 둘 다 1인 경우에만 결과가 1이 되는 연산입니다. AND 연산자는 일반적으로 "&" 기호로 표현되며, A AND B 또는 A & B와 같이 표기합니다.

AND 연산의 진리표는 다음과 같습니다:
```
A   B   A AND B
0   0      0
0   1      0
1   0      0
1   1      1
```

예를 들어, 5(이진수로 0101)와 3(이진수로 0011)의 AND 연산은 다음과 같습니다:
```
  0101 (5)
& 0011 (3)
--------
  0001 (1)
```
결과는 1(이진수로 0001)이 됩니다.

2. OR 연산:
   OR 연산은 두 개의 비트를 비교하여 하나 이상의 비트가 1이면 결과가 1이 되는 연산입니다. OR 연산자는 일반적으로 "|" 기호로 표현되며, A OR B 또는 A | B와 같이 표기합니다.

OR 연산의 진리표는 다음과 같습니다:
```
A   B   A OR B
0   0     0
0   1     1
1   0     1
1   1     1
```

예를 들어, 5(이진수로 0101)와 3(이진수로 0011)의 OR 연산은 다음과 같습니다:
```
  0101 (5)
| 0011 (3)
--------
  0111 (7)
```
결과는 7(이진수로 0111)이 됩니다.

3. XOR 연산:
   XOR 연산은 두 개의 비트를 비교하여 서로 다른 경우에만 결과가 1이 되는 연산입니다. XOR 연산자는 일반적으로 "^" 기호로 표현되며, A XOR B 또는 A ^ B와 같이 표기합니다.

XOR 연산의 진리표는 다음과 같습니다:
```
A   B   A XOR B
0   0       0
0   1       1
1   0       1
1   1       0
```

예를 들어, 5(이진수로 0101)와 3(이진수로 0011)의 XOR 연산은 다음과 같습니다:
```
  0101 (5)
^ 0011 (3)
--------
  0110 (6)
```
결과는 6(이진수로 0110)이 됩니다.

4. NOT 연산:
   NOT 연산은 단일 비트의 값을 반전시키는 연산입니다. NOT 연산자는 일반적으로 "~" 기호로 표현되며, NOT A 또는 ~A와 같이 표기합니다.

NOT 연산의 진리표는 다음과 같습니다:
```
A   NOT A
0     1
1     0
```

예를 들어, 5(이진수로 0101)의 NOT 연산은 다음과 같습니다:
```
  NOT 0101 (5)
-----------
  1010 (10)
```
결과는 10(이진수로 1010)이 됩니다.

비트 단위 논리 연산은 컴퓨터 프로그래밍, 컴퓨터 아키텍처, 데이터 암호화 등 다양한 분야에서 활용되며, 복잡한 연산과 조건 판단에 유용합니다.


# mask란?
- 주로 비트 연산을 수행할 때 특정 비트들을 선택하거나 제외하기 위해 사용되는 비트 패턴을 말합니다.
- 마스크는 일종의 필터 역할을 수행하여 원하는 비트들을 보존하고 다른 비트들을 변경하거나 제거하는 데에 활용됩니다.


## 비트 추출하기
- 특정 위치의 비트 값을 추출하는 데에 마스크를 사용할 수 있습니다. 
- 예를 들어, 4번째 비트(인덱스는 0부터 시작)를 추출하고 싶다고 가정해 봅시다.
- 다음과 같이 AND 연산을 활용하여 해당 비트를 추출할 수 있습니다.


```typescript
// 원본 비트열
const number = 12;  // 00001100 (2진수로 표현하면 1100)

// 4번째 비트 추출하기
const mask = 1 << 3;  // 4번째 비트의 위치를 나타내는 마스크 (00001000)
const result = number & mask;

console.log(result.toString(2));  // 출력 결과: 1000 (2진수로 표현하면 1000)

```

## 비트 설정하기
- 특정 위치의 비트를 1로 설정하고 싶다면 OR 연산을 활용할 수 있습니다. 
- 예를 들어, 3번째 비트를 1로 설정해 보겠습니다.

```typescript
// 원본 비트열
let number = 9;   // 00001001 (2진수로 표현하면 1001)

// 3번째 비트를 1로 설정
const mask = 1 << 2;  // 3번째 비트의 위치를 나타내는 마스크 (00000100)
number |= mask;

console.log(number.toString(2));  // 출력 결과: 1101 (2진수로 표현하면 1101)

```


## 비트 반전하기
- NOT 연산을 활용하여 특정 비트를 반전시킬 수 있습니다.
- 예를 들어, 2번째 비트를 반전시켜 보겠습니다.

```typescript
// 원본 비트열
let number = 6;   // 00000110 (2진수로 표현하면 110)

// 2번째 비트 반전
const mask = 1 << 1;  // 2번째 비트의 위치를 나타내는 마스크 (00000010)
number ^= mask;

console.log(number.toString(2));  // 출력 결과: 1110 (2진수로 표현하면 1110)

```