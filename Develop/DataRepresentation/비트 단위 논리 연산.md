---
title: 비트 단위 논리 연산
tags: [datarepresentation, 비트-단위-논리-연산, bitwise-operations, logical-operations]
updated: 2025-08-14
---

# 비트 단위 논리 연산

## 배경

컴퓨터에서 데이터를 비트(bit) 단위로 처리하는 논리 연산을 의미합니다. 논리 연산은 주로 논리적인 조건을 판단하거나 비트 단위의 데이터를 조작하는 데 사용됩니다.

### 비트 연산의 특징
- 일반적으로 AND, OR, XOR, NOT 등의 비트 논리 연산자가 사용됩니다
- 비트 연산은 메모리 효율성과 연산 속도 측면에서 매우 효율적입니다
- 하드웨어 레벨에서 직접 지원되므로 일반적인 산술 연산보다 빠르게 수행됩니다
- 플래그 처리, 마스킹, 암호화 등 다양한 분야에서 활용됩니다

### 비트 연산의 필요성
- **메모리 효율성**: 여러 상태를 하나의 정수로 표현
- **성능 최적화**: 하드웨어 레벨에서 직접 지원되는 빠른 연산
- **저수준 프로그래밍**: 시스템 프로그래밍, 임베디드 시스템에서 필수
- **알고리즘 최적화**: 특정 알고리즘에서 비트 연산을 활용한 최적화

## 핵심

### 기본 비트 연산자

#### 1. AND 연산 (&)
두 개의 비트를 비교하여 둘 다 1인 경우에만 결과가 1이 되는 연산입니다.

**AND 연산의 진리표:**
```
A   B   A AND B
0   0      0
0   1      0
1   0      0
1   1      1
```

**AND 연산의 주요 활용 사례:**

```javascript
// 1. 비트 마스킹
// 하위 4비트만 추출하기
const number = 0b10101111;  // 175
const mask = 0b00001111;    // 15
const result = number & mask;  // 결과: 15 (0b00001111)

// 2. 짝수/홀수 판별
// 마지막 비트가 0이면 짝수, 1이면 홀수
const isEven = (n) => (n & 1) === 0;
console.log(isEven(4));  // true
console.log(isEven(7));  // false

// 3. 플래그 확인
const READ = 0b0001;    // 1
const WRITE = 0b0010;   // 2
const EXECUTE = 0b0100; // 4

const permissions = READ | WRITE;  // 3 (0b0011)
const canRead = (permissions & READ) !== 0;  // true
const canExecute = (permissions & EXECUTE) !== 0;  // false
```

#### 2. OR 연산 (|)
두 개의 비트를 비교하여 하나 이상의 비트가 1이면 결과가 1이 되는 연산입니다.

**OR 연산의 진리표:**
```
A   B   A OR B
0   0     0
0   1     1
1   0     1
1   1     1
```

**OR 연산의 주요 활용 사례:**

```javascript
// 1. 비트 설정
// 특정 비트를 1로 설정
const number = 0b1010;     // 10
const mask = 0b0100;       // 4
const result = number | mask;  // 결과: 14 (0b1110)

// 2. 플래그 추가
const READ = 0b0001;
const WRITE = 0b0010;
const EXECUTE = 0b0100;

let permissions = READ;  // 읽기 권한만 있음
permissions |= WRITE;    // 쓰기 권한 추가
permissions |= EXECUTE;  // 실행 권한 추가
// 결과: 7 (0b0111)

// 3. 여러 옵션 결합
const OPTION_A = 0b0001;
const OPTION_B = 0b0010;
const OPTION_C = 0b0100;
const OPTION_D = 0b1000;

const options = OPTION_A | OPTION_C | OPTION_D;  // A, C, D 옵션 활성화
```

#### 3. XOR 연산 (^)
두 개의 비트를 비교하여 서로 다른 경우에만 결과가 1이 되는 연산입니다.

**XOR 연산의 진리표:**
```
A   B   A XOR B
0   0       0
0   1       1
1   0       1
1   1       0
```

**XOR 연산의 주요 활용 사례:**

```javascript
// 1. 비트 토글
// 특정 비트 반전
const number = 0b1010;     // 10
const mask = 0b0100;       // 4
const result = number ^ mask;  // 결과: 14 (0b1110)

// 2. 값 교환 (XOR 스왑)
let a = 5, b = 3;
a = a ^ b;  // a = 6
b = a ^ b;  // b = 5
a = a ^ b;  // a = 3
// 결과: a = 3, b = 5

// 3. 간단한 암호화
const message = 0b1010;    // 10
const key = 0b1100;        // 12
const encrypted = message ^ key;  // 암호화
const decrypted = encrypted ^ key;  // 복호화
// decrypted = message

// 4. 중복 제거
const numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];
let result = 0;
for (const num of numbers) {
    result ^= num;  // 짝수 번 나타나는 수는 제거됨
}
console.log(result);  // 5 (홀수 번 나타나는 수만 남음)
```

#### 4. NOT 연산 (~)
단일 비트의 값을 반전시키는 연산입니다.

**NOT 연산의 진리표:**
```
A   NOT A
0     1
1     0
```

**NOT 연산의 주요 활용 사례:**

```javascript
// 1. 비트 반전
const number = 0b1010;     // 10
const result = ~number;    // -11 (모든 비트가 반전됨)

// 2. 음수 표현
// 2의 보수를 이용한 음수 표현
const positive = 5;        // 0b0101
const negative = ~positive + 1;  // -5

// 3. 마스크 생성
const bitPosition = 3;
const mask = ~(1 << bitPosition);  // 해당 비트만 0, 나머지는 1
```

### 비트 시프트 연산

#### 1. 왼쪽 시프트 (<<)
모든 비트를 왼쪽으로 지정된 수만큼 이동시킵니다.

```javascript
// 기본 시프트
const number = 0b1010;     // 10
const result = number << 2;  // 40 (0b101000)

// 2의 거듭제곱 계산
const powerOfTwo = (n) => 1 << n;
console.log(powerOfTwo(3));  // 8 (2^3)
console.log(powerOfTwo(5));  // 32 (2^5)

// 마스크 생성
const createMask = (n) => (1 << n) - 1;
console.log(createMask(3));  // 7 (0b111)
console.log(createMask(5));  // 31 (0b11111)
```

#### 2. 오른쪽 시프트 (>>)
모든 비트를 오른쪽으로 지정된 수만큼 이동시킵니다.

```javascript
// 기본 시프트
const number = 0b101000;   // 40
const result = number >> 2;  // 10 (0b1010)

// 2로 나누기
const divideByTwo = (n) => n >> 1;
console.log(divideByTwo(10));  // 5
console.log(divideByTwo(20));  // 10

// 비트 추출
const extractBit = (number, position) => (number >> position) & 1;
console.log(extractBit(0b1010, 1));  // 1
console.log(extractBit(0b1010, 2));  // 0
```

#### 3. 부호 없는 오른쪽 시프트 (>>>)
모든 비트를 오른쪽으로 이동시키고 왼쪽은 항상 0으로 채웁니다.

```javascript
// 부호 있는 vs 부호 없는 시프트
const negativeNumber = -10;
console.log(negativeNumber >> 1);   // -5 (부호 유지)
console.log(negativeNumber >>> 1);  // 2147483643 (부호 무시)
```

## 예시

### 실전 비트 연산 예제

#### 플래그 시스템 구현
```javascript
// 플래그 시스템 클래스
class FlagSystem {
    constructor() {
        this.flags = 0;
    }
    
    // 플래그 상수 정의
    static FLAGS = {
        READ: 1 << 0,      // 0b0001
        WRITE: 1 << 1,     // 0b0010
        EXECUTE: 1 << 2,   // 0b0100
        DELETE: 1 << 3,    // 0b1000
        ADMIN: 1 << 4,     // 0b10000
        GUEST: 1 << 5      // 0b100000
    };
    
    // 플래그 설정
    setFlag(flag) {
        this.flags |= flag;
    }
    
    // 플래그 제거
    clearFlag(flag) {
        this.flags &= ~flag;
    }
    
    // 플래그 토글
    toggleFlag(flag) {
        this.flags ^= flag;
    }
    
    // 플래그 확인
    hasFlag(flag) {
        return (this.flags & flag) !== 0;
    }
    
    // 모든 플래그 확인
    hasAllFlags(flags) {
        return (this.flags & flags) === flags;
    }
    
    // 플래그 개수 세기
    countFlags() {
        let count = 0;
        let temp = this.flags;
        while (temp) {
            count += temp & 1;
            temp >>= 1;
        }
        return count;
    }
    
    // 플래그 목록 반환
    getActiveFlags() {
        const activeFlags = [];
        for (const [name, flag] of Object.entries(FlagSystem.FLAGS)) {
            if (this.hasFlag(flag)) {
                activeFlags.push(name);
            }
        }
        return activeFlags;
    }
    
    // 플래그 초기화
    reset() {
        this.flags = 0;
    }
}

// 사용 예제
const userPermissions = new FlagSystem();

// 권한 설정
userPermissions.setFlag(FlagSystem.FLAGS.READ);
userPermissions.setFlag(FlagSystem.FLAGS.WRITE);
userPermissions.setFlag(FlagSystem.FLAGS.EXECUTE);

console.log('활성 플래그:', userPermissions.getActiveFlags());
console.log('읽기 권한 있음:', userPermissions.hasFlag(FlagSystem.FLAGS.READ));
console.log('관리자 권한 있음:', userPermissions.hasFlag(FlagSystem.FLAGS.ADMIN));
console.log('총 플래그 개수:', userPermissions.countFlags());

// 권한 토글
userPermissions.toggleFlag(FlagSystem.FLAGS.ADMIN);
console.log('관리자 권한 토글 후:', userPermissions.hasFlag(FlagSystem.FLAGS.ADMIN));
```

#### 비트 마스킹 유틸리티
```javascript
// 비트 마스킹 유틸리티 클래스
class BitMaskUtils {
    // 특정 비트 설정
    static setBit(number, position) {
        return number | (1 << position);
    }
    
    // 특정 비트 제거
    static clearBit(number, position) {
        return number & ~(1 << position);
    }
    
    // 특정 비트 토글
    static toggleBit(number, position) {
        return number ^ (1 << position);
    }
    
    // 특정 비트 확인
    static getBit(number, position) {
        return (number >> position) & 1;
    }
    
    // 연속된 비트 설정
    static setBits(number, start, count) {
        const mask = ((1 << count) - 1) << start;
        return number | mask;
    }
    
    // 연속된 비트 제거
    static clearBits(number, start, count) {
        const mask = ~(((1 << count) - 1) << start);
        return number & mask;
    }
    
    // 비트 범위 추출
    static extractBits(number, start, count) {
        const mask = (1 << count) - 1;
        return (number >> start) & mask;
    }
    
    // 비트 범위 설정
    static setBitRange(number, start, count, value) {
        const mask = ((1 << count) - 1) << start;
        const cleared = number & ~mask;
        return cleared | ((value & ((1 << count) - 1)) << start);
    }
    
    // 비트 개수 세기
    static countBits(number) {
        let count = 0;
        while (number) {
            count += number & 1;
            number >>= 1;
        }
        return count;
    }
    
    // 최하위 비트 제거
    static removeLowestBit(number) {
        return number & (number - 1);
    }
    
    // 최하위 비트 추출
    static getLowestBit(number) {
        return number & (-number);
    }
    
    // 2의 거듭제곱 확인
    static isPowerOfTwo(number) {
        return number > 0 && (number & (number - 1)) === 0;
    }
    
    // 비트 반전
    static reverseBits(number, bits = 32) {
        let result = 0;
        for (let i = 0; i < bits; i++) {
            result = (result << 1) | (number & 1);
            number >>= 1;
        }
        return result;
    }
}

// 사용 예제
console.log('비트 마스킹 예제:');

const number = 0b1010;  // 10

console.log('원본:', number.toString(2).padStart(8, '0'));
console.log('비트 2 설정:', BitMaskUtils.setBit(number, 2).toString(2).padStart(8, '0'));
console.log('비트 1 제거:', BitMaskUtils.clearBit(number, 1).toString(2).padStart(8, '0'));
console.log('비트 3 토글:', BitMaskUtils.toggleBit(number, 3).toString(2).padStart(8, '0'));
console.log('비트 2 값:', BitMaskUtils.getBit(number, 2));

console.log('2의 거듭제곱 확인:');
console.log('8은 2의 거듭제곱:', BitMaskUtils.isPowerOfTwo(8));
console.log('10은 2의 거듭제곱:', BitMaskUtils.isPowerOfTwo(10));
```

#### 암호화 및 해시 함수
```javascript
// 간단한 비트 기반 암호화
class BitCrypto {
    // XOR 기반 암호화
    static xorEncrypt(data, key) {
        let result = 0;
        for (let i = 0; i < 32; i++) {
            const dataBit = (data >> i) & 1;
            const keyBit = (key >> (i % 32)) & 1;
            const encryptedBit = dataBit ^ keyBit;
            result |= encryptedBit << i;
        }
        return result;
    }
    
    // 비트 순열 암호화
    static permuteBits(data, permutation) {
        let result = 0;
        for (let i = 0; i < permutation.length; i++) {
            const sourceBit = (data >> permutation[i]) & 1;
            result |= sourceBit << i;
        }
        return result;
    }
    
    // 간단한 해시 함수
    static simpleHash(data) {
        let hash = 0;
        for (let i = 0; i < 32; i++) {
            const bit = (data >> i) & 1;
            hash = ((hash << 1) | bit) ^ (hash >> 31);
        }
        return hash;
    }
    
    // 비트 회전
    static rotateLeft(number, shift, bits = 32) {
        const mask = (1 << bits) - 1;
        return ((number << shift) | (number >> (bits - shift))) & mask;
    }
    
    static rotateRight(number, shift, bits = 32) {
        const mask = (1 << bits) - 1;
        return ((number >> shift) | (number << (bits - shift))) & mask;
    }
}

// 사용 예제
console.log('비트 암호화 예제:');

const message = 0x12345678;
const key = 0xABCDEF01;

const encrypted = BitCrypto.xorEncrypt(message, key);
const decrypted = BitCrypto.xorEncrypt(encrypted, key);

console.log('원본 메시지:', message.toString(16));
console.log('암호화된 메시지:', encrypted.toString(16));
console.log('복호화된 메시지:', decrypted.toString(16));
console.log('복호화 성공:', message === decrypted);

// 비트 순열 예제
const permutation = [7, 6, 5, 4, 3, 2, 1, 0];  // 8비트 순열
const permuted = BitCrypto.permuteBits(0b10101010, permutation);
console.log('순열 결과:', permuted.toString(2).padStart(8, '0'));
```

### 고급 비트 연산 예제

#### 비트 보드 (Bitboard) 구현
```javascript
// 체스 비트보드 구현
class ChessBitboard {
    constructor() {
        this.pieces = {
            whitePawns: 0n,
            whiteRooks: 0n,
            whiteKnights: 0n,
            whiteBishops: 0n,
            whiteQueens: 0n,
            whiteKing: 0n,
            blackPawns: 0n,
            blackRooks: 0n,
            blackKnights: 0n,
            blackBishops: 0n,
            blackQueens: 0n,
            blackKing: 0n
        };
        
        this.initializeBoard();
    }
    
    // 초기 보드 설정
    initializeBoard() {
        // 흰색 폰 (두 번째 줄)
        this.pieces.whitePawns = 0xFF00n;
        
        // 흰색 기물 (첫 번째 줄)
        this.pieces.whiteRooks = 0x81n;
        this.pieces.whiteKnights = 0x42n;
        this.pieces.whiteBishops = 0x24n;
        this.pieces.whiteQueens = 0x8n;
        this.pieces.whiteKing = 0x10n;
        
        // 검은색 폰 (일곱 번째 줄)
        this.pieces.blackPawns = 0xFF000000000000n;
        
        // 검은색 기물 (여덟 번째 줄)
        this.pieces.blackRooks = 0x8100000000000000n;
        this.pieces.blackKnights = 0x4200000000000000n;
        this.pieces.blackBishops = 0x2400000000000000n;
        this.pieces.blackQueens = 0x800000000000000n;
        this.pieces.blackKing = 0x1000000000000000n;
    }
    
    // 모든 흰색 기물
    getAllWhitePieces() {
        return this.pieces.whitePawns | this.pieces.whiteRooks | 
               this.pieces.whiteKnights | this.pieces.whiteBishops | 
               this.pieces.whiteQueens | this.pieces.whiteKing;
    }
    
    // 모든 검은색 기물
    getAllBlackPieces() {
        return this.pieces.blackPawns | this.pieces.blackRooks | 
               this.pieces.blackKnights | this.pieces.blackBishops | 
               this.pieces.blackQueens | this.pieces.blackKing;
    }
    
    // 모든 기물
    getAllPieces() {
        return this.getAllWhitePieces() | this.getAllBlackPieces();
    }
    
    // 특정 위치에 기물이 있는지 확인
    hasPiece(square, pieceType) {
        const bit = 1n << BigInt(square);
        return (this.pieces[pieceType] & bit) !== 0n;
    }
    
    // 기물 이동
    movePiece(from, to, pieceType) {
        const fromBit = 1n << BigInt(from);
        const toBit = 1n << BigInt(to);
        
        this.pieces[pieceType] &= ~fromBit;  // 원래 위치에서 제거
        this.pieces[pieceType] |= toBit;     // 새 위치에 배치
    }
    
    // 보드 출력
    printBoard() {
        console.log('  a b c d e f g h');
        console.log('  ---------------');
        
        for (let rank = 7; rank >= 0; rank--) {
            let row = `${rank + 1} `;
            for (let file = 0; file < 8; file++) {
                const square = rank * 8 + file;
                let piece = '.';
                
                // 각 기물 타입 확인
                for (const [type, bitboard] of Object.entries(this.pieces)) {
                    if ((bitboard & (1n << BigInt(square))) !== 0n) {
                        piece = this.getPieceSymbol(type);
                        break;
                    }
                }
                
                row += piece + ' ';
            }
            console.log(row + rank + 1);
        }
        console.log('  ---------------');
        console.log('  a b c d e f g h');
    }
    
    // 기물 심볼 반환
    getPieceSymbol(pieceType) {
        const symbols = {
            whitePawns: 'P', whiteRooks: 'R', whiteKnights: 'N',
            whiteBishops: 'B', whiteQueens: 'Q', whiteKing: 'K',
            blackPawns: 'p', blackRooks: 'r', blackKnights: 'n',
            blackBishops: 'b', blackQueens: 'q', blackKing: 'k'
        };
        return symbols[pieceType] || '.';
    }
}

// 사용 예제
const chess = new ChessBitboard();
chess.printBoard();

// 폰 이동 예제
chess.movePiece(8, 16, 'whitePawns');  // a2에서 a3으로 이동
console.log('\n폰 이동 후:');
chess.printBoard();
```

## 운영 팁

### 성능 최적화

#### 비트 연산 최적화 기법
```javascript
// 비트 연산 최적화 클래스
class BitOptimization {
    // 빠른 2의 거듭제곱 계산
    static powerOfTwo(n) {
        return 1 << n;
    }
    
    // 빠른 나머지 연산 (2의 거듭제곱으로 나눌 때)
    static fastModulo(number, divisor) {
        return number & (divisor - 1);
    }
    
    // 빠른 나누기 (2의 거듭제곱으로 나눌 때)
    static fastDivide(number, divisor) {
        return number >> Math.log2(divisor);
    }
    
    // 비트 개수 세기 (Kernighan 알고리즘)
    static countBitsOptimized(number) {
        let count = 0;
        while (number) {
            number &= number - 1;
            count++;
        }
        return count;
    }
    
    // 최하위 비트 제거
    static removeLowestBit(number) {
        return number & (number - 1);
    }
    
    // 최하위 비트 추출
    static getLowestBit(number) {
        return number & (-number);
    }
    
    // 비트 반전 (32비트)
    static reverseBits32(number) {
        number = ((number & 0xFFFF0000) >>> 16) | ((number & 0x0000FFFF) << 16);
        number = ((number & 0xFF00FF00) >>> 8) | ((number & 0x00FF00FF) << 8);
        number = ((number & 0xF0F0F0F0) >>> 4) | ((number & 0x0F0F0F0F) << 4);
        number = ((number & 0xCCCCCCCC) >>> 2) | ((number & 0x33333333) << 2);
        number = ((number & 0xAAAAAAAA) >>> 1) | ((number & 0x55555555) << 1);
        return number;
    }
    
    // 패리티 계산
    static calculateParity(number) {
        number ^= number >>> 16;
        number ^= number >>> 8;
        number ^= number >>> 4;
        number ^= number >>> 2;
        number ^= number >>> 1;
        return number & 1;
    }
}

// 성능 비교 예제
console.log('성능 최적화 예제:');

const testNumber = 123456789;

console.time('일반 나머지');
for (let i = 0; i < 1000000; i++) {
    testNumber % 16;
}
console.timeEnd('일반 나머지');

console.time('빠른 나머지');
for (let i = 0; i < 1000000; i++) {
    BitOptimization.fastModulo(testNumber, 16);
}
console.timeEnd('빠른 나머지');
```

### 메모리 효율성

#### 압축된 데이터 구조
```javascript
// 압축된 플래그 시스템
class CompressedFlags {
    constructor() {
        this.data = 0;
    }
    
    // 여러 플래그를 하나의 정수로 압축
    setFlags(flags) {
        this.data |= flags;
    }
    
    // 플래그 그룹 설정
    setFlagGroup(group, value) {
        const mask = 0xF << (group * 4);  // 4비트씩 그룹화
        this.data = (this.data & ~mask) | ((value & 0xF) << (group * 4));
    }
    
    // 플래그 그룹 가져오기
    getFlagGroup(group) {
        return (this.data >> (group * 4)) & 0xF;
    }
    
    // 압축된 데이터 출력
    getCompressedData() {
        return this.data;
    }
}

// 사용 예제
const compressed = new CompressedFlags();

// 4비트씩 그룹화하여 8개의 그룹에 각각 0-15 값 저장
compressed.setFlagGroup(0, 5);   // 그룹 0에 값 5
compressed.setFlagGroup(1, 10);  // 그룹 1에 값 10
compressed.setFlagGroup(2, 3);   // 그룹 2에 값 3

console.log('압축된 데이터:', compressed.getCompressedData().toString(16));
console.log('그룹 0 값:', compressed.getFlagGroup(0));
console.log('그룹 1 값:', compressed.getFlagGroup(1));
console.log('그룹 2 값:', compressed.getFlagGroup(2));
```

### 디버깅 및 테스트

#### 비트 연산 디버깅 도구
```javascript
// 비트 연산 디버깅 유틸리티
class BitDebugUtils {
    // 비트 패턴 출력
    static printBits(number, bits = 32) {
        let result = '';
        for (let i = bits - 1; i >= 0; i--) {
            result += ((number >> i) & 1) ? '1' : '0';
            if (i % 8 === 0 && i !== 0) result += ' ';
        }
        return result;
    }
    
    // 비트 연산 단계별 출력
    static debugBitOperation(operation, a, b) {
        console.log(`연산: ${operation}`);
        console.log(`A: ${this.printBits(a)} (${a})`);
        console.log(`B: ${this.printBits(b)} (${b})`);
        
        let result;
        switch (operation) {
            case 'AND':
                result = a & b;
                break;
            case 'OR':
                result = a | b;
                break;
            case 'XOR':
                result = a ^ b;
                break;
            case 'NOT':
                result = ~a;
                break;
        }
        
        console.log(`결과: ${this.printBits(result)} (${result})`);
        return result;
    }
    
    // 비트 마스크 검증
    static validateMask(mask, expectedBits) {
        const actualBits = this.countBits(mask);
        const isValid = actualBits === expectedBits;
        
        console.log(`마스크: ${this.printBits(mask)}`);
        console.log(`예상 비트 수: ${expectedBits}`);
        console.log(`실제 비트 수: ${actualBits}`);
        console.log(`검증 결과: ${isValid ? '통과' : '실패'}`);
        
        return isValid;
    }
}

// 디버깅 예제
console.log('비트 연산 디버깅:');

BitDebugUtils.debugBitOperation('AND', 0b1010, 0b1100);
BitDebugUtils.debugBitOperation('XOR', 0b1010, 0b1100);

BitDebugUtils.validateMask(0b1111, 4);
BitDebugUtils.validateMask(0b1010, 2);
```

## 참고

### 비트 연산의 수학적 기초

#### 불 대수 (Boolean Algebra)
```javascript
// 불 대수 법칙 검증
class BooleanAlgebra {
    // 교환법칙
    static commutativeLaw(a, b) {
        const and1 = a & b;
        const and2 = b & a;
        const or1 = a | b;
        const or2 = b | a;
        
        return {
            andCommutative: and1 === and2,
            orCommutative: or1 === or2
        };
    }
    
    // 결합법칙
    static associativeLaw(a, b, c) {
        const and1 = (a & b) & c;
        const and2 = a & (b & c);
        const or1 = (a | b) | c;
        const or2 = a | (b | c);
        
        return {
            andAssociative: and1 === and2,
            orAssociative: or1 === or2
        };
    }
    
    // 분배법칙
    static distributiveLaw(a, b, c) {
        const andOverOr = a & (b | c);
        const andOverOrExpanded = (a & b) | (a & c);
        const orOverAnd = a | (b & c);
        const orOverAndExpanded = (a | b) & (a | c);
        
        return {
            andOverOr: andOverOr === andOverOrExpanded,
            orOverAnd: orOverAnd === orOverAndExpanded
        };
    }
    
    // 드모르간 법칙
    static demorganLaw(a, b) {
        const notAnd = ~(a & b);
        const notAndExpanded = ~a | ~b;
        const notOr = ~(a | b);
        const notOrExpanded = ~a & ~b;
        
        return {
            notAnd: notAnd === notAndExpanded,
            notOr: notOr === notOrExpanded
        };
    }
}

// 법칙 검증 예제
console.log('불 대수 법칙 검증:');

const a = 0b1010;
const b = 0b1100;
const c = 0b0110;

console.log('교환법칙:', BooleanAlgebra.commutativeLaw(a, b));
console.log('결합법칙:', BooleanAlgebra.associativeLaw(a, b, c));
console.log('분배법칙:', BooleanAlgebra.distributiveLaw(a, b, c));
console.log('드모르간 법칙:', BooleanAlgebra.demorganLaw(a, b));
```

### 결론
비트 단위 논리 연산은 컴퓨터 과학의 기본 개념으로, 메모리 효율성과 성능 최적화에 매우 중요합니다.
AND, OR, XOR, NOT 연산자를 이해하고 적절히 활용하면 플래그 처리, 마스킹, 암호화 등 다양한 분야에서 효율적인 코드를 작성할 수 있습니다.
비트 시프트 연산은 곱셈/나눗셈의 최적화된 대안으로 사용되며, 특히 2의 거듭제곱 연산에서 매우 유용합니다.
실제 개발에서는 성능과 가독성을 고려하여 비트 연산을 적절히 활용해야 하며, 디버깅 도구를 활용하여 정확성을 보장해야 합니다.
비트 연산의 수학적 기초인 불 대수를 이해하면 더욱 체계적으로 비트 연산을 활용할 수 있습니다.

