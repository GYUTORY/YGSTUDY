---
title: AWS S3 정리
tags: [aws, s3, storage, object-storage, cloud-storage]
updated: 2026-01-17
---

# AWS S3 정리

## 개요

Amazon S3(Simple Storage Service)는 AWS의 객체 스토리지 서비스다. 무제한 확장 가능한 저장소를 제공하며, 웹 스케일 데이터 저장에 사용된다.

**S3의 특징:**
- 객체 스토리지: 파일을 객체로 저장한다
- HTTP/HTTPS API: REST API로 접근한다
- 무제한 확장: 용량 제한이 없다
- 높은 내구성: 99.999999999%(11개 9) 내구성 보장

## S3 기본 개념

### 버킷(Bucket)

버킷은 S3에서 객체를 저장하는 컨테이너다.

**버킷의 특징:**
- 전역적으로 고유한 이름이 필요하다
- 리전별로 생성된다
- 버킷 이름은 DNS 호환되어야 한다
- 버킷당 무제한 객체 저장 가능

**버킷 네이밍 규칙:**
- 3-63자 길이
- 소문자, 숫자, 하이픈(-), 점(.)만 사용 가능
- IP 주소 형식 불가
- `xn--`로 시작 불가

**예시:**
- `my-bucket`
- `my.bucket.name`
- `my-bucket-123`

### 객체(Object)

객체는 S3에 저장되는 데이터 단위다.

**객체의 구성:**
- 키(Key): 객체의 고유 식별자 (파일 경로)
- 값(Value): 실제 데이터
- 메타데이터: 객체에 대한 정보
- 버전 ID: 버전 관리 시 사용

**객체 키 예시:**
- `images/photo.jpg`
- `documents/report.pdf`
- `videos/movie.mp4`

**객체 크기 제한:**
- 단일 객체: 최대 5TB
- 멀티파트 업로드: 5MB 이상 권장

### 키(Key)

키는 객체의 고유 식별자다. 파일 시스템의 경로와 유사하다.

**키 구조:**
- 슬래시(/)로 구분된 경로
- 접두사(Prefix)로 그룹화 가능
- 버킷 내에서 고유해야 한다

**예시:**
```
my-bucket/
  ├── images/
  │   ├── 2024/
  │   │   ├── photo1.jpg
  │   │   └── photo2.jpg
  │   └── 2025/
  │       └── photo3.jpg
  └── documents/
      └── report.pdf
```

## S3 스토리지 클래스

S3는 다양한 스토리지 클래스를 제공한다. 용도와 접근 빈도에 따라 선택한다.

### S3 Standard

**특징:**
- 자주 접근하는 데이터에 적합
- 높은 내구성과 가용성
- 가장 빠른 성능

**사용 사례:**
- 정적 웹사이트 호스팅
- 콘텐츠 배포
- 모바일 앱 데이터
- 빅데이터 분석

**가격:**
- 저장: 약 $0.023/GB/월
- 요청: PUT $0.005/1,000건, GET $0.0004/1,000건

### S3 Intelligent-Tiering

**특징:**
- 접근 패턴에 따라 자동으로 최적 스토리지 클래스로 이동
- 모니터링 비용: $0.0025/1,000개 객체/월
- 자주 접근하지 않는 데이터에 적합

**사용 사례:**
- 접근 패턴이 예측 불가능한 데이터
- 장기 저장 데이터

### S3 Standard-IA (Infrequent Access)

**특징:**
- 자주 접근하지 않는 데이터에 적합
- Standard보다 저렴하지만 검색 비용이 있음
- 최소 저장 기간: 30일
- 최소 청구 크기: 128KB

**사용 사례:**
- 백업 데이터
- 재해 복구용 데이터
- 오래된 로그 파일

**가격:**
- 저장: 약 $0.0125/GB/월
- 검색: $0.01/GB

### S3 One Zone-IA

**특징:**
- 단일 가용 영역에만 저장
- Standard-IA보다 저렴
- 가용 영역 장애 시 데이터 손실 가능
- 최소 저장 기간: 30일

**사용 사례:**
- 재생성 가능한 데이터
- 보조 백업 복사본

**가격:**
- 저장: 약 $0.01/GB/월

### S3 Glacier Instant Retrieval

**특징:**
- 즉시 검색 가능
- 아카이브 스토리지 중 가장 빠름
- 최소 저장 기간: 90일
- 최소 청구 크기: 128KB

**사용 사례:**
- 자주 접근하지 않지만 필요 시 즉시 접근해야 하는 데이터
- 의료 이미지, 뉴스 미디어 아카이브

**가격:**
- 저장: 약 $0.004/GB/월
- 검색: $0.03/GB

### S3 Glacier Flexible Retrieval

**특징:**
- 검색 시간: 1분~5분 (Expedited), 3~5시간 (Standard), 5~12시간 (Bulk)
- 아카이브 스토리지
- 최소 저장 기간: 90일

**사용 사례:**
- 장기 백업
- 아카이브 데이터
- 규정 준수용 데이터

**가격:**
- 저장: 약 $0.0036/GB/월
- 검색: Expedited $0.03/GB, Standard $0.01/GB, Bulk $0.0025/GB

### S3 Glacier Deep Archive

**특징:**
- 가장 저렴한 스토리지 클래스
- 검색 시간: 12시간 (Standard), 48시간 (Bulk)
- 최소 저장 기간: 180일

**사용 사례:**
- 장기 아카이브
- 규정 준수용 장기 보관
- 재생성 불가능한 데이터

**가격:**
- 저장: 약 $0.00099/GB/월
- 검색: Standard $0.02/GB, Bulk $0.0025/GB

### S3 Reduced Redundancy Storage (RRS)

**참고:**
- RRS는 더 이상 권장되지 않는다
- Standard를 사용하는 것이 좋다

## S3 주요 기능

### 버전 관리 (Versioning)

버전 관리를 활성화하면 객체의 모든 버전을 보관한다.

**활성화 시:**
- 객체를 덮어쓰면 새 버전이 생성된다
- 이전 버전도 보관된다
- 삭제 시 삭제 마커만 생성된다
- 모든 버전에 대한 비용이 발생한다

**사용 사례:**
- 실수로 삭제하거나 덮어쓴 경우 복구
- 변경 이력 추적
- 규정 준수

**주의사항:**
- 비용이 증가한다
- 버전을 완전히 삭제하려면 버전 ID를 지정해야 한다

### 라이프사이클 정책 (Lifecycle Policy)

라이프사이클 정책으로 객체를 자동으로 다른 스토리지 클래스로 이동하거나 삭제한다.

**전환 작업:**
- 객체를 다른 스토리지 클래스로 이동
- 예: 30일 후 Standard-IA로, 90일 후 Glacier로

**만료 작업:**
- 지정된 날짜 후 객체 삭제
- 예: 365일 후 삭제

**예시:**
```
- 생성 후 30일: Standard → Standard-IA
- 생성 후 90일: Standard-IA → Glacier
- 생성 후 365일: Glacier → 삭제
```

**사용 사례:**
- 로그 파일 자동 아카이빙
- 오래된 백업 자동 삭제
- 비용 최적화

### 암호화 (Encryption)

S3는 저장 시와 전송 시 암호화를 지원한다.

**저장 시 암호화 (Encryption at Rest):**

**SSE-S3:**
- S3가 관리하는 키 사용
- 추가 비용 없음
- 기본 권장 방식

**SSE-KMS:**
- AWS KMS로 키 관리
- 키 사용에 대한 비용 발생
- 감사 추적 가능

**SSE-C:**
- 고객이 제공하는 키 사용
- 키 관리 책임은 고객에게 있음

**전송 시 암호화 (Encryption in Transit):**
- HTTPS 사용
- TLS/SSL로 전송 중 암호화

### 접근 제어

**IAM 정책:**
- 사용자/역할별 접근 제어
- 세밀한 권한 관리

**버킷 정책:**
- 버킷 레벨 접근 제어
- 퍼블릭 액세스 제어

**ACL (Access Control List):**
- 객체/버킷별 접근 제어
- 레거시 방식, 권장하지 않음

**퍼블릭 액세스 차단:**
- 버킷의 퍼블릭 액세스 차단
- 실수로 퍼블릭으로 만드는 것 방지

### 정적 웹사이트 호스팅

S3 버킷을 정적 웹사이트로 호스팅할 수 있다.

**설정:**
- 버킷 정책에서 퍼블릭 읽기 허용
- 정적 웹사이트 호스팅 활성화
- 인덱스 문서 지정 (예: index.html)

**사용 사례:**
- 정적 웹사이트
- React/Vue 앱 배포
- 문서 사이트

**제한사항:**
- 서버 사이드 스크립팅 불가
- HTTPS는 CloudFront와 함께 사용해야 함

### CORS (Cross-Origin Resource Sharing)

CORS를 설정하면 다른 도메인에서 S3 리소스에 접근할 수 있다.

**설정:**
- 버킷 CORS 설정에서 허용할 오리진 지정
- 허용할 HTTP 메서드 지정
- 허용할 헤더 지정

**사용 사례:**
- 웹 애플리케이션에서 S3 이미지 로드
- 브라우저에서 직접 S3 업로드

### 이벤트 알림

S3 이벤트를 다른 AWS 서비스로 전송할 수 있다.

**지원 대상:**
- SNS
- SQS
- Lambda
- EventBridge

**이벤트 유형:**
- 객체 생성 (PUT, POST, COPY)
- 객체 삭제
- 객체 복원

**사용 사례:**
- 이미지 업로드 시 썸네일 생성 (Lambda)
- 파일 업로드 시 알림 (SNS)
- 로그 파일 처리 (Lambda)

### 멀티파트 업로드

큰 파일을 여러 부분으로 나눠 업로드한다.

**장점:**
- 대용량 파일 업로드 가능 (최대 5TB)
- 네트워크 오류 시 재시도 용이
- 병렬 업로드로 속도 향상

**사용 기준:**
- 5MB 이상 파일 권장
- 네트워크가 불안정한 경우

### 전송 가속 (Transfer Acceleration)

CloudFront를 사용해 전송 속도를 향상시킨다.

**동작 원리:**
- 가장 가까운 엣지 로케이션으로 업로드
- AWS 백본 네트워크로 전송
- 버킷 리전으로 전달

**사용 사례:**
- 전 세계에서 업로드하는 경우
- 대용량 파일 전송
- 낮은 지연 시간이 필요한 경우

**비용:**
- 전송 가속 비용 + 데이터 전송 비용

## S3 성능 최적화

### 요청 속도 향상

**접두사 분산:**
- 객체 키를 여러 접두사로 분산
- 예: `images/2024/01/`, `images/2024/02/` 등

**해시 접두사 사용:**
- 순차적 키 대신 해시 사용
- 예: `a1b2c3/photo.jpg` 대신 `3c2b1a/photo.jpg`

**주의사항:**
- 같은 접두사에 너무 많은 객체를 두지 않는다
- 핫키(Hot Key) 문제를 피한다

### 멀티파트 업로드 최적화

**파트 크기:**
- 권장: 100MB 이상
- 최소: 5MB (마지막 파트 제외)

**동시 업로드:**
- 여러 파트를 동시에 업로드
- 네트워크 대역폭 활용

### CloudFront 연동

**캐싱:**
- 자주 접근하는 객체를 엣지 로케이션에 캐시
- 원본 요청 감소

**지연 시간 감소:**
- 가장 가까운 엣지에서 제공
- 전 세계 사용자에게 빠른 응답

## S3 보안 모범 사례

### 퍼블릭 액세스 차단

**설정:**
- 버킷 퍼블릭 액세스 차단 활성화
- 필요한 경우에만 선택적으로 허용

**주의사항:**
- 실수로 퍼블릭으로 만드는 것 방지
- 버킷 정책과 ACL 모두 확인

### IAM 정책 최소 권한

**원칙:**
- 필요한 최소 권한만 부여
- 리소스별 세밀한 제어

**예시:**
- 특정 접두사만 접근 허용
- 특정 IP에서만 접근 허용
- 특정 시간대에만 접근 허용

### 암호화 활성화

**권장:**
- 모든 객체 암호화
- SSE-S3 또는 SSE-KMS 사용
- 전송 시 HTTPS 사용

### 버킷 정책 검토

**정기 검토:**
- 버킷 정책 정기 검토
- 불필요한 권한 제거
- 퍼블릭 액세스 확인

### 버전 관리와 MFA Delete

**MFA Delete:**
- 버전 삭제 시 MFA 요구
- 실수로 삭제하는 것 방지

## S3 비용 최적화

### 스토리지 클래스 선택

**접근 빈도에 따라:**
- 자주 접근: Standard
- 가끔 접근: Standard-IA
- 거의 접근 안 함: Glacier

### 라이프사이클 정책 활용

**자동 전환:**
- 오래된 데이터 자동 전환
- 비용 절감

**자동 삭제:**
- 불필요한 데이터 자동 삭제
- 저장 비용 절감

### Intelligent-Tiering 사용

**자동 최적화:**
- 접근 패턴에 따라 자동 전환
- 수동 관리 불필요

### 요청 비용 최적화

**캐싱:**
- CloudFront로 요청 감소
- GET 요청 비용 절감

**배치 작업:**
- 여러 객체를 한 번에 처리
- 요청 수 감소

### 데이터 전송 비용

**리전 내 전송:**
- 같은 리전 내 전송은 무료
- 리전 간 전송은 비용 발생

**CloudFront 사용:**
- 캐시 히트 시 원본 요청 감소
- 데이터 전송 비용 절감

## S3 실무 사용 사례

### 정적 웹사이트 호스팅

**설정:**
1. 버킷 생성
2. 정적 웹사이트 호스팅 활성화
3. 버킷 정책 설정 (퍼블릭 읽기)
4. index.html 업로드

**CloudFront 연동:**
- HTTPS 지원
- 커스텀 도메인
- 캐싱 최적화

### 이미지/비디오 저장

**구조:**
- 사용자별 폴더 분리
- 날짜별 폴더 분리
- CDN 연동

**처리:**
- Lambda로 썸네일 생성
- 이미지 최적화
- 메타데이터 저장

### 백업 및 아카이브

**백업:**
- 데이터베이스 백업
- 파일 시스템 백업
- 버전 관리 활성화

**아카이브:**
- 오래된 데이터 Glacier로 이동
- 라이프사이클 정책 활용
- 장기 보관

### 로그 수집 및 분석

**로그 저장:**
- 애플리케이션 로그
- 서버 로그
- 접근 로그

**처리:**
- Lambda로 로그 처리
- Athena로 분석
- CloudWatch Logs 연동

### 데이터 레이크

**빅데이터 저장:**
- 원시 데이터 저장
- 다양한 형식 지원
- 무제한 확장

**분석:**
- Athena로 쿼리
- EMR로 처리
- Redshift로 분석

## MSA에서 S3 활용

### MSA에서 S3가 필요한 이유

**서비스 분리:**
- 각 마이크로서비스가 독립적인 저장소를 가진다
- 공유 파일 시스템(EFS) 대신 객체 스토리지(S3)를 사용한다
- 서비스 간 느슨한 결합을 유지한다

**확장성:**
- 서비스별로 독립적으로 확장한다
- S3는 무제한 확장이 가능하다
- 트래픽 증가에 유연하게 대응한다

**비용 효율:**
- 사용한 만큼만 비용이 발생한다
- 스토리지 클래스를 선택해 비용을 최적화한다
- 불필요한 인프라 비용이 없다

### MSA에서 S3 활용 패턴

#### 1. 서비스별 버킷 분리

**패턴:**
각 마이크로서비스가 자신의 버킷을 가진다.

**구조:**
```
user-service-bucket/
  ├── avatars/
  └── documents/

order-service-bucket/
  ├── receipts/
  └── invoices/

product-service-bucket/
  ├── images/
  └── catalogs/
```

**장점:**
- 서비스 간 데이터 격리
- 서비스별 접근 제어
- 서비스별 비용 추적

**주의사항:**
- 버킷 수가 많아지면 관리가 복잡해진다
- 버킷 정책을 서비스별로 관리해야 한다

#### 2. 접두사 기반 분리

**패턴:**
하나의 버킷을 여러 서비스가 공유하되, 접두사로 분리한다.

**구조:**
```
shared-bucket/
  ├── user-service/
  │   ├── avatars/
  │   └── documents/
  ├── order-service/
  │   ├── receipts/
  │   └── invoices/
  └── product-service/
      ├── images/
      └── catalogs/
```

**장점:**
- 버킷 관리가 단순하다
- 공통 정책 적용이 쉽다
- 비용 추적은 IAM 태그로 가능하다

**주의사항:**
- 접두사별 접근 제어가 필요하다
- 서비스 간 데이터 격리가 약하다

#### 3. 이벤트 기반 파일 처리

**패턴:**
파일 업로드 시 S3 이벤트를 발행하고, 다른 서비스가 이벤트를 구독해 처리한다.

**흐름:**
```
1. 사용자가 이미지 업로드 (User Service)
2. User Service가 S3에 업로드
3. S3 이벤트 발행 (ObjectCreated)
4. Image Processing Service가 이벤트 수신
5. 썸네일 생성 후 S3에 저장
6. Notification Service가 완료 알림 발행
```

**구현:**
- S3 이벤트 → SNS/SQS → Lambda/서비스
- 비동기 처리로 서비스 간 결합도 감소
- 확장성이 좋다

**사용 사례:**
- 이미지 업로드 시 썸네일 생성
- 문서 업로드 시 변환 처리
- 비디오 업로드 시 인코딩

#### 4. 서비스 간 파일 공유

**패턴:**
한 서비스가 업로드한 파일을 다른 서비스가 읽는다.

**예시:**
```
Order Service:
  - 주문 영수증 생성
  - S3에 저장: s3://order-service/receipts/order-123.pdf

Notification Service:
  - 주문 완료 알림 발송
  - S3에서 영수증 다운로드
  - 이메일 첨부
```

**접근 제어:**
- IAM 역할로 서비스별 권한 부여
- 버킷 정책으로 접두사별 제어
- Presigned URL로 임시 접근 허용

**주의사항:**
- 서비스 간 의존성이 생긴다
- 파일이 준비될 때까지 대기해야 한다
- 이벤트로 알림을 받는 것이 좋다

#### 5. 데이터 레이크 패턴

**패턴:**
각 서비스가 원시 데이터를 S3에 저장하고, 분석 서비스가 집계한다.

**구조:**
```
각 서비스:
  - 로그/이벤트를 S3에 저장
  - 날짜별 파티셔닝: s3://data-lake/service-name/year/month/day/

Analytics Service:
  - Athena로 쿼리
  - EMR로 처리
  - 집계 결과를 별도 버킷에 저장
```

**장점:**
- 서비스별 원시 데이터 보존
- 분석 서비스가 독립적으로 동작
- 데이터 레이크 구축이 쉽다

**사용 사례:**
- 사용자 행동 로그 수집
- 주문 데이터 분석
- 제품 조회 통계

### MSA에서 S3 사용 시나리오

#### 시나리오 1: 사용자 프로필 이미지 업로드

**아키텍처:**
```
1. 사용자가 이미지 업로드 요청 (API Gateway)
2. User Service가 Presigned URL 생성
3. 클라이언트가 직접 S3에 업로드
4. S3 이벤트 발행 (ObjectCreated)
5. Image Processing Service가 이벤트 수신
6. 썸네일 생성 후 S3에 저장
7. User Service에 완료 알림 (SNS)
8. User Service가 DB에 이미지 URL 업데이트
```

**장점:**
- User Service 부하 감소 (직접 업로드)
- 비동기 처리로 응답 속도 향상
- 서비스 간 느슨한 결합

**구현 포인트:**
- Presigned URL로 업로드 권한 부여
- S3 이벤트로 비동기 처리
- 멱등성 보장 (같은 이미지 중복 처리 방지)

#### 시나리오 2: 주문 영수증 생성 및 이메일 발송

**아키텍처:**
```
1. Order Service가 주문 완료 처리
2. Receipt Service에 영수증 생성 요청
3. Receipt Service가 영수증 PDF 생성
4. S3에 저장: s3://order-service/receipts/order-123.pdf
5. S3 이벤트 발행
6. Notification Service가 이벤트 수신
7. S3에서 영수증 다운로드
8. 이메일 첨부하여 발송
```

**장점:**
- 영수증 생성과 발송이 분리됨
- 영수증은 S3에 보관되어 재발송 가능
- 서비스별 독립적 확장

**구현 포인트:**
- 영수증은 버전 관리 활성화
- 라이프사이클 정책으로 오래된 영수증 아카이브
- Presigned URL로 사용자가 직접 다운로드 가능

#### 시나리오 3: 제품 이미지 관리

**아키텍처:**
```
1. Admin이 제품 이미지 업로드 (Product Service)
2. Product Service가 S3에 원본 저장
3. S3 이벤트 발행
4. Image Processing Service가 이벤트 수신
5. 여러 크기 썸네일 생성 (100x100, 200x200, 500x500)
6. 각각 S3에 저장
7. Product Service에 완료 알림
8. Product Service가 DB에 이미지 URL 업데이트
```

**장점:**
- 원본과 썸네일 분리 저장
- 필요 시에만 썸네일 생성
- CDN 연동으로 빠른 제공

**구현 포인트:**
- 이미지 키 구조: `products/{productId}/original.jpg`, `products/{productId}/thumbnails/200x200.jpg`
- CloudFront로 이미지 제공
- 라이프사이클 정책으로 오래된 이미지 최적화

#### 시나리오 4: 로그 수집 및 분석

**아키텍처:**
```
각 서비스:
  - 애플리케이션 로그를 S3에 저장
  - 날짜별 파티셔닝: s3://logs/service-name/2026/01/14/

Analytics Service:
  - Athena로 로그 쿼리
  - 에러 로그 집계
  - 트렌드 분석

Alert Service:
  - Athena 결과를 기반으로 알람 발송
```

**장점:**
- 서비스별 로그 독립 저장
- 분석 서비스가 필요할 때만 쿼리
- 장기 보관 가능

**구현 포인트:**
- 로그 형식 표준화 (JSON)
- 날짜별 파티셔닝으로 쿼리 성능 향상
- 라이프사이클 정책으로 오래된 로그 Glacier로 이동

### MSA에서 S3 접근 제어

#### 서비스별 IAM 역할

**패턴:**
각 서비스에 전용 IAM 역할을 부여하고, 필요한 버킷/접두사만 접근 허용한다.

**예시:**
```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "s3:GetObject",
        "s3:PutObject"
      ],
      "Resource": "arn:aws:s3:::user-service-bucket/avatars/*"
    }
  ]
}
```

**장점:**
- 서비스별 최소 권한 원칙
- 보안 강화
- 접근 추적 가능

#### 버킷 정책으로 서비스 간 접근 제어

**패턴:**
버킷 정책으로 다른 서비스의 접근을 제어한다.

**예시:**
```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "AWS": "arn:aws:iam::123456789012:role/NotificationService"
      },
      "Action": "s3:GetObject",
      "Resource": "arn:aws:s3:::order-service-bucket/receipts/*"
    }
  ]
}
```

**장점:**
- 버킷 소유자가 접근 제어
- 서비스 역할 기반 제어
- 세밀한 권한 관리

#### Presigned URL로 임시 접근

**패턴:**
임시 접근이 필요한 경우 Presigned URL을 생성한다.

**사용 사례:**
- 사용자가 직접 파일 업로드
- 사용자가 파일 다운로드
- 외부 시스템에 임시 접근 권한 부여

**주의사항:**
- URL 만료 시간 설정
- 최소 권한 원칙
- 로그 모니터링

### MSA에서 S3 모니터링

#### 서비스별 비용 추적

**방법:**
- 버킷별 비용 추적
- 접두사별 비용 추적 (태그 사용)
- 서비스별 IAM 역할로 요청 추적

**도구:**
- AWS Cost Explorer
- CloudWatch Billing 메트릭
- 커스텀 태그

#### 접근 모니터링

**방법:**
- CloudTrail로 API 호출 로깅
- S3 Access Logging 활성화
- CloudWatch 메트릭 모니터링

**모니터링 항목:**
- 요청 수 (GET, PUT, DELETE)
- 에러율
- 지연 시간
- 데이터 전송량

#### 알람 설정

**항목:**
- 버킷 크기 증가
- 요청 수 급증
- 에러율 증가
- 비용 임계값 초과

**도구:**
- CloudWatch Alarms
- SNS 알림
- Lambda로 커스텀 알람

### MSA에서 S3 사용 시 주의사항

#### 서비스 간 의존성 관리

**문제:**
한 서비스가 다른 서비스의 파일에 의존하면 결합도가 증가한다.

**해결:**
- 이벤트 기반 통신 사용
- 파일 준비 여부를 확인하는 메커니즘
- 타임아웃과 재시도 로직

#### 파일 일관성

**문제:**
파일 업로드 중 다른 서비스가 읽으면 불완전한 파일을 읽을 수 있다.

**해결:**
- 멀티파트 업로드 완료 확인
- 이벤트는 업로드 완료 후에만 발행
- 버전 관리로 이전 버전 복구 가능

#### 비용 관리

**문제:**
서비스가 많아지면 S3 비용이 급증할 수 있다.

**해결:**
- 라이프사이클 정책으로 자동 최적화
- 불필요한 파일 정기 정리
- 스토리지 클래스 적절히 선택
- 서비스별 비용 모니터링

#### 성능 최적화

**문제:**
같은 접두사에 너무 많은 객체가 있으면 성능이 저하된다.

**해결:**
- 접두사 분산 (날짜, 해시 등)
- CloudFront 캐싱
- 멀티파트 업로드 활용

### MSA에서 S3와 다른 서비스 연동

#### Lambda와 연동

**패턴:**
S3 이벤트를 Lambda로 전송해 처리한다.

**사용 사례:**
- 이미지 썸네일 생성
- 파일 변환
- 메타데이터 추출

**장점:**
- 서버리스로 비용 효율
- 자동 확장
- 이벤트 기반 처리

#### EventBridge와 연동

**패턴:**
S3 이벤트를 EventBridge로 전송해 여러 서비스에 알림한다.

**사용 사례:**
- 파일 업로드 시 여러 서비스에 알림
- 이벤트 라우팅
- 복잡한 이벤트 처리

#### CloudFront와 연동

**패턴:**
S3를 CloudFront의 오리진으로 사용한다.

**사용 사례:**
- 정적 자산 배포
- 이미지 CDN
- 전 세계 사용자에게 빠른 제공

**장점:**
- 캐싱으로 원본 요청 감소
- 지연 시간 감소
- 비용 절감

## S3 실무에서 겪는 문제

### 비용 폭증

**원인:**
- 버전 관리로 인한 중복 저장
- 라이프사이클 정책 미설정
- 불필요한 데이터 보관

**해결:**
- 라이프사이클 정책 설정
- 오래된 버전 정리
- 스토리지 클래스 최적화

### 퍼블릭 액세스 실수

**원인:**
- 버킷 정책 오설정
- ACL 실수
- 퍼블릭 액세스 차단 미활성화

**해결:**
- 퍼블릭 액세스 차단 활성화
- 버킷 정책 검토
- CloudTrail로 모니터링

### 성능 저하

**원인:**
- 같은 접두사에 너무 많은 객체
- 순차적 키 사용
- 핫키 문제

**해결:**
- 접두사 분산
- 해시 키 사용
- CloudFront 캐싱

### 삭제 실수

**원인:**
- 버전 관리 미활성화
- MFA Delete 미설정
- 라이프사이클 정책 오설정

**해결:**
- 버전 관리 활성화
- MFA Delete 설정
- 라이프사이클 정책 검토

## S3 vs EFS 비교

### 개념 요약

| 항목 | Amazon S3 | Amazon EFS |
|------|-----------|------------|
| 타입 | 객체 스토리지 | 파일 시스템 (NFS 기반) |
| 접근 방식 | HTTP(S) API 기반 | POSIX 파일시스템 (EC2 마운트) |
| 사용 용도 | 정적 자산 저장, 백업, 이미지 저장 | EC2에서 파일 읽기/쓰기, 공유 파일시스템 |
| 데이터 구조 | 객체 단위 (Key-Value) | 디렉토리/파일 단위 |
| 마운트 가능 여부 | ❌ 직접 마운트 불가 | ✅ EC2, ECS에 NFS 방식으로 마운트 |
| 지연 시간 | ms 단위 | µs ~ ms 단위 (더 낮음) |
| 확장성 | 무제한 | 수 페타바이트까지 자동 확장 |
| 과금 기준 | 저장 용량 + 요청 수 + 전송량 | 저장 용량 + 처리량 (IOPS, 처리 클래스) |
| 동시접근 | 무제한 | 다수의 EC2에서 동시 마운트 가능 |
| 파일 수정 | 전체 객체 재업로드 | 파일 단위 수정 가능 |

---

## 주요 차이점

### 1. 접근 방식

- **S3:** HTTP API 방식 (PUT/GET 등). OS 레벨에서 파일처럼 사용할 수 없음.
- **EFS:** 리눅스 파일 시스템처럼 사용 가능. EC2에서 `mount` 명령어로 사용.

### 2. 성능 (IOPS)

- **S3:** 고속 다운로드에는 적합하지만, 다수의 작은 파일에 빈번한 접근은 비효율적
- **EFS:** 고성능 파일 입출력(IO-intensive)에 적합
  > 예: 로그 저장, 썸네일 처리, 워커 간 공유 파일 등

### 3. 마운트 & 공유

- **S3:** 마운트 불가, 모든 접근은 API 기반
- **EFS:** 여러 EC2 인스턴스가 동시에 마운트하여 공유 가능 (MSA에 유리)

---

## 사용 사례

| 사용 사례 | 권장 스토리지 |
|-----------|----------------|
| 정적 웹사이트 (HTML, 이미지 등) | S3 |
| React build 파일 배포 | S3 |
| EC2 웹 서버 간 공유 디렉토리 | EFS |
| 서버에서 실시간 파일 쓰기/읽기 | EFS |
| 데이터 백업, 로그 보관 | S3 |
| 고속 영상 처리용 스토리지 | EFS |
| 머신러닝 모델 체크포인트 공유 | EFS |
| 비디오 스트리밍용 정적 콘텐츠 | S3 |

---

## 마운트 방식

### EFS 마운트 예시 (Linux)

```bash
sudo yum install -y amazon-efs-utils

sudo mkdir -p /mnt/efs

sudo mount -t efs fs-12345678:/ /mnt/efs
```

> ECS, Lambda에서도 EFS 연동 가능 (단, VPC 내에서만 가능)

---

## 가격 비교

| 항목 | S3 | EFS |
|------|----|-----|
| 저장 비용 (GB/월) | 약 $0.023 | 약 $0.30 (표준 스토리지 기준) |
| API 요청 | 과금 있음 | 없음 |
| 데이터 전송 | 아웃바운드 과금 동일 | 동일 |
| Throughput/IOPS | 무료 (요청 기반 과금) | 성능 모드별 과금 |

> S3는 용량 + API 요청 수 기준  
> EFS는 용량 + 처리량 기준 (Provisioned Throughput 선택 시 추가 비용)

---

## 동시접근/공유에 대한 차이

| 기능 | S3 | EFS |
|------|----|-----|
| EC2 여러 대에서 공유 | API만 가능 | 마운트로 공유 가능 (동기화 즉시 반영) |
| 파일 잠금/수정 반영 | ❌ (객체 단위) | ✅ (POSIX 지원) |
| 실시간 파일 수정 | ❌ (전체 객체 재업로드) | ✅ (파일 단위 수정) |

---

## 실무 판단 기준

| 조건 | 선택 |
|------|------|
| 이미지, JS, HTML 파일 저장 | ✅ S3 |
| EC2 여러 대가 파일 공유 | ✅ EFS |
| 고속 파일 쓰기/읽기 성능 필요 | ✅ EFS |
| 객체 단위로 저장하고 HTTP로 접근 | ✅ S3 |
| 비정형 데이터 아카이브 | ✅ S3 |
| 워크로드가 파일 시스템 기반 | ✅ EFS |

---

## 보안 설정 차이

- **S3**
    - IAM 정책 + 버킷 정책
    - 퍼블릭 액세스 차단 가능
    - 정적 웹 호스팅 가능

- **EFS**
    - 보안그룹 + VPC/Subnet 기반 제어
    - IAM으로 파일 수준 제어 불가능 (리눅스 ACL 사용)

---

## MSA에서 S3 vs EFS 비교

### MSA 관점에서의 차이점

**S3가 MSA에 적합한 경우:**

**1. 객체 기반 저장:**
- 이미지, 비디오, 문서 등 정적 자산
- 버전 관리가 필요한 파일
- 장기 보관이 필요한 데이터

**2. 이벤트 기반 처리:**
- 파일 업로드 시 이벤트 발행
- 비동기 처리 (썸네일 생성, 변환 등)
- 서비스 간 느슨한 결합

**3. HTTP API 접근:**
- REST API로 접근
- Presigned URL로 임시 접근
- 외부 시스템과 연동 용이

**4. 비용 효율:**
- 사용한 만큼만 비용
- 스토리지 클래스 선택으로 최적화
- 라이프사이클 정책으로 자동 최적화

**EFS가 MSA에 적합한 경우:**

**1. 파일 시스템 기반 워크로드:**
- 애플리케이션이 파일 시스템 API 사용
- 기존 애플리케이션 마이그레이션
- POSIX 호환 필요

**2. 실시간 파일 수정:**
- 파일 일부만 수정
- 로그 파일 실시간 추가
- 공유 설정 파일

**3. 낮은 지연 시간:**
- 마이크로초 단위 지연 필요
- 고성능 파일 IO
- 실시간 처리

**4. 공유 파일 시스템:**
- 여러 EC2 인스턴스가 같은 파일 접근
- 파일 잠금 필요
- 즉시 동기화 필요

### MSA에서 선택 기준

| 시나리오 | S3 | EFS |
|---------|----|-----|
| 사용자 업로드 이미지 저장 | ✅ | ❌ |
| 이미지 썸네일 생성 (비동기) | ✅ | ❌ |
| 실시간 로그 파일 쓰기 | ❌ | ✅ |
| 정적 웹사이트 호스팅 | ✅ | ❌ |
| 여러 서비스가 공유 설정 파일 | ❌ | ✅ |
| 데이터 백업 및 아카이브 | ✅ | ❌ |
| ML 모델 체크포인트 (빈번한 읽기/쓰기) | ❌ | ✅ |
| 문서 변환 작업 (비동기) | ✅ | ❌ |
| 실시간 파일 처리 (동기) | ❌ | ✅ |
| CDN을 통한 콘텐츠 배포 | ✅ | ❌ |

### MSA에서 혼합 사용 전략

**S3 사용:**
- 정적 자산 (이미지, 비디오, 문서)
- 사용자 업로드 파일
- 백업 및 아카이브
- 이벤트 기반 비동기 처리
- CDN 연동이 필요한 콘텐츠

**EFS 사용:**
- 실시간 로그 파일
- 공유 설정 파일
- ML 모델 체크포인트 (빈번한 접근)
- 파일 시스템 API를 사용하는 레거시 애플리케이션
- 실시간 파일 수정이 필요한 경우

**예시:**
```
이미지 업로드 서비스:
  - 원본 이미지: S3 저장
  - 썸네일 생성: S3 이벤트 → Lambda → S3 저장
  - CDN 배포: CloudFront → S3

로그 수집 서비스:
  - 실시간 로그: EFS에 실시간 쓰기
  - 일일 아카이브: EFS → S3 (Lambda로 주기적 이동)
  - 장기 보관: S3 Glacier

ML 학습 서비스:
  - 모델 체크포인트: EFS (빈번한 읽기/쓰기)
  - 학습 완료 모델: EFS → S3 (최종 저장)
  - 모델 서빙: S3 → ECS (배포 시)
```

## 혼합 사용 전략

- 정적 자산은 **S3**로 배포
- 동적 서버가 처리하는 파일은 **EFS**
- 장기 보관은 **S3 Glacier** 또는 **S3 Intelligent Tiering**
- MSA에서는 용도에 따라 S3와 EFS를 혼합 사용

---

## 참고 문서

- [Amazon S3 vs Amazon EFS 비교](https://aws.amazon.com/ko/s3/faqs/)
- [Amazon EFS 공식 문서](https://docs.aws.amazon.com/efs/)
- [AWS S3 가격](https://aws.amazon.com/ko/s3/pricing/)
- [AWS EFS 가격](https://aws.amazon.com/ko/efs/pricing/)