---
title: 데이터베이스 옵티마이저 (Database Optimizer) 가이드
tags: [database, optimizer, query-optimization, performance-tuning, execution-plan]
updated: 2025-12-09
---

# 데이터베이스 옵티마이저

## 정의

데이터베이스 옵티마이저는 DBMS의 핵심 엔진으로, 개발자가 작성한 SQL 쿼리를 분석하여 가장 효율적인 실행 방법을 찾아내는 시스템입니다.

### 핵심 개념

**실행 계획(Execution Plan)**
- SQL 쿼리를 실제로 실행하기 위한 단계별 처리 방법

**비용 기반 최적화(Cost-Based Optimization)**
- 각 실행 방법의 비용을 계산하여 가장 낮은 비용의 방법 선택

**통계 정보(Statistics)**
- 테이블의 크기, 컬럼 값의 분포도, 인덱스의 선택도 등

## 동작 원리

### 1. 쿼리 분석 (Parsing)

- 문법 검사: SQL 문법 확인
- 의미 분석: 테이블과 컬럼 존재 여부 확인
- 권한 검증: 사용자 접근 권한 확인
- 내부 표현 변환: 쿼리 트리 생성

### 2. 실행 계획 생성

**데이터 접근 방법:**

| 방법 | 설명 | 사용 시점 |
|------|------|----------|
| Full Table Scan | 테이블 전체 읽기 | 테이블이 작거나 대부분의 행 검색 |
| Index Range Scan | 인덱스로 범위 검색 | 특정 범위의 데이터 검색 |
| Index Unique Scan | 인덱스로 단일 행 검색 | PK나 Unique 키로 검색 |

**조인 알고리즘:**

| 알고리즘 | 설명 | 적합한 경우 |
|---------|------|------------|
| Nested Loop Join | 중첩 반복문 방식 | 작은 테이블 조인 |
| Hash Join | 해시 테이블 활용 | 큰 테이블 조인 |
| Sort Merge Join | 정렬 후 병합 | 정렬된 데이터 조인 |

### 3. 비용 계산

옵티마이저는 각 실행 방법의 비용을 계산합니다:

```
총 비용 = I/O 비용 + CPU 비용 + 메모리 비용
```

## 사용법

### 실행 계획 확인

**MySQL:**
```sql
EXPLAIN SELECT * FROM users WHERE age > 30;
```

**PostgreSQL:**
```sql
EXPLAIN ANALYZE SELECT * FROM users WHERE age > 30;
```

**실행 계획 해석:**
```
id | select_type | table | type  | key     | rows | Extra
1  | SIMPLE      | users | range | idx_age | 100  | Using where
```

- **type**: 접근 방법 (const > eq_ref > ref > range > index > ALL)
- **key**: 사용된 인덱스
- **rows**: 예상 검색 행 수
- **Extra**: 추가 정보

### 힌트 사용

```sql
-- 인덱스 힌트
SELECT /*+ INDEX(users idx_age) */ * FROM users WHERE age > 30;

-- 조인 순서 힌트
SELECT /*+ LEADING(a b) */ * FROM orders a JOIN customers b ON a.customer_id = b.id;

-- 조인 방법 힌트
SELECT /*+ USE_HASH(a b) */ * FROM orders a JOIN customers b ON a.customer_id = b.id;
```

## 최적화 기법

### 인덱스 최적화

**인덱스 생성 전략:**
```sql
-- 단일 컬럼 인덱스
CREATE INDEX idx_age ON users(age);

-- 복합 인덱스 (선택도 높은 컬럼 우선)
CREATE INDEX idx_status_date ON orders(status, order_date);

-- 커버링 인덱스
CREATE INDEX idx_cover ON users(status, age, name);
```

### 쿼리 최적화

**비효율적 쿼리:**
```sql
-- 함수 사용으로 인덱스 미사용
SELECT * FROM users WHERE YEAR(created_at) = 2024;

-- SELECT *
SELECT * FROM users WHERE age > 30;

-- 서브쿼리
SELECT * FROM orders WHERE customer_id IN (
  SELECT id FROM customers WHERE city = 'Seoul'
);
```

**최적화된 쿼리:**
```sql
-- 인덱스를 활용할 수 있도록 변경
SELECT * FROM users 
WHERE created_at >= '2024-01-01' AND created_at < '2025-01-01';

-- 필요한 컬럼만 선택
SELECT id, name, age FROM users WHERE age > 30;

-- JOIN으로 변경
SELECT o.* FROM orders o
JOIN customers c ON o.customer_id = c.id
WHERE c.city = 'Seoul';
```

## 성능 튜닝

### 통계 정보 관리

```sql
-- MySQL
ANALYZE TABLE users;

-- PostgreSQL
ANALYZE users;

-- Oracle
EXEC DBMS_STATS.GATHER_TABLE_STATS('schema_name', 'users');
```

### 쿼리 캐시

```javascript
const Redis = require('redis');
const redis = Redis.createClient();

async function getCachedQuery(key, queryFn) {
  // 캐시 확인
  const cached = await redis.get(key);
  if (cached) {
    return JSON.parse(cached);
  }
  
  // 쿼리 실행
  const result = await queryFn();
  
  // 결과 캐싱 (5분)
  await redis.setex(key, 300, JSON.stringify(result));
  
  return result;
}
```

## 참고

### 옵티마이저 종류

| DBMS | 옵티마이저 유형 | 특징 |
|------|---------------|------|
| MySQL | Cost-Based | 비용 기반, 통계 정보 활용 |
| PostgreSQL | Cost-Based | 고급 비용 모델, GEQO |
| Oracle | CBO + RBO | 비용 기반 + 규칙 기반 |
| SQL Server | Cost-Based | Cardinality Estimation |

### 모범 사례

1. 적절한 인덱스 생성 및 관리
2. 통계 정보를 최신 상태로 유지
3. 실행 계획을 주기적으로 확인
4. 복잡한 쿼리는 단순화
5. 필요한 경우에만 힌트 사용

### 관련 문서
- MySQL Query Optimization Guide
- PostgreSQL Performance Tuning
- Oracle Database Performance Tuning Guide
