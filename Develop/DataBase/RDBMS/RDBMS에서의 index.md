## RDBMS에서의 Index

### 인덱스의 정의와 목적
- 인덱스는 데이터베이스 테이블의 검색 성능을 향상시키기 위한 자료구조입니다.
- 책의 목차와 같이 특정 컬럼의 값을 기준으로 데이터를 빠르게 찾을 수 있게 해줍니다.
- 인덱스는 테이블과 별도의 저장 공간에 저장되며, 데이터의 물리적 위치를 가리키는 포인터를 포함합니다.

### 인덱스의 종류
1. B-Tree 인덱스
   - 가장 일반적으로 사용되는 인덱스 구조
   - 범위 검색과 정렬된 데이터 접근에 최적화
   - MySQL의 InnoDB, PostgreSQL 등에서 기본적으로 사용

2. Hash 인덱스
   - 해시 함수를 사용하여 데이터를 저장
   - 동등 비교(=) 연산에 매우 빠름
   - 범위 검색이나 정렬에는 적합하지 않음
   - MySQL의 Memory 스토리지 엔진에서 사용

3. Fractal 인덱스
   - 프랙탈 기하학을 기반으로 한 인덱스 구조
   - 대용량 데이터 처리에 특화
   - 특수한 용도로 사용

### B-Tree 인덱스의 상세 구조

#### 1. 노드의 구성
- **루트 노드(Root Node)**: 트리의 최상위 노드로, 전체 인덱스의 시작점
- **브랜치 노드(Branch Node)**: 중간 단계의 노드들로, 자식 노드들의 범위 정보를 가짐
- **리프 노드(Leaf Node)**: 실제 데이터의 위치 정보를 저장하는 최하위 노드

#### 2. 페이지(Page) 구조
- **페이지 크기**: 일반적으로 16KB (MySQL InnoDB 기준)
- **페이지 구성**:
  - 페이지 헤더: 페이지의 메타데이터 저장
  - 인덱스 레코드: 실제 인덱스 데이터
  - 페이지 푸터: 다음 페이지의 포인터 등

#### 3. 인덱스 레코드 구조
- **키 값**: 인덱싱된 컬럼의 실제 값
- **포인터**: 실제 데이터 레코드의 위치 정보
- **트랜잭션 ID**: MVCC(Multi-Version Concurrency Control)를 위한 정보

### 인덱스의 동작 방식

#### 1. 인덱스 스캔 과정
1. 루트 노드에서 시작하여 키 값을 비교
2. 브랜치 노드를 통해 적절한 리프 노드로 이동
3. 리프 노드에서 실제 데이터의 위치를 찾음
4. 데이터 페이지에서 실제 레코드를 읽음

#### 2. I/O 작업의 종류
- **순차 I/O**: 연속된 데이터 블록을 순서대로 읽는 방식
  - 예: 인덱스 범위 스캔, 테이블 풀 스캔
  - 디스크 헤드의 이동이 최소화되어 효율적

- **랜덤 I/O**: 불연속적인 데이터 블록을 읽는 방식
  - 예: 인덱스를 통한 단일 레코드 조회
  - 디스크 헤드의 이동이 많아 성능 저하 가능성

### 인덱스 사용 시 고려사항

#### 1. 인덱스의 장점
- 검색 성능 향상
- 정렬 작업 최적화
- 조인 연산 가속화
- 유니크 제약 조건 강제

#### 2. 인덱스의 단점
- 추가 저장 공간 필요
- 데이터 변경 작업(INSERT, UPDATE, DELETE) 성능 저하
- 인덱스 관리 오버헤드

#### 3. 인덱스 설계 시 고려 요소
- 카디널리티(중복도)
- 선택성(Selectivity)
- 쿼리 패턴
- 데이터 변경 빈도

### 실무적 예시

#### 1. 복합 인덱스 설계
```sql
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    customer_id INT,
    order_date DATETIME,
    status VARCHAR(20),
    INDEX idx_customer_date (customer_id, order_date)
);
```
- customer_id와 order_date의 조합으로 검색이 빈번한 경우
- 선행 컬럼(customer_id)의 선택성이 중요

#### 2. 커버링 인덱스
```sql
CREATE INDEX idx_covering ON orders (customer_id, order_date, status);
```
- 인덱스만으로 쿼리를 완성할 수 있는 경우
- 테이블 접근 없이 결과를 반환 가능

### 성능 최적화 팁

1. **인덱스 선택성 최적화**
   - 높은 선택성을 가진 컬럼을 선행 컬럼으로
   - 낮은 선택성의 컬럼은 후행 컬럼으로

2. **인덱스 크기 관리**
   - 불필요한 컬럼 제외
   - 문자열 인덱스의 경우 길이 제한 고려

3. **인덱스 통계 정보 관리**
   - 주기적인 ANALYZE TABLE 실행
   - 통계 정보 갱신으로 실행 계획 최적화

### 모니터링과 유지보수

1. **인덱스 사용 현황 모니터링**
```sql
-- MySQL에서 인덱스 사용 통계 확인
SHOW INDEX FROM table_name;
```

2. **인덱스 조각화 관리**
```sql
-- 인덱스 재구성
OPTIMIZE TABLE table_name;
```

3. **불필요한 인덱스 제거**
- 사용되지 않는 인덱스 모니터링
- 주기적인 인덱스 사용 통계 분석

### 결론
- 인덱스는 데이터베이스 성능에 중요한 영향을 미치는 요소
- 적절한 인덱스 설계와 관리는 시스템 성능 향상의 핵심
- 실제 사용 패턴을 고려한 인덱스 전략 수립 필요

```
출처
https://mangkyu.tistory.com/286
https://dev.mysql.com/doc/refman/8.0/en/optimization-indexes.html
https://use-the-index-luke.com/
```