

## RDBMS에서의 Index
- 인덱스를 저장하는 방식(또는 알고리즘)에 따라 B-Tree 인덱스, Hash 인덱스, Fractal 인덱스 등으로 나눌 수 있습니다. 
- 일반적으로 B-Tree 구조가 사용되기 때문에 B-Tree 인덱스를 통해 인덱스의 동작 방식에 대해 살펴보도록 하겠습니다.

### B- Tree
- B-Tree는 자식 2개 만을 갖는 이진 트리를 확장하여 N개의 자식을 가질 수 있도록 항상 균형을 맞춘다.

### [ B-Tree 구조란?]
- B-Tree는 최상위에 단 하나의 노드 만이 존재하는데, 이를 루트 노드(Root Node)라고 하고 중간 노드를 브랜치 노드(Branch Node), 최하위 노드를 리프 노드(Leaf Node)라고 한다.
> 루프노트 - 브랜치 노트 - 리프 노드  


![B-tree.png](..%2F..%2F..%2Fetc%2Fimage%2FDataBase%2FRDBMS%2FB-tree.png)

### [ 페이지(Page)란?]
- 디스크와 메모리(버퍼풀)에 데이터를 읽고 쓰는 최소 작업 단위이다. 
- 따라서 만약 쿼리를 통해 1개의 레코드를 읽고 싶더라도 결국은 하나의 블록을 읽어야 하는 것이다.
- 1개의 페이지에 많은 데이터들을 저장할 수 있도록 하는 것이 상당히 중요하다. 


#### 무분별한 페이지의 문제점
1. 디스크 I/O가 많아질 수 있음
2. 메모리에 캐싱할 수 있는 페이지의 수가 줄어들 수 있음


#### 예를 들어 다음과 같이 설계된 테이블이 있다고 하자.
```
CREATE TABLE employee (
    emp_no INT NOT NULL AUTO_INCREMENT,
    name VARCHAR(64),
    PRIMARY KEY(emp_no),
    INDEX idx_name (name)
) ENGINE=InnoDB;
```


- 위와 같은 테이블에 임의의 데이터가 들어있다고 할 때, 이러한 구조를 그림으로 표현하면 다음과 같다.

![인덱스 구조.png](..%2F..%2F..%2Fetc%2Fimage%2FDataBase%2FRDBMS%2F%EC%9D%B8%EB%8D%B1%EC%8A%A4%20%EA%B5%AC%EC%A1%B0.png)

- 인덱스는 테이블과 독립적인 저장 공간이므로 인덱스를 통해 데이터를 조회하려면 먼저 PK를 찾아야 한다. 
- PK로 레코드를 조회할 때는(인덱스 영역에서 테이블 영역으로 넘어가는 경우) PK가 어느 페이지에 저장되어 있는지 알 수 없으므로 랜덤 I/O가 발생한다.
- 이후에는 PK를 따라 리프노드에서 실제 레코드를 읽어온다. 
- 참고로 연속된 데이터를 조회하는 경우에는 순차 I/O가 발생하는데, 랜덤 I/O는 임의의 장소에서 데이터를 가져오지만 순차 I/O는 다음 장소에서 데이터를 가져오므로 훨씬 빠르다.



```
출처
https://mangkyu.tistory.com/286
```