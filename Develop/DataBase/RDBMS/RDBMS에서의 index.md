---
title: RDBMS에서의 Index
tags: [database, rdbms, index, performance, optimization, b-tree]
updated: 2025-09-23
---

# RDBMS에서의 Index

## 인덱스의 본질

### 인덱스가 무엇인가?
인덱스는 데이터베이스에서 데이터를 빠르게 찾기 위한 별도의 자료구조입니다. 마치 도서관에서 책을 찾을 때 사용하는 카드 목록과 같은 역할을 합니다. 

실제 데이터는 테이블에 저장되어 있지만, 인덱스는 그 데이터의 위치 정보를 별도로 관리합니다. 이렇게 분리된 구조 덕분에 전체 테이블을 뒤지지 않고도 원하는 데이터를 빠르게 찾을 수 있게 됩니다.

### 왜 인덱스가 필요한가?
데이터베이스에서 데이터를 찾는 방법은 크게 두 가지입니다:

**1. 전체 테이블 스캔 (Table Full Scan)**
- 테이블의 모든 행을 처음부터 끝까지 순차적으로 읽어가며 조건에 맞는 데이터를 찾는 방식
- 작은 테이블에서는 괜찮지만, 수백만 개의 레코드가 있는 테이블에서는 매우 비효율적
- 시간 복잡도: O(n)

**2. 인덱스 스캔 (Index Scan)**
- 인덱스를 통해 필요한 데이터만 선택적으로 읽는 방식
- 인덱스는 이미 정렬되어 있어 이진 탐색이 가능
- 시간 복잡도: O(log n)

### 인덱스의 물리적 구조 이해
데이터베이스는 디스크에 페이지 단위로 데이터를 저장합니다:

- **데이터 페이지**: 실제 테이블 데이터가 저장되는 공간
- **인덱스 페이지**: 인덱스 정보가 저장되는 공간  
- **페이지 링크**: 페이지들 간의 연결 정보로 순차 접근을 가능하게 함

## 인덱스의 다양한 형태

### B-Tree 인덱스 - 가장 널리 사용되는 구조
B-Tree 인덱스는 현재 대부분의 관계형 데이터베이스에서 기본으로 사용하는 인덱스 구조입니다. 

**특징:**
- 균형 이진 트리의 확장된 형태로, 각 노드가 여러 개의 자식을 가질 수 있음
- 데이터가 정렬된 상태로 저장되어 범위 검색에 매우 효율적
- 삽입, 삭제, 수정 시에도 자동으로 균형을 유지
- MySQL InnoDB, PostgreSQL, Oracle 등에서 표준으로 사용

**동작 원리:**
루트 노드에서 시작해서 키 값을 비교하며 리프 노드까지 내려가면서 데이터의 위치를 찾습니다. 100만 개의 데이터가 있어도 최대 20번 정도의 비교만으로 원하는 데이터를 찾을 수 있습니다.

### Hash 인덱스 - 정확한 매칭에 특화
해시 함수를 사용해서 데이터를 저장하는 방식입니다.

**장점:**
- 동등 비교(=) 연산이 매우 빠름 (O(1)에 가까움)
- 메모리 기반 데이터베이스에서 효과적

**단점:**
- 범위 검색이나 정렬된 데이터 접근이 불가능
- 해시 충돌 처리로 인한 추가 오버헤드
- MySQL Memory 엔진에서만 지원

### 특수 목적 인덱스들

**Full-Text 인덱스**
- 텍스트 내용을 기반으로 한 검색을 위한 인덱스
- 자연어 처리 기능을 지원하여 "비슷한 의미"의 검색도 가능
- MySQL의 FULLTEXT, PostgreSQL의 GIN 인덱스가 대표적

**Spatial 인덱스**
- 지리적 위치 데이터를 위한 인덱스
- R-Tree 구조를 사용하여 "이 지역 근처의 데이터"를 효율적으로 검색
- GPS 좌표, 지도 데이터 처리에 필수

**Fractal 인덱스**
- 프랙탈 기하학을 기반으로 한 특수한 인덱스
- 대용량 시계열 데이터나 공간 데이터 처리에 특화
- 일반적인 용도로는 거의 사용되지 않음

## 인덱스의 장단점 분석

### 인덱스가 가져다주는 이점들

**1. 극적인 검색 성능 향상**
- 전체 테이블을 스캔하는 대신 인덱스를 통해 필요한 데이터만 접근
- 100만 개 레코드에서도 몇 번의 비교만으로 원하는 데이터 발견
- 대용량 데이터베이스에서 필수적인 성능 최적화 수단

**2. 정렬 작업의 자동화**
- 인덱스는 이미 정렬된 상태로 저장되어 있음
- ORDER BY 절이 인덱스 순서를 따르면 별도의 정렬 작업 불필요
- 메모리 사용량과 CPU 부하를 크게 줄일 수 있음

**3. 조인 연산의 효율성**
- 두 테이블을 조인할 때 조인 조건 컬럼에 인덱스가 있으면 매우 빠름
- Nested Loop Join에서 특히 효과적
- 대용량 테이블 간 조인에서 필수적

**4. 데이터 무결성 보장**
- 유니크 인덱스를 통해 중복 데이터 자동 방지
- 데이터베이스 레벨에서 무결성 제약 조건 강제

### 인덱스의 숨겨진 비용들

**1. 저장 공간의 추가 소모**
- 인덱스는 별도의 저장 공간을 차지함
- 대용량 테이블에서는 인덱스 크기가 상당할 수 있음
- 디스크 공간과 메모리 사용량 증가

**2. 데이터 변경 시의 성능 저하**
- INSERT, UPDATE, DELETE 작업 시 인덱스도 함께 업데이트해야 함
- B-Tree 구조 유지를 위한 추가 작업 필요
- 동시성 제어가 복잡해짐

**3. 지속적인 관리 필요**
- 인덱스 조각화로 인한 성능 저하
- 통계 정보 업데이트 필요
- 사용하지 않는 인덱스의 정기적인 정리

## 실제 사용 사례와 예시

### B-Tree 인덱스의 동작 과정
B-Tree 인덱스가 데이터를 찾는 과정을 단계별로 살펴보면:

1. **루트 노드 접근**: 인덱스의 최상위 노드에서 시작
2. **키 값 비교**: 찾고자 하는 값과 노드의 키 값들을 비교
3. **하위 노드 이동**: 비교 결과에 따라 적절한 하위 노드로 이동
4. **리프 노드 도달**: 최종적으로 실제 데이터 위치 정보가 있는 리프 노드에 도달
5. **데이터 읽기**: 리프 노드의 포인터를 통해 실제 데이터 페이지에서 데이터를 읽음

이 과정에서 100만 개의 레코드가 있어도 최대 20번 정도의 비교만으로 원하는 데이터를 찾을 수 있습니다.

### 인덱스 생성과 활용 예시

**기본 테이블 구조:**
```sql
CREATE TABLE users (
  id INT PRIMARY KEY,
  name VARCHAR(100),
  email VARCHAR(100),
  age INT,
  created_at TIMESTAMP,
  active BOOLEAN DEFAULT true
);
```

**다양한 인덱스 생성:**
```sql
-- 단일 컬럼 인덱스
CREATE INDEX idx_users_name ON users(name);
CREATE INDEX idx_users_email ON users(email);

-- 복합 인덱스 (여러 컬럼을 조합)
CREATE INDEX idx_users_age_created ON users(age, created_at);

-- 부분 인덱스 (특정 조건을 만족하는 행만 인덱싱)
CREATE INDEX idx_users_active ON users(email) WHERE active = true;

-- 유니크 인덱스 (중복 방지)
CREATE UNIQUE INDEX idx_users_email_unique ON users(email);
```

**인덱스가 효과적인 쿼리들:**
```sql
-- 정확한 매칭 (인덱스 스캔)
SELECT * FROM users WHERE name = 'John Doe';

-- 범위 검색 (인덱스 범위 스캔)
SELECT * FROM users WHERE age BETWEEN 20 AND 30;

-- 정렬과 함께 사용
SELECT * FROM users WHERE age = 25 ORDER BY created_at DESC;

-- 복합 인덱스 활용
SELECT * FROM users WHERE age = 25 AND created_at > '2023-01-01';
```

### I/O 패턴의 차이점

**순차 I/O (Sequential I/O)**
- 연속된 디스크 블록을 순서대로 읽는 방식
- 디스크 헤드의 이동이 최소화되어 효율적
- 인덱스 범위 스캔이나 전체 테이블 스캔에서 발생

**랜덤 I/O (Random I/O)**
- 불연속된 디스크 블록을 읽는 방식
- 디스크 헤드의 이동이 많아 상대적으로 느림
- 인덱스를 통한 개별 레코드 접근에서 발생

### 성능 차이의 실제 예시

100만 개의 사용자 데이터가 있는 테이블에서 특정 사용자를 찾는 경우:

**인덱스 없는 경우:**
- 전체 테이블을 순차적으로 스캔
- 평균적으로 50만 개의 레코드를 읽어야 함
- 시간 복잡도: O(n)

**인덱스 있는 경우:**
- B-Tree 인덱스를 통해 최대 20번의 비교
- 실제로는 3-4개의 페이지만 읽으면 됨
- 시간 복잡도: O(log n)

실제로는 수십 배에서 수백 배의 성능 차이가 발생할 수 있습니다.

## 인덱스 설계와 운영 가이드

### 효과적인 인덱스 설계 원칙

**1. 선택도(Selectivity)를 고려한 컬럼 선정**
- 선택도가 높은 컬럼일수록 인덱스 효과가 큼
- 성별(남/여 2개 값)보다는 나이(다양한 값)가 더 좋은 인덱스
- 카디널리티가 높은 컬럼을 우선적으로 고려

**2. 복합 인덱스의 컬럼 순서**
- 가장 자주 사용되는 조건을 앞에 배치
- 등호 조건(=)이 있는 컬럼을 범위 조건(>, <, BETWEEN)보다 앞에 배치
- 자주 함께 사용되는 컬럼들을 그룹화

**3. 쿼리 패턴 분석**
- 실제 애플리케이션에서 사용되는 쿼리 패턴을 분석
- WHERE 절, ORDER BY 절, JOIN 조건을 종합적으로 고려
- 자주 사용되지 않는 인덱스는 제거 고려

### 인덱스 모니터링과 관리

**인덱스 사용 현황 확인:**
```sql
-- MySQL에서 인덱스 사용 통계 확인
SELECT 
  table_name,
  index_name,
  cardinality,
  index_type
FROM information_schema.statistics 
WHERE table_schema = 'your_database'
ORDER BY table_name, index_name;

-- PostgreSQL에서 인덱스 사용 통계 확인
SELECT 
  schemaname, 
  tablename, 
  indexname, 
  idx_scan, 
  idx_tup_read, 
  idx_tup_fetch
FROM pg_stat_user_indexes
WHERE tablename = 'users';
```

**인덱스 크기와 효율성 분석:**
```sql
-- 인덱스 크기 확인
SELECT 
  table_name,
  index_name,
  ROUND(((data_length + index_length) / 1024 / 1024), 2) AS 'Size (MB)'
FROM information_schema.tables 
WHERE table_schema = 'your_database';
```

### 인덱스 최적화 작업

**정기적인 인덱스 관리:**
```sql
-- 불필요한 인덱스 제거
DROP INDEX idx_unused_index ON users;

-- 인덱스 재구성 (MySQL)
OPTIMIZE TABLE users;

-- 인덱스 통계 업데이트 (PostgreSQL)
ANALYZE users;

-- 인덱스 조각화 확인 및 해결
-- 조각화가 심한 인덱스는 재구성 필요
```

**성능 모니터링 지표:**
- 인덱스 사용 빈도 (idx_scan)
- 인덱스를 통한 읽은 튜플 수 (idx_tup_read)
- 인덱스 크기와 테이블 크기 비율
- 인덱스 조각화 정도

## B-Tree 인덱스의 내부 구조

### 노드의 구성과 역할

**루트 노드(Root Node)**
- B-Tree의 최상위 노드로, 모든 검색의 시작점
- 일반적으로 메모리에 캐시되어 있어 매우 빠른 접근 가능
- 브랜치 노드나 리프 노드로의 포인터를 포함

**브랜치 노드(Branch Node)**
- 중간 단계의 노드들로, 자식 노드들의 범위 정보를 관리
- 키 값과 자식 노드 포인터의 쌍으로 구성
- 페이지 분할과 병합이 발생할 수 있는 동적 구조

**리프 노드(Leaf Node)**
- 실제 데이터의 위치 정보를 저장하는 최하위 노드
- 키 값과 실제 데이터 레코드의 포인터를 포함
- 양방향 링크로 연결되어 범위 스캔에 효율적

### 페이지 구조의 세부 사항

**페이지 크기와 최적화**
- 일반적으로 16KB (MySQL InnoDB 기준)
- 운영체제의 페이지 크기와 맞추는 것이 성능상 유리
- 페이지 크기는 I/O 효율성에 직접적인 영향

**페이지 내부 구성**
- **페이지 헤더**: 페이지의 메타데이터 저장
  - 페이지 타입, 이전/다음 페이지 포인터
  - 페이지 내 레코드 수, 최소/최대 키 값
- **인덱스 레코드**: 실제 인덱스 데이터
  - 키 값과 포인터의 쌍
  - 슬롯 디렉토리로 빠른 접근 지원
- **페이지 푸터**: 다음 페이지의 포인터 등
  - 체크섬, 페이지 상태 정보

### 인덱스 레코드의 구조

**키 값 관리**
- 인덱싱된 컬럼의 실제 값이 정렬된 순서로 저장
- 중복 키 처리 방식을 포함한 메타데이터
- NULL 값 처리 방식도 인덱스 구조에 반영

**포인터 정보**
- 실제 데이터 레코드의 정확한 위치 정보
- 페이지 번호와 오프셋 정보의 조합
- 클러스터링 여부에 따라 구조가 달라짐

**트랜잭션 정보**
- MVCC(Multi-Version Concurrency Control)를 위한 정보
- 트랜잭션 ID, 롤백 포인터
- 삭제 마커 등 동시성 제어 관련 데이터

## 핵심 용어 정리

### 인덱스 관련 전문 용어
- **Cardinality**: 인덱스에서 고유한 값의 개수, 인덱스 효율성의 지표
- **Selectivity**: 선택도, 인덱스가 얼마나 선택적인지를 나타내는 비율
- **Covering Index**: 쿼리에서 필요한 모든 컬럼이 인덱스에 포함된 경우
- **Index Fragmentation**: 인덱스 조각화, 성능 저하의 주요 원인
- **Index Scan vs Index Range Scan**: 단일 값 검색과 범위 검색의 차이

### 실제 적용 사례
1. **웹 애플리케이션**: 사용자 검색, 상품 검색 기능
2. **로그 분석 시스템**: 날짜별, 시간별 데이터 조회
3. **게시판 시스템**: 제목, 작성자, 날짜별 검색
4. **전자상거래**: 카테고리, 가격, 브랜드별 상품 검색
5. **소셜 네트워크**: 친구 관계, 활동 피드 조회

## 마무리

인덱스는 데이터베이스 성능 최적화의 핵심 도구입니다. 적절한 인덱스 설계와 관리를 통해 검색 성능을 극적으로 향상시킬 수 있지만, 과도한 인덱스는 오히려 성능을 저하시킬 수 있습니다. 

실제 애플리케이션의 쿼리 패턴을 철저히 분석하고, 선택도가 높은 컬럼을 우선적으로 인덱싱하며, 정기적인 모니터링을 통해 인덱스의 효율성을 지속적으로 관리하는 것이 중요합니다.

## 참조

- MySQL 8.0 Reference Manual - Indexes
- PostgreSQL Documentation - Indexes
- Oracle Database Concepts - Indexes
- Database System Concepts (Silberschatz, Korth, Sudarshan)
- High Performance MySQL (Baron Schwartz, Peter Zaitsev, Vadim Tkachenko)
