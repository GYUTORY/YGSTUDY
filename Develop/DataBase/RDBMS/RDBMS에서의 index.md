## RDBMS에서의 Index

### 인덱스의 정의와 목적
- 인덱스는 데이터베이스 테이블의 검색 성능을 향상시키기 위한 자료구조입니다.
- 책의 목차와 같이 특정 컬럼의 값을 기준으로 데이터를 빠르게 찾을 수 있게 해줍니다.
- 인덱스는 테이블과 별도의 저장 공간에 저장되며, 데이터의 물리적 위치를 가리키는 포인터를 포함합니다.
- 데이터베이스의 성능 최적화에서 가장 중요한 요소 중 하나입니다.

### 인덱스의 기본 원리
1. **데이터 접근 방식**
   - Table Full Scan: 테이블의 모든 데이터를 순차적으로 읽는 방식
   - Index Scan: 인덱스를 통해 필요한 데이터만 선택적으로 읽는 방식
   - Index Range Scan: 인덱스를 통해 특정 범위의 데이터를 읽는 방식

2. **인덱스의 물리적 구조**
   - 데이터 페이지: 실제 데이터가 저장되는 공간
   - 인덱스 페이지: 인덱스 데이터가 저장되는 공간
   - 페이지 링크: 페이지 간의 연결 정보

### 인덱스의 종류
1. **B-Tree 인덱스**
   - 가장 일반적으로 사용되는 인덱스 구조
   - 범위 검색과 정렬된 데이터 접근에 최적화
   - MySQL의 InnoDB, PostgreSQL 등에서 기본적으로 사용
   - 균형 트리 구조로 데이터의 삽입/삭제/수정 시 자동으로 균형을 맞춤
   - 각 노드는 여러 개의 키와 포인터를 가질 수 있음

2. **Hash 인덱스**
   - 해시 함수를 사용하여 데이터를 저장
   - 동등 비교(=) 연산에 매우 빠름
   - 범위 검색이나 정렬에는 적합하지 않음
   - MySQL의 Memory 스토리지 엔진에서 사용
   - 충돌 해결을 위한 체이닝이나 개방 주소법 사용

3. **Fractal 인덱스**
   - 프랙탈 기하학을 기반으로 한 인덱스 구조
   - 대용량 데이터 처리에 특화
   - 특수한 용도로 사용
   - 공간 데이터나 시계열 데이터에 효과적

4. **Full-Text 인덱스**
   - 텍스트 검색을 위한 특수 인덱스
   - 자연어 처리 기능 지원
   - MySQL의 FULLTEXT 인덱스, PostgreSQL의 GIN 인덱스 등

5. **Spatial 인덱스**
   - 공간 데이터를 위한 특수 인덱스
   - R-Tree 구조 사용
   - 위치 기반 검색에 최적화

### B-Tree 인덱스의 상세 구조

#### 1. 노드의 구성
- **루트 노드(Root Node)**
  - 트리의 최상위 노드로, 전체 인덱스의 시작점
  - 항상 메모리에 캐시되어 있어 빠른 접근 가능
  - 브랜치 노드나 리프 노드로의 포인터 포함

- **브랜치 노드(Branch Node)**
  - 중간 단계의 노드들로, 자식 노드들의 범위 정보를 가짐
  - 키 값과 자식 노드 포인터의 쌍으로 구성
  - 페이지 분할과 병합이 발생할 수 있음

- **리프 노드(Leaf Node)**
  - 실제 데이터의 위치 정보를 저장하는 최하위 노드
  - 키 값과 실제 데이터 레코드의 포인터 포함
  - 양방향 링크로 연결되어 범위 스캔에 효율적

#### 2. 페이지(Page) 구조
- **페이지 크기**
  - 일반적으로 16KB (MySQL InnoDB 기준)
  - 운영체제의 페이지 크기와 맞추는 것이 좋음
  - 페이지 크기는 성능에 직접적인 영향

- **페이지 구성**
  - 페이지 헤더: 페이지의 메타데이터 저장
    - 페이지 타입, 이전/다음 페이지 포인터
    - 페이지 내 레코드 수, 최소/최대 키 값
  - 인덱스 레코드: 실제 인덱스 데이터
    - 키 값과 포인터의 쌍
    - 슬롯 디렉토리로 빠른 접근 지원
  - 페이지 푸터: 다음 페이지의 포인터 등
    - 체크섬, 페이지 상태 정보

#### 3. 인덱스 레코드 구조
- **키 값**
  - 인덱싱된 컬럼의 실제 값
  - 정렬된 순서로 저장
  - 중복 키 처리 방식 포함

- **포인터**
  - 실제 데이터 레코드의 위치 정보
  - 페이지 번호와 오프셋 정보
  - 클러스터링 여부에 따라 구조가 다름

- **트랜잭션 정보**
  - MVCC(Multi-Version Concurrency Control)를 위한 정보
  - 트랜잭션 ID, 롤백 포인터
  - 삭제 마커 등

### 인덱스의 동작 방식

#### 1. 인덱스 스캔 과정
1. **루트 노드 접근**
   - 루트 노드는 메모리에 캐시되어 있어 빠른 접근
   - 키 값 비교를 통해 다음 노드 결정

2. **브랜치 노드 탐색**
   - 키 값의 범위에 따라 적절한 브랜치 선택
   - 여러 단계의 브랜치 노드를 거칠 수 있음

3. **리프 노드 도달**
   - 실제 데이터의 위치 정보 확인
   - 필요한 경우 추가 데이터 페이지 접근

4. **데이터 읽기**
   - 포인터를 통해 실제 데이터 페이지 접근
   - 필요한 컬럼만 선택적으로 읽기

#### 2. I/O 작업의 종류
- **순차 I/O**
  - 연속된 데이터 블록을 순서대로 읽는 방식
  - 디스크 헤드의 이동이 최소화되어 효율적
  - 예: 인덱스 범위 스캔, 테이블 풀 스캔
  - 대용량 데이터 처리에 적합

- **랜덤 I/O**
  - 불연속적인 데이터 블록을 읽는 방식
  - 디스크 헤드의 이동이 많아 성능 저하
  - 예: 인덱스를 통한 단일 레코드 조회
  - SSD에서는 상대적으로 영향이 적음

### 인덱스 사용 시 고려사항

#### 1. 인덱스의 장점
- **검색 성능 향상**
  - O(log n)의 시간 복잡도로 데이터 접근
  - 대용량 데이터에서 효과적
  - 특정 조건의 데이터 검색이 빠름

- **정렬 작업 최적화**
  - 인덱스는 이미 정렬된 상태
  - ORDER BY 작업이 인덱스 순서로 처리
  - 정렬 작업의 부하 감소

- **조인 연산 가속화**
  - 조인 조건의 컬럼에 인덱스가 있으면 효율적
  - Nested Loop Join에서 특히 효과적
  - 조인 성능 향상

- **유니크 제약 조건 강제**
  - 중복 데이터 방지
  - 데이터 무결성 보장
  - 유니크 인덱스로 구현

#### 2. 인덱스의 단점
- **저장 공간 증가**
  - 인덱스 데이터의 추가 저장 필요
  - 대용량 데이터베이스에서 중요한 고려사항
  - 디스크 공간 비용 발생

- **데이터 변경 작업 성능 저하**
  - INSERT: 인덱스 업데이트 필요
  - UPDATE: 인덱스 키 변경 시 재정렬
  - DELETE: 인덱스 엔트리 제거

- **인덱스 관리 오버헤드**
  - 인덱스 재구성 필요
  - 통계 정보 업데이트
  - 페이지 분할/병합 작업

#### 3. 인덱스 설계 시 고려 요소
- **카디널리티**
  - 컬럼의 고유한 값의 수
  - 높은 카디널리티가 좋음
  - 예: 성별(2) vs 이메일(수천)

- **선택성**
  - 특정 값을 가진 레코드의 비율
  - 낮은 선택성이 좋음
  - 예: 100만 건 중 10건 vs 100만 건 중 50만 건

- **쿼리 패턴**
  - 자주 사용되는 WHERE 조건
  - 정렬이나 그룹화 조건
  - 조인 조건

- **데이터 변경 빈도**
  - 읽기/쓰기 비율
  - 배치 작업의 존재
  - 실시간 처리 요구사항

### 실무적 예시

#### 1. 복합 인덱스 설계
```sql
-- 주문 테이블 예시
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    customer_id INT,
    order_date DATETIME,
    status VARCHAR(20),
    amount DECIMAL(10,2),
    INDEX idx_customer_date (customer_id, order_date)
);

-- 효율적인 쿼리
SELECT * FROM orders 
WHERE customer_id = 100 
AND order_date BETWEEN '2024-01-01' AND '2024-12-31';

-- 비효율적인 쿼리 (인덱스 사용 불가)
SELECT * FROM orders 
WHERE order_date BETWEEN '2024-01-01' AND '2024-12-31';
```

#### 2. 커버링 인덱스
```sql
-- 커버링 인덱스 예시
CREATE INDEX idx_covering ON orders (customer_id, order_date, status);

-- 인덱스만으로 처리되는 쿼리
SELECT customer_id, order_date, status 
FROM orders 
WHERE customer_id = 100;

-- 테이블 접근이 필요한 쿼리
SELECT * FROM orders 
WHERE customer_id = 100;
```

#### 3. 부분 인덱스
```sql
-- 활성 주문만 인덱싱
CREATE INDEX idx_active_orders ON orders (customer_id) 
WHERE status = 'ACTIVE';

-- 특정 기간의 주문만 인덱싱
CREATE INDEX idx_recent_orders ON orders (order_date) 
WHERE order_date > '2024-01-01';
```

### 성능 최적화 팁

1. **인덱스 선택성 최적화**
   - 높은 선택성을 가진 컬럼을 선행 컬럼으로
   - 낮은 선택성의 컬럼은 후행 컬럼으로
   - 카디널리티가 높은 컬럼 우선

2. **인덱스 크기 관리**
   - 불필요한 컬럼 제외
   - 문자열 인덱스의 경우 길이 제한
   - 부분 인덱스 활용

3. **인덱스 통계 정보 관리**
   - 주기적인 ANALYZE TABLE 실행
   - 통계 정보 갱신으로 실행 계획 최적화
   - 히스토그램 정보 활용

4. **인덱스 조각화 관리**
   - 주기적인 인덱스 재구성
   - 페이지 분할/병합 모니터링
   - 조각화율 체크

### 모니터링과 유지보수

1. **인덱스 사용 현황 모니터링**
```sql
-- MySQL에서 인덱스 사용 통계 확인
SHOW INDEX FROM table_name;

-- 인덱스 사용 통계 확인
SELECT * FROM information_schema.statistics 
WHERE table_schema = 'your_database' 
AND table_name = 'your_table';
```

2. **인덱스 조각화 관리**
```sql
-- 인덱스 재구성
OPTIMIZE TABLE table_name;

-- 인덱스 통계 업데이트
ANALYZE TABLE table_name;
```

3. **불필요한 인덱스 제거**
- 사용되지 않는 인덱스 모니터링
- 주기적인 인덱스 사용 통계 분석
- 인덱스 유지 비용 고려

### 실제 운영 시나리오

1. **대용량 데이터 마이그레이션**
   - 인덱스 일시 비활성화
   - 데이터 로드 후 인덱스 재생성
   - 배치 작업 최적화

2. **실시간 트랜잭션 처리**
   - 핫스팟 방지
   - 인덱스 분할
   - 동시성 제어

3. **데이터 웨어하우스**
   - 비트맵 인덱스 활용
   - 부분 인덱스 전략
   - 배치 작업 최적화

### 결론
- 인덱스는 데이터베이스 성능에 중요한 영향을 미치는 요소
- 적절한 인덱스 설계와 관리는 시스템 성능 향상의 핵심
- 실제 사용 패턴을 고려한 인덱스 전략 수립 필요
- 지속적인 모니터링과 최적화가 중요

### 참고 자료
- https://mangkyu.tistory.com/286
- https://dev.mysql.com/doc/refman/8.0/en/optimization-indexes.html
- https://use-the-index-luke.com/
- https://www.percona.com/blog/
- https://www.mysqlperformanceblog.com/