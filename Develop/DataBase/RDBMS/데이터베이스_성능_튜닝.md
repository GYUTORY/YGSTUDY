---
title: 데이터베이스 성능 튜닝
tags: [database, performance-tuning, optimization, query-optimization, indexing]
updated: 2025-12-09
---

# 데이터베이스 성능 튜닝

## 개요

데이터베이스 성능 튜닝은 시스템의 응답 시간을 단축하고, 처리량을 증가시키며, 리소스 사용을 최적화하는 과정입니다.

### 성능 문제의 주요 원인

**1. 비효율적인 쿼리**
- SELECT * 사용
- 불필요한 JOIN
- 서브쿼리 남용

**2. 잘못된 인덱스 설계**
- 인덱스 부족
- 과도한 인덱스
- 비효율적인 복합 인덱스

**3. 과도한 데이터 조회**
- 페이지네이션 없음
- 대량 데이터 한번에 로드

**4. 연결 관리 문제**
- 연결 풀 부족
- 연결 누수

## 성능 측정

### 핵심 지표

| 지표 | 목표값 | 측정 방법 |
|------|--------|----------|
| 응답 시간 | < 100ms | 쿼리 실행 시간 측정 |
| 처리량 | 1000+ TPS | 초당 트랜잭션 수 |
| CPU 사용률 | < 70% | 시스템 모니터링 |
| 메모리 사용률 | < 80% | 시스템 모니터링 |
| 연결 수 | < 80% 풀 크기 | 활성 연결 수 |

## 쿼리 최적화

### 실행 계획 분석

**MySQL:**
```sql
EXPLAIN SELECT * FROM orders 
WHERE customer_id = 123 AND order_date > '2024-01-01';
```

**PostgreSQL:**
```sql
EXPLAIN ANALYZE SELECT * FROM orders 
WHERE customer_id = 123 AND order_date > '2024-01-01';
```

**실행 계획 해석:**
```
id | select_type | table  | type  | key         | rows | Extra
1  | SIMPLE      | orders | ref   | idx_customer| 50   | Using where
```

- **type**: 접근 방법 (const > eq_ref > ref > range > index > ALL)
- **key**: 사용된 인덱스
- **rows**: 예상 검색 행 수
- **Extra**: 추가 정보

### 쿼리 최적화 기법

**1. SELECT * 회피**
```sql
-- 비효율적
SELECT * FROM users WHERE age > 30;

-- 최적화
SELECT id, name, email FROM users WHERE age > 30;
```

**2. 서브쿼리를 JOIN으로 변경**
```sql
-- 비효율적
SELECT * FROM orders 
WHERE customer_id IN (SELECT id FROM customers WHERE city = 'Seoul');

-- 최적화
SELECT o.* FROM orders o
JOIN customers c ON o.customer_id = c.id
WHERE c.city = 'Seoul';
```

**3. LIMIT 사용**
```sql
SELECT * FROM orders 
WHERE status = 'pending'
ORDER BY created_at DESC
LIMIT 100;
```

## 인덱스 최적화

### 인덱스 생성 전략

**1. 단일 컬럼 인덱스**
```sql
CREATE INDEX idx_email ON users(email);
```

**2. 복합 인덱스 (선택도 높은 컬럼 우선)**
```sql
CREATE INDEX idx_status_date ON orders(status, order_date);
```

**3. 커버링 인덱스**
```sql
-- 쿼리에 필요한 모든 컬럼 포함
CREATE INDEX idx_cover ON users(status, age, name, email);

SELECT name, email FROM users 
WHERE status = 'active' AND age > 30;
```

### 인덱스 사용 확인

```sql
-- 인덱스 사용 현황
SELECT 
    table_name,
    index_name,
    cardinality,
    seq_in_index
FROM information_schema.statistics
WHERE table_schema = 'mydb';
```

## 연결 풀 관리

### Node.js 연결 풀 설정

```javascript
const mysql = require('mysql2/promise');

const pool = mysql.createPool({
  host: 'localhost',
  user: 'root',
  password: 'password',
  database: 'mydb',
  connectionLimit: 10,        // 최대 연결 수
  queueLimit: 0,              // 대기 큐 제한 (0=무제한)
  waitForConnections: true,   // 연결 대기
  connectionTimeout: 10000,   // 연결 타임아웃 (10초)
  idleTimeout: 60000          // 유휴 연결 타임아웃 (60초)
});

// 쿼리 실행
async function getUser(id) {
  const [rows] = await pool.execute(
    'SELECT * FROM users WHERE id = ?',
    [id]
  );
  return rows[0];
}
```

### 연결 풀 크기 계산

```
적정 연결 풀 크기 = ((코어 수 * 2) + 효과적인 디스크 수)

예: 4코어 CPU, 1개 디스크 → 풀 크기 = 10
```

## 캐싱 전략

### 쿼리 결과 캐싱

```javascript
const Redis = require('redis');
const redis = Redis.createClient();

async function getCachedUser(userId) {
  const cacheKey = `user:${userId}`;
  
  // 캐시 확인
  const cached = await redis.get(cacheKey);
  if (cached) {
    return JSON.parse(cached);
  }
  
  // DB 조회
  const user = await pool.execute(
    'SELECT * FROM users WHERE id = ?',
    [userId]
  );
  
  // 캐시 저장 (5분)
  await redis.setex(cacheKey, 300, JSON.stringify(user));
  
  return user;
}
```

## 모니터링

### 느린 쿼리 로그

**MySQL 설정:**
```sql
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL long_query_time = 1;  -- 1초 이상 쿼리 로깅
```

**로그 분석:**
```bash
# 느린 쿼리 상위 10개
mysqldumpslow -s t -t 10 /var/log/mysql/slow-query.log
```

### 성능 메트릭

```sql
-- MySQL 성능 통계
SHOW GLOBAL STATUS LIKE 'Threads_connected';
SHOW GLOBAL STATUS LIKE 'Questions';
SHOW GLOBAL STATUS LIKE 'Slow_queries';

-- PostgreSQL 통계
SELECT * FROM pg_stat_database;
SELECT * FROM pg_stat_user_tables;
```

## 파티셔닝

### 파티션 전략

```sql
-- Range 파티션 (날짜 기반)
CREATE TABLE orders (
    id INT,
    order_date DATE,
    customer_id INT,
    amount DECIMAL(10,2)
) PARTITION BY RANGE (YEAR(order_date)) (
    PARTITION p2022 VALUES LESS THAN (2023),
    PARTITION p2023 VALUES LESS THAN (2024),
    PARTITION p2024 VALUES LESS THAN (2025)
);

-- List 파티션 (지역 기반)
CREATE TABLE customers (
    id INT,
    name VARCHAR(100),
    region VARCHAR(50)
) PARTITION BY LIST COLUMNS(region) (
    PARTITION p_korea VALUES IN ('Seoul', 'Busan'),
    PARTITION p_japan VALUES IN ('Tokyo', 'Osaka')
);
```

## 참고

### 성능 튜닝 체크리스트

- [ ] 실행 계획 분석 완료
- [ ] 적절한 인덱스 생성
- [ ] SELECT * 제거
- [ ] 불필요한 JOIN 제거
- [ ] 연결 풀 설정 최적화
- [ ] 느린 쿼리 로그 모니터링
- [ ] 캐싱 전략 수립
- [ ] 파티셔닝 적용 (대용량)

### 도구

| 도구 | 용도 | DBMS |
|------|------|------|
| EXPLAIN | 실행 계획 분석 | 모든 DBMS |
| pt-query-digest | 느린 쿼리 분석 | MySQL |
| pg_stat_statements | 쿼리 통계 | PostgreSQL |
| Percona Monitoring | 성능 모니터링 | MySQL |
| pgBadger | 로그 분석 | PostgreSQL |

### 참고 자료
- [MySQL Performance Tuning](https://dev.mysql.com/doc/refman/8.0/en/optimization.html)
- [PostgreSQL Performance Tips](https://wiki.postgresql.org/wiki/Performance_Optimization)
- High Performance MySQL (Book)
