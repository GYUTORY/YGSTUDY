---
title: 데이터베이스 성능 튜닝 가이드
tags: [database, performance-tuning, query-optimization, indexing, connection-pool, benchmarking]
updated: 2024-09-14
---

# 데이터베이스 성능 튜닝 가이드 (Database Performance Tuning Guide)

## 📋 목차
1. [쿼리 최적화 및 실행 계획 분석](#쿼리-최적화-및-실행-계획-분석)
2. [인덱스 설계 및 최적화 전략](#인덱스-설계-및-최적화-전략)
3. [데이터베이스 파티셔닝 및 샤딩](#데이터베이스-파티셔닝-및-샤딩)
4. [연결 풀 관리 및 최적화](#연결-풀-관리-및-최적화)
5. [실제 성능 튜닝 사례 및 벤치마킹](#실제-성능-튜닝-사례-및-벤치마킹)

### 📌 통합된 기존 파일들
이 가이드는 다음 기존 파일들의 내용을 통합하여 더 체계적으로 정리한 것입니다:
- **RDBMS에서의 index**: 인덱스 종류, 설계 원칙, 모니터링 및 최적화
- **옵티마이저**: 쿼리 분석, 실행 계획 생성, 비용 기반 최적화
- **DB Proxy**: 연결 풀링, 자동 재연결, 성능 최적화
- **메시지 큐 및 분산 락**: 트랜잭션 최적화, 락 성능 최적화
- **데이터베이스 통합 테스트**: 성능 고려사항, 모니터링

---

## 쿼리 최적화 및 실행 계획 분석

### 1. 실행 계획 분석 기초

#### MySQL 실행 계획 분석
```sql
-- 기본 실행 계획 확인
EXPLAIN SELECT * FROM users WHERE email = 'user@example.com';

-- 상세한 실행 계획 확인
EXPLAIN FORMAT=JSON SELECT * FROM users WHERE email = 'user@example.com';

-- 실행 계획과 함께 실제 실행
EXPLAIN ANALYZE SELECT * FROM users WHERE email = 'user@example.com';
```

#### PostgreSQL 실행 계획 분석
```sql
-- 기본 실행 계획 확인
EXPLAIN SELECT * FROM users WHERE email = 'user@example.com';

-- 상세한 실행 계획 확인
EXPLAIN (ANALYZE, BUFFERS, FORMAT JSON) 
SELECT * FROM users WHERE email = 'user@example.com';

-- 실행 계획 캐싱
EXPLAIN (ANALYZE, BUFFERS, COSTS, VERBOSE, FORMAT JSON)
SELECT * FROM users WHERE email = 'user@example.com';
```

### 2. 실행 계획 해석

#### 주요 실행 계획 요소
```sql
-- 실행 계획 결과 해석 예시
EXPLAIN SELECT u.*, p.name as profile_name 
FROM users u 
JOIN profiles p ON u.id = p.user_id 
WHERE u.created_at > '2024-01-01';

-- 결과 해석:
-- 1. type: ALL (전체 테이블 스캔) vs index (인덱스 스캔)
-- 2. key: 사용된 인덱스
-- 3. rows: 예상 행 수
-- 4. Extra: 추가 정보 (Using index, Using temporary, Using filesort)
```

#### 성능 문제 진단
```javascript
class QueryAnalyzer {
  constructor() {
    this.slowQueries = [];
    this.queryStats = new Map();
  }

  // 느린 쿼리 감지
  analyzeSlowQuery(query, executionTime) {
    if (executionTime > 1000) { // 1초 이상
      this.slowQueries.push({
        query,
        executionTime,
        timestamp: new Date(),
        suggestions: this.generateSuggestions(query)
      });
    }
  }

  // 쿼리 최적화 제안
  generateSuggestions(query) {
    const suggestions = [];
    
    if (query.includes('SELECT *')) {
      suggestions.push('SELECT * 대신 필요한 컬럼만 선택하세요');
    }
    
    if (query.includes('ORDER BY') && !query.includes('LIMIT')) {
      suggestions.push('ORDER BY와 함께 LIMIT을 사용하세요');
    }
    
    if (query.includes('LIKE \'%')) {
      suggestions.push('LIKE \'%...\' 패턴은 인덱스를 사용할 수 없습니다');
    }
    
    return suggestions;
  }

  // 쿼리 통계 수집
  collectQueryStats(query, executionTime) {
    const normalizedQuery = this.normalizeQuery(query);
    
    if (!this.queryStats.has(normalizedQuery)) {
      this.queryStats.set(normalizedQuery, {
        count: 0,
        totalTime: 0,
        avgTime: 0,
        maxTime: 0
      });
    }
    
    const stats = this.queryStats.get(normalizedQuery);
    stats.count++;
    stats.totalTime += executionTime;
    stats.avgTime = stats.totalTime / stats.count;
    stats.maxTime = Math.max(stats.maxTime, executionTime);
  }

  // 쿼리 정규화 (매개변수 제거)
  normalizeQuery(query) {
    return query.replace(/\d+/g, '?')
                .replace(/'[^']*'/g, '?')
                .replace(/"[^"]*"/g, '?');
  }
}
```

### 3. 쿼리 최적화 기법

#### 인덱스 힌트 사용
```sql
-- MySQL 인덱스 힌트
SELECT * FROM users USE INDEX (idx_email) WHERE email = 'user@example.com';
SELECT * FROM users FORCE INDEX (idx_email) WHERE email = 'user@example.com';
SELECT * FROM users IGNORE INDEX (idx_old) WHERE email = 'user@example.com';

-- PostgreSQL 인덱스 힌트
SELECT * FROM users WHERE email = 'user@example.com';
-- PostgreSQL에서는 힌트 대신 통계 정보 업데이트
ANALYZE users;
```

#### 쿼리 재작성
```sql
-- ❌ 비효율적인 쿼리
SELECT * FROM users WHERE YEAR(created_at) = 2024;

-- ✅ 최적화된 쿼리
SELECT * FROM users WHERE created_at >= '2024-01-01' AND created_at < '2025-01-01';

-- ❌ 비효율적인 쿼리
SELECT * FROM users WHERE email LIKE '%@gmail.com';

-- ✅ 최적화된 쿼리 (가능한 경우)
SELECT * FROM users WHERE email LIKE 'user%@gmail.com';
```

#### 서브쿼리 최적화
```sql
-- ❌ 비효율적인 서브쿼리
SELECT * FROM users WHERE id IN (
  SELECT user_id FROM orders WHERE total_amount > 1000
);

-- ✅ 최적화된 JOIN
SELECT DISTINCT u.* FROM users u
JOIN orders o ON u.id = o.user_id
WHERE o.total_amount > 1000;

-- ❌ 비효율적인 EXISTS
SELECT * FROM users WHERE EXISTS (
  SELECT 1 FROM orders WHERE user_id = users.id AND total_amount > 1000
);

-- ✅ 최적화된 EXISTS (인덱스 활용)
SELECT * FROM users WHERE EXISTS (
  SELECT 1 FROM orders WHERE user_id = users.id AND total_amount > 1000
);
```

---

## 인덱스 설계 및 최적화 전략

### 1. 인덱스 종류 및 특성

#### B-Tree 인덱스
```sql
-- 단일 컬럼 인덱스
CREATE INDEX idx_email ON users(email);

-- 복합 인덱스
CREATE INDEX idx_user_status ON users(status, created_at);

-- 부분 인덱스 (PostgreSQL)
CREATE INDEX idx_active_users ON users(email) WHERE status = 'active';

-- 함수 기반 인덱스
CREATE INDEX idx_lower_email ON users(LOWER(email));
```

#### Hash 인덱스
```sql
-- MySQL Memory 엔진에서 사용
CREATE TABLE user_cache (
  id INT PRIMARY KEY,
  data VARCHAR(255)
) ENGINE=MEMORY;

CREATE INDEX idx_hash ON user_cache(id) USING HASH;
```

#### 전문 검색 인덱스
```sql
-- MySQL Full-Text 인덱스
CREATE FULLTEXT INDEX idx_content ON articles(title, content);

-- 전문 검색 쿼리
SELECT * FROM articles 
WHERE MATCH(title, content) AGAINST('database performance' IN NATURAL LANGUAGE MODE);
```

### 2. 인덱스 설계 원칙

#### 선택도 기반 인덱스 설계
```javascript
class IndexDesigner {
  constructor() {
    this.columnStats = new Map();
  }

  // 컬럼 선택도 계산
  calculateSelectivity(tableName, columnName) {
    // 실제로는 데이터베이스에서 통계 정보를 가져옴
    const totalRows = 1000000;
    const distinctValues = 100000;
    
    return distinctValues / totalRows; // 0.1 (10%)
  }

  // 인덱스 효율성 평가
  evaluateIndexEfficiency(tableName, columns) {
    const selectivities = columns.map(col => 
      this.calculateSelectivity(tableName, col)
    );
    
    // 선택도가 높을수록 좋은 인덱스
    const avgSelectivity = selectivities.reduce((a, b) => a + b, 0) / selectivities.length;
    
    return {
      efficiency: avgSelectivity,
      recommendation: avgSelectivity > 0.1 ? 'Good' : 'Poor'
    };
  }

  // 복합 인덱스 컬럼 순서 결정
  determineColumnOrder(tableName, columns) {
    // 1. 등호 조건이 있는 컬럼을 앞에 배치
    // 2. 선택도가 높은 컬럼을 앞에 배치
    // 3. 범위 검색이 있는 컬럼을 뒤에 배치
    
    return columns.sort((a, b) => {
      const selectivityA = this.calculateSelectivity(tableName, a);
      const selectivityB = this.calculateSelectivity(tableName, b);
      return selectivityB - selectivityA; // 내림차순
    });
  }
}
```

#### 인덱스 모니터링
```sql
-- MySQL 인덱스 사용 현황
SELECT 
  TABLE_NAME,
  INDEX_NAME,
  CARDINALITY,
  INDEX_TYPE,
  COMMENT
FROM information_schema.STATISTICS 
WHERE TABLE_SCHEMA = 'your_database'
ORDER BY TABLE_NAME, INDEX_NAME;

-- PostgreSQL 인덱스 사용 현황
SELECT 
  schemaname,
  tablename,
  indexname,
  idx_scan,
  idx_tup_read,
  idx_tup_fetch
FROM pg_stat_user_indexes
WHERE schemaname = 'public'
ORDER BY idx_scan DESC;

-- 사용되지 않는 인덱스 찾기
SELECT 
  schemaname,
  tablename,
  indexname,
  idx_scan
FROM pg_stat_user_indexes
WHERE idx_scan = 0
ORDER BY tablename;
```

### 3. 인덱스 최적화 전략

#### 인덱스 조각화 관리
```sql
-- MySQL 인덱스 조각화 확인
SELECT 
  TABLE_NAME,
  INDEX_NAME,
  CARDINALITY,
  SUB_PART,
  PACKED,
  NULLABLE,
  INDEX_TYPE
FROM information_schema.STATISTICS 
WHERE TABLE_SCHEMA = 'your_database';

-- 인덱스 재구성
OPTIMIZE TABLE users;

-- PostgreSQL 인덱스 재구성
REINDEX INDEX idx_email;
REINDEX TABLE users;
```

#### 인덱스 통계 업데이트
```sql
-- MySQL 통계 업데이트
ANALYZE TABLE users;

-- PostgreSQL 통계 업데이트
ANALYZE users;

-- 특정 컬럼 통계 업데이트
ANALYZE users (email, created_at);
```

---

## 데이터베이스 파티셔닝 및 샤딩

### 1. 파티셔닝 전략

#### 범위 기반 파티셔닝
```sql
-- 날짜 기반 파티셔닝
CREATE TABLE user_activities (
    id BIGINT,
    user_id BIGINT,
    activity_type VARCHAR(50),
    created_at TIMESTAMP,
    data JSONB
) PARTITION BY RANGE (created_at);

-- 월별 파티션 생성
CREATE TABLE user_activities_2024_01 PARTITION OF user_activities
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

CREATE TABLE user_activities_2024_02 PARTITION OF user_activities
    FOR VALUES FROM ('2024-02-01') TO ('2024-03-01');

-- 파티션 자동 생성 함수
CREATE OR REPLACE FUNCTION create_monthly_partition(table_name text, start_date date)
RETURNS void AS $$
DECLARE
    partition_name text;
    end_date date;
BEGIN
    partition_name := table_name || '_' || to_char(start_date, 'YYYY_MM');
    end_date := start_date + interval '1 month';
    
    EXECUTE format('CREATE TABLE %I PARTITION OF %I FOR VALUES FROM (%L) TO (%L)',
                   partition_name, table_name, start_date, end_date);
END;
$$ LANGUAGE plpgsql;
```

#### 해시 기반 파티셔닝
```sql
-- 사용자 ID 기반 해시 파티셔닝
CREATE TABLE users (
    id BIGINT,
    username VARCHAR(50),
    email VARCHAR(100),
    created_at TIMESTAMP
) PARTITION BY HASH (id);

-- 4개 파티션 생성
CREATE TABLE users_0 PARTITION OF users
    FOR VALUES WITH (modulus 4, remainder 0);

CREATE TABLE users_1 PARTITION OF users
    FOR VALUES WITH (modulus 4, remainder 1);

CREATE TABLE users_2 PARTITION OF users
    FOR VALUES WITH (modulus 4, remainder 2);

CREATE TABLE users_3 PARTITION OF users
    FOR VALUES WITH (modulus 4, remainder 3);
```

### 2. 샤딩 구현

#### 수평 샤딩
```javascript
class HorizontalSharding {
  constructor(shardCount) {
    this.shardCount = shardCount;
    this.shards = new Array(shardCount).fill(null).map(() => ({
      connection: null,
      data: new Map()
    }));
  }

  // 해시 기반 샤딩
  getShardId(key) {
    const hash = this.hashFunction(key);
    return hash % this.shardCount;
  }

  hashFunction(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return Math.abs(hash);
  }

  async insert(key, value) {
    const shardId = this.getShardId(key);
    const shard = this.shards[shardId];
    
    shard.data.set(key, value);
    console.log(`Inserted ${key} into shard ${shardId}`);
  }

  async get(key) {
    const shardId = this.getShardId(key);
    const shard = this.shards[shardId];
    
    return shard.data.get(key);
  }

  // 크로스 샤드 쿼리
  async crossShardQuery(predicate) {
    const results = [];
    
    for (let i = 0; i < this.shardCount; i++) {
      const shard = this.shards[i];
      const shardResults = Array.from(shard.data.values())
        .filter(predicate);
      results.push(...shardResults);
    }
    
    return results;
  }
}
```

#### 수직 샤딩
```javascript
class VerticalSharding {
  constructor() {
    this.shards = {
      userProfile: new Map(),    // 사용자 프로필 정보
      userActivity: new Map(),   // 사용자 활동 로그
      userSettings: new Map()    // 사용자 설정
    };
  }

  async insertUserProfile(userId, profile) {
    this.shards.userProfile.set(userId, profile);
  }

  async insertUserActivity(userId, activity) {
    if (!this.shards.userActivity.has(userId)) {
      this.shards.userActivity.set(userId, []);
    }
    this.shards.userActivity.get(userId).push(activity);
  }

  async insertUserSettings(userId, settings) {
    this.shards.userSettings.set(userId, settings);
  }

  async getUserData(userId) {
    const profile = this.shards.userProfile.get(userId);
    const activities = this.shards.userActivity.get(userId) || [];
    const settings = this.shards.userSettings.get(userId);

    return {
      profile,
      activities,
      settings
    };
  }
}
```

---

## 연결 풀 관리 및 최적화

### 1. 연결 풀 설정

#### Node.js 연결 풀 설정
```javascript
const mysql = require('mysql2/promise');

class DatabaseConnectionPool {
  constructor() {
    this.pool = mysql.createPool({
      host: process.env.DB_HOST,
      user: process.env.DB_USER,
      password: process.env.DB_PASSWORD,
      database: process.env.DB_NAME,
      
      // 연결 풀 설정
      connectionLimit: 20,           // 최대 연결 수
      acquireTimeoutMillis: 5000,    // 연결 획득 타임아웃
      timeout: 30000,                // 쿼리 타임아웃
      idleTimeoutMillis: 300000,     // 유휴 연결 타임아웃 (5분)
      
      // 재연결 설정
      reconnect: true,
      maxReconnects: 3,
      reconnectDelay: 1000,
      
      // 성능 설정
      multipleStatements: false,
      dateStrings: true,
      supportBigNumbers: true,
      bigNumberStrings: true
    });
    
    this.setupEventHandlers();
  }

  setupEventHandlers() {
    this.pool.on('connection', (connection) => {
      console.log('New connection established:', connection.threadId);
    });

    this.pool.on('acquire', (connection) => {
      console.log('Connection acquired:', connection.threadId);
    });

    this.pool.on('release', (connection) => {
      console.log('Connection released:', connection.threadId);
    });

    this.pool.on('error', (err) => {
      console.error('Pool error:', err);
    });
  }

  async query(sql, params = []) {
    let connection;
    try {
      connection = await this.pool.getConnection();
      const [rows] = await connection.execute(sql, params);
      return rows;
    } catch (error) {
      console.error('Query error:', error);
      throw error;
    } finally {
      if (connection) {
        connection.release();
      }
    }
  }

  async withTransaction(operation) {
    let connection;
    try {
      connection = await this.pool.getConnection();
      await connection.beginTransaction();
      
      const result = await operation(connection);
      
      await connection.commit();
      return result;
    } catch (error) {
      if (connection) {
        await connection.rollback();
      }
      throw error;
    } finally {
      if (connection) {
        connection.release();
      }
    }
  }

  // 연결 풀 상태 모니터링
  getPoolStatus() {
    return {
      totalConnections: this.pool._allConnections.length,
      freeConnections: this.pool._freeConnections.length,
      queuedRequests: this.pool._connectionQueue.length
    };
  }
}
```

#### PostgreSQL 연결 풀 설정
```javascript
const { Pool } = require('pg');

class PostgreSQLConnectionPool {
  constructor() {
    this.pool = new Pool({
      host: process.env.DB_HOST,
      port: process.env.DB_PORT,
      database: process.env.DB_NAME,
      user: process.env.DB_USER,
      password: process.env.DB_PASSWORD,
      
      // 연결 풀 설정
      max: 20,                    // 최대 연결 수
      min: 5,                     // 최소 연결 수
      idleTimeoutMillis: 30000,   // 유휴 연결 타임아웃
      connectionTimeoutMillis: 5000, // 연결 타임아웃
      
      // 성능 설정
      statement_timeout: 30000,   // 쿼리 타임아웃
      query_timeout: 30000,       // 쿼리 타임아웃
      application_name: 'myapp',  // 애플리케이션 이름
      
      // SSL 설정
      ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false
    });
    
    this.setupEventHandlers();
  }

  setupEventHandlers() {
    this.pool.on('connect', (client) => {
      console.log('New client connected');
    });

    this.pool.on('error', (err, client) => {
      console.error('Unexpected error on idle client', err);
    });
  }

  async query(text, params = []) {
    const start = Date.now();
    try {
      const result = await this.pool.query(text, params);
      const duration = Date.now() - start;
      console.log('Query executed', { text, duration, rows: result.rowCount });
      return result;
    } catch (error) {
      console.error('Query error:', error);
      throw error;
    }
  }
}
```

### 2. 연결 풀 최적화

#### 동적 연결 풀 크기 조정
```javascript
class AdaptiveConnectionPool {
  constructor() {
    this.pool = null;
    this.metrics = {
      activeConnections: 0,
      queuedRequests: 0,
      avgResponseTime: 0,
      errorRate: 0
    };
    
    this.startMonitoring();
  }

  startMonitoring() {
    setInterval(() => {
      this.adjustPoolSize();
    }, 60000); // 1분마다
  }

  adjustPoolSize() {
    const { activeConnections, queuedRequests, avgResponseTime, errorRate } = this.metrics;
    
    // 큐에 대기 중인 요청이 많으면 연결 수 증가
    if (queuedRequests > 10) {
      this.increasePoolSize();
    }
    
    // 평균 응답 시간이 길면 연결 수 증가
    if (avgResponseTime > 1000) {
      this.increasePoolSize();
    }
    
    // 에러율이 높으면 연결 수 감소
    if (errorRate > 0.05) {
      this.decreasePoolSize();
    }
    
    // 유휴 연결이 많으면 연결 수 감소
    if (activeConnections < this.pool.options.connectionLimit * 0.3) {
      this.decreasePoolSize();
    }
  }

  increasePoolSize() {
    const currentLimit = this.pool.options.connectionLimit;
    const newLimit = Math.min(currentLimit + 5, 50); // 최대 50개
    
    if (newLimit > currentLimit) {
      this.pool.options.connectionLimit = newLimit;
      console.log(`Pool size increased to ${newLimit}`);
    }
  }

  decreasePoolSize() {
    const currentLimit = this.pool.options.connectionLimit;
    const newLimit = Math.max(currentLimit - 2, 5); // 최소 5개
    
    if (newLimit < currentLimit) {
      this.pool.options.connectionLimit = newLimit;
      console.log(`Pool size decreased to ${newLimit}`);
    }
  }
}
```

#### 연결 풀 모니터링
```javascript
class ConnectionPoolMonitor {
  constructor(pool) {
    this.pool = pool;
    this.metrics = {
      totalConnections: 0,
      activeConnections: 0,
      idleConnections: 0,
      queuedRequests: 0,
      totalQueries: 0,
      failedQueries: 0,
      avgQueryTime: 0
    };
    
    this.startMonitoring();
  }

  startMonitoring() {
    setInterval(() => {
      this.collectMetrics();
      this.logMetrics();
    }, 10000); // 10초마다
  }

  collectMetrics() {
    this.metrics.totalConnections = this.pool._allConnections.length;
    this.metrics.activeConnections = this.pool._allConnections.filter(c => c._inUse).length;
    this.metrics.idleConnections = this.pool._freeConnections.length;
    this.metrics.queuedRequests = this.pool._connectionQueue.length;
  }

  logMetrics() {
    console.log('Connection Pool Metrics:', {
      total: this.metrics.totalConnections,
      active: this.metrics.activeConnections,
      idle: this.metrics.idleConnections,
      queued: this.metrics.queuedRequests,
      utilization: (this.metrics.activeConnections / this.metrics.totalConnections * 100).toFixed(2) + '%'
    });
  }

  // 알림 설정
  checkThresholds() {
    const utilization = this.metrics.activeConnections / this.metrics.totalConnections;
    
    if (utilization > 0.8) {
      console.warn('High connection pool utilization:', utilization);
    }
    
    if (this.metrics.queuedRequests > 20) {
      console.warn('High queued requests:', this.metrics.queuedRequests);
    }
  }
}
```

---

## 실제 성능 튜닝 사례 및 벤치마킹

### 1. 성능 튜닝 사례

#### 사례 1: 느린 사용자 검색 쿼리 최적화
```sql
-- ❌ 최적화 전 (2.5초)
SELECT u.*, p.name as profile_name 
FROM users u 
LEFT JOIN profiles p ON u.id = p.user_id 
WHERE u.email LIKE '%@gmail.com' 
ORDER BY u.created_at DESC 
LIMIT 20;

-- ✅ 최적화 후 (0.1초)
-- 1. 인덱스 생성
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_created_at ON users(created_at);

-- 2. 쿼리 최적화
SELECT u.id, u.email, u.created_at, p.name as profile_name
FROM users u 
LEFT JOIN profiles p ON u.id = p.user_id 
WHERE u.email LIKE 'user%@gmail.com'  -- 앞쪽 와일드카드 제거
ORDER BY u.created_at DESC 
LIMIT 20;
```

#### 사례 2: 대량 데이터 삽입 최적화
```javascript
// ❌ 최적화 전 (1000개 삽입에 10초)
async function insertUsersSlow(users) {
  for (const user of users) {
    await db.query('INSERT INTO users (name, email) VALUES (?, ?)', [user.name, user.email]);
  }
}

// ✅ 최적화 후 (1000개 삽입에 0.5초)
async function insertUsersFast(users) {
  const values = users.map(user => [user.name, user.email]);
  const placeholders = users.map(() => '(?, ?)').join(', ');
  
  await db.query(`INSERT INTO users (name, email) VALUES ${placeholders}`, values.flat());
}

// ✅ 배치 삽입 최적화
async function insertUsersBatch(users, batchSize = 1000) {
  for (let i = 0; i < users.length; i += batchSize) {
    const batch = users.slice(i, i + batchSize);
    await insertUsersFast(batch);
  }
}
```

#### 사례 3: 복잡한 조인 쿼리 최적화
```sql
-- ❌ 최적화 전 (5초)
SELECT u.name, u.email, COUNT(o.id) as order_count, SUM(o.total) as total_spent
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
LEFT JOIN order_items oi ON o.id = oi.order_id
WHERE u.created_at > '2024-01-01'
GROUP BY u.id, u.name, u.email
HAVING COUNT(o.id) > 5
ORDER BY total_spent DESC
LIMIT 100;

-- ✅ 최적화 후 (0.3초)
-- 1. 인덱스 생성
CREATE INDEX idx_users_created_at ON users(created_at);
CREATE INDEX idx_orders_user_id ON orders(user_id);
CREATE INDEX idx_orders_total ON orders(total);

-- 2. 쿼리 최적화 (서브쿼리 활용)
SELECT u.name, u.email, o.order_count, o.total_spent
FROM users u
JOIN (
  SELECT user_id, COUNT(*) as order_count, SUM(total) as total_spent
  FROM orders
  WHERE created_at > '2024-01-01'
  GROUP BY user_id
  HAVING COUNT(*) > 5
) o ON u.id = o.user_id
WHERE u.created_at > '2024-01-01'
ORDER BY o.total_spent DESC
LIMIT 100;
```

### 2. 벤치마킹 도구

#### 성능 벤치마킹 클래스
```javascript
class DatabaseBenchmark {
  constructor() {
    this.results = [];
    this.metrics = {
      totalQueries: 0,
      totalTime: 0,
      avgTime: 0,
      minTime: Infinity,
      maxTime: 0,
      errorCount: 0
    };
  }

  // 단일 쿼리 벤치마크
  async benchmarkQuery(name, query, params = [], iterations = 100) {
    console.log(`Benchmarking: ${name}`);
    
    const times = [];
    let errors = 0;
    
    for (let i = 0; i < iterations; i++) {
      const start = process.hrtime.bigint();
      
      try {
        await this.executeQuery(query, params);
        const end = process.hrtime.bigint();
        const duration = Number(end - start) / 1000000; // ms
        times.push(duration);
      } catch (error) {
        errors++;
        console.error(`Query error: ${error.message}`);
      }
    }
    
    const result = this.calculateStats(times, errors, iterations);
    this.results.push({ name, ...result });
    
    console.log(`Results for ${name}:`, result);
    return result;
  }

  // 동시성 벤치마크
  async benchmarkConcurrency(name, query, params = [], concurrency = 10, duration = 10000) {
    console.log(`Concurrency benchmark: ${name}`);
    
    const startTime = Date.now();
    const results = [];
    const promises = [];
    
    for (let i = 0; i < concurrency; i++) {
      promises.push(this.runConcurrentQueries(query, params, startTime, duration));
    }
    
    const allResults = await Promise.all(promises);
    const combinedResults = allResults.flat();
    
    const result = this.calculateStats(combinedResults, 0, combinedResults.length);
    this.results.push({ name: `${name}_concurrent`, ...result });
    
    console.log(`Concurrency results for ${name}:`, result);
    return result;
  }

  async runConcurrentQueries(query, params, startTime, duration) {
    const results = [];
    
    while (Date.now() - startTime < duration) {
      const start = process.hrtime.bigint();
      
      try {
        await this.executeQuery(query, params);
        const end = process.hrtime.bigint();
        const queryTime = Number(end - start) / 1000000;
        results.push(queryTime);
      } catch (error) {
        // 에러는 무시하고 계속
      }
    }
    
    return results;
  }

  calculateStats(times, errors, total) {
    if (times.length === 0) {
      return {
        avgTime: 0,
        minTime: 0,
        maxTime: 0,
        p95Time: 0,
        p99Time: 0,
        errorRate: errors / total,
        throughput: 0
      };
    }
    
    const sortedTimes = times.sort((a, b) => a - b);
    const avgTime = times.reduce((a, b) => a + b, 0) / times.length;
    const minTime = Math.min(...times);
    const maxTime = Math.max(...times);
    const p95Time = sortedTimes[Math.floor(sortedTimes.length * 0.95)];
    const p99Time = sortedTimes[Math.floor(sortedTimes.length * 0.99)];
    const errorRate = errors / total;
    const throughput = times.length / (times.reduce((a, b) => a + b, 0) / 1000); // queries per second
    
    return {
      avgTime: Math.round(avgTime * 100) / 100,
      minTime: Math.round(minTime * 100) / 100,
      maxTime: Math.round(maxTime * 100) / 100,
      p95Time: Math.round(p95Time * 100) / 100,
      p99Time: Math.round(p99Time * 100) / 100,
      errorRate: Math.round(errorRate * 10000) / 100, // percentage
      throughput: Math.round(throughput * 100) / 100
    };
  }

  // 결과 비교
  compareResults() {
    console.log('\n=== Benchmark Results Comparison ===');
    
    this.results.forEach(result => {
      console.log(`\n${result.name}:`);
      console.log(`  Average Time: ${result.avgTime}ms`);
      console.log(`  Min Time: ${result.minTime}ms`);
      console.log(`  Max Time: ${result.maxTime}ms`);
      console.log(`  95th Percentile: ${result.p95Time}ms`);
      console.log(`  99th Percentile: ${result.p99Time}ms`);
      console.log(`  Error Rate: ${result.errorRate}%`);
      console.log(`  Throughput: ${result.throughput} queries/sec`);
    });
  }

  async executeQuery(query, params) {
    // 실제 데이터베이스 쿼리 실행
    // 이 부분은 실제 데이터베이스 연결에 맞게 구현
    throw new Error('executeQuery method must be implemented');
  }
}
```

#### 실제 벤치마킹 예시
```javascript
// 벤치마킹 실행 예시
async function runBenchmarks() {
  const benchmark = new DatabaseBenchmark();
  
  // 단일 쿼리 벤치마크
  await benchmark.benchmarkQuery(
    'Simple SELECT',
    'SELECT * FROM users WHERE id = ?',
    [1],
    1000
  );
  
  await benchmark.benchmarkQuery(
    'Complex JOIN',
    `SELECT u.name, COUNT(o.id) as order_count 
     FROM users u 
     LEFT JOIN orders o ON u.id = o.user_id 
     GROUP BY u.id, u.name 
     LIMIT 100`,
    [],
    100
  );
  
  // 동시성 벤치마크
  await benchmark.benchmarkConcurrency(
    'Concurrent SELECT',
    'SELECT * FROM users WHERE email = ?',
    ['test@example.com'],
    20,
    10000
  );
  
  // 결과 비교
  benchmark.compareResults();
}

runBenchmarks().catch(console.error);
```

### 3. 성능 모니터링 대시보드

```javascript
class PerformanceDashboard {
  constructor() {
    this.metrics = {
      queries: [],
      connections: [],
      errors: []
    };
    
    this.startMonitoring();
  }

  startMonitoring() {
    setInterval(() => {
      this.collectMetrics();
      this.updateDashboard();
    }, 5000); // 5초마다
  }

  collectMetrics() {
    // 쿼리 성능 메트릭 수집
    const queryMetrics = {
      timestamp: new Date(),
      avgResponseTime: this.getAverageResponseTime(),
      totalQueries: this.getTotalQueries(),
      slowQueries: this.getSlowQueries(),
      errorRate: this.getErrorRate()
    };
    
    this.metrics.queries.push(queryMetrics);
    
    // 연결 풀 메트릭 수집
    const connectionMetrics = {
      timestamp: new Date(),
      activeConnections: this.getActiveConnections(),
      idleConnections: this.getIdleConnections(),
      queuedRequests: this.getQueuedRequests()
    };
    
    this.metrics.connections.push(connectionMetrics);
  }

  updateDashboard() {
    console.log('\n=== Performance Dashboard ===');
    console.log(`Time: ${new Date().toLocaleTimeString()}`);
    
    const latestQuery = this.metrics.queries[this.metrics.queries.length - 1];
    const latestConnection = this.metrics.connections[this.metrics.connections.length - 1];
    
    console.log('\nQuery Performance:');
    console.log(`  Average Response Time: ${latestQuery.avgResponseTime}ms`);
    console.log(`  Total Queries: ${latestQuery.totalQueries}`);
    console.log(`  Slow Queries: ${latestQuery.slowQueries}`);
    console.log(`  Error Rate: ${latestQuery.errorRate}%`);
    
    console.log('\nConnection Pool:');
    console.log(`  Active Connections: ${latestConnection.activeConnections}`);
    console.log(`  Idle Connections: ${latestConnection.idleConnections}`);
    console.log(`  Queued Requests: ${latestConnection.queuedRequests}`);
    
    // 알림 체크
    this.checkAlerts(latestQuery, latestConnection);
  }

  checkAlerts(queryMetrics, connectionMetrics) {
    if (queryMetrics.avgResponseTime > 1000) {
      console.warn('⚠️  High average response time detected!');
    }
    
    if (queryMetrics.errorRate > 5) {
      console.warn('⚠️  High error rate detected!');
    }
    
    if (connectionMetrics.queuedRequests > 20) {
      console.warn('⚠️  High queued requests detected!');
    }
  }

  // 실제 구현은 데이터베이스 연결에 맞게 수정
  getAverageResponseTime() { return Math.random() * 100; }
  getTotalQueries() { return Math.floor(Math.random() * 1000); }
  getSlowQueries() { return Math.floor(Math.random() * 10); }
  getErrorRate() { return Math.random() * 2; }
  getActiveConnections() { return Math.floor(Math.random() * 20); }
  getIdleConnections() { return Math.floor(Math.random() * 10); }
  getQueuedRequests() { return Math.floor(Math.random() * 5); }
}
```

---

## 결론

데이터베이스 성능 튜닝은 시스템의 전반적인 성능에 직접적인 영향을 미치는 중요한 작업입니다.

### 핵심 원칙 요약

1. **쿼리 최적화**: 실행 계획 분석을 통한 효율적인 쿼리 작성
2. **인덱스 설계**: 선택도 기반의 적절한 인덱스 설계 및 관리
3. **파티셔닝/샤딩**: 대용량 데이터 처리를 위한 분산 전략
4. **연결 풀 최적화**: 효율적인 연결 관리 및 모니터링
5. **지속적인 모니터링**: 성능 지표 추적 및 최적화

### 실무 적용 가이드

- **개발 단계**: 쿼리 최적화 및 인덱스 설계에 집중
- **테스트 단계**: 벤치마킹을 통한 성능 검증
- **운영 단계**: 모니터링 및 지속적인 튜닝

이러한 원칙들을 바탕으로 데이터베이스 성능을 최적화하여 안정적이고 확장 가능한 시스템을 구축하세요.

