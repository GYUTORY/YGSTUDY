---
title: ë°ì´í„°ë² ì´ìŠ¤ ì„±ëŠ¥ íŠœë‹ ê°€ì´ë“œ
tags: [database, performance-tuning, query-optimization, indexing, connection-pool, benchmarking]
updated: 2024-09-14
---

# ë°ì´í„°ë² ì´ìŠ¤ ì„±ëŠ¥ íŠœë‹ ê°€ì´ë“œ (Database Performance Tuning Guide)

## ğŸ“‹ ëª©ì°¨
1. [ì¿¼ë¦¬ ìµœì í™” ë° ì‹¤í–‰ ê³„íš ë¶„ì„](#ì¿¼ë¦¬-ìµœì í™”-ë°-ì‹¤í–‰-ê³„íš-ë¶„ì„)
2. [ì¸ë±ìŠ¤ ì„¤ê³„ ë° ìµœì í™” ì „ëµ](#ì¸ë±ìŠ¤-ì„¤ê³„-ë°-ìµœì í™”-ì „ëµ)
3. [ë°ì´í„°ë² ì´ìŠ¤ íŒŒí‹°ì…”ë‹ ë° ìƒ¤ë”©](#ë°ì´í„°ë² ì´ìŠ¤-íŒŒí‹°ì…”ë‹-ë°-ìƒ¤ë”©)
4. [ì—°ê²° í’€ ê´€ë¦¬ ë° ìµœì í™”](#ì—°ê²°-í’€-ê´€ë¦¬-ë°-ìµœì í™”)
5. [ì‹¤ì œ ì„±ëŠ¥ íŠœë‹ ì‚¬ë¡€ ë° ë²¤ì¹˜ë§ˆí‚¹](#ì‹¤ì œ-ì„±ëŠ¥-íŠœë‹-ì‚¬ë¡€-ë°-ë²¤ì¹˜ë§ˆí‚¹)

### ğŸ“Œ í†µí•©ëœ ê¸°ì¡´ íŒŒì¼ë“¤
ì´ ê°€ì´ë“œëŠ” ë‹¤ìŒ ê¸°ì¡´ íŒŒì¼ë“¤ì˜ ë‚´ìš©ì„ í†µí•©í•˜ì—¬ ë” ì²´ê³„ì ìœ¼ë¡œ ì •ë¦¬í•œ ê²ƒì…ë‹ˆë‹¤:
- **RDBMSì—ì„œì˜ index**: ì¸ë±ìŠ¤ ì¢…ë¥˜, ì„¤ê³„ ì›ì¹™, ëª¨ë‹ˆí„°ë§ ë° ìµœì í™”
- **ì˜µí‹°ë§ˆì´ì €**: ì¿¼ë¦¬ ë¶„ì„, ì‹¤í–‰ ê³„íš ìƒì„±, ë¹„ìš© ê¸°ë°˜ ìµœì í™”
- **DB Proxy**: ì—°ê²° í’€ë§, ìë™ ì¬ì—°ê²°, ì„±ëŠ¥ ìµœì í™”
- **ë©”ì‹œì§€ í ë° ë¶„ì‚° ë½**: íŠ¸ëœì­ì…˜ ìµœì í™”, ë½ ì„±ëŠ¥ ìµœì í™”
- **ë°ì´í„°ë² ì´ìŠ¤ í†µí•© í…ŒìŠ¤íŠ¸**: ì„±ëŠ¥ ê³ ë ¤ì‚¬í•­, ëª¨ë‹ˆí„°ë§

---

## ì¿¼ë¦¬ ìµœì í™” ë° ì‹¤í–‰ ê³„íš ë¶„ì„

### 1. ì‹¤í–‰ ê³„íš ë¶„ì„ ê¸°ì´ˆ

#### MySQL ì‹¤í–‰ ê³„íš ë¶„ì„
```sql
-- ê¸°ë³¸ ì‹¤í–‰ ê³„íš í™•ì¸
EXPLAIN SELECT * FROM users WHERE email = 'user@example.com';

-- ìƒì„¸í•œ ì‹¤í–‰ ê³„íš í™•ì¸
EXPLAIN FORMAT=JSON SELECT * FROM users WHERE email = 'user@example.com';

-- ì‹¤í–‰ ê³„íšê³¼ í•¨ê»˜ ì‹¤ì œ ì‹¤í–‰
EXPLAIN ANALYZE SELECT * FROM users WHERE email = 'user@example.com';
```

#### PostgreSQL ì‹¤í–‰ ê³„íš ë¶„ì„
```sql
-- ê¸°ë³¸ ì‹¤í–‰ ê³„íš í™•ì¸
EXPLAIN SELECT * FROM users WHERE email = 'user@example.com';

-- ìƒì„¸í•œ ì‹¤í–‰ ê³„íš í™•ì¸
EXPLAIN (ANALYZE, BUFFERS, FORMAT JSON) 
SELECT * FROM users WHERE email = 'user@example.com';

-- ì‹¤í–‰ ê³„íš ìºì‹±
EXPLAIN (ANALYZE, BUFFERS, COSTS, VERBOSE, FORMAT JSON)
SELECT * FROM users WHERE email = 'user@example.com';
```

### 2. ì‹¤í–‰ ê³„íš í•´ì„

#### ì£¼ìš” ì‹¤í–‰ ê³„íš ìš”ì†Œ
```sql
-- ì‹¤í–‰ ê³„íš ê²°ê³¼ í•´ì„ ì˜ˆì‹œ
EXPLAIN SELECT u.*, p.name as profile_name 
FROM users u 
JOIN profiles p ON u.id = p.user_id 
WHERE u.created_at > '2024-01-01';

-- ê²°ê³¼ í•´ì„:
-- 1. type: ALL (ì „ì²´ í…Œì´ë¸” ìŠ¤ìº”) vs index (ì¸ë±ìŠ¤ ìŠ¤ìº”)
-- 2. key: ì‚¬ìš©ëœ ì¸ë±ìŠ¤
-- 3. rows: ì˜ˆìƒ í–‰ ìˆ˜
-- 4. Extra: ì¶”ê°€ ì •ë³´ (Using index, Using temporary, Using filesort)
```

#### ì„±ëŠ¥ ë¬¸ì œ ì§„ë‹¨
```javascript
class QueryAnalyzer {
  constructor() {
    this.slowQueries = [];
    this.queryStats = new Map();
  }

  // ëŠë¦° ì¿¼ë¦¬ ê°ì§€
  analyzeSlowQuery(query, executionTime) {
    if (executionTime > 1000) { // 1ì´ˆ ì´ìƒ
      this.slowQueries.push({
        query,
        executionTime,
        timestamp: new Date(),
        suggestions: this.generateSuggestions(query)
      });
    }
  }

  // ì¿¼ë¦¬ ìµœì í™” ì œì•ˆ
  generateSuggestions(query) {
    const suggestions = [];
    
    if (query.includes('SELECT *')) {
      suggestions.push('SELECT * ëŒ€ì‹  í•„ìš”í•œ ì»¬ëŸ¼ë§Œ ì„ íƒí•˜ì„¸ìš”');
    }
    
    if (query.includes('ORDER BY') && !query.includes('LIMIT')) {
      suggestions.push('ORDER BYì™€ í•¨ê»˜ LIMITì„ ì‚¬ìš©í•˜ì„¸ìš”');
    }
    
    if (query.includes('LIKE \'%')) {
      suggestions.push('LIKE \'%...\' íŒ¨í„´ì€ ì¸ë±ìŠ¤ë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
    }
    
    return suggestions;
  }

  // ì¿¼ë¦¬ í†µê³„ ìˆ˜ì§‘
  collectQueryStats(query, executionTime) {
    const normalizedQuery = this.normalizeQuery(query);
    
    if (!this.queryStats.has(normalizedQuery)) {
      this.queryStats.set(normalizedQuery, {
        count: 0,
        totalTime: 0,
        avgTime: 0,
        maxTime: 0
      });
    }
    
    const stats = this.queryStats.get(normalizedQuery);
    stats.count++;
    stats.totalTime += executionTime;
    stats.avgTime = stats.totalTime / stats.count;
    stats.maxTime = Math.max(stats.maxTime, executionTime);
  }

  // ì¿¼ë¦¬ ì •ê·œí™” (ë§¤ê°œë³€ìˆ˜ ì œê±°)
  normalizeQuery(query) {
    return query.replace(/\d+/g, '?')
                .replace(/'[^']*'/g, '?')
                .replace(/"[^"]*"/g, '?');
  }
}
```

### 3. ì¿¼ë¦¬ ìµœì í™” ê¸°ë²•

#### ì¸ë±ìŠ¤ íŒíŠ¸ ì‚¬ìš©
```sql
-- MySQL ì¸ë±ìŠ¤ íŒíŠ¸
SELECT * FROM users USE INDEX (idx_email) WHERE email = 'user@example.com';
SELECT * FROM users FORCE INDEX (idx_email) WHERE email = 'user@example.com';
SELECT * FROM users IGNORE INDEX (idx_old) WHERE email = 'user@example.com';

-- PostgreSQL ì¸ë±ìŠ¤ íŒíŠ¸
SELECT * FROM users WHERE email = 'user@example.com';
-- PostgreSQLì—ì„œëŠ” íŒíŠ¸ ëŒ€ì‹  í†µê³„ ì •ë³´ ì—…ë°ì´íŠ¸
ANALYZE users;
```

#### ì¿¼ë¦¬ ì¬ì‘ì„±
```sql
-- âŒ ë¹„íš¨ìœ¨ì ì¸ ì¿¼ë¦¬
SELECT * FROM users WHERE YEAR(created_at) = 2024;

-- âœ… ìµœì í™”ëœ ì¿¼ë¦¬
SELECT * FROM users WHERE created_at >= '2024-01-01' AND created_at < '2025-01-01';

-- âŒ ë¹„íš¨ìœ¨ì ì¸ ì¿¼ë¦¬
SELECT * FROM users WHERE email LIKE '%@gmail.com';

-- âœ… ìµœì í™”ëœ ì¿¼ë¦¬ (ê°€ëŠ¥í•œ ê²½ìš°)
SELECT * FROM users WHERE email LIKE 'user%@gmail.com';
```

#### ì„œë¸Œì¿¼ë¦¬ ìµœì í™”
```sql
-- âŒ ë¹„íš¨ìœ¨ì ì¸ ì„œë¸Œì¿¼ë¦¬
SELECT * FROM users WHERE id IN (
  SELECT user_id FROM orders WHERE total_amount > 1000
);

-- âœ… ìµœì í™”ëœ JOIN
SELECT DISTINCT u.* FROM users u
JOIN orders o ON u.id = o.user_id
WHERE o.total_amount > 1000;

-- âŒ ë¹„íš¨ìœ¨ì ì¸ EXISTS
SELECT * FROM users WHERE EXISTS (
  SELECT 1 FROM orders WHERE user_id = users.id AND total_amount > 1000
);

-- âœ… ìµœì í™”ëœ EXISTS (ì¸ë±ìŠ¤ í™œìš©)
SELECT * FROM users WHERE EXISTS (
  SELECT 1 FROM orders WHERE user_id = users.id AND total_amount > 1000
);
```

---

## ì¸ë±ìŠ¤ ì„¤ê³„ ë° ìµœì í™” ì „ëµ

### 1. ì¸ë±ìŠ¤ ì¢…ë¥˜ ë° íŠ¹ì„±

#### B-Tree ì¸ë±ìŠ¤
```sql
-- ë‹¨ì¼ ì»¬ëŸ¼ ì¸ë±ìŠ¤
CREATE INDEX idx_email ON users(email);

-- ë³µí•© ì¸ë±ìŠ¤
CREATE INDEX idx_user_status ON users(status, created_at);

-- ë¶€ë¶„ ì¸ë±ìŠ¤ (PostgreSQL)
CREATE INDEX idx_active_users ON users(email) WHERE status = 'active';

-- í•¨ìˆ˜ ê¸°ë°˜ ì¸ë±ìŠ¤
CREATE INDEX idx_lower_email ON users(LOWER(email));
```

#### Hash ì¸ë±ìŠ¤
```sql
-- MySQL Memory ì—”ì§„ì—ì„œ ì‚¬ìš©
CREATE TABLE user_cache (
  id INT PRIMARY KEY,
  data VARCHAR(255)
) ENGINE=MEMORY;

CREATE INDEX idx_hash ON user_cache(id) USING HASH;
```

#### ì „ë¬¸ ê²€ìƒ‰ ì¸ë±ìŠ¤
```sql
-- MySQL Full-Text ì¸ë±ìŠ¤
CREATE FULLTEXT INDEX idx_content ON articles(title, content);

-- ì „ë¬¸ ê²€ìƒ‰ ì¿¼ë¦¬
SELECT * FROM articles 
WHERE MATCH(title, content) AGAINST('database performance' IN NATURAL LANGUAGE MODE);
```

### 2. ì¸ë±ìŠ¤ ì„¤ê³„ ì›ì¹™

#### ì„ íƒë„ ê¸°ë°˜ ì¸ë±ìŠ¤ ì„¤ê³„
```javascript
class IndexDesigner {
  constructor() {
    this.columnStats = new Map();
  }

  // ì»¬ëŸ¼ ì„ íƒë„ ê³„ì‚°
  calculateSelectivity(tableName, columnName) {
    // ì‹¤ì œë¡œëŠ” ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ í†µê³„ ì •ë³´ë¥¼ ê°€ì ¸ì˜´
    const totalRows = 1000000;
    const distinctValues = 100000;
    
    return distinctValues / totalRows; // 0.1 (10%)
  }

  // ì¸ë±ìŠ¤ íš¨ìœ¨ì„± í‰ê°€
  evaluateIndexEfficiency(tableName, columns) {
    const selectivities = columns.map(col => 
      this.calculateSelectivity(tableName, col)
    );
    
    // ì„ íƒë„ê°€ ë†’ì„ìˆ˜ë¡ ì¢‹ì€ ì¸ë±ìŠ¤
    const avgSelectivity = selectivities.reduce((a, b) => a + b, 0) / selectivities.length;
    
    return {
      efficiency: avgSelectivity,
      recommendation: avgSelectivity > 0.1 ? 'Good' : 'Poor'
    };
  }

  // ë³µí•© ì¸ë±ìŠ¤ ì»¬ëŸ¼ ìˆœì„œ ê²°ì •
  determineColumnOrder(tableName, columns) {
    // 1. ë“±í˜¸ ì¡°ê±´ì´ ìˆëŠ” ì»¬ëŸ¼ì„ ì•ì— ë°°ì¹˜
    // 2. ì„ íƒë„ê°€ ë†’ì€ ì»¬ëŸ¼ì„ ì•ì— ë°°ì¹˜
    // 3. ë²”ìœ„ ê²€ìƒ‰ì´ ìˆëŠ” ì»¬ëŸ¼ì„ ë’¤ì— ë°°ì¹˜
    
    return columns.sort((a, b) => {
      const selectivityA = this.calculateSelectivity(tableName, a);
      const selectivityB = this.calculateSelectivity(tableName, b);
      return selectivityB - selectivityA; // ë‚´ë¦¼ì°¨ìˆœ
    });
  }
}
```

#### ì¸ë±ìŠ¤ ëª¨ë‹ˆí„°ë§
```sql
-- MySQL ì¸ë±ìŠ¤ ì‚¬ìš© í˜„í™©
SELECT 
  TABLE_NAME,
  INDEX_NAME,
  CARDINALITY,
  INDEX_TYPE,
  COMMENT
FROM information_schema.STATISTICS 
WHERE TABLE_SCHEMA = 'your_database'
ORDER BY TABLE_NAME, INDEX_NAME;

-- PostgreSQL ì¸ë±ìŠ¤ ì‚¬ìš© í˜„í™©
SELECT 
  schemaname,
  tablename,
  indexname,
  idx_scan,
  idx_tup_read,
  idx_tup_fetch
FROM pg_stat_user_indexes
WHERE schemaname = 'public'
ORDER BY idx_scan DESC;

-- ì‚¬ìš©ë˜ì§€ ì•ŠëŠ” ì¸ë±ìŠ¤ ì°¾ê¸°
SELECT 
  schemaname,
  tablename,
  indexname,
  idx_scan
FROM pg_stat_user_indexes
WHERE idx_scan = 0
ORDER BY tablename;
```

### 3. ì¸ë±ìŠ¤ ìµœì í™” ì „ëµ

#### ì¸ë±ìŠ¤ ì¡°ê°í™” ê´€ë¦¬
```sql
-- MySQL ì¸ë±ìŠ¤ ì¡°ê°í™” í™•ì¸
SELECT 
  TABLE_NAME,
  INDEX_NAME,
  CARDINALITY,
  SUB_PART,
  PACKED,
  NULLABLE,
  INDEX_TYPE
FROM information_schema.STATISTICS 
WHERE TABLE_SCHEMA = 'your_database';

-- ì¸ë±ìŠ¤ ì¬êµ¬ì„±
OPTIMIZE TABLE users;

-- PostgreSQL ì¸ë±ìŠ¤ ì¬êµ¬ì„±
REINDEX INDEX idx_email;
REINDEX TABLE users;
```

#### ì¸ë±ìŠ¤ í†µê³„ ì—…ë°ì´íŠ¸
```sql
-- MySQL í†µê³„ ì—…ë°ì´íŠ¸
ANALYZE TABLE users;

-- PostgreSQL í†µê³„ ì—…ë°ì´íŠ¸
ANALYZE users;

-- íŠ¹ì • ì»¬ëŸ¼ í†µê³„ ì—…ë°ì´íŠ¸
ANALYZE users (email, created_at);
```

---

## ë°ì´í„°ë² ì´ìŠ¤ íŒŒí‹°ì…”ë‹ ë° ìƒ¤ë”©

### 1. íŒŒí‹°ì…”ë‹ ì „ëµ

#### ë²”ìœ„ ê¸°ë°˜ íŒŒí‹°ì…”ë‹
```sql
-- ë‚ ì§œ ê¸°ë°˜ íŒŒí‹°ì…”ë‹
CREATE TABLE user_activities (
    id BIGINT,
    user_id BIGINT,
    activity_type VARCHAR(50),
    created_at TIMESTAMP,
    data JSONB
) PARTITION BY RANGE (created_at);

-- ì›”ë³„ íŒŒí‹°ì…˜ ìƒì„±
CREATE TABLE user_activities_2024_01 PARTITION OF user_activities
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

CREATE TABLE user_activities_2024_02 PARTITION OF user_activities
    FOR VALUES FROM ('2024-02-01') TO ('2024-03-01');

-- íŒŒí‹°ì…˜ ìë™ ìƒì„± í•¨ìˆ˜
CREATE OR REPLACE FUNCTION create_monthly_partition(table_name text, start_date date)
RETURNS void AS $$
DECLARE
    partition_name text;
    end_date date;
BEGIN
    partition_name := table_name || '_' || to_char(start_date, 'YYYY_MM');
    end_date := start_date + interval '1 month';
    
    EXECUTE format('CREATE TABLE %I PARTITION OF %I FOR VALUES FROM (%L) TO (%L)',
                   partition_name, table_name, start_date, end_date);
END;
$$ LANGUAGE plpgsql;
```

#### í•´ì‹œ ê¸°ë°˜ íŒŒí‹°ì…”ë‹
```sql
-- ì‚¬ìš©ì ID ê¸°ë°˜ í•´ì‹œ íŒŒí‹°ì…”ë‹
CREATE TABLE users (
    id BIGINT,
    username VARCHAR(50),
    email VARCHAR(100),
    created_at TIMESTAMP
) PARTITION BY HASH (id);

-- 4ê°œ íŒŒí‹°ì…˜ ìƒì„±
CREATE TABLE users_0 PARTITION OF users
    FOR VALUES WITH (modulus 4, remainder 0);

CREATE TABLE users_1 PARTITION OF users
    FOR VALUES WITH (modulus 4, remainder 1);

CREATE TABLE users_2 PARTITION OF users
    FOR VALUES WITH (modulus 4, remainder 2);

CREATE TABLE users_3 PARTITION OF users
    FOR VALUES WITH (modulus 4, remainder 3);
```

### 2. ìƒ¤ë”© êµ¬í˜„

#### ìˆ˜í‰ ìƒ¤ë”©
```javascript
class HorizontalSharding {
  constructor(shardCount) {
    this.shardCount = shardCount;
    this.shards = new Array(shardCount).fill(null).map(() => ({
      connection: null,
      data: new Map()
    }));
  }

  // í•´ì‹œ ê¸°ë°˜ ìƒ¤ë”©
  getShardId(key) {
    const hash = this.hashFunction(key);
    return hash % this.shardCount;
  }

  hashFunction(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return Math.abs(hash);
  }

  async insert(key, value) {
    const shardId = this.getShardId(key);
    const shard = this.shards[shardId];
    
    shard.data.set(key, value);
    console.log(`Inserted ${key} into shard ${shardId}`);
  }

  async get(key) {
    const shardId = this.getShardId(key);
    const shard = this.shards[shardId];
    
    return shard.data.get(key);
  }

  // í¬ë¡œìŠ¤ ìƒ¤ë“œ ì¿¼ë¦¬
  async crossShardQuery(predicate) {
    const results = [];
    
    for (let i = 0; i < this.shardCount; i++) {
      const shard = this.shards[i];
      const shardResults = Array.from(shard.data.values())
        .filter(predicate);
      results.push(...shardResults);
    }
    
    return results;
  }
}
```

#### ìˆ˜ì§ ìƒ¤ë”©
```javascript
class VerticalSharding {
  constructor() {
    this.shards = {
      userProfile: new Map(),    // ì‚¬ìš©ì í”„ë¡œí•„ ì •ë³´
      userActivity: new Map(),   // ì‚¬ìš©ì í™œë™ ë¡œê·¸
      userSettings: new Map()    // ì‚¬ìš©ì ì„¤ì •
    };
  }

  async insertUserProfile(userId, profile) {
    this.shards.userProfile.set(userId, profile);
  }

  async insertUserActivity(userId, activity) {
    if (!this.shards.userActivity.has(userId)) {
      this.shards.userActivity.set(userId, []);
    }
    this.shards.userActivity.get(userId).push(activity);
  }

  async insertUserSettings(userId, settings) {
    this.shards.userSettings.set(userId, settings);
  }

  async getUserData(userId) {
    const profile = this.shards.userProfile.get(userId);
    const activities = this.shards.userActivity.get(userId) || [];
    const settings = this.shards.userSettings.get(userId);

    return {
      profile,
      activities,
      settings
    };
  }
}
```

---

## ì—°ê²° í’€ ê´€ë¦¬ ë° ìµœì í™”

### 1. ì—°ê²° í’€ ì„¤ì •

#### Node.js ì—°ê²° í’€ ì„¤ì •
```javascript
const mysql = require('mysql2/promise');

class DatabaseConnectionPool {
  constructor() {
    this.pool = mysql.createPool({
      host: process.env.DB_HOST,
      user: process.env.DB_USER,
      password: process.env.DB_PASSWORD,
      database: process.env.DB_NAME,
      
      // ì—°ê²° í’€ ì„¤ì •
      connectionLimit: 20,           // ìµœëŒ€ ì—°ê²° ìˆ˜
      acquireTimeoutMillis: 5000,    // ì—°ê²° íšë“ íƒ€ì„ì•„ì›ƒ
      timeout: 30000,                // ì¿¼ë¦¬ íƒ€ì„ì•„ì›ƒ
      idleTimeoutMillis: 300000,     // ìœ íœ´ ì—°ê²° íƒ€ì„ì•„ì›ƒ (5ë¶„)
      
      // ì¬ì—°ê²° ì„¤ì •
      reconnect: true,
      maxReconnects: 3,
      reconnectDelay: 1000,
      
      // ì„±ëŠ¥ ì„¤ì •
      multipleStatements: false,
      dateStrings: true,
      supportBigNumbers: true,
      bigNumberStrings: true
    });
    
    this.setupEventHandlers();
  }

  setupEventHandlers() {
    this.pool.on('connection', (connection) => {
      console.log('New connection established:', connection.threadId);
    });

    this.pool.on('acquire', (connection) => {
      console.log('Connection acquired:', connection.threadId);
    });

    this.pool.on('release', (connection) => {
      console.log('Connection released:', connection.threadId);
    });

    this.pool.on('error', (err) => {
      console.error('Pool error:', err);
    });
  }

  async query(sql, params = []) {
    let connection;
    try {
      connection = await this.pool.getConnection();
      const [rows] = await connection.execute(sql, params);
      return rows;
    } catch (error) {
      console.error('Query error:', error);
      throw error;
    } finally {
      if (connection) {
        connection.release();
      }
    }
  }

  async withTransaction(operation) {
    let connection;
    try {
      connection = await this.pool.getConnection();
      await connection.beginTransaction();
      
      const result = await operation(connection);
      
      await connection.commit();
      return result;
    } catch (error) {
      if (connection) {
        await connection.rollback();
      }
      throw error;
    } finally {
      if (connection) {
        connection.release();
      }
    }
  }

  // ì—°ê²° í’€ ìƒíƒœ ëª¨ë‹ˆí„°ë§
  getPoolStatus() {
    return {
      totalConnections: this.pool._allConnections.length,
      freeConnections: this.pool._freeConnections.length,
      queuedRequests: this.pool._connectionQueue.length
    };
  }
}
```

#### PostgreSQL ì—°ê²° í’€ ì„¤ì •
```javascript
const { Pool } = require('pg');

class PostgreSQLConnectionPool {
  constructor() {
    this.pool = new Pool({
      host: process.env.DB_HOST,
      port: process.env.DB_PORT,
      database: process.env.DB_NAME,
      user: process.env.DB_USER,
      password: process.env.DB_PASSWORD,
      
      // ì—°ê²° í’€ ì„¤ì •
      max: 20,                    // ìµœëŒ€ ì—°ê²° ìˆ˜
      min: 5,                     // ìµœì†Œ ì—°ê²° ìˆ˜
      idleTimeoutMillis: 30000,   // ìœ íœ´ ì—°ê²° íƒ€ì„ì•„ì›ƒ
      connectionTimeoutMillis: 5000, // ì—°ê²° íƒ€ì„ì•„ì›ƒ
      
      // ì„±ëŠ¥ ì„¤ì •
      statement_timeout: 30000,   // ì¿¼ë¦¬ íƒ€ì„ì•„ì›ƒ
      query_timeout: 30000,       // ì¿¼ë¦¬ íƒ€ì„ì•„ì›ƒ
      application_name: 'myapp',  // ì• í”Œë¦¬ì¼€ì´ì…˜ ì´ë¦„
      
      // SSL ì„¤ì •
      ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false
    });
    
    this.setupEventHandlers();
  }

  setupEventHandlers() {
    this.pool.on('connect', (client) => {
      console.log('New client connected');
    });

    this.pool.on('error', (err, client) => {
      console.error('Unexpected error on idle client', err);
    });
  }

  async query(text, params = []) {
    const start = Date.now();
    try {
      const result = await this.pool.query(text, params);
      const duration = Date.now() - start;
      console.log('Query executed', { text, duration, rows: result.rowCount });
      return result;
    } catch (error) {
      console.error('Query error:', error);
      throw error;
    }
  }
}
```

### 2. ì—°ê²° í’€ ìµœì í™”

#### ë™ì  ì—°ê²° í’€ í¬ê¸° ì¡°ì •
```javascript
class AdaptiveConnectionPool {
  constructor() {
    this.pool = null;
    this.metrics = {
      activeConnections: 0,
      queuedRequests: 0,
      avgResponseTime: 0,
      errorRate: 0
    };
    
    this.startMonitoring();
  }

  startMonitoring() {
    setInterval(() => {
      this.adjustPoolSize();
    }, 60000); // 1ë¶„ë§ˆë‹¤
  }

  adjustPoolSize() {
    const { activeConnections, queuedRequests, avgResponseTime, errorRate } = this.metrics;
    
    // íì— ëŒ€ê¸° ì¤‘ì¸ ìš”ì²­ì´ ë§ìœ¼ë©´ ì—°ê²° ìˆ˜ ì¦ê°€
    if (queuedRequests > 10) {
      this.increasePoolSize();
    }
    
    // í‰ê·  ì‘ë‹µ ì‹œê°„ì´ ê¸¸ë©´ ì—°ê²° ìˆ˜ ì¦ê°€
    if (avgResponseTime > 1000) {
      this.increasePoolSize();
    }
    
    // ì—ëŸ¬ìœ¨ì´ ë†’ìœ¼ë©´ ì—°ê²° ìˆ˜ ê°ì†Œ
    if (errorRate > 0.05) {
      this.decreasePoolSize();
    }
    
    // ìœ íœ´ ì—°ê²°ì´ ë§ìœ¼ë©´ ì—°ê²° ìˆ˜ ê°ì†Œ
    if (activeConnections < this.pool.options.connectionLimit * 0.3) {
      this.decreasePoolSize();
    }
  }

  increasePoolSize() {
    const currentLimit = this.pool.options.connectionLimit;
    const newLimit = Math.min(currentLimit + 5, 50); // ìµœëŒ€ 50ê°œ
    
    if (newLimit > currentLimit) {
      this.pool.options.connectionLimit = newLimit;
      console.log(`Pool size increased to ${newLimit}`);
    }
  }

  decreasePoolSize() {
    const currentLimit = this.pool.options.connectionLimit;
    const newLimit = Math.max(currentLimit - 2, 5); // ìµœì†Œ 5ê°œ
    
    if (newLimit < currentLimit) {
      this.pool.options.connectionLimit = newLimit;
      console.log(`Pool size decreased to ${newLimit}`);
    }
  }
}
```

#### ì—°ê²° í’€ ëª¨ë‹ˆí„°ë§
```javascript
class ConnectionPoolMonitor {
  constructor(pool) {
    this.pool = pool;
    this.metrics = {
      totalConnections: 0,
      activeConnections: 0,
      idleConnections: 0,
      queuedRequests: 0,
      totalQueries: 0,
      failedQueries: 0,
      avgQueryTime: 0
    };
    
    this.startMonitoring();
  }

  startMonitoring() {
    setInterval(() => {
      this.collectMetrics();
      this.logMetrics();
    }, 10000); // 10ì´ˆë§ˆë‹¤
  }

  collectMetrics() {
    this.metrics.totalConnections = this.pool._allConnections.length;
    this.metrics.activeConnections = this.pool._allConnections.filter(c => c._inUse).length;
    this.metrics.idleConnections = this.pool._freeConnections.length;
    this.metrics.queuedRequests = this.pool._connectionQueue.length;
  }

  logMetrics() {
    console.log('Connection Pool Metrics:', {
      total: this.metrics.totalConnections,
      active: this.metrics.activeConnections,
      idle: this.metrics.idleConnections,
      queued: this.metrics.queuedRequests,
      utilization: (this.metrics.activeConnections / this.metrics.totalConnections * 100).toFixed(2) + '%'
    });
  }

  // ì•Œë¦¼ ì„¤ì •
  checkThresholds() {
    const utilization = this.metrics.activeConnections / this.metrics.totalConnections;
    
    if (utilization > 0.8) {
      console.warn('High connection pool utilization:', utilization);
    }
    
    if (this.metrics.queuedRequests > 20) {
      console.warn('High queued requests:', this.metrics.queuedRequests);
    }
  }
}
```

---

## ì‹¤ì œ ì„±ëŠ¥ íŠœë‹ ì‚¬ë¡€ ë° ë²¤ì¹˜ë§ˆí‚¹

### 1. ì„±ëŠ¥ íŠœë‹ ì‚¬ë¡€

#### ì‚¬ë¡€ 1: ëŠë¦° ì‚¬ìš©ì ê²€ìƒ‰ ì¿¼ë¦¬ ìµœì í™”
```sql
-- âŒ ìµœì í™” ì „ (2.5ì´ˆ)
SELECT u.*, p.name as profile_name 
FROM users u 
LEFT JOIN profiles p ON u.id = p.user_id 
WHERE u.email LIKE '%@gmail.com' 
ORDER BY u.created_at DESC 
LIMIT 20;

-- âœ… ìµœì í™” í›„ (0.1ì´ˆ)
-- 1. ì¸ë±ìŠ¤ ìƒì„±
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_created_at ON users(created_at);

-- 2. ì¿¼ë¦¬ ìµœì í™”
SELECT u.id, u.email, u.created_at, p.name as profile_name
FROM users u 
LEFT JOIN profiles p ON u.id = p.user_id 
WHERE u.email LIKE 'user%@gmail.com'  -- ì•ìª½ ì™€ì¼ë“œì¹´ë“œ ì œê±°
ORDER BY u.created_at DESC 
LIMIT 20;
```

#### ì‚¬ë¡€ 2: ëŒ€ëŸ‰ ë°ì´í„° ì‚½ì… ìµœì í™”
```javascript
// âŒ ìµœì í™” ì „ (1000ê°œ ì‚½ì…ì— 10ì´ˆ)
async function insertUsersSlow(users) {
  for (const user of users) {
    await db.query('INSERT INTO users (name, email) VALUES (?, ?)', [user.name, user.email]);
  }
}

// âœ… ìµœì í™” í›„ (1000ê°œ ì‚½ì…ì— 0.5ì´ˆ)
async function insertUsersFast(users) {
  const values = users.map(user => [user.name, user.email]);
  const placeholders = users.map(() => '(?, ?)').join(', ');
  
  await db.query(`INSERT INTO users (name, email) VALUES ${placeholders}`, values.flat());
}

// âœ… ë°°ì¹˜ ì‚½ì… ìµœì í™”
async function insertUsersBatch(users, batchSize = 1000) {
  for (let i = 0; i < users.length; i += batchSize) {
    const batch = users.slice(i, i + batchSize);
    await insertUsersFast(batch);
  }
}
```

#### ì‚¬ë¡€ 3: ë³µì¡í•œ ì¡°ì¸ ì¿¼ë¦¬ ìµœì í™”
```sql
-- âŒ ìµœì í™” ì „ (5ì´ˆ)
SELECT u.name, u.email, COUNT(o.id) as order_count, SUM(o.total) as total_spent
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
LEFT JOIN order_items oi ON o.id = oi.order_id
WHERE u.created_at > '2024-01-01'
GROUP BY u.id, u.name, u.email
HAVING COUNT(o.id) > 5
ORDER BY total_spent DESC
LIMIT 100;

-- âœ… ìµœì í™” í›„ (0.3ì´ˆ)
-- 1. ì¸ë±ìŠ¤ ìƒì„±
CREATE INDEX idx_users_created_at ON users(created_at);
CREATE INDEX idx_orders_user_id ON orders(user_id);
CREATE INDEX idx_orders_total ON orders(total);

-- 2. ì¿¼ë¦¬ ìµœì í™” (ì„œë¸Œì¿¼ë¦¬ í™œìš©)
SELECT u.name, u.email, o.order_count, o.total_spent
FROM users u
JOIN (
  SELECT user_id, COUNT(*) as order_count, SUM(total) as total_spent
  FROM orders
  WHERE created_at > '2024-01-01'
  GROUP BY user_id
  HAVING COUNT(*) > 5
) o ON u.id = o.user_id
WHERE u.created_at > '2024-01-01'
ORDER BY o.total_spent DESC
LIMIT 100;
```

### 2. ë²¤ì¹˜ë§ˆí‚¹ ë„êµ¬

#### ì„±ëŠ¥ ë²¤ì¹˜ë§ˆí‚¹ í´ë˜ìŠ¤
```javascript
class DatabaseBenchmark {
  constructor() {
    this.results = [];
    this.metrics = {
      totalQueries: 0,
      totalTime: 0,
      avgTime: 0,
      minTime: Infinity,
      maxTime: 0,
      errorCount: 0
    };
  }

  // ë‹¨ì¼ ì¿¼ë¦¬ ë²¤ì¹˜ë§ˆí¬
  async benchmarkQuery(name, query, params = [], iterations = 100) {
    console.log(`Benchmarking: ${name}`);
    
    const times = [];
    let errors = 0;
    
    for (let i = 0; i < iterations; i++) {
      const start = process.hrtime.bigint();
      
      try {
        await this.executeQuery(query, params);
        const end = process.hrtime.bigint();
        const duration = Number(end - start) / 1000000; // ms
        times.push(duration);
      } catch (error) {
        errors++;
        console.error(`Query error: ${error.message}`);
      }
    }
    
    const result = this.calculateStats(times, errors, iterations);
    this.results.push({ name, ...result });
    
    console.log(`Results for ${name}:`, result);
    return result;
  }

  // ë™ì‹œì„± ë²¤ì¹˜ë§ˆí¬
  async benchmarkConcurrency(name, query, params = [], concurrency = 10, duration = 10000) {
    console.log(`Concurrency benchmark: ${name}`);
    
    const startTime = Date.now();
    const results = [];
    const promises = [];
    
    for (let i = 0; i < concurrency; i++) {
      promises.push(this.runConcurrentQueries(query, params, startTime, duration));
    }
    
    const allResults = await Promise.all(promises);
    const combinedResults = allResults.flat();
    
    const result = this.calculateStats(combinedResults, 0, combinedResults.length);
    this.results.push({ name: `${name}_concurrent`, ...result });
    
    console.log(`Concurrency results for ${name}:`, result);
    return result;
  }

  async runConcurrentQueries(query, params, startTime, duration) {
    const results = [];
    
    while (Date.now() - startTime < duration) {
      const start = process.hrtime.bigint();
      
      try {
        await this.executeQuery(query, params);
        const end = process.hrtime.bigint();
        const queryTime = Number(end - start) / 1000000;
        results.push(queryTime);
      } catch (error) {
        // ì—ëŸ¬ëŠ” ë¬´ì‹œí•˜ê³  ê³„ì†
      }
    }
    
    return results;
  }

  calculateStats(times, errors, total) {
    if (times.length === 0) {
      return {
        avgTime: 0,
        minTime: 0,
        maxTime: 0,
        p95Time: 0,
        p99Time: 0,
        errorRate: errors / total,
        throughput: 0
      };
    }
    
    const sortedTimes = times.sort((a, b) => a - b);
    const avgTime = times.reduce((a, b) => a + b, 0) / times.length;
    const minTime = Math.min(...times);
    const maxTime = Math.max(...times);
    const p95Time = sortedTimes[Math.floor(sortedTimes.length * 0.95)];
    const p99Time = sortedTimes[Math.floor(sortedTimes.length * 0.99)];
    const errorRate = errors / total;
    const throughput = times.length / (times.reduce((a, b) => a + b, 0) / 1000); // queries per second
    
    return {
      avgTime: Math.round(avgTime * 100) / 100,
      minTime: Math.round(minTime * 100) / 100,
      maxTime: Math.round(maxTime * 100) / 100,
      p95Time: Math.round(p95Time * 100) / 100,
      p99Time: Math.round(p99Time * 100) / 100,
      errorRate: Math.round(errorRate * 10000) / 100, // percentage
      throughput: Math.round(throughput * 100) / 100
    };
  }

  // ê²°ê³¼ ë¹„êµ
  compareResults() {
    console.log('\n=== Benchmark Results Comparison ===');
    
    this.results.forEach(result => {
      console.log(`\n${result.name}:`);
      console.log(`  Average Time: ${result.avgTime}ms`);
      console.log(`  Min Time: ${result.minTime}ms`);
      console.log(`  Max Time: ${result.maxTime}ms`);
      console.log(`  95th Percentile: ${result.p95Time}ms`);
      console.log(`  99th Percentile: ${result.p99Time}ms`);
      console.log(`  Error Rate: ${result.errorRate}%`);
      console.log(`  Throughput: ${result.throughput} queries/sec`);
    });
  }

  async executeQuery(query, params) {
    // ì‹¤ì œ ë°ì´í„°ë² ì´ìŠ¤ ì¿¼ë¦¬ ì‹¤í–‰
    // ì´ ë¶€ë¶„ì€ ì‹¤ì œ ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²°ì— ë§ê²Œ êµ¬í˜„
    throw new Error('executeQuery method must be implemented');
  }
}
```

#### ì‹¤ì œ ë²¤ì¹˜ë§ˆí‚¹ ì˜ˆì‹œ
```javascript
// ë²¤ì¹˜ë§ˆí‚¹ ì‹¤í–‰ ì˜ˆì‹œ
async function runBenchmarks() {
  const benchmark = new DatabaseBenchmark();
  
  // ë‹¨ì¼ ì¿¼ë¦¬ ë²¤ì¹˜ë§ˆí¬
  await benchmark.benchmarkQuery(
    'Simple SELECT',
    'SELECT * FROM users WHERE id = ?',
    [1],
    1000
  );
  
  await benchmark.benchmarkQuery(
    'Complex JOIN',
    `SELECT u.name, COUNT(o.id) as order_count 
     FROM users u 
     LEFT JOIN orders o ON u.id = o.user_id 
     GROUP BY u.id, u.name 
     LIMIT 100`,
    [],
    100
  );
  
  // ë™ì‹œì„± ë²¤ì¹˜ë§ˆí¬
  await benchmark.benchmarkConcurrency(
    'Concurrent SELECT',
    'SELECT * FROM users WHERE email = ?',
    ['test@example.com'],
    20,
    10000
  );
  
  // ê²°ê³¼ ë¹„êµ
  benchmark.compareResults();
}

runBenchmarks().catch(console.error);
```

### 3. ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ëŒ€ì‹œë³´ë“œ

```javascript
class PerformanceDashboard {
  constructor() {
    this.metrics = {
      queries: [],
      connections: [],
      errors: []
    };
    
    this.startMonitoring();
  }

  startMonitoring() {
    setInterval(() => {
      this.collectMetrics();
      this.updateDashboard();
    }, 5000); // 5ì´ˆë§ˆë‹¤
  }

  collectMetrics() {
    // ì¿¼ë¦¬ ì„±ëŠ¥ ë©”íŠ¸ë¦­ ìˆ˜ì§‘
    const queryMetrics = {
      timestamp: new Date(),
      avgResponseTime: this.getAverageResponseTime(),
      totalQueries: this.getTotalQueries(),
      slowQueries: this.getSlowQueries(),
      errorRate: this.getErrorRate()
    };
    
    this.metrics.queries.push(queryMetrics);
    
    // ì—°ê²° í’€ ë©”íŠ¸ë¦­ ìˆ˜ì§‘
    const connectionMetrics = {
      timestamp: new Date(),
      activeConnections: this.getActiveConnections(),
      idleConnections: this.getIdleConnections(),
      queuedRequests: this.getQueuedRequests()
    };
    
    this.metrics.connections.push(connectionMetrics);
  }

  updateDashboard() {
    console.log('\n=== Performance Dashboard ===');
    console.log(`Time: ${new Date().toLocaleTimeString()}`);
    
    const latestQuery = this.metrics.queries[this.metrics.queries.length - 1];
    const latestConnection = this.metrics.connections[this.metrics.connections.length - 1];
    
    console.log('\nQuery Performance:');
    console.log(`  Average Response Time: ${latestQuery.avgResponseTime}ms`);
    console.log(`  Total Queries: ${latestQuery.totalQueries}`);
    console.log(`  Slow Queries: ${latestQuery.slowQueries}`);
    console.log(`  Error Rate: ${latestQuery.errorRate}%`);
    
    console.log('\nConnection Pool:');
    console.log(`  Active Connections: ${latestConnection.activeConnections}`);
    console.log(`  Idle Connections: ${latestConnection.idleConnections}`);
    console.log(`  Queued Requests: ${latestConnection.queuedRequests}`);
    
    // ì•Œë¦¼ ì²´í¬
    this.checkAlerts(latestQuery, latestConnection);
  }

  checkAlerts(queryMetrics, connectionMetrics) {
    if (queryMetrics.avgResponseTime > 1000) {
      console.warn('âš ï¸  High average response time detected!');
    }
    
    if (queryMetrics.errorRate > 5) {
      console.warn('âš ï¸  High error rate detected!');
    }
    
    if (connectionMetrics.queuedRequests > 20) {
      console.warn('âš ï¸  High queued requests detected!');
    }
  }

  // ì‹¤ì œ êµ¬í˜„ì€ ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²°ì— ë§ê²Œ ìˆ˜ì •
  getAverageResponseTime() { return Math.random() * 100; }
  getTotalQueries() { return Math.floor(Math.random() * 1000); }
  getSlowQueries() { return Math.floor(Math.random() * 10); }
  getErrorRate() { return Math.random() * 2; }
  getActiveConnections() { return Math.floor(Math.random() * 20); }
  getIdleConnections() { return Math.floor(Math.random() * 10); }
  getQueuedRequests() { return Math.floor(Math.random() * 5); }
}
```

---

## ê²°ë¡ 

ë°ì´í„°ë² ì´ìŠ¤ ì„±ëŠ¥ íŠœë‹ì€ ì‹œìŠ¤í…œì˜ ì „ë°˜ì ì¸ ì„±ëŠ¥ì— ì§ì ‘ì ì¸ ì˜í–¥ì„ ë¯¸ì¹˜ëŠ” ì¤‘ìš”í•œ ì‘ì—…ì…ë‹ˆë‹¤.

### í•µì‹¬ ì›ì¹™ ìš”ì•½

1. **ì¿¼ë¦¬ ìµœì í™”**: ì‹¤í–‰ ê³„íš ë¶„ì„ì„ í†µí•œ íš¨ìœ¨ì ì¸ ì¿¼ë¦¬ ì‘ì„±
2. **ì¸ë±ìŠ¤ ì„¤ê³„**: ì„ íƒë„ ê¸°ë°˜ì˜ ì ì ˆí•œ ì¸ë±ìŠ¤ ì„¤ê³„ ë° ê´€ë¦¬
3. **íŒŒí‹°ì…”ë‹/ìƒ¤ë”©**: ëŒ€ìš©ëŸ‰ ë°ì´í„° ì²˜ë¦¬ë¥¼ ìœ„í•œ ë¶„ì‚° ì „ëµ
4. **ì—°ê²° í’€ ìµœì í™”**: íš¨ìœ¨ì ì¸ ì—°ê²° ê´€ë¦¬ ë° ëª¨ë‹ˆí„°ë§
5. **ì§€ì†ì ì¸ ëª¨ë‹ˆí„°ë§**: ì„±ëŠ¥ ì§€í‘œ ì¶”ì  ë° ìµœì í™”

### ì‹¤ë¬´ ì ìš© ê°€ì´ë“œ

- **ê°œë°œ ë‹¨ê³„**: ì¿¼ë¦¬ ìµœì í™” ë° ì¸ë±ìŠ¤ ì„¤ê³„ì— ì§‘ì¤‘
- **í…ŒìŠ¤íŠ¸ ë‹¨ê³„**: ë²¤ì¹˜ë§ˆí‚¹ì„ í†µí•œ ì„±ëŠ¥ ê²€ì¦
- **ìš´ì˜ ë‹¨ê³„**: ëª¨ë‹ˆí„°ë§ ë° ì§€ì†ì ì¸ íŠœë‹

ì´ëŸ¬í•œ ì›ì¹™ë“¤ì„ ë°”íƒ•ìœ¼ë¡œ ë°ì´í„°ë² ì´ìŠ¤ ì„±ëŠ¥ì„ ìµœì í™”í•˜ì—¬ ì•ˆì •ì ì´ê³  í™•ì¥ ê°€ëŠ¥í•œ ì‹œìŠ¤í…œì„ êµ¬ì¶•í•˜ì„¸ìš”.

