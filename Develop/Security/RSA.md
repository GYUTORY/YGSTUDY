---
title: RSA
tags: [security, rsa]
updated: 2025-08-10
---
## 1. 개요 ✨

RSA는 **공개 키 암호화(Public Key Cryptography) 알고리즘** 중 하나로, **안전한 데이터 전송 및 디지털 서명**에 사용됩니다.  
1977년 **Ron Rivest, Adi Shamir, Leonard Adleman**에 의해 개발되었으며, **그들의 이름의 앞글자를 따서 RSA**라고 불립니다.

RSA는 **대형 소수를 기반으로 한 수학적 원리**를 이용하여 데이터를 안전하게 암호화합니다.

> **🔹 RSA의 특징**
> - **비대칭 키 암호화 방식** (공개 키 & 개인 키)
> - **소인수분해의 어려움**을 이용한 보안
> - **데이터 암호화 & 디지털 서명에 활용**

---

## 2. RSA 동작 원리

RSA 암호화는 **공개 키와 개인 키를 이용한 비대칭 암호화 방식**입니다.

### 2.1 비대칭 암호화란?

👉🏻 **공개 키(Public Key)**: 데이터를 암호화하는 데 사용  
👉🏻 **개인 키(Private Key)**: 데이터를 복호화하는 데 사용

즉, **누구나 공개 키를 이용해 데이터를 암호화할 수 있지만, 개인 키 없이는 복호화할 수 없습니다.**

---

## 3. RSA 키 생성 과정

RSA는 다음 4단계를 거쳐 키를 생성합니다.

1️⃣ **두 개의 큰 소수 p와 q를 선택**  
2️⃣ **두 소수의 곱 n = p × q를 계산**  
3️⃣ **오일러 함수(φ(n)) 계산: φ(n) = (p-1) × (q-1)**  
4️⃣ **공개 키(e)와 개인 키(d) 계산**

---

### 3.1 키 생성 예제

```python
import random

## 배경
p = 61
q = 53

phi = (p - 1) * (q - 1)  # φ(n) = (61-1) × (53-1) = 3120

- 메시지를 암호화하여 **안전한 통신** 가능
- 예: HTTPS(SSL/TLS), VPN, 이메일 암호화

- 송신자가 메시지를 보냈다는 **증명 가능**
- 예: 블록체인, 전자 서명 시스템






---





# 🔐 RSA 암호화 알고리즘 가이드

# n 계산 (공개 키의 일부)
n = p * q  # n = 61 × 53 = 3233

# 공개 키 e 선택 (1 < e < φ(n) 이고, e와 φ(n)이 서로소)
e = 17

# 개인 키 d 계산 (e * d ≡ 1 (mod φ(n)) 만족하는 d 찾기)
def mod_inverse(e, phi):
    for d in range(2, phi):
        if (e * d) % phi == 1:
            return d
    return None

d = mod_inverse(e, phi)  # d = 2753

print(f"공개 키: (n={n}, e={e})")
print(f"개인 키: (n={n}, d={d})")
```

> 🔹 **설명**
> - `p = 61`, `q = 53`: 두 개의 큰 소수를 선택
> - `n = p × q`: 두 소수의 곱을 계산하여 공개 키 일부로 사용
> - `φ(n)`: 오일러 함수 계산
> - `e`: 공개 키로 사용할 작은 값 선택 (17)
> - `d`: `e * d ≡ 1 (mod φ(n))`을 만족하는 개인 키 계산

---

## 4. RSA 암호화 및 복호화

RSA 암호화는 아래의 공식을 이용합니다.

### **4.1 암호화** (Encryption)

암호문 `C`를 생성하는 공식:
\$
C = M^e \mod n
\$

> `M`은 평문(Message), `e`는 공개 키의 지수, `n`은 모듈러 연산 값

### **4.2 복호화** (Decryption)

원래 메시지를 복구하는 공식:
\$
M = C^d \mod n
\$

> `C`는 암호문, `d`는 개인 키의 지수, `n`은 모듈러 연산 값

---

### 4.3 암호화 & 복호화 예제

```python
# 메시지 (M) 선택
M = 65  # 암호화할 숫자

# 암호화 (C = M^e mod n)
C = (M ** e) % n

# 복호화 (M = C^d mod n)
decrypted_M = (C ** d) % n

print(f"원본 메시지: {M}")
print(f"암호화된 메시지: {C}")
print(f"복호화된 메시지: {decrypted_M}")
```

> 🔹 **설명**
> - `M = 65`: 암호화할 원본 데이터
> - `C = (M^e) % n`: 암호문 생성
> - `decrypted_M = (C^d) % n`: 복호화하여 원본 데이터 복원

---

## 5. RSA의 활용 분야

### **✅ 인증(Authentication)**
- 사용자 인증에 사용
- 예: SSH 키 기반 로그인, 보안 토큰

---

## 6. RSA의 보안성

🔴 **소인수분해 문제(Factoring Problem)**
- RSA의 보안성은 **큰 숫자의 소인수분해가 어렵다는 점**에 기반합니다.
- `n = p × q`에서 `p`, `q`를 찾기 매우 어려움

🔴 **키 길이**
- **2048비트 이상의 키**를 사용해야 안전
- 1024비트 이하 키는 현재 컴퓨팅 기술로 쉽게 깨질 수 있음

🔴 **양자 컴퓨팅 위협**
- 양자 컴퓨터가 발전하면 RSA가 깨질 가능성이 있음
- 대안: **ECC(타원 곡선 암호) 또는 양자 암호화 기술**

---

## 7. 정리 🎯

✔️ **RSA는 공개 키 암호화 방식으로, 암호화 & 디지털 서명에 사용**  
✔️ **소인수분해의 어려움을 기반으로 보안이 유지됨**  
✔️ **큰 숫자의 연산을 사용하여 데이터를 안전하게 보호**  
✔️ **현재 널리 사용되지만, 양자 컴퓨터 시대에는 위험 가능성이 있음**

📌 **RSA는 보안성이 뛰어나지만, 키 길이를 충분히 길게 설정해야 안전합니다!**

