---
title: 보안 심화 및 취약점 분석
tags: [security, vulnerability-analysis, authentication, authorization, encryption, monitoring, incident-response]
updated: 2025-12-06
---

# 보안 심화 및 취약점 분석

## 개요

보안 취약점 분석과 대응 전략을 다룬다.

## OWASP Top 10 대응

### SQL Injection

**정의:**
SQL Injection은 사용자 입력을 SQL 쿼리에 직접 삽입해 데이터베이스를 조작하는 공격이다.

**공격 원리:**
1. 사용자 입력이 SQL 쿼리 문자열에 직접 포함됨
2. 공격자가 악의적인 SQL 코드를 입력
3. 데이터베이스가 해당 코드를 실행
4. 데이터 유출, 수정, 삭제 발생

**공격 예시:**
```javascript
// 공격자가 userId에 입력: "1' OR '1'='1"
const query = `SELECT * FROM users WHERE id = ${userId}`;
// 실행되는 쿼리: SELECT * FROM users WHERE id = 1' OR '1'='1
// 결과: 모든 사용자 정보 유출

// 공격자가 userId에 입력: "1; DROP TABLE users; --"
const query = `DELETE FROM users WHERE id = ${userId}`;
// 실행되는 쿼리: DELETE FROM users WHERE id = 1; DROP TABLE users; --
// 결과: users 테이블 삭제
```

**방어 방법:**

**취약한 코드:**
```javascript
const query = `SELECT * FROM users WHERE id = ${userId}`;
db.query(query); // SQL Injection 취약
```

**안전한 코드:**
```javascript
// Prepared Statement 사용
const query = 'SELECT * FROM users WHERE id = ?';
db.query(query, [userId]); // 안전

// ORM 사용 (권장)
const user = await User.findOne({ where: { id: userId } });
```

**실무 팁:**
- ORM을 사용하면 대부분 자동으로 방어된다
- 직접 쿼리를 작성할 때는 Prepared Statement를 사용해야 한다
- 입력값 검증도 함께 수행한다

### XSS (Cross-Site Scripting)

**정의:**
XSS는 웹 애플리케이션에 악의적인 JavaScript 코드를 삽입해 사용자 브라우저에서 실행하는 공격이다.

**공격 유형:**

**1. Stored XSS (저장형):**
악의적인 스크립트가 데이터베이스에 저장되고, 다른 사용자가 해당 페이지를 볼 때 실행된다.

```javascript
// 공격자가 댓글에 입력: <script>alert(document.cookie)</script>
// 데이터베이스에 저장됨
// 다른 사용자가 댓글을 볼 때 스크립트 실행
```

**2. Reflected XSS (반사형):**
URL 파라미터나 폼 입력에 포함된 스크립트가 즉시 실행된다.

```javascript
// 공격자가 URL에 입력: ?search=<script>alert('XSS')</script>
// 서버가 검색 결과에 그대로 포함
// 사용자 브라우저에서 스크립트 실행
```

**3. DOM-based XSS:**
클라이언트 측 JavaScript가 DOM을 조작할 때 발생한다.

```javascript
// 취약한 코드
document.getElementById('output').innerHTML = userInput;
// 공격자가 userInput에 <img src=x onerror="alert('XSS')"> 입력
```

**공격 피해:**
- 쿠키 탈취 (세션 하이재킹)
- 사용자 정보 유출
- 피싱 공격
- 악성 코드 실행

**방어 방법:**

**입력 검증 및 이스케이핑:**
```javascript
function sanitizeInput(input) {
  return input
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#x27;')
    .replace(/\//g, '&#x2F;');
}

// 또는 라이브러리 사용 (권장)
const DOMPurify = require('isomorphic-dompurify');
const clean = DOMPurify.sanitize(userInput);
```

**Content Security Policy 설정:**
```javascript
app.use(helmet.contentSecurityPolicy({
  directives: {
    defaultSrc: ["'self'"],
    scriptSrc: ["'self'"], // 'unsafe-inline' 제거
    styleSrc: ["'self'", "'unsafe-inline'"]
  }
}));
```

**실무 팁:**
- `innerHTML` 대신 `textContent` 사용
- React, Vue 같은 프레임워크는 기본적으로 XSS 방어
- CSP 헤더를 설정해 스크립트 실행 제한

### CSRF (Cross-Site Request Forgery)

**정의:**
CSRF는 사용자가 의도하지 않은 요청을 다른 사이트에서 대신 보내는 공격이다. 사용자가 로그인한 상태에서 악의적인 사이트가 사용자의 권한으로 요청을 보낸다.

**공격 원리:**
1. 사용자가 은행 사이트에 로그인 (세션 쿠키 저장)
2. 사용자가 악의적인 사이트 방문
3. 악의적인 사이트가 은행 사이트로 자동 요청 전송
4. 브라우저가 세션 쿠키를 자동으로 포함
5. 사용자 권한으로 요청 실행 (이체, 정보 변경 등)

**공격 예시:**
```html
<!-- 악의적인 사이트의 HTML -->
<img src="https://bank.com/transfer?to=attacker&amount=1000" />

<!-- 또는 자동 실행 스크립트 -->
<script>
  fetch('https://bank.com/transfer', {
    method: 'POST',
    body: JSON.stringify({ to: 'attacker', amount: 1000 }),
    credentials: 'include' // 쿠키 자동 포함
  });
</script>
```

**공격 조건:**
- 사용자가 대상 사이트에 로그인한 상태
- 쿠키 기반 인증 사용
- 상태 변경 요청 (GET이 아닌 POST, PUT, DELETE)

**방어 방법:**

**1. CSRF 토큰 사용:**
```javascript
const csrf = require('csurf');
const csrfProtection = csrf({ cookie: true });

// 토큰 생성 (폼 렌더링 시)
app.get('/form', csrfProtection, (req, res) => {
  res.render('form', { csrfToken: req.csrfToken() });
});

// 토큰 검증 (요청 처리 시)
app.post('/transfer', csrfProtection, (req, res) => {
  // CSRF 토큰 검증 완료
  processTransfer(req.body);
});
```

**2. SameSite 쿠키 속성:**
```javascript
app.use(session({
  cookie: {
    sameSite: 'strict', // 또는 'lax'
    secure: true,
    httpOnly: true
  }
}));
```

**3. Referer 검증:**
```javascript
app.post('/transfer', (req, res) => {
  const referer = req.get('Referer');
  if (!referer || !referer.startsWith('https://yourdomain.com')) {
    return res.status(403).send('Invalid request origin');
  }
  processTransfer(req.body);
});
```

**실무 팁:**
- 상태 변경 요청에는 항상 CSRF 토큰 사용
- SameSite 쿠키 속성으로 추가 방어
- GET 요청은 상태를 변경하지 않도록 설계

## 주요 보안 취약점 추가

### Directory Traversal (경로 탐색)

**정의:**
Directory Traversal은 `../` 같은 경로 조작을 통해 시스템 파일에 접근하는 공격이다.

**공격 예시:**
```javascript
// 취약한 코드
app.get('/file', (req, res) => {
  const filename = req.query.name;
  res.sendFile(`/uploads/${filename}`); // 위험
});

// 공격자가 입력: ?name=../../../etc/passwd
// 결과: /etc/passwd 파일 유출
```

**방어 방법:**
```javascript
const path = require('path');

app.get('/file', (req, res) => {
  const filename = req.query.name;
  const safePath = path.resolve('/uploads', filename);
  
  // 경로 검증
  if (!safePath.startsWith('/uploads')) {
    return res.status(403).send('Invalid path');
  }
  
  res.sendFile(safePath);
});
```

### Command Injection

**정의:**
Command Injection은 시스템 명령어를 실행하는 함수에 사용자 입력을 직접 전달해 악의적인 명령을 실행하는 공격이다.

**공격 예시:**
```javascript
// 취약한 코드
const { exec } = require('child_process');
const userInput = req.query.filename;
exec(`cat ${userInput}`, (error, stdout) => {
  // ...
});

// 공격자가 입력: file.txt; rm -rf /
// 결과: 시스템 파일 삭제
```

**방어 방법:**
```javascript
// 입력값 검증
const filename = req.query.filename;
if (!/^[a-zA-Z0-9._-]+$/.test(filename)) {
  return res.status(400).send('Invalid filename');
}

// 또는 exec 대신 execFile 사용
const { execFile } = require('child_process');
execFile('cat', [filename], (error, stdout) => {
  // ...
});
```

### XXE (XML External Entity)

**정의:**
XXE는 XML 파서가 외부 엔티티를 처리할 때 발생하는 취약점이다.

**공격 예시:**
```xml
<!-- 공격자가 입력한 XML -->
<?xml version="1.0"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<foo>&xxe;</foo>
```

**방어 방법:**
```javascript
const libxml = require('libxmljs');

const xml = req.body;
const doc = libxml.parseXmlString(xml, {
  noent: false, // 외부 엔티티 비활성화
  noblanks: true
});
```

## 자동화된 보안 테스트

### 정적 분석 (SAST)

코드를 실행하지 않고 분석한다. SonarQube, ESLint 보안 플러그인 등을 사용한다.

```javascript
class StaticSecurityAnalyzer {
  constructor() {
    this.rules = {
      hardcodedSecrets: /(password|secret|key|token)\s*=\s*['"][^'"]+['"]/gi,
      sqlInjection: /query\s*\(\s*['"][^'"]*\+/gi,
      xssVulnerability: /innerHTML\s*=\s*[^;]+/gi,
      weakCrypto: /md5|sha1|des\s*\(/gi
    };
  }

  analyzeCode(code) {
    const vulnerabilities = [];
    
    for (const [type, pattern] of Object.entries(this.rules)) {
      const matches = code.match(pattern);
      if (matches) {
        vulnerabilities.push({
          type,
          matches,
          severity: this.getSeverity(type)
        });
      }
    }
    
    return vulnerabilities;
  }
}
```

### 동적 분석 (DAST)

실행 중인 애플리케이션을 테스트한다. OWASP ZAP, Burp Suite 등을 사용한다.

```javascript
class DynamicSecurityTester {
  async scanSQLInjection(targetUrl) {
    const payloads = [
      "' OR '1'='1",
      "'; DROP TABLE users; --",
      "' UNION SELECT * FROM information_schema.tables --"
    ];

    const results = [];
    
    for (const payload of payloads) {
      const response = await this.sendPayload(targetUrl, payload);
      if (this.detectSQLInjection(response)) {
        results.push({
          type: 'SQL_INJECTION',
          payload,
          severity: 'HIGH'
        });
      }
    }
    
    return results;
  }
}
```

## 보안 모니터링

### 실시간 위협 탐지

의심스러운 요청 패턴을 실시간으로 감지한다.

```javascript
class ThreatDetector {
  constructor() {
    this.rateLimiter = new Map();
    this.suspiciousPatterns = [
      /\.\.\//g,  // Directory traversal
      /<script>/gi,  // XSS
      /union.*select/gi  // SQL Injection
    ];
  }

  async detectThreat(request) {
    const threats = [];

    // Rate limiting 체크
    if (this.isRateLimitExceeded(request.ip)) {
      threats.push({ type: 'RATE_LIMIT', severity: 'MEDIUM' });
    }

    // 의심스러운 패턴 체크
    const content = JSON.stringify(request.body) + request.url;
    for (const pattern of this.suspiciousPatterns) {
      if (pattern.test(content)) {
        threats.push({
          type: 'SUSPICIOUS_PATTERN',
          pattern: pattern.source,
          severity: 'HIGH'
        });
      }
    }

    return threats;
  }

  isRateLimitExceeded(ip) {
    const now = Date.now();
    const requests = this.rateLimiter.get(ip) || [];
    
    // 최근 1분간 요청 수
    const recentRequests = requests.filter(time => now - time < 60000);
    
    if (recentRequests.length > 100) {
      return true;
    }
    
    recentRequests.push(now);
    this.rateLimiter.set(ip, recentRequests);
    return false;
  }
}
```

## WAF 구현

### 웹 애플리케이션 방화벽

웹 공격을 차단하는 방화벽이다. AWS WAF, Cloudflare 등을 사용할 수 있다.

```javascript
class SimpleWAF {
  constructor() {
    this.blockedIPs = new Set();
    this.rules = this.loadRules();
  }

  loadRules() {
    return [
      { pattern: /\.\.\//g, action: 'BLOCK', reason: 'Directory Traversal' },
      { pattern: /<script>/gi, action: 'BLOCK', reason: 'XSS Attempt' },
      { pattern: /union.*select/gi, action: 'BLOCK', reason: 'SQL Injection' },
      { pattern: /eval\s*\(/gi, action: 'WARN', reason: 'Eval Usage' }
    ];
  }

  async inspect(request) {
    // IP 차단 확인
    if (this.blockedIPs.has(request.ip)) {
      return { action: 'BLOCK', reason: 'Blocked IP' };
    }

    // 규칙 검사
    const content = JSON.stringify(request.body) + request.url;
    for (const rule of this.rules) {
      if (rule.pattern.test(content)) {
        if (rule.action === 'BLOCK') {
          this.blockedIPs.add(request.ip);
        }
        return {
          action: rule.action,
          reason: rule.reason,
          pattern: rule.pattern.source
        };
      }
    }

    return { action: 'ALLOW' };
  }
}
```

## 인증/인가 보안 강화

### JWT 보안

JWT는 토큰 기반 인증에 사용한다. 토큰 탈취를 방지하기 위해 짧은 만료 시간과 refresh token을 사용한다.

```javascript
const jwt = require('jsonwebtoken');

class SecureJWTManager {
  constructor(secret, refreshSecret) {
    this.secret = secret;
    this.refreshSecret = refreshSecret;
    this.blacklist = new Set();
  }

  generateTokenPair(payload) {
    const accessToken = jwt.sign(payload, this.secret, {
      expiresIn: '15m',
      algorithm: 'HS256'
    });

    const refreshToken = jwt.sign(payload, this.refreshSecret, {
      expiresIn: '7d',
      algorithm: 'HS256'
    });

    return { accessToken, refreshToken };
  }

  verifyAccessToken(token) {
    if (this.blacklist.has(token)) {
      throw new Error('Token has been revoked');
    }

    try {
      return jwt.verify(token, this.secret);
    } catch (error) {
      throw new Error('Invalid token');
    }
  }

  revokeToken(token) {
    this.blacklist.add(token);
  }
}
```

### OAuth 2.0 구현

OAuth 2.0은 제3자 인증에 사용한다. 인가 코드 플로우를 사용하는 게 가장 안전하다.

```javascript
class OAuth2Server {
  async authorize(clientId, redirectUri, scope) {
    // 클라이언트 검증
    const client = await this.validateClient(clientId, redirectUri);
    
    // 인가 코드 생성
    const code = crypto.randomBytes(32).toString('hex');
    
    await this.storeAuthCode(code, {
      clientId,
      redirectUri,
      scope,
      expiresAt: Date.now() + 600000 // 10분
    });
    
    return code;
  }

  async token(code, clientId, clientSecret) {
    // 인가 코드 검증
    const authData = await this.validateAuthCode(code, clientId);
    
    // 클라이언트 인증
    await this.authenticateClient(clientId, clientSecret);
    
    // 액세스 토큰 발급
    const accessToken = jwt.sign(
      { clientId, scope: authData.scope },
      this.secret,
      { expiresIn: '1h' }
    );
    
    return {
      access_token: accessToken,
      token_type: 'Bearer',
      expires_in: 3600
    };
  }
}
```

## 암호화 및 키 관리

### 키 로테이션

정기적으로 키를 교체해 키 유출 시 피해를 최소화한다.

```javascript
class KeyRotationManager {
  constructor() {
    this.keys = [];
    this.currentKeyIndex = 0;
  }

  rotateKey() {
    const newKey = crypto.randomBytes(32);
    this.keys.push({
      key: newKey,
      createdAt: Date.now(),
      id: crypto.randomBytes(8).toString('hex')
    });
    
    this.currentKeyIndex = this.keys.length - 1;
    
    // 오래된 키 제거 (30일 이상)
    this.keys = this.keys.filter(k => 
      Date.now() - k.createdAt < 30 * 24 * 60 * 60 * 1000
    );
  }

  getCurrentKey() {
    return this.keys[this.currentKeyIndex];
  }

  getKeyById(keyId) {
    return this.keys.find(k => k.id === keyId);
  }
}
```

## 보안 사고 대응

### 침입 탐지 및 대응

보안 사고 발생 시 즉시 대응해야 한다. 자동화된 대응 시스템을 구축하는 게 좋다.

```javascript
class IncidentResponseSystem {
  constructor() {
    this.incidents = [];
    this.alertThreshold = {
      CRITICAL: 1,
      HIGH: 3,
      MEDIUM: 10
    };
  }

  async handleSecurityEvent(event) {
    // 사고 분류
    const severity = this.classifySeverity(event);
    
    // 자동 대응
    if (severity === 'CRITICAL') {
      await this.blockSource(event.source);
      await this.notifySecurityTeam(event);
      await this.isolateAffectedSystems(event);
    }
    
    // 로깅
    this.logIncident({
      ...event,
      severity,
      timestamp: Date.now()
    });
  }

  classifySeverity(event) {
    if (event.type === 'SQL_INJECTION' || event.type === 'RCE') {
      return 'CRITICAL';
    }
    if (event.type === 'XSS' || event.type === 'UNAUTHORIZED_ACCESS') {
      return 'HIGH';
    }
    return 'MEDIUM';
  }

  async blockSource(source) {
    // 방화벽에 IP 차단 규칙 추가
    await this.firewall.blockIP(source.ip);
  }
}
```

## 참고

### 보안 도구

| 도구 | 용도 | 권장도 |
|------|------|--------|
| OWASP ZAP | 동적 보안 테스트 | 높음 |
| SonarQube | 정적 코드 분석 | 높음 |
| Snyk | 의존성 취약점 검사 | 높음 |
| Burp Suite | 침투 테스트 | 중간 |
| npm audit | npm 패키지 취약점 검사 | 높음 |

### 관련 자료
- [OWASP Top 10](https://owasp.org/www-project-top-ten/)
- [NIST Cybersecurity Framework](https://www.nist.gov/cyberframework)
- [CWE (Common Weakness Enumeration)](https://cwe.mitre.org/)
- [CVE (Common Vulnerabilities and Exposures)](https://cve.mitre.org/)
