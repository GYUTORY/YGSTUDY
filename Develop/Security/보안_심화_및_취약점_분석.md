---
title: 보안 심화 및 취약점 분석
tags: [security, vulnerability-analysis, authentication, authorization, encryption, monitoring, incident-response]
updated: 2025-12-06
---

# 보안 심화 및 취약점 분석

## 개요

보안 취약점 분석과 대응 전략을 다룬다.

## OWASP Top 10 대응

### SQL Injection 방어

**취약한 코드:**
```javascript
const query = `SELECT * FROM users WHERE id = ${userId}`;
db.query(query); // SQL Injection 취약
```

**안전한 코드:**
```javascript
const query = 'SELECT * FROM users WHERE id = ?';
db.query(query, [userId]); // Prepared Statement 사용
```

**실무 팁:**
ORM을 사용하면 대부분 자동으로 방어된다. 직접 쿼리를 작성할 때만 주의하면 된다.

### XSS (Cross-Site Scripting) 방어

**입력 검증 및 이스케이핑:**
```javascript
function sanitizeInput(input) {
  return input
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#x27;')
    .replace(/\//g, '&#x2F;');
}

// Content Security Policy 설정
app.use(helmet.contentSecurityPolicy({
  directives: {
    defaultSrc: ["'self'"],
    scriptSrc: ["'self'", "'unsafe-inline'"],
    styleSrc: ["'self'", "'unsafe-inline'"]
  }
}));
```

### CSRF (Cross-Site Request Forgery) 방어

```javascript
const csrf = require('csurf');
const csrfProtection = csrf({ cookie: true });

app.post('/transfer', csrfProtection, (req, res) => {
  // CSRF 토큰 검증 완료
  processTransfer(req.body);
});
```

## 자동화된 보안 테스트

### 정적 분석 (SAST)

코드를 실행하지 않고 분석한다. SonarQube, ESLint 보안 플러그인 등을 사용한다.

```javascript
class StaticSecurityAnalyzer {
  constructor() {
    this.rules = {
      hardcodedSecrets: /(password|secret|key|token)\s*=\s*['"][^'"]+['"]/gi,
      sqlInjection: /query\s*\(\s*['"][^'"]*\+/gi,
      xssVulnerability: /innerHTML\s*=\s*[^;]+/gi,
      weakCrypto: /md5|sha1|des\s*\(/gi
    };
  }

  analyzeCode(code) {
    const vulnerabilities = [];
    
    for (const [type, pattern] of Object.entries(this.rules)) {
      const matches = code.match(pattern);
      if (matches) {
        vulnerabilities.push({
          type,
          matches,
          severity: this.getSeverity(type)
        });
      }
    }
    
    return vulnerabilities;
  }
}
```

### 동적 분석 (DAST)

실행 중인 애플리케이션을 테스트한다. OWASP ZAP, Burp Suite 등을 사용한다.

```javascript
class DynamicSecurityTester {
  async scanSQLInjection(targetUrl) {
    const payloads = [
      "' OR '1'='1",
      "'; DROP TABLE users; --",
      "' UNION SELECT * FROM information_schema.tables --"
    ];

    const results = [];
    
    for (const payload of payloads) {
      const response = await this.sendPayload(targetUrl, payload);
      if (this.detectSQLInjection(response)) {
        results.push({
          type: 'SQL_INJECTION',
          payload,
          severity: 'HIGH'
        });
      }
    }
    
    return results;
  }
}
```

## 보안 모니터링

### 실시간 위협 탐지

의심스러운 요청 패턴을 실시간으로 감지한다.

```javascript
class ThreatDetector {
  constructor() {
    this.rateLimiter = new Map();
    this.suspiciousPatterns = [
      /\.\.\//g,  // Directory traversal
      /<script>/gi,  // XSS
      /union.*select/gi  // SQL Injection
    ];
  }

  async detectThreat(request) {
    const threats = [];

    // Rate limiting 체크
    if (this.isRateLimitExceeded(request.ip)) {
      threats.push({ type: 'RATE_LIMIT', severity: 'MEDIUM' });
    }

    // 의심스러운 패턴 체크
    const content = JSON.stringify(request.body) + request.url;
    for (const pattern of this.suspiciousPatterns) {
      if (pattern.test(content)) {
        threats.push({
          type: 'SUSPICIOUS_PATTERN',
          pattern: pattern.source,
          severity: 'HIGH'
        });
      }
    }

    return threats;
  }

  isRateLimitExceeded(ip) {
    const now = Date.now();
    const requests = this.rateLimiter.get(ip) || [];
    
    // 최근 1분간 요청 수
    const recentRequests = requests.filter(time => now - time < 60000);
    
    if (recentRequests.length > 100) {
      return true;
    }
    
    recentRequests.push(now);
    this.rateLimiter.set(ip, recentRequests);
    return false;
  }
}
```

## WAF 구현

### 웹 애플리케이션 방화벽

웹 공격을 차단하는 방화벽이다. AWS WAF, Cloudflare 등을 사용할 수 있다.

```javascript
class SimpleWAF {
  constructor() {
    this.blockedIPs = new Set();
    this.rules = this.loadRules();
  }

  loadRules() {
    return [
      { pattern: /\.\.\//g, action: 'BLOCK', reason: 'Directory Traversal' },
      { pattern: /<script>/gi, action: 'BLOCK', reason: 'XSS Attempt' },
      { pattern: /union.*select/gi, action: 'BLOCK', reason: 'SQL Injection' },
      { pattern: /eval\s*\(/gi, action: 'WARN', reason: 'Eval Usage' }
    ];
  }

  async inspect(request) {
    // IP 차단 확인
    if (this.blockedIPs.has(request.ip)) {
      return { action: 'BLOCK', reason: 'Blocked IP' };
    }

    // 규칙 검사
    const content = JSON.stringify(request.body) + request.url;
    for (const rule of this.rules) {
      if (rule.pattern.test(content)) {
        if (rule.action === 'BLOCK') {
          this.blockedIPs.add(request.ip);
        }
        return {
          action: rule.action,
          reason: rule.reason,
          pattern: rule.pattern.source
        };
      }
    }

    return { action: 'ALLOW' };
  }
}
```

## 인증/인가 보안 강화

### JWT 보안

JWT는 토큰 기반 인증에 사용한다. 토큰 탈취를 방지하기 위해 짧은 만료 시간과 refresh token을 사용한다.

```javascript
const jwt = require('jsonwebtoken');

class SecureJWTManager {
  constructor(secret, refreshSecret) {
    this.secret = secret;
    this.refreshSecret = refreshSecret;
    this.blacklist = new Set();
  }

  generateTokenPair(payload) {
    const accessToken = jwt.sign(payload, this.secret, {
      expiresIn: '15m',
      algorithm: 'HS256'
    });

    const refreshToken = jwt.sign(payload, this.refreshSecret, {
      expiresIn: '7d',
      algorithm: 'HS256'
    });

    return { accessToken, refreshToken };
  }

  verifyAccessToken(token) {
    if (this.blacklist.has(token)) {
      throw new Error('Token has been revoked');
    }

    try {
      return jwt.verify(token, this.secret);
    } catch (error) {
      throw new Error('Invalid token');
    }
  }

  revokeToken(token) {
    this.blacklist.add(token);
  }
}
```

### OAuth 2.0 구현

OAuth 2.0은 제3자 인증에 사용한다. 인가 코드 플로우를 사용하는 게 가장 안전하다.

```javascript
class OAuth2Server {
  async authorize(clientId, redirectUri, scope) {
    // 클라이언트 검증
    const client = await this.validateClient(clientId, redirectUri);
    
    // 인가 코드 생성
    const code = crypto.randomBytes(32).toString('hex');
    
    await this.storeAuthCode(code, {
      clientId,
      redirectUri,
      scope,
      expiresAt: Date.now() + 600000 // 10분
    });
    
    return code;
  }

  async token(code, clientId, clientSecret) {
    // 인가 코드 검증
    const authData = await this.validateAuthCode(code, clientId);
    
    // 클라이언트 인증
    await this.authenticateClient(clientId, clientSecret);
    
    // 액세스 토큰 발급
    const accessToken = jwt.sign(
      { clientId, scope: authData.scope },
      this.secret,
      { expiresIn: '1h' }
    );
    
    return {
      access_token: accessToken,
      token_type: 'Bearer',
      expires_in: 3600
    };
  }
}
```

## 암호화 및 키 관리

### 키 로테이션

정기적으로 키를 교체해 키 유출 시 피해를 최소화한다.

```javascript
class KeyRotationManager {
  constructor() {
    this.keys = [];
    this.currentKeyIndex = 0;
  }

  rotateKey() {
    const newKey = crypto.randomBytes(32);
    this.keys.push({
      key: newKey,
      createdAt: Date.now(),
      id: crypto.randomBytes(8).toString('hex')
    });
    
    this.currentKeyIndex = this.keys.length - 1;
    
    // 오래된 키 제거 (30일 이상)
    this.keys = this.keys.filter(k => 
      Date.now() - k.createdAt < 30 * 24 * 60 * 60 * 1000
    );
  }

  getCurrentKey() {
    return this.keys[this.currentKeyIndex];
  }

  getKeyById(keyId) {
    return this.keys.find(k => k.id === keyId);
  }
}
```

## 보안 사고 대응

### 침입 탐지 및 대응

보안 사고 발생 시 즉시 대응해야 한다. 자동화된 대응 시스템을 구축하는 게 좋다.

```javascript
class IncidentResponseSystem {
  constructor() {
    this.incidents = [];
    this.alertThreshold = {
      CRITICAL: 1,
      HIGH: 3,
      MEDIUM: 10
    };
  }

  async handleSecurityEvent(event) {
    // 사고 분류
    const severity = this.classifySeverity(event);
    
    // 자동 대응
    if (severity === 'CRITICAL') {
      await this.blockSource(event.source);
      await this.notifySecurityTeam(event);
      await this.isolateAffectedSystems(event);
    }
    
    // 로깅
    this.logIncident({
      ...event,
      severity,
      timestamp: Date.now()
    });
  }

  classifySeverity(event) {
    if (event.type === 'SQL_INJECTION' || event.type === 'RCE') {
      return 'CRITICAL';
    }
    if (event.type === 'XSS' || event.type === 'UNAUTHORIZED_ACCESS') {
      return 'HIGH';
    }
    return 'MEDIUM';
  }

  async blockSource(source) {
    // 방화벽에 IP 차단 규칙 추가
    await this.firewall.blockIP(source.ip);
  }
}
```

## 참고

### 보안 도구

| 도구 | 용도 | 권장도 |
|------|------|--------|
| OWASP ZAP | 동적 보안 테스트 | 높음 |
| SonarQube | 정적 코드 분석 | 높음 |
| Snyk | 의존성 취약점 검사 | 높음 |
| Burp Suite | 침투 테스트 | 중간 |

### 관련 자료
- [OWASP Top 10](https://owasp.org/www-project-top-ten/)
- [NIST Cybersecurity Framework](https://www.nist.gov/cyberframework)
- [CWE (Common Weakness Enumeration)](https://cwe.mitre.org/)
- [CVE (Common Vulnerabilities and Exposures)](https://cve.mitre.org/)
