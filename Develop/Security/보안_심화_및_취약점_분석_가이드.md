---
title: 보안 심화 및 취약점 분석 가이드
tags: [security, vulnerability-analysis, authentication, authorization, encryption, monitoring, incident-response]
updated: 2024-09-14
---

# 보안 심화 및 취약점 분석 가이드 (Advanced Security and Vulnerability Analysis Guide)

## 📋 목차
1. [OWASP Top 10 취약점 심화 분석 및 고급 방어 전략](#owasp-top-10-취약점-심화-분석-및-고급-방어-전략)
2. [자동화된 보안 테스트 파이프라인](#자동화된-보안-테스트-파이프라인)
3. [실시간 보안 모니터링 시스템](#실시간-보안-모니터링-시스템)
4. [WAF 및 보안 미들웨어 구현](#waf-및-보안-미들웨어-구현)
5. [보안 사고 대응 자동화](#보안-사고-대응-자동화)
6. [인증/인가 시스템 보안 강화](#인증인가-시스템-보안-강화)
7. [데이터 암호화 및 키 관리](#데이터-암호화-및-키-관리)
8. [보안 모니터링 및 침입 탐지](#보안-모니터링-및-침입-탐지)
9. [실제 보안 사고 대응 사례 및 복구 절차](#실제-보안-사고-대응-사례-및-복구-절차)

### 📌 통합된 기존 파일들
이 가이드는 다음 기존 파일들의 내용을 심화하여 더 체계적으로 정리한 것입니다:
- **OWASP Top 10 대응 가이드**: 기본적인 취약점 방어 → 고급 방어 전략으로 확장
- **AES/RSA 암호화**: 기본 암호화 → 키 관리 및 로테이션 전략으로 확장
- **OAuth 2.0**: 기본 인증 → 보안 강화된 인증/인가 시스템으로 확장

---

## OWASP Top 10 취약점 심화 분석 및 고급 방어 전략

### 1. 고급 취약점 분석 기법

#### 동적 보안 테스트 (DAST)
```javascript
class DynamicSecurityTester {
  constructor() {
    this.vulnerabilityScanners = {
      sqlInjection: new SQLInjectionScanner(),
      xss: new XSSScanner(),
      csrf: new CSRFScanner(),
      authentication: new AuthenticationScanner()
    };
  }

  // SQL Injection 고급 탐지
  async scanSQLInjection(targetUrl) {
    const payloads = [
      "' OR '1'='1",
      "'; DROP TABLE users; --",
      "' UNION SELECT * FROM information_schema.tables --",
      "' AND (SELECT COUNT(*) FROM users) > 0 --"
    ];

    const results = [];
    
    for (const payload of payloads) {
      const response = await this.sendPayload(targetUrl, payload);
      
      if (this.detectSQLInjection(response)) {
        results.push({
          type: 'SQL_INJECTION',
          payload,
          severity: 'HIGH',
          evidence: response.body,
          recommendation: 'Use parameterized queries'
        });
      }
    }
    
    return results;
  }

  // XSS 고급 탐지
  async scanXSS(targetUrl) {
    const xssPayloads = [
      "<script>alert('XSS')</script>",
      "javascript:alert('XSS')",
      "<img src=x onerror=alert('XSS')>",
      "<svg onload=alert('XSS')>",
      "';alert('XSS');//"
    ];

    const results = [];
    
    for (const payload of xssPayloads) {
      const response = await this.sendPayload(targetUrl, payload);
      
      if (this.detectXSS(response)) {
        results.push({
          type: 'XSS',
          payload,
          severity: 'MEDIUM',
          evidence: response.body,
          recommendation: 'Implement proper input sanitization'
        });
      }
    }
    
    return results;
  }

  detectSQLInjection(response) {
    const sqlErrorPatterns = [
      /mysql_fetch_array\(\)/i,
      /ORA-01756/i,
      /Microsoft OLE DB Provider/i,
      /SQLServer JDBC Driver/i,
      /PostgreSQL query failed/i
    ];
    
    return sqlErrorPatterns.some(pattern => pattern.test(response.body));
  }

  detectXSS(response) {
    return response.body.includes('alert(') || 
           response.body.includes('<script>') ||
           response.body.includes('javascript:');
  }
}
```

#### 정적 보안 테스트 (SAST)
```javascript
class StaticSecurityAnalyzer {
  constructor() {
    this.rules = {
      hardcodedSecrets: /(password|secret|key|token)\s*=\s*['"][^'"]+['"]/gi,
      sqlInjection: /query\s*\(\s*['"][^'"]*\+/gi,
      xssVulnerability: /innerHTML\s*=\s*[^;]+/gi,
      weakCrypto: /md5|sha1|des\s*\(/gi
    };
  }

  analyzeCode(code) {
    const vulnerabilities = [];
    
    for (const [type, pattern] of Object.entries(this.rules)) {
      const matches = code.match(pattern);
      
      if (matches) {
        vulnerabilities.push({
          type,
          matches,
          severity: this.getSeverity(type),
          recommendation: this.getRecommendation(type)
        });
      }
    }
    
    return vulnerabilities;
  }

  getSeverity(type) {
    const severityMap = {
      hardcodedSecrets: 'CRITICAL',
      sqlInjection: 'HIGH',
      xssVulnerability: 'MEDIUM',
      weakCrypto: 'HIGH'
    };
    
    return severityMap[type] || 'LOW';
  }

  getRecommendation(type) {
    const recommendations = {
      hardcodedSecrets: 'Use environment variables for sensitive data',
      sqlInjection: 'Use parameterized queries or ORM',
      xssVulnerability: 'Use textContent instead of innerHTML',
      weakCrypto: 'Use strong cryptographic algorithms (AES-256, SHA-256)'
    };
    
    return recommendations[type];
  }
}
```

### 2. 고급 방어 전략

#### 다층 보안 방어 (Defense in Depth)
```javascript
class MultiLayerSecurity {
  constructor() {
    this.layers = {
      network: new NetworkSecurityLayer(),
      application: new ApplicationSecurityLayer(),
      data: new DataSecurityLayer(),
      monitoring: new SecurityMonitoringLayer()
    };
  }

  // 네트워크 레벨 보안
  setupNetworkSecurity() {
    return {
      firewall: {
        rules: [
          { action: 'DENY', source: '0.0.0.0/0', port: 22 },
          { action: 'ALLOW', source: '10.0.0.0/8', port: 443 },
          { action: 'DENY', source: 'any', port: 'any' }
        ]
      },
      waf: {
        rules: [
          { type: 'SQL_INJECTION', action: 'BLOCK' },
          { type: 'XSS', action: 'BLOCK' },
          { type: 'RATE_LIMIT', threshold: 100, window: 60 }
        ]
      },
      ddos: {
        protection: true,
        threshold: 1000,
        mitigation: 'AUTO'
      }
    };
  }

  // 애플리케이션 레벨 보안
  setupApplicationSecurity() {
    return {
      authentication: {
        multiFactor: true,
        sessionTimeout: 1800,
        maxAttempts: 5,
        lockoutDuration: 900
      },
      authorization: {
        rbac: true,
        principle: 'LEAST_PRIVILEGE',
        audit: true
      },
      inputValidation: {
        sanitization: true,
        encoding: 'UTF-8',
        maxLength: 1000
      }
    };
  }
}
```

---

## 인증/인가 시스템 보안 강화

### 1. JWT 보안 강화

#### JWT 토큰 보안 강화
```javascript
class SecureJWTManager {
  constructor() {
    this.secretKey = process.env.JWT_SECRET;
    this.refreshSecretKey = process.env.JWT_REFRESH_SECRET;
    this.algorithm = 'HS256';
    this.accessTokenExpiry = '15m';
    this.refreshTokenExpiry = '7d';
    this.tokenBlacklist = new Set();
  }

  // 보안 강화된 JWT 생성
  generateSecureTokens(user) {
    const payload = {
      sub: user.id,
      email: user.email,
      roles: user.roles,
      iat: Math.floor(Date.now() / 1000),
      jti: this.generateJTI(), // JWT ID for tracking
      iss: 'your-app', // Issuer
      aud: 'your-app-users' // Audience
    };

    const accessToken = jwt.sign(payload, this.secretKey, {
      algorithm: this.algorithm,
      expiresIn: this.accessTokenExpiry
    });

    const refreshToken = jwt.sign(
      { sub: user.id, jti: this.generateJTI() },
      this.refreshSecretKey,
      { expiresIn: this.refreshTokenExpiry }
    );

    return { accessToken, refreshToken };
  }

  // JWT 검증 및 보안 체크
  verifyToken(token) {
    try {
      // 토큰 블랙리스트 확인
      if (this.tokenBlacklist.has(token)) {
        throw new Error('Token is blacklisted');
      }

      const decoded = jwt.verify(token, this.secretKey, {
        algorithms: [this.algorithm],
        issuer: 'your-app',
        audience: 'your-app-users'
      });

      // 토큰 만료 시간 체크
      if (decoded.exp < Date.now() / 1000) {
        throw new Error('Token has expired');
      }

      // 추가 보안 검증
      this.validateTokenClaims(decoded);

      return decoded;
    } catch (error) {
      throw new Error(`Token verification failed: ${error.message}`);
    }
  }

  // 토큰 무효화
  revokeToken(token) {
    this.tokenBlacklist.add(token);
    
    // Redis나 데이터베이스에 저장하여 영구 보관
    this.storeBlacklistedToken(token);
  }

  // 토큰 갱신
  async refreshToken(refreshToken) {
    try {
      const decoded = jwt.verify(refreshToken, this.refreshSecretKey);
      
      // 사용자 정보 조회
      const user = await this.getUserById(decoded.sub);
      
      if (!user) {
        throw new Error('User not found');
      }

      // 새로운 토큰 생성
      const newTokens = this.generateSecureTokens(user);
      
      // 기존 리프레시 토큰 무효화
      this.revokeToken(refreshToken);
      
      return newTokens;
    } catch (error) {
      throw new Error(`Token refresh failed: ${error.message}`);
    }
  }
}
```

### 2. OAuth 2.0 보안 강화

#### OAuth 2.0 보안 강화 구현
```javascript
class SecureOAuth2Provider {
  constructor() {
    this.clients = new Map();
    this.authorizationCodes = new Map();
    this.accessTokens = new Map();
    this.rateLimiter = new Map();
  }

  // 클라이언트 등록 및 보안 검증
  registerClient(clientInfo) {
    const clientId = this.generateClientId();
    const clientSecret = this.generateClientSecret();
    
    const client = {
      id: clientId,
      secret: this.hashClientSecret(clientSecret),
      redirectUris: clientInfo.redirectUris,
      scopes: clientInfo.scopes,
      grantTypes: clientInfo.grantTypes,
      createdAt: new Date(),
      lastUsed: null
    };

    this.clients.set(clientId, client);
    
    return { clientId, clientSecret };
  }

  // 인증 코드 발급 (PKCE 지원)
  generateAuthorizationCode(clientId, userId, scopes, codeChallenge) {
    const code = this.generateSecureCode();
    
    const authCode = {
      code,
      clientId,
      userId,
      scopes,
      codeChallenge,
      expiresAt: new Date(Date.now() + 600000), // 10분
      used: false
    };

    this.authorizationCodes.set(code, authCode);
    
    return code;
  }

  // 액세스 토큰 발급
  generateAccessToken(authCode, codeVerifier) {
    const authCodeData = this.authorizationCodes.get(authCode);
    
    if (!authCodeData || authCodeData.used) {
      throw new Error('Invalid or used authorization code');
    }

    if (authCodeData.expiresAt < new Date()) {
      throw new Error('Authorization code has expired');
    }

    // PKCE 검증
    if (authCodeData.codeChallenge) {
      const expectedChallenge = this.generateCodeChallenge(codeVerifier);
      if (expectedChallenge !== authCodeData.codeChallenge) {
        throw new Error('Invalid code verifier');
      }
    }

    // 토큰 생성
    const accessToken = this.generateSecureToken();
    const refreshToken = this.generateSecureToken();
    
    const tokenData = {
      accessToken,
      refreshToken,
      clientId: authCodeData.clientId,
      userId: authCodeData.userId,
      scopes: authCodeData.scopes,
      expiresAt: new Date(Date.now() + 3600000), // 1시간
      createdAt: new Date()
    };

    this.accessTokens.set(accessToken, tokenData);
    authCodeData.used = true;
    
    return tokenData;
  }

  // 토큰 검증
  validateToken(token) {
    const tokenData = this.accessTokens.get(token);
    
    if (!tokenData) {
      throw new Error('Invalid token');
    }

    if (tokenData.expiresAt < new Date()) {
      this.accessTokens.delete(token);
      throw new Error('Token has expired');
    }

    return tokenData;
  }
}
```

### 3. RBAC (Role-Based Access Control) 고급 구현

#### 세밀한 권한 제어 시스템
```javascript
class AdvancedRBAC {
  constructor() {
    this.roles = new Map();
    this.permissions = new Map();
    this.resources = new Map();
    this.policies = new Map();
  }

  // 역할 및 권한 정의
  defineRole(roleName, permissions) {
    this.roles.set(roleName, {
      name: roleName,
      permissions: new Set(permissions),
      createdAt: new Date(),
      updatedAt: new Date()
    });
  }

  // 리소스 기반 권한 정의
  defineResource(resourceName, actions) {
    this.resources.set(resourceName, {
      name: resourceName,
      actions: new Set(actions),
      attributes: new Map()
    });
  }

  // 정책 기반 접근 제어 (ABAC)
  definePolicy(policyName, conditions) {
    this.policies.set(policyName, {
      name: policyName,
      conditions,
      effect: 'ALLOW' // 또는 'DENY'
    });
  }

  // 권한 검증
  checkPermission(user, resource, action, context = {}) {
    const userRoles = user.roles || [];
    
    for (const roleName of userRoles) {
      const role = this.roles.get(roleName);
      if (!role) continue;

      // 기본 권한 확인
      if (role.permissions.has(`${resource}:${action}`)) {
        // 정책 기반 추가 검증
        if (this.evaluatePolicies(user, resource, action, context)) {
          return true;
        }
      }
    }

    return false;
  }

  // 정책 평가
  evaluatePolicies(user, resource, action, context) {
    for (const [policyName, policy] of this.policies) {
      if (this.matchesPolicy(policy, user, resource, action, context)) {
        return policy.effect === 'ALLOW';
      }
    }
    
    return true; // 기본적으로 허용
  }

  // 동적 권한 부여
  grantTemporaryPermission(userId, resource, action, expiresAt) {
    const tempPermission = {
      userId,
      resource,
      action,
      expiresAt,
      grantedAt: new Date()
    };

    // 임시 권한 저장 (Redis 등)
    this.storeTemporaryPermission(tempPermission);
  }
}
```

---

## 데이터 암호화 및 키 관리

### 1. 키 관리 시스템 (KMS)

#### 키 생명주기 관리
```javascript
class KeyManagementSystem {
  constructor() {
    this.keys = new Map();
    this.keyVersions = new Map();
    this.rotationSchedule = new Map();
  }

  // 키 생성
  generateKey(keyId, algorithm = 'AES-256-GCM') {
    const key = {
      id: keyId,
      algorithm,
      material: crypto.randomBytes(32),
      version: 1,
      createdAt: new Date(),
      status: 'ACTIVE',
      usage: 'ENCRYPT_DECRYPT'
    };

    this.keys.set(keyId, key);
    this.keyVersions.set(keyId, [key]);
    
    return key;
  }

  // 키 로테이션
  rotateKey(keyId) {
    const currentKey = this.keys.get(keyId);
    if (!currentKey) {
      throw new Error('Key not found');
    }

    const newKey = {
      id: keyId,
      algorithm: currentKey.algorithm,
      material: crypto.randomBytes(32),
      version: currentKey.version + 1,
      createdAt: new Date(),
      status: 'ACTIVE',
      usage: currentKey.usage
    };

    // 이전 키를 비활성화
    currentKey.status = 'INACTIVE';
    currentKey.rotatedAt = new Date();

    // 새 키 활성화
    this.keys.set(keyId, newKey);
    this.keyVersions.get(keyId).push(newKey);

    return newKey;
  }

  // 자동 키 로테이션 스케줄링
  scheduleKeyRotation(keyId, intervalDays = 90) {
    const rotationDate = new Date();
    rotationDate.setDate(rotationDate.getDate() + intervalDays);
    
    this.rotationSchedule.set(keyId, {
      nextRotation: rotationDate,
      interval: intervalDays * 24 * 60 * 60 * 1000 // 밀리초
    });

    // 스케줄된 로테이션 실행
    this.setupRotationTimer(keyId);
  }

  // 암호화 (키 버전 자동 선택)
  encrypt(data, keyId) {
    const key = this.keys.get(keyId);
    if (!key || key.status !== 'ACTIVE') {
      throw new Error('Key not available');
    }

    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipher(key.algorithm, key.material);
    cipher.setAAD(Buffer.from(keyId, 'utf8'));

    let encrypted = cipher.update(data, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    
    const authTag = cipher.getAuthTag();

    return {
      encrypted,
      iv: iv.toString('hex'),
      authTag: authTag.toString('hex'),
      keyVersion: key.version,
      algorithm: key.algorithm
    };
  }

  // 복호화 (키 버전 자동 선택)
  decrypt(encryptedData, keyId) {
    const keyVersions = this.keyVersions.get(keyId);
    if (!keyVersions) {
      throw new Error('Key not found');
    }

    // 키 버전으로 키 찾기
    const key = keyVersions.find(k => k.version === encryptedData.keyVersion);
    if (!key) {
      throw new Error('Key version not found');
    }

    const decipher = crypto.createDecipher(key.algorithm, key.material);
    decipher.setAAD(Buffer.from(keyId, 'utf8'));
    decipher.setAuthTag(Buffer.from(encryptedData.authTag, 'hex'));

    let decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');

    return decrypted;
  }
}
```

### 2. 데이터베이스 암호화

#### 투명한 데이터 암호화 (TDE)
```javascript
class TransparentDataEncryption {
  constructor(kms) {
    this.kms = kms;
    this.encryptedColumns = new Map();
  }

  // 컬럼 암호화 설정
  setupColumnEncryption(tableName, columnName, keyId) {
    const columnKey = `${tableName}.${columnName}`;
    this.encryptedColumns.set(columnKey, {
      keyId,
      algorithm: 'AES-256-GCM',
      createdAt: new Date()
    });
  }

  // 데이터 삽입 시 자동 암호화
  async insertEncryptedData(tableName, data) {
    const encryptedData = { ...data };
    
    for (const [column, value] of Object.entries(data)) {
      const columnKey = `${tableName}.${column}`;
      const encryptionConfig = this.encryptedColumns.get(columnKey);
      
      if (encryptionConfig && value !== null) {
        encryptedData[column] = await this.encryptValue(value, encryptionConfig.keyId);
      }
    }

    return encryptedData;
  }

  // 데이터 조회 시 자동 복호화
  async decryptQueryResult(tableName, results) {
    const decryptedResults = [];
    
    for (const row of results) {
      const decryptedRow = { ...row };
      
      for (const [column, value] of Object.entries(row)) {
        const columnKey = `${tableName}.${column}`;
        const encryptionConfig = this.encryptedColumns.get(columnKey);
        
        if (encryptionConfig && value !== null) {
          decryptedRow[column] = await this.decryptValue(value, encryptionConfig.keyId);
        }
      }
      
      decryptedResults.push(decryptedRow);
    }

    return decryptedResults;
  }

  // 값 암호화
  async encryptValue(value, keyId) {
    const stringValue = JSON.stringify(value);
    const encrypted = this.kms.encrypt(stringValue, keyId);
    
    return JSON.stringify(encrypted);
  }

  // 값 복호화
  async decryptValue(encryptedValue, keyId) {
    const encryptedData = JSON.parse(encryptedValue);
    const decrypted = this.kms.decrypt(encryptedData, keyId);
    
    return JSON.parse(decrypted);
  }
}
```

---

## 보안 모니터링 및 침입 탐지

### 1. SIEM (Security Information and Event Management)

#### 실시간 보안 이벤트 수집 및 분석
```javascript
class SIEMSystem {
  constructor() {
    this.eventCollectors = new Map();
    this.analyzers = new Map();
    this.alertRules = new Map();
    this.incidents = new Map();
  }

  // 보안 이벤트 수집
  collectSecurityEvent(event) {
    const securityEvent = {
      id: this.generateEventId(),
      timestamp: new Date(),
      source: event.source,
      type: event.type,
      severity: event.severity,
      data: event.data,
      raw: event.raw
    };

    // 이벤트 저장
    this.storeEvent(securityEvent);
    
    // 실시간 분석
    this.analyzeEvent(securityEvent);
    
    return securityEvent;
  }

  // 이벤트 분석
  analyzeEvent(event) {
    const analysisResults = [];
    
    // 각 분석기 실행
    for (const [analyzerName, analyzer] of this.analyzers) {
      try {
        const result = analyzer.analyze(event);
        if (result) {
          analysisResults.push({
            analyzer: analyzerName,
            result,
            confidence: result.confidence || 0.8
          });
        }
      } catch (error) {
        console.error(`Analyzer ${analyzerName} failed:`, error);
      }
    }

    // 결과 통합 및 알림 생성
    if (analysisResults.length > 0) {
      this.generateAlert(event, analysisResults);
    }
  }

  // 침입 탐지 규칙
  setupIntrusionDetectionRules() {
    // Brute Force 공격 탐지
    this.addRule('brute_force', {
      condition: (events) => {
        const failedLogins = events.filter(e => 
          e.type === 'LOGIN_FAILED' && 
          Date.now() - e.timestamp.getTime() < 300000 // 5분 내
        );
        
        return failedLogins.length >= 5;
      },
      action: 'BLOCK_IP',
      severity: 'HIGH'
    });

    // SQL Injection 시도 탐지
    this.addRule('sql_injection', {
      condition: (events) => {
        return events.some(e => 
          e.type === 'HTTP_REQUEST' &&
          e.data.url.includes('union') &&
          e.data.url.includes('select')
        );
      },
      action: 'ALERT_SECURITY_TEAM',
      severity: 'CRITICAL'
    });

    // 비정상적인 데이터 접근 패턴
    this.addRule('data_exfiltration', {
      condition: (events) => {
        const dataAccess = events.filter(e => 
          e.type === 'DATA_ACCESS' &&
          Date.now() - e.timestamp.getTime() < 3600000 // 1시간 내
        );
        
        return dataAccess.length > 1000; // 1000건 이상 접근
      },
      action: 'INVESTIGATE_USER',
      severity: 'MEDIUM'
    });
  }

  // 알림 생성
  generateAlert(event, analysisResults) {
    const alert = {
      id: this.generateAlertId(),
      timestamp: new Date(),
      eventId: event.id,
      severity: this.calculateSeverity(analysisResults),
      title: this.generateAlertTitle(event, analysisResults),
      description: this.generateAlertDescription(event, analysisResults),
      recommendations: this.generateRecommendations(analysisResults),
      status: 'OPEN'
    };

    this.storeAlert(alert);
    this.sendNotification(alert);
    
    return alert;
  }
}
```

### 2. 로그 분석 및 상관관계 분석

#### 고급 로그 분석 시스템
```javascript
class LogAnalysisSystem {
  constructor() {
    this.logParsers = new Map();
    this.correlationRules = new Map();
    this.threatIntelligence = new Map();
  }

  // 로그 파싱 및 정규화
  parseLog(logEntry) {
    const parsedLog = {
      timestamp: this.extractTimestamp(logEntry),
      source: this.extractSource(logEntry),
      level: this.extractLevel(logEntry),
      message: this.extractMessage(logEntry),
      fields: this.extractFields(logEntry),
      raw: logEntry
    };

    return parsedLog;
  }

  // 상관관계 분석
  correlateEvents(events, timeWindow = 300000) { // 5분
    const correlations = [];
    const sortedEvents = events.sort((a, b) => a.timestamp - b.timestamp);
    
    for (let i = 0; i < sortedEvents.length; i++) {
      const currentEvent = sortedEvents[i];
      const relatedEvents = [];
      
      // 시간 윈도우 내의 관련 이벤트 찾기
      for (let j = i + 1; j < sortedEvents.length; j++) {
        const nextEvent = sortedEvents[j];
        
        if (nextEvent.timestamp - currentEvent.timestamp > timeWindow) {
          break;
        }
        
        if (this.areEventsRelated(currentEvent, nextEvent)) {
          relatedEvents.push(nextEvent);
        }
      }
      
      if (relatedEvents.length > 0) {
        correlations.push({
          primaryEvent: currentEvent,
          relatedEvents,
          correlationScore: this.calculateCorrelationScore(currentEvent, relatedEvents),
          timeWindow
        });
      }
    }
    
    return correlations;
  }

  // 위협 인텔리전스 연동
  enrichWithThreatIntelligence(event) {
    const enrichedEvent = { ...event };
    
    // IP 주소 위협 인텔리전스 확인
    if (event.sourceIP) {
      const threatInfo = this.threatIntelligence.get(event.sourceIP);
      if (threatInfo) {
        enrichedEvent.threatIntelligence = {
          isMalicious: threatInfo.isMalicious,
          threatType: threatInfo.threatType,
          confidence: threatInfo.confidence,
          lastSeen: threatInfo.lastSeen
        };
      }
    }
    
    // 도메인 위협 인텔리전스 확인
    if (event.domain) {
      const domainThreatInfo = this.threatIntelligence.get(event.domain);
      if (domainThreatInfo) {
        enrichedEvent.domainThreatIntelligence = domainThreatInfo;
      }
    }
    
    return enrichedEvent;
  }
}
```

---

## 실제 보안 사고 대응 사례 및 복구 절차

### 1. 보안 사고 대응 플레이북

#### 데이터 유출 사고 대응
```javascript
class DataBreachResponse {
  constructor() {
    this.responseTeam = {
      incidentCommander: null,
      technicalLead: null,
      legalCounsel: null,
      communicationsLead: null
    };
    this.responseSteps = [];
  }

  // 1단계: 초기 대응 (0-1시간)
  async initialResponse(incident) {
    const response = {
      step: 'INITIAL_RESPONSE',
      timestamp: new Date(),
      actions: []
    };

    // 1. 사고 확인 및 분류
    const classification = await this.classifyIncident(incident);
    response.actions.push({
      action: 'CLASSIFY_INCIDENT',
      result: classification,
      timestamp: new Date()
    });

    // 2. 영향 범위 평가
    const impact = await this.assessImpact(incident);
    response.actions.push({
      action: 'ASSESS_IMPACT',
      result: impact,
      timestamp: new Date()
    });

    // 3. 초기 격리 조치
    const isolation = await this.isolateAffectedSystems(incident);
    response.actions.push({
      action: 'ISOLATE_SYSTEMS',
      result: isolation,
      timestamp: new Date()
    });

    // 4. 대응팀 소집
    await this.assembleResponseTeam(classification.severity);
    response.actions.push({
      action: 'ASSEMBLE_TEAM',
      result: 'Team assembled',
      timestamp: new Date()
    });

    this.responseSteps.push(response);
    return response;
  }

  // 2단계: 조사 및 분석 (1-24시간)
  async investigationPhase(incident) {
    const response = {
      step: 'INVESTIGATION',
      timestamp: new Date(),
      actions: []
    };

    // 1. 포렌식 증거 수집
    const evidence = await this.collectForensicEvidence(incident);
    response.actions.push({
      action: 'COLLECT_EVIDENCE',
      result: evidence,
      timestamp: new Date()
    });

    // 2. 공격 벡터 분석
    const attackVector = await this.analyzeAttackVector(incident);
    response.actions.push({
      action: 'ANALYZE_ATTACK_VECTOR',
      result: attackVector,
      timestamp: new Date()
    });

    // 3. 피해 범위 정확한 평가
    const damageAssessment = await this.assessDamage(incident);
    response.actions.push({
      action: 'ASSESS_DAMAGE',
      result: damageAssessment,
      timestamp: new Date()
    });

    // 4. 취약점 분석
    const vulnerabilities = await this.analyzeVulnerabilities(incident);
    response.actions.push({
      action: 'ANALYZE_VULNERABILITIES',
      result: vulnerabilities,
      timestamp: new Date()
    });

    this.responseSteps.push(response);
    return response;
  }

  // 3단계: 복구 및 복원 (24-72시간)
  async recoveryPhase(incident) {
    const response = {
      step: 'RECOVERY',
      timestamp: new Date(),
      actions: []
    };

    // 1. 취약점 패치
    const patching = await this.patchVulnerabilities(incident.vulnerabilities);
    response.actions.push({
      action: 'PATCH_VULNERABILITIES',
      result: patching,
      timestamp: new Date()
    });

    // 2. 시스템 복원
    const restoration = await this.restoreSystems(incident.affectedSystems);
    response.actions.push({
      action: 'RESTORE_SYSTEMS',
      result: restoration,
      timestamp: new Date()
    });

    // 3. 보안 강화
    const hardening = await this.hardenSecurity(incident);
    response.actions.push({
      action: 'HARDEN_SECURITY',
      result: hardening,
      timestamp: new Date()
    });

    // 4. 모니터링 강화
    const monitoring = await this.enhanceMonitoring(incident);
    response.actions.push({
      action: 'ENHANCE_MONITORING',
      result: monitoring,
      timestamp: new Date()
    });

    this.responseSteps.push(response);
    return response;
  }

  // 4단계: 사후 분석 및 개선 (72시간 이후)
  async postIncidentAnalysis(incident) {
    const response = {
      step: 'POST_INCIDENT_ANALYSIS',
      timestamp: new Date(),
      actions: []
    };

    // 1. 사고 원인 분석
    const rootCause = await this.analyzeRootCause(incident);
    response.actions.push({
      action: 'ANALYZE_ROOT_CAUSE',
      result: rootCause,
      timestamp: new Date()
    });

    // 2. 대응 과정 평가
    const responseEvaluation = await this.evaluateResponse(incident);
    response.actions.push({
      action: 'EVALUATE_RESPONSE',
      result: responseEvaluation,
      timestamp: new Date()
    });

    // 3. 개선 사항 도출
    const improvements = await this.identifyImprovements(incident);
    response.actions.push({
      action: 'IDENTIFY_IMPROVEMENTS',
      result: improvements,
      timestamp: new Date()
    });

    // 4. 플레이북 업데이트
    await this.updatePlaybook(improvements);
    response.actions.push({
      action: 'UPDATE_PLAYBOOK',
      result: 'Playbook updated',
      timestamp: new Date()
    });

    this.responseSteps.push(response);
    return response;
  }
}
```

### 2. 실제 사고 사례 분석

#### 사례 1: SQL Injection을 통한 데이터 유출
```javascript
class SQLInjectionBreachCase {
  constructor() {
    this.incident = {
      id: 'INC-2024-001',
      type: 'DATA_BREACH',
      severity: 'CRITICAL',
      discoveredAt: new Date('2024-01-15T10:30:00Z'),
      affectedData: ['user_credentials', 'personal_information', 'payment_data']
    };
  }

  // 사고 시나리오 재현
  async reproduceIncident() {
    return {
      attackVector: 'SQL Injection',
      entryPoint: '/api/users/search',
      vulnerableCode: `
        app.get('/api/users/search', (req, res) => {
          const query = req.query.q;
          const sql = \`SELECT * FROM users WHERE name LIKE '%\${query}%'\`;
          db.query(sql, (err, results) => {
            res.json(results);
          });
        });
      `,
      attackPayload: "'; DROP TABLE users; --",
      impact: {
        dataExposed: 50000,
        systemsAffected: 3,
        downtime: 8 // hours
      }
    };
  }

  // 대응 과정 분석
  analyzeResponse() {
    return {
      detectionTime: '2 hours',
      containmentTime: '4 hours',
      eradicationTime: '12 hours',
      recoveryTime: '24 hours',
      lessonsLearned: [
        'Input validation was insufficient',
        'Database access controls were weak',
        'Monitoring was inadequate',
        'Incident response was slow'
      ],
      improvements: [
        'Implement parameterized queries',
        'Add WAF protection',
        'Enhance database monitoring',
        'Improve incident response procedures'
      ]
    };
  }
}
```

#### 사례 2: 인증 우회를 통한 권한 상승
```javascript
class AuthenticationBypassCase {
  constructor() {
    this.incident = {
      id: 'INC-2024-002',
      type: 'PRIVILEGE_ESCALATION',
      severity: 'HIGH',
      discoveredAt: new Date('2024-02-20T14:15:00Z'),
      affectedSystems: ['admin_panel', 'user_management']
    };
  }

  // 공격 시나리오 분석
  async analyzeAttack() {
    return {
      vulnerability: 'JWT Token Manipulation',
      attackMethod: 'Algorithm Confusion Attack',
      technicalDetails: {
        originalToken: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...',
        manipulatedToken: 'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0...',
        algorithmChanged: 'HS256 → none',
        payload: {
          sub: 'admin',
          role: 'super_admin',
          exp: 9999999999
        }
      },
      impact: {
        adminAccountsCompromised: 2,
        dataAccessGained: 'All user data',
        systemsCompromised: 5
      }
    };
  }

  // 방어 전략 개선
  getDefenseImprovements() {
    return {
      immediateActions: [
        'Revoke all existing JWT tokens',
        'Implement algorithm whitelist',
        'Add token signature verification',
        'Enable token blacklisting'
      ],
      longTermImprovements: [
        'Implement OAuth 2.0 with PKCE',
        'Add multi-factor authentication',
        'Implement role-based access control',
        'Add session management'
      ],
      monitoringEnhancements: [
        'JWT token validation monitoring',
        'Unusual authentication pattern detection',
        'Admin action logging',
        'Real-time alerting for privilege escalation'
      ]
    };
  }
}
```

---

## 결론

보안 심화 및 취약점 분석은 지속적인 과정으로, 다음과 같은 핵심 원칙을 따라야 합니다:

### 핵심 원칙 요약

1. **다층 방어**: 네트워크, 애플리케이션, 데이터 레벨의 통합 보안
2. **지속적 모니터링**: 실시간 보안 이벤트 감지 및 대응
3. **자동화된 대응**: 보안 사고 발생 시 신속한 자동 대응
4. **정기적 평가**: 보안 상태의 지속적인 평가 및 개선
5. **팀 교육**: 보안 인식 향상을 위한 정기 교육

### 실무 적용 가이드

- **개발 단계**: 보안 우선 설계 및 코드 리뷰
- **테스트 단계**: 자동화된 보안 테스트 및 취약점 스캔
- **운영 단계**: 실시간 모니터링 및 사고 대응

이러한 원칙들을 바탕으로 강력하고 지속 가능한 보안 시스템을 구축하세요.

