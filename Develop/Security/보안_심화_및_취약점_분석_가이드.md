---
title: ë³´ì•ˆ ì‹¬í™” ë° ì·¨ì•½ì  ë¶„ì„ ê°€ì´ë“œ
tags: [security, vulnerability-analysis, authentication, authorization, encryption, monitoring, incident-response]
updated: 2024-09-14
---

# ë³´ì•ˆ ì‹¬í™” ë° ì·¨ì•½ì  ë¶„ì„ ê°€ì´ë“œ (Advanced Security and Vulnerability Analysis Guide)

## ğŸ“‹ ëª©ì°¨
1. [OWASP Top 10 ì·¨ì•½ì  ì‹¬í™” ë¶„ì„ ë° ê³ ê¸‰ ë°©ì–´ ì „ëµ](#owasp-top-10-ì·¨ì•½ì -ì‹¬í™”-ë¶„ì„-ë°-ê³ ê¸‰-ë°©ì–´-ì „ëµ)
2. [ìë™í™”ëœ ë³´ì•ˆ í…ŒìŠ¤íŠ¸ íŒŒì´í”„ë¼ì¸](#ìë™í™”ëœ-ë³´ì•ˆ-í…ŒìŠ¤íŠ¸-íŒŒì´í”„ë¼ì¸)
3. [ì‹¤ì‹œê°„ ë³´ì•ˆ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ](#ì‹¤ì‹œê°„-ë³´ì•ˆ-ëª¨ë‹ˆí„°ë§-ì‹œìŠ¤í…œ)
4. [WAF ë° ë³´ì•ˆ ë¯¸ë“¤ì›¨ì–´ êµ¬í˜„](#waf-ë°-ë³´ì•ˆ-ë¯¸ë“¤ì›¨ì–´-êµ¬í˜„)
5. [ë³´ì•ˆ ì‚¬ê³  ëŒ€ì‘ ìë™í™”](#ë³´ì•ˆ-ì‚¬ê³ -ëŒ€ì‘-ìë™í™”)
6. [ì¸ì¦/ì¸ê°€ ì‹œìŠ¤í…œ ë³´ì•ˆ ê°•í™”](#ì¸ì¦ì¸ê°€-ì‹œìŠ¤í…œ-ë³´ì•ˆ-ê°•í™”)
7. [ë°ì´í„° ì•”í˜¸í™” ë° í‚¤ ê´€ë¦¬](#ë°ì´í„°-ì•”í˜¸í™”-ë°-í‚¤-ê´€ë¦¬)
8. [ë³´ì•ˆ ëª¨ë‹ˆí„°ë§ ë° ì¹¨ì… íƒì§€](#ë³´ì•ˆ-ëª¨ë‹ˆí„°ë§-ë°-ì¹¨ì…-íƒì§€)
9. [ì‹¤ì œ ë³´ì•ˆ ì‚¬ê³  ëŒ€ì‘ ì‚¬ë¡€ ë° ë³µêµ¬ ì ˆì°¨](#ì‹¤ì œ-ë³´ì•ˆ-ì‚¬ê³ -ëŒ€ì‘-ì‚¬ë¡€-ë°-ë³µêµ¬-ì ˆì°¨)

### ğŸ“Œ í†µí•©ëœ ê¸°ì¡´ íŒŒì¼ë“¤
ì´ ê°€ì´ë“œëŠ” ë‹¤ìŒ ê¸°ì¡´ íŒŒì¼ë“¤ì˜ ë‚´ìš©ì„ ì‹¬í™”í•˜ì—¬ ë” ì²´ê³„ì ìœ¼ë¡œ ì •ë¦¬í•œ ê²ƒì…ë‹ˆë‹¤:
- **OWASP Top 10 ëŒ€ì‘ ê°€ì´ë“œ**: ê¸°ë³¸ì ì¸ ì·¨ì•½ì  ë°©ì–´ â†’ ê³ ê¸‰ ë°©ì–´ ì „ëµìœ¼ë¡œ í™•ì¥
- **AES/RSA ì•”í˜¸í™”**: ê¸°ë³¸ ì•”í˜¸í™” â†’ í‚¤ ê´€ë¦¬ ë° ë¡œí…Œì´ì…˜ ì „ëµìœ¼ë¡œ í™•ì¥
- **OAuth 2.0**: ê¸°ë³¸ ì¸ì¦ â†’ ë³´ì•ˆ ê°•í™”ëœ ì¸ì¦/ì¸ê°€ ì‹œìŠ¤í…œìœ¼ë¡œ í™•ì¥

---

## OWASP Top 10 ì·¨ì•½ì  ì‹¬í™” ë¶„ì„ ë° ê³ ê¸‰ ë°©ì–´ ì „ëµ

### 1. ê³ ê¸‰ ì·¨ì•½ì  ë¶„ì„ ê¸°ë²•

#### ë™ì  ë³´ì•ˆ í…ŒìŠ¤íŠ¸ (DAST)
```javascript
class DynamicSecurityTester {
  constructor() {
    this.vulnerabilityScanners = {
      sqlInjection: new SQLInjectionScanner(),
      xss: new XSSScanner(),
      csrf: new CSRFScanner(),
      authentication: new AuthenticationScanner()
    };
  }

  // SQL Injection ê³ ê¸‰ íƒì§€
  async scanSQLInjection(targetUrl) {
    const payloads = [
      "' OR '1'='1",
      "'; DROP TABLE users; --",
      "' UNION SELECT * FROM information_schema.tables --",
      "' AND (SELECT COUNT(*) FROM users) > 0 --"
    ];

    const results = [];
    
    for (const payload of payloads) {
      const response = await this.sendPayload(targetUrl, payload);
      
      if (this.detectSQLInjection(response)) {
        results.push({
          type: 'SQL_INJECTION',
          payload,
          severity: 'HIGH',
          evidence: response.body,
          recommendation: 'Use parameterized queries'
        });
      }
    }
    
    return results;
  }

  // XSS ê³ ê¸‰ íƒì§€
  async scanXSS(targetUrl) {
    const xssPayloads = [
      "<script>alert('XSS')</script>",
      "javascript:alert('XSS')",
      "<img src=x onerror=alert('XSS')>",
      "<svg onload=alert('XSS')>",
      "';alert('XSS');//"
    ];

    const results = [];
    
    for (const payload of xssPayloads) {
      const response = await this.sendPayload(targetUrl, payload);
      
      if (this.detectXSS(response)) {
        results.push({
          type: 'XSS',
          payload,
          severity: 'MEDIUM',
          evidence: response.body,
          recommendation: 'Implement proper input sanitization'
        });
      }
    }
    
    return results;
  }

  detectSQLInjection(response) {
    const sqlErrorPatterns = [
      /mysql_fetch_array\(\)/i,
      /ORA-01756/i,
      /Microsoft OLE DB Provider/i,
      /SQLServer JDBC Driver/i,
      /PostgreSQL query failed/i
    ];
    
    return sqlErrorPatterns.some(pattern => pattern.test(response.body));
  }

  detectXSS(response) {
    return response.body.includes('alert(') || 
           response.body.includes('<script>') ||
           response.body.includes('javascript:');
  }
}
```

#### ì •ì  ë³´ì•ˆ í…ŒìŠ¤íŠ¸ (SAST)
```javascript
class StaticSecurityAnalyzer {
  constructor() {
    this.rules = {
      hardcodedSecrets: /(password|secret|key|token)\s*=\s*['"][^'"]+['"]/gi,
      sqlInjection: /query\s*\(\s*['"][^'"]*\+/gi,
      xssVulnerability: /innerHTML\s*=\s*[^;]+/gi,
      weakCrypto: /md5|sha1|des\s*\(/gi
    };
  }

  analyzeCode(code) {
    const vulnerabilities = [];
    
    for (const [type, pattern] of Object.entries(this.rules)) {
      const matches = code.match(pattern);
      
      if (matches) {
        vulnerabilities.push({
          type,
          matches,
          severity: this.getSeverity(type),
          recommendation: this.getRecommendation(type)
        });
      }
    }
    
    return vulnerabilities;
  }

  getSeverity(type) {
    const severityMap = {
      hardcodedSecrets: 'CRITICAL',
      sqlInjection: 'HIGH',
      xssVulnerability: 'MEDIUM',
      weakCrypto: 'HIGH'
    };
    
    return severityMap[type] || 'LOW';
  }

  getRecommendation(type) {
    const recommendations = {
      hardcodedSecrets: 'Use environment variables for sensitive data',
      sqlInjection: 'Use parameterized queries or ORM',
      xssVulnerability: 'Use textContent instead of innerHTML',
      weakCrypto: 'Use strong cryptographic algorithms (AES-256, SHA-256)'
    };
    
    return recommendations[type];
  }
}
```

### 2. ê³ ê¸‰ ë°©ì–´ ì „ëµ

#### ë‹¤ì¸µ ë³´ì•ˆ ë°©ì–´ (Defense in Depth)
```javascript
class MultiLayerSecurity {
  constructor() {
    this.layers = {
      network: new NetworkSecurityLayer(),
      application: new ApplicationSecurityLayer(),
      data: new DataSecurityLayer(),
      monitoring: new SecurityMonitoringLayer()
    };
  }

  // ë„¤íŠ¸ì›Œí¬ ë ˆë²¨ ë³´ì•ˆ
  setupNetworkSecurity() {
    return {
      firewall: {
        rules: [
          { action: 'DENY', source: '0.0.0.0/0', port: 22 },
          { action: 'ALLOW', source: '10.0.0.0/8', port: 443 },
          { action: 'DENY', source: 'any', port: 'any' }
        ]
      },
      waf: {
        rules: [
          { type: 'SQL_INJECTION', action: 'BLOCK' },
          { type: 'XSS', action: 'BLOCK' },
          { type: 'RATE_LIMIT', threshold: 100, window: 60 }
        ]
      },
      ddos: {
        protection: true,
        threshold: 1000,
        mitigation: 'AUTO'
      }
    };
  }

  // ì• í”Œë¦¬ì¼€ì´ì…˜ ë ˆë²¨ ë³´ì•ˆ
  setupApplicationSecurity() {
    return {
      authentication: {
        multiFactor: true,
        sessionTimeout: 1800,
        maxAttempts: 5,
        lockoutDuration: 900
      },
      authorization: {
        rbac: true,
        principle: 'LEAST_PRIVILEGE',
        audit: true
      },
      inputValidation: {
        sanitization: true,
        encoding: 'UTF-8',
        maxLength: 1000
      }
    };
  }
}
```

---

## ì¸ì¦/ì¸ê°€ ì‹œìŠ¤í…œ ë³´ì•ˆ ê°•í™”

### 1. JWT ë³´ì•ˆ ê°•í™”

#### JWT í† í° ë³´ì•ˆ ê°•í™”
```javascript
class SecureJWTManager {
  constructor() {
    this.secretKey = process.env.JWT_SECRET;
    this.refreshSecretKey = process.env.JWT_REFRESH_SECRET;
    this.algorithm = 'HS256';
    this.accessTokenExpiry = '15m';
    this.refreshTokenExpiry = '7d';
    this.tokenBlacklist = new Set();
  }

  // ë³´ì•ˆ ê°•í™”ëœ JWT ìƒì„±
  generateSecureTokens(user) {
    const payload = {
      sub: user.id,
      email: user.email,
      roles: user.roles,
      iat: Math.floor(Date.now() / 1000),
      jti: this.generateJTI(), // JWT ID for tracking
      iss: 'your-app', // Issuer
      aud: 'your-app-users' // Audience
    };

    const accessToken = jwt.sign(payload, this.secretKey, {
      algorithm: this.algorithm,
      expiresIn: this.accessTokenExpiry
    });

    const refreshToken = jwt.sign(
      { sub: user.id, jti: this.generateJTI() },
      this.refreshSecretKey,
      { expiresIn: this.refreshTokenExpiry }
    );

    return { accessToken, refreshToken };
  }

  // JWT ê²€ì¦ ë° ë³´ì•ˆ ì²´í¬
  verifyToken(token) {
    try {
      // í† í° ë¸”ë™ë¦¬ìŠ¤íŠ¸ í™•ì¸
      if (this.tokenBlacklist.has(token)) {
        throw new Error('Token is blacklisted');
      }

      const decoded = jwt.verify(token, this.secretKey, {
        algorithms: [this.algorithm],
        issuer: 'your-app',
        audience: 'your-app-users'
      });

      // í† í° ë§Œë£Œ ì‹œê°„ ì²´í¬
      if (decoded.exp < Date.now() / 1000) {
        throw new Error('Token has expired');
      }

      // ì¶”ê°€ ë³´ì•ˆ ê²€ì¦
      this.validateTokenClaims(decoded);

      return decoded;
    } catch (error) {
      throw new Error(`Token verification failed: ${error.message}`);
    }
  }

  // í† í° ë¬´íš¨í™”
  revokeToken(token) {
    this.tokenBlacklist.add(token);
    
    // Redisë‚˜ ë°ì´í„°ë² ì´ìŠ¤ì— ì €ì¥í•˜ì—¬ ì˜êµ¬ ë³´ê´€
    this.storeBlacklistedToken(token);
  }

  // í† í° ê°±ì‹ 
  async refreshToken(refreshToken) {
    try {
      const decoded = jwt.verify(refreshToken, this.refreshSecretKey);
      
      // ì‚¬ìš©ì ì •ë³´ ì¡°íšŒ
      const user = await this.getUserById(decoded.sub);
      
      if (!user) {
        throw new Error('User not found');
      }

      // ìƒˆë¡œìš´ í† í° ìƒì„±
      const newTokens = this.generateSecureTokens(user);
      
      // ê¸°ì¡´ ë¦¬í”„ë ˆì‹œ í† í° ë¬´íš¨í™”
      this.revokeToken(refreshToken);
      
      return newTokens;
    } catch (error) {
      throw new Error(`Token refresh failed: ${error.message}`);
    }
  }
}
```

### 2. OAuth 2.0 ë³´ì•ˆ ê°•í™”

#### OAuth 2.0 ë³´ì•ˆ ê°•í™” êµ¬í˜„
```javascript
class SecureOAuth2Provider {
  constructor() {
    this.clients = new Map();
    this.authorizationCodes = new Map();
    this.accessTokens = new Map();
    this.rateLimiter = new Map();
  }

  // í´ë¼ì´ì–¸íŠ¸ ë“±ë¡ ë° ë³´ì•ˆ ê²€ì¦
  registerClient(clientInfo) {
    const clientId = this.generateClientId();
    const clientSecret = this.generateClientSecret();
    
    const client = {
      id: clientId,
      secret: this.hashClientSecret(clientSecret),
      redirectUris: clientInfo.redirectUris,
      scopes: clientInfo.scopes,
      grantTypes: clientInfo.grantTypes,
      createdAt: new Date(),
      lastUsed: null
    };

    this.clients.set(clientId, client);
    
    return { clientId, clientSecret };
  }

  // ì¸ì¦ ì½”ë“œ ë°œê¸‰ (PKCE ì§€ì›)
  generateAuthorizationCode(clientId, userId, scopes, codeChallenge) {
    const code = this.generateSecureCode();
    
    const authCode = {
      code,
      clientId,
      userId,
      scopes,
      codeChallenge,
      expiresAt: new Date(Date.now() + 600000), // 10ë¶„
      used: false
    };

    this.authorizationCodes.set(code, authCode);
    
    return code;
  }

  // ì•¡ì„¸ìŠ¤ í† í° ë°œê¸‰
  generateAccessToken(authCode, codeVerifier) {
    const authCodeData = this.authorizationCodes.get(authCode);
    
    if (!authCodeData || authCodeData.used) {
      throw new Error('Invalid or used authorization code');
    }

    if (authCodeData.expiresAt < new Date()) {
      throw new Error('Authorization code has expired');
    }

    // PKCE ê²€ì¦
    if (authCodeData.codeChallenge) {
      const expectedChallenge = this.generateCodeChallenge(codeVerifier);
      if (expectedChallenge !== authCodeData.codeChallenge) {
        throw new Error('Invalid code verifier');
      }
    }

    // í† í° ìƒì„±
    const accessToken = this.generateSecureToken();
    const refreshToken = this.generateSecureToken();
    
    const tokenData = {
      accessToken,
      refreshToken,
      clientId: authCodeData.clientId,
      userId: authCodeData.userId,
      scopes: authCodeData.scopes,
      expiresAt: new Date(Date.now() + 3600000), // 1ì‹œê°„
      createdAt: new Date()
    };

    this.accessTokens.set(accessToken, tokenData);
    authCodeData.used = true;
    
    return tokenData;
  }

  // í† í° ê²€ì¦
  validateToken(token) {
    const tokenData = this.accessTokens.get(token);
    
    if (!tokenData) {
      throw new Error('Invalid token');
    }

    if (tokenData.expiresAt < new Date()) {
      this.accessTokens.delete(token);
      throw new Error('Token has expired');
    }

    return tokenData;
  }
}
```

### 3. RBAC (Role-Based Access Control) ê³ ê¸‰ êµ¬í˜„

#### ì„¸ë°€í•œ ê¶Œí•œ ì œì–´ ì‹œìŠ¤í…œ
```javascript
class AdvancedRBAC {
  constructor() {
    this.roles = new Map();
    this.permissions = new Map();
    this.resources = new Map();
    this.policies = new Map();
  }

  // ì—­í•  ë° ê¶Œí•œ ì •ì˜
  defineRole(roleName, permissions) {
    this.roles.set(roleName, {
      name: roleName,
      permissions: new Set(permissions),
      createdAt: new Date(),
      updatedAt: new Date()
    });
  }

  // ë¦¬ì†ŒìŠ¤ ê¸°ë°˜ ê¶Œí•œ ì •ì˜
  defineResource(resourceName, actions) {
    this.resources.set(resourceName, {
      name: resourceName,
      actions: new Set(actions),
      attributes: new Map()
    });
  }

  // ì •ì±… ê¸°ë°˜ ì ‘ê·¼ ì œì–´ (ABAC)
  definePolicy(policyName, conditions) {
    this.policies.set(policyName, {
      name: policyName,
      conditions,
      effect: 'ALLOW' // ë˜ëŠ” 'DENY'
    });
  }

  // ê¶Œí•œ ê²€ì¦
  checkPermission(user, resource, action, context = {}) {
    const userRoles = user.roles || [];
    
    for (const roleName of userRoles) {
      const role = this.roles.get(roleName);
      if (!role) continue;

      // ê¸°ë³¸ ê¶Œí•œ í™•ì¸
      if (role.permissions.has(`${resource}:${action}`)) {
        // ì •ì±… ê¸°ë°˜ ì¶”ê°€ ê²€ì¦
        if (this.evaluatePolicies(user, resource, action, context)) {
          return true;
        }
      }
    }

    return false;
  }

  // ì •ì±… í‰ê°€
  evaluatePolicies(user, resource, action, context) {
    for (const [policyName, policy] of this.policies) {
      if (this.matchesPolicy(policy, user, resource, action, context)) {
        return policy.effect === 'ALLOW';
      }
    }
    
    return true; // ê¸°ë³¸ì ìœ¼ë¡œ í—ˆìš©
  }

  // ë™ì  ê¶Œí•œ ë¶€ì—¬
  grantTemporaryPermission(userId, resource, action, expiresAt) {
    const tempPermission = {
      userId,
      resource,
      action,
      expiresAt,
      grantedAt: new Date()
    };

    // ì„ì‹œ ê¶Œí•œ ì €ì¥ (Redis ë“±)
    this.storeTemporaryPermission(tempPermission);
  }
}
```

---

## ë°ì´í„° ì•”í˜¸í™” ë° í‚¤ ê´€ë¦¬

### 1. í‚¤ ê´€ë¦¬ ì‹œìŠ¤í…œ (KMS)

#### í‚¤ ìƒëª…ì£¼ê¸° ê´€ë¦¬
```javascript
class KeyManagementSystem {
  constructor() {
    this.keys = new Map();
    this.keyVersions = new Map();
    this.rotationSchedule = new Map();
  }

  // í‚¤ ìƒì„±
  generateKey(keyId, algorithm = 'AES-256-GCM') {
    const key = {
      id: keyId,
      algorithm,
      material: crypto.randomBytes(32),
      version: 1,
      createdAt: new Date(),
      status: 'ACTIVE',
      usage: 'ENCRYPT_DECRYPT'
    };

    this.keys.set(keyId, key);
    this.keyVersions.set(keyId, [key]);
    
    return key;
  }

  // í‚¤ ë¡œí…Œì´ì…˜
  rotateKey(keyId) {
    const currentKey = this.keys.get(keyId);
    if (!currentKey) {
      throw new Error('Key not found');
    }

    const newKey = {
      id: keyId,
      algorithm: currentKey.algorithm,
      material: crypto.randomBytes(32),
      version: currentKey.version + 1,
      createdAt: new Date(),
      status: 'ACTIVE',
      usage: currentKey.usage
    };

    // ì´ì „ í‚¤ë¥¼ ë¹„í™œì„±í™”
    currentKey.status = 'INACTIVE';
    currentKey.rotatedAt = new Date();

    // ìƒˆ í‚¤ í™œì„±í™”
    this.keys.set(keyId, newKey);
    this.keyVersions.get(keyId).push(newKey);

    return newKey;
  }

  // ìë™ í‚¤ ë¡œí…Œì´ì…˜ ìŠ¤ì¼€ì¤„ë§
  scheduleKeyRotation(keyId, intervalDays = 90) {
    const rotationDate = new Date();
    rotationDate.setDate(rotationDate.getDate() + intervalDays);
    
    this.rotationSchedule.set(keyId, {
      nextRotation: rotationDate,
      interval: intervalDays * 24 * 60 * 60 * 1000 // ë°€ë¦¬ì´ˆ
    });

    // ìŠ¤ì¼€ì¤„ëœ ë¡œí…Œì´ì…˜ ì‹¤í–‰
    this.setupRotationTimer(keyId);
  }

  // ì•”í˜¸í™” (í‚¤ ë²„ì „ ìë™ ì„ íƒ)
  encrypt(data, keyId) {
    const key = this.keys.get(keyId);
    if (!key || key.status !== 'ACTIVE') {
      throw new Error('Key not available');
    }

    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipher(key.algorithm, key.material);
    cipher.setAAD(Buffer.from(keyId, 'utf8'));

    let encrypted = cipher.update(data, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    
    const authTag = cipher.getAuthTag();

    return {
      encrypted,
      iv: iv.toString('hex'),
      authTag: authTag.toString('hex'),
      keyVersion: key.version,
      algorithm: key.algorithm
    };
  }

  // ë³µí˜¸í™” (í‚¤ ë²„ì „ ìë™ ì„ íƒ)
  decrypt(encryptedData, keyId) {
    const keyVersions = this.keyVersions.get(keyId);
    if (!keyVersions) {
      throw new Error('Key not found');
    }

    // í‚¤ ë²„ì „ìœ¼ë¡œ í‚¤ ì°¾ê¸°
    const key = keyVersions.find(k => k.version === encryptedData.keyVersion);
    if (!key) {
      throw new Error('Key version not found');
    }

    const decipher = crypto.createDecipher(key.algorithm, key.material);
    decipher.setAAD(Buffer.from(keyId, 'utf8'));
    decipher.setAuthTag(Buffer.from(encryptedData.authTag, 'hex'));

    let decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');

    return decrypted;
  }
}
```

### 2. ë°ì´í„°ë² ì´ìŠ¤ ì•”í˜¸í™”

#### íˆ¬ëª…í•œ ë°ì´í„° ì•”í˜¸í™” (TDE)
```javascript
class TransparentDataEncryption {
  constructor(kms) {
    this.kms = kms;
    this.encryptedColumns = new Map();
  }

  // ì»¬ëŸ¼ ì•”í˜¸í™” ì„¤ì •
  setupColumnEncryption(tableName, columnName, keyId) {
    const columnKey = `${tableName}.${columnName}`;
    this.encryptedColumns.set(columnKey, {
      keyId,
      algorithm: 'AES-256-GCM',
      createdAt: new Date()
    });
  }

  // ë°ì´í„° ì‚½ì… ì‹œ ìë™ ì•”í˜¸í™”
  async insertEncryptedData(tableName, data) {
    const encryptedData = { ...data };
    
    for (const [column, value] of Object.entries(data)) {
      const columnKey = `${tableName}.${column}`;
      const encryptionConfig = this.encryptedColumns.get(columnKey);
      
      if (encryptionConfig && value !== null) {
        encryptedData[column] = await this.encryptValue(value, encryptionConfig.keyId);
      }
    }

    return encryptedData;
  }

  // ë°ì´í„° ì¡°íšŒ ì‹œ ìë™ ë³µí˜¸í™”
  async decryptQueryResult(tableName, results) {
    const decryptedResults = [];
    
    for (const row of results) {
      const decryptedRow = { ...row };
      
      for (const [column, value] of Object.entries(row)) {
        const columnKey = `${tableName}.${column}`;
        const encryptionConfig = this.encryptedColumns.get(columnKey);
        
        if (encryptionConfig && value !== null) {
          decryptedRow[column] = await this.decryptValue(value, encryptionConfig.keyId);
        }
      }
      
      decryptedResults.push(decryptedRow);
    }

    return decryptedResults;
  }

  // ê°’ ì•”í˜¸í™”
  async encryptValue(value, keyId) {
    const stringValue = JSON.stringify(value);
    const encrypted = this.kms.encrypt(stringValue, keyId);
    
    return JSON.stringify(encrypted);
  }

  // ê°’ ë³µí˜¸í™”
  async decryptValue(encryptedValue, keyId) {
    const encryptedData = JSON.parse(encryptedValue);
    const decrypted = this.kms.decrypt(encryptedData, keyId);
    
    return JSON.parse(decrypted);
  }
}
```

---

## ë³´ì•ˆ ëª¨ë‹ˆí„°ë§ ë° ì¹¨ì… íƒì§€

### 1. SIEM (Security Information and Event Management)

#### ì‹¤ì‹œê°„ ë³´ì•ˆ ì´ë²¤íŠ¸ ìˆ˜ì§‘ ë° ë¶„ì„
```javascript
class SIEMSystem {
  constructor() {
    this.eventCollectors = new Map();
    this.analyzers = new Map();
    this.alertRules = new Map();
    this.incidents = new Map();
  }

  // ë³´ì•ˆ ì´ë²¤íŠ¸ ìˆ˜ì§‘
  collectSecurityEvent(event) {
    const securityEvent = {
      id: this.generateEventId(),
      timestamp: new Date(),
      source: event.source,
      type: event.type,
      severity: event.severity,
      data: event.data,
      raw: event.raw
    };

    // ì´ë²¤íŠ¸ ì €ì¥
    this.storeEvent(securityEvent);
    
    // ì‹¤ì‹œê°„ ë¶„ì„
    this.analyzeEvent(securityEvent);
    
    return securityEvent;
  }

  // ì´ë²¤íŠ¸ ë¶„ì„
  analyzeEvent(event) {
    const analysisResults = [];
    
    // ê° ë¶„ì„ê¸° ì‹¤í–‰
    for (const [analyzerName, analyzer] of this.analyzers) {
      try {
        const result = analyzer.analyze(event);
        if (result) {
          analysisResults.push({
            analyzer: analyzerName,
            result,
            confidence: result.confidence || 0.8
          });
        }
      } catch (error) {
        console.error(`Analyzer ${analyzerName} failed:`, error);
      }
    }

    // ê²°ê³¼ í†µí•© ë° ì•Œë¦¼ ìƒì„±
    if (analysisResults.length > 0) {
      this.generateAlert(event, analysisResults);
    }
  }

  // ì¹¨ì… íƒì§€ ê·œì¹™
  setupIntrusionDetectionRules() {
    // Brute Force ê³µê²© íƒì§€
    this.addRule('brute_force', {
      condition: (events) => {
        const failedLogins = events.filter(e => 
          e.type === 'LOGIN_FAILED' && 
          Date.now() - e.timestamp.getTime() < 300000 // 5ë¶„ ë‚´
        );
        
        return failedLogins.length >= 5;
      },
      action: 'BLOCK_IP',
      severity: 'HIGH'
    });

    // SQL Injection ì‹œë„ íƒì§€
    this.addRule('sql_injection', {
      condition: (events) => {
        return events.some(e => 
          e.type === 'HTTP_REQUEST' &&
          e.data.url.includes('union') &&
          e.data.url.includes('select')
        );
      },
      action: 'ALERT_SECURITY_TEAM',
      severity: 'CRITICAL'
    });

    // ë¹„ì •ìƒì ì¸ ë°ì´í„° ì ‘ê·¼ íŒ¨í„´
    this.addRule('data_exfiltration', {
      condition: (events) => {
        const dataAccess = events.filter(e => 
          e.type === 'DATA_ACCESS' &&
          Date.now() - e.timestamp.getTime() < 3600000 // 1ì‹œê°„ ë‚´
        );
        
        return dataAccess.length > 1000; // 1000ê±´ ì´ìƒ ì ‘ê·¼
      },
      action: 'INVESTIGATE_USER',
      severity: 'MEDIUM'
    });
  }

  // ì•Œë¦¼ ìƒì„±
  generateAlert(event, analysisResults) {
    const alert = {
      id: this.generateAlertId(),
      timestamp: new Date(),
      eventId: event.id,
      severity: this.calculateSeverity(analysisResults),
      title: this.generateAlertTitle(event, analysisResults),
      description: this.generateAlertDescription(event, analysisResults),
      recommendations: this.generateRecommendations(analysisResults),
      status: 'OPEN'
    };

    this.storeAlert(alert);
    this.sendNotification(alert);
    
    return alert;
  }
}
```

### 2. ë¡œê·¸ ë¶„ì„ ë° ìƒê´€ê´€ê³„ ë¶„ì„

#### ê³ ê¸‰ ë¡œê·¸ ë¶„ì„ ì‹œìŠ¤í…œ
```javascript
class LogAnalysisSystem {
  constructor() {
    this.logParsers = new Map();
    this.correlationRules = new Map();
    this.threatIntelligence = new Map();
  }

  // ë¡œê·¸ íŒŒì‹± ë° ì •ê·œí™”
  parseLog(logEntry) {
    const parsedLog = {
      timestamp: this.extractTimestamp(logEntry),
      source: this.extractSource(logEntry),
      level: this.extractLevel(logEntry),
      message: this.extractMessage(logEntry),
      fields: this.extractFields(logEntry),
      raw: logEntry
    };

    return parsedLog;
  }

  // ìƒê´€ê´€ê³„ ë¶„ì„
  correlateEvents(events, timeWindow = 300000) { // 5ë¶„
    const correlations = [];
    const sortedEvents = events.sort((a, b) => a.timestamp - b.timestamp);
    
    for (let i = 0; i < sortedEvents.length; i++) {
      const currentEvent = sortedEvents[i];
      const relatedEvents = [];
      
      // ì‹œê°„ ìœˆë„ìš° ë‚´ì˜ ê´€ë ¨ ì´ë²¤íŠ¸ ì°¾ê¸°
      for (let j = i + 1; j < sortedEvents.length; j++) {
        const nextEvent = sortedEvents[j];
        
        if (nextEvent.timestamp - currentEvent.timestamp > timeWindow) {
          break;
        }
        
        if (this.areEventsRelated(currentEvent, nextEvent)) {
          relatedEvents.push(nextEvent);
        }
      }
      
      if (relatedEvents.length > 0) {
        correlations.push({
          primaryEvent: currentEvent,
          relatedEvents,
          correlationScore: this.calculateCorrelationScore(currentEvent, relatedEvents),
          timeWindow
        });
      }
    }
    
    return correlations;
  }

  // ìœ„í˜‘ ì¸í…”ë¦¬ì „ìŠ¤ ì—°ë™
  enrichWithThreatIntelligence(event) {
    const enrichedEvent = { ...event };
    
    // IP ì£¼ì†Œ ìœ„í˜‘ ì¸í…”ë¦¬ì „ìŠ¤ í™•ì¸
    if (event.sourceIP) {
      const threatInfo = this.threatIntelligence.get(event.sourceIP);
      if (threatInfo) {
        enrichedEvent.threatIntelligence = {
          isMalicious: threatInfo.isMalicious,
          threatType: threatInfo.threatType,
          confidence: threatInfo.confidence,
          lastSeen: threatInfo.lastSeen
        };
      }
    }
    
    // ë„ë©”ì¸ ìœ„í˜‘ ì¸í…”ë¦¬ì „ìŠ¤ í™•ì¸
    if (event.domain) {
      const domainThreatInfo = this.threatIntelligence.get(event.domain);
      if (domainThreatInfo) {
        enrichedEvent.domainThreatIntelligence = domainThreatInfo;
      }
    }
    
    return enrichedEvent;
  }
}
```

---

## ì‹¤ì œ ë³´ì•ˆ ì‚¬ê³  ëŒ€ì‘ ì‚¬ë¡€ ë° ë³µêµ¬ ì ˆì°¨

### 1. ë³´ì•ˆ ì‚¬ê³  ëŒ€ì‘ í”Œë ˆì´ë¶

#### ë°ì´í„° ìœ ì¶œ ì‚¬ê³  ëŒ€ì‘
```javascript
class DataBreachResponse {
  constructor() {
    this.responseTeam = {
      incidentCommander: null,
      technicalLead: null,
      legalCounsel: null,
      communicationsLead: null
    };
    this.responseSteps = [];
  }

  // 1ë‹¨ê³„: ì´ˆê¸° ëŒ€ì‘ (0-1ì‹œê°„)
  async initialResponse(incident) {
    const response = {
      step: 'INITIAL_RESPONSE',
      timestamp: new Date(),
      actions: []
    };

    // 1. ì‚¬ê³  í™•ì¸ ë° ë¶„ë¥˜
    const classification = await this.classifyIncident(incident);
    response.actions.push({
      action: 'CLASSIFY_INCIDENT',
      result: classification,
      timestamp: new Date()
    });

    // 2. ì˜í–¥ ë²”ìœ„ í‰ê°€
    const impact = await this.assessImpact(incident);
    response.actions.push({
      action: 'ASSESS_IMPACT',
      result: impact,
      timestamp: new Date()
    });

    // 3. ì´ˆê¸° ê²©ë¦¬ ì¡°ì¹˜
    const isolation = await this.isolateAffectedSystems(incident);
    response.actions.push({
      action: 'ISOLATE_SYSTEMS',
      result: isolation,
      timestamp: new Date()
    });

    // 4. ëŒ€ì‘íŒ€ ì†Œì§‘
    await this.assembleResponseTeam(classification.severity);
    response.actions.push({
      action: 'ASSEMBLE_TEAM',
      result: 'Team assembled',
      timestamp: new Date()
    });

    this.responseSteps.push(response);
    return response;
  }

  // 2ë‹¨ê³„: ì¡°ì‚¬ ë° ë¶„ì„ (1-24ì‹œê°„)
  async investigationPhase(incident) {
    const response = {
      step: 'INVESTIGATION',
      timestamp: new Date(),
      actions: []
    };

    // 1. í¬ë Œì‹ ì¦ê±° ìˆ˜ì§‘
    const evidence = await this.collectForensicEvidence(incident);
    response.actions.push({
      action: 'COLLECT_EVIDENCE',
      result: evidence,
      timestamp: new Date()
    });

    // 2. ê³µê²© ë²¡í„° ë¶„ì„
    const attackVector = await this.analyzeAttackVector(incident);
    response.actions.push({
      action: 'ANALYZE_ATTACK_VECTOR',
      result: attackVector,
      timestamp: new Date()
    });

    // 3. í”¼í•´ ë²”ìœ„ ì •í™•í•œ í‰ê°€
    const damageAssessment = await this.assessDamage(incident);
    response.actions.push({
      action: 'ASSESS_DAMAGE',
      result: damageAssessment,
      timestamp: new Date()
    });

    // 4. ì·¨ì•½ì  ë¶„ì„
    const vulnerabilities = await this.analyzeVulnerabilities(incident);
    response.actions.push({
      action: 'ANALYZE_VULNERABILITIES',
      result: vulnerabilities,
      timestamp: new Date()
    });

    this.responseSteps.push(response);
    return response;
  }

  // 3ë‹¨ê³„: ë³µêµ¬ ë° ë³µì› (24-72ì‹œê°„)
  async recoveryPhase(incident) {
    const response = {
      step: 'RECOVERY',
      timestamp: new Date(),
      actions: []
    };

    // 1. ì·¨ì•½ì  íŒ¨ì¹˜
    const patching = await this.patchVulnerabilities(incident.vulnerabilities);
    response.actions.push({
      action: 'PATCH_VULNERABILITIES',
      result: patching,
      timestamp: new Date()
    });

    // 2. ì‹œìŠ¤í…œ ë³µì›
    const restoration = await this.restoreSystems(incident.affectedSystems);
    response.actions.push({
      action: 'RESTORE_SYSTEMS',
      result: restoration,
      timestamp: new Date()
    });

    // 3. ë³´ì•ˆ ê°•í™”
    const hardening = await this.hardenSecurity(incident);
    response.actions.push({
      action: 'HARDEN_SECURITY',
      result: hardening,
      timestamp: new Date()
    });

    // 4. ëª¨ë‹ˆí„°ë§ ê°•í™”
    const monitoring = await this.enhanceMonitoring(incident);
    response.actions.push({
      action: 'ENHANCE_MONITORING',
      result: monitoring,
      timestamp: new Date()
    });

    this.responseSteps.push(response);
    return response;
  }

  // 4ë‹¨ê³„: ì‚¬í›„ ë¶„ì„ ë° ê°œì„  (72ì‹œê°„ ì´í›„)
  async postIncidentAnalysis(incident) {
    const response = {
      step: 'POST_INCIDENT_ANALYSIS',
      timestamp: new Date(),
      actions: []
    };

    // 1. ì‚¬ê³  ì›ì¸ ë¶„ì„
    const rootCause = await this.analyzeRootCause(incident);
    response.actions.push({
      action: 'ANALYZE_ROOT_CAUSE',
      result: rootCause,
      timestamp: new Date()
    });

    // 2. ëŒ€ì‘ ê³¼ì • í‰ê°€
    const responseEvaluation = await this.evaluateResponse(incident);
    response.actions.push({
      action: 'EVALUATE_RESPONSE',
      result: responseEvaluation,
      timestamp: new Date()
    });

    // 3. ê°œì„  ì‚¬í•­ ë„ì¶œ
    const improvements = await this.identifyImprovements(incident);
    response.actions.push({
      action: 'IDENTIFY_IMPROVEMENTS',
      result: improvements,
      timestamp: new Date()
    });

    // 4. í”Œë ˆì´ë¶ ì—…ë°ì´íŠ¸
    await this.updatePlaybook(improvements);
    response.actions.push({
      action: 'UPDATE_PLAYBOOK',
      result: 'Playbook updated',
      timestamp: new Date()
    });

    this.responseSteps.push(response);
    return response;
  }
}
```

### 2. ì‹¤ì œ ì‚¬ê³  ì‚¬ë¡€ ë¶„ì„

#### ì‚¬ë¡€ 1: SQL Injectionì„ í†µí•œ ë°ì´í„° ìœ ì¶œ
```javascript
class SQLInjectionBreachCase {
  constructor() {
    this.incident = {
      id: 'INC-2024-001',
      type: 'DATA_BREACH',
      severity: 'CRITICAL',
      discoveredAt: new Date('2024-01-15T10:30:00Z'),
      affectedData: ['user_credentials', 'personal_information', 'payment_data']
    };
  }

  // ì‚¬ê³  ì‹œë‚˜ë¦¬ì˜¤ ì¬í˜„
  async reproduceIncident() {
    return {
      attackVector: 'SQL Injection',
      entryPoint: '/api/users/search',
      vulnerableCode: `
        app.get('/api/users/search', (req, res) => {
          const query = req.query.q;
          const sql = \`SELECT * FROM users WHERE name LIKE '%\${query}%'\`;
          db.query(sql, (err, results) => {
            res.json(results);
          });
        });
      `,
      attackPayload: "'; DROP TABLE users; --",
      impact: {
        dataExposed: 50000,
        systemsAffected: 3,
        downtime: 8 // hours
      }
    };
  }

  // ëŒ€ì‘ ê³¼ì • ë¶„ì„
  analyzeResponse() {
    return {
      detectionTime: '2 hours',
      containmentTime: '4 hours',
      eradicationTime: '12 hours',
      recoveryTime: '24 hours',
      lessonsLearned: [
        'Input validation was insufficient',
        'Database access controls were weak',
        'Monitoring was inadequate',
        'Incident response was slow'
      ],
      improvements: [
        'Implement parameterized queries',
        'Add WAF protection',
        'Enhance database monitoring',
        'Improve incident response procedures'
      ]
    };
  }
}
```

#### ì‚¬ë¡€ 2: ì¸ì¦ ìš°íšŒë¥¼ í†µí•œ ê¶Œí•œ ìƒìŠ¹
```javascript
class AuthenticationBypassCase {
  constructor() {
    this.incident = {
      id: 'INC-2024-002',
      type: 'PRIVILEGE_ESCALATION',
      severity: 'HIGH',
      discoveredAt: new Date('2024-02-20T14:15:00Z'),
      affectedSystems: ['admin_panel', 'user_management']
    };
  }

  // ê³µê²© ì‹œë‚˜ë¦¬ì˜¤ ë¶„ì„
  async analyzeAttack() {
    return {
      vulnerability: 'JWT Token Manipulation',
      attackMethod: 'Algorithm Confusion Attack',
      technicalDetails: {
        originalToken: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...',
        manipulatedToken: 'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0...',
        algorithmChanged: 'HS256 â†’ none',
        payload: {
          sub: 'admin',
          role: 'super_admin',
          exp: 9999999999
        }
      },
      impact: {
        adminAccountsCompromised: 2,
        dataAccessGained: 'All user data',
        systemsCompromised: 5
      }
    };
  }

  // ë°©ì–´ ì „ëµ ê°œì„ 
  getDefenseImprovements() {
    return {
      immediateActions: [
        'Revoke all existing JWT tokens',
        'Implement algorithm whitelist',
        'Add token signature verification',
        'Enable token blacklisting'
      ],
      longTermImprovements: [
        'Implement OAuth 2.0 with PKCE',
        'Add multi-factor authentication',
        'Implement role-based access control',
        'Add session management'
      ],
      monitoringEnhancements: [
        'JWT token validation monitoring',
        'Unusual authentication pattern detection',
        'Admin action logging',
        'Real-time alerting for privilege escalation'
      ]
    };
  }
}
```

---

## ê²°ë¡ 

ë³´ì•ˆ ì‹¬í™” ë° ì·¨ì•½ì  ë¶„ì„ì€ ì§€ì†ì ì¸ ê³¼ì •ìœ¼ë¡œ, ë‹¤ìŒê³¼ ê°™ì€ í•µì‹¬ ì›ì¹™ì„ ë”°ë¼ì•¼ í•©ë‹ˆë‹¤:

### í•µì‹¬ ì›ì¹™ ìš”ì•½

1. **ë‹¤ì¸µ ë°©ì–´**: ë„¤íŠ¸ì›Œí¬, ì• í”Œë¦¬ì¼€ì´ì…˜, ë°ì´í„° ë ˆë²¨ì˜ í†µí•© ë³´ì•ˆ
2. **ì§€ì†ì  ëª¨ë‹ˆí„°ë§**: ì‹¤ì‹œê°„ ë³´ì•ˆ ì´ë²¤íŠ¸ ê°ì§€ ë° ëŒ€ì‘
3. **ìë™í™”ëœ ëŒ€ì‘**: ë³´ì•ˆ ì‚¬ê³  ë°œìƒ ì‹œ ì‹ ì†í•œ ìë™ ëŒ€ì‘
4. **ì •ê¸°ì  í‰ê°€**: ë³´ì•ˆ ìƒíƒœì˜ ì§€ì†ì ì¸ í‰ê°€ ë° ê°œì„ 
5. **íŒ€ êµìœ¡**: ë³´ì•ˆ ì¸ì‹ í–¥ìƒì„ ìœ„í•œ ì •ê¸° êµìœ¡

### ì‹¤ë¬´ ì ìš© ê°€ì´ë“œ

- **ê°œë°œ ë‹¨ê³„**: ë³´ì•ˆ ìš°ì„  ì„¤ê³„ ë° ì½”ë“œ ë¦¬ë·°
- **í…ŒìŠ¤íŠ¸ ë‹¨ê³„**: ìë™í™”ëœ ë³´ì•ˆ í…ŒìŠ¤íŠ¸ ë° ì·¨ì•½ì  ìŠ¤ìº”
- **ìš´ì˜ ë‹¨ê³„**: ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ë° ì‚¬ê³  ëŒ€ì‘

ì´ëŸ¬í•œ ì›ì¹™ë“¤ì„ ë°”íƒ•ìœ¼ë¡œ ê°•ë ¥í•˜ê³  ì§€ì† ê°€ëŠ¥í•œ ë³´ì•ˆ ì‹œìŠ¤í…œì„ êµ¬ì¶•í•˜ì„¸ìš”.

